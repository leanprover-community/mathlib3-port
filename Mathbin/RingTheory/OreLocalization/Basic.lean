/-
Copyright (c) 2022 Jakob von Raumer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jakob von Raumer, Kevin Klinge

! This file was ported from Lean 3 source module ring_theory.ore_localization.basic
! leanprover-community/mathlib commit b6da1a0b3e7cd83b1f744c49ce48ef8c6307d2f6
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.GroupTheory.MonoidLocalization
import Mathbin.RingTheory.NonZeroDivisors
import Mathbin.RingTheory.OreLocalization.OreSet
import Mathbin.Tactic.NoncommRing

/-!

# Localization over right Ore sets.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines the localization of a monoid over a right Ore set and proves its universal
mapping property. It then extends the definition and its properties first to semirings and then
to rings. We show that in the case of a commutative monoid this definition coincides with the
common monoid localization. Finally we show that in a ring without zero divisors, taking the Ore
localization at `R - {0}` results in a division ring.

## Notations

Introduces the notation `R[S⁻¹]` for the Ore localization of a monoid `R` at a right Ore
subset `S`. Also defines a new heterogeneos division notation `r /ₒ s` for a numerator `r : R` and
a denominator `s : S`.

## References

* <https://ncatlab.org/nlab/show/Ore+localization>
* [Zoran Škoda, *Noncommutative localization in noncommutative geometry*][skoda2006]


## Tags
localization, Ore, non-commutative

-/


universe u

open OreLocalization

namespace OreLocalization

variable (R : Type _) [Monoid R] (S : Submonoid R) [OreSet S]

/- warning: ore_localization.ore_eqv -> OreLocalization.oreEqv is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Monoid.{u1} R] (S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S], Setoid.{succ u1} (Prod.{u1, u1} R (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Monoid.{u1} R] (S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S], Setoid.{succ u1} (Prod.{u1, u1} R (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)))
Case conversion may be inaccurate. Consider using '#align ore_localization.ore_eqv OreLocalization.oreEqvₓ'. -/
/-- The setoid on `R × S` used for the Ore localization. -/
def oreEqv : Setoid (R × S)
    where
  R rs rs' := ∃ (u : S)(v : R), rs'.1 * u = rs.1 * v ∧ (rs'.2 : R) * u = rs.2 * v
  iseqv := by
    refine' ⟨_, _, _⟩
    · rintro ⟨r, s⟩
      use 1
      use 1
      simp [Submonoid.one_mem]
    · rintro ⟨r, s⟩ ⟨r', s'⟩ ⟨u, v, hru, hsu⟩
      rcases ore_condition (s : R) s' with ⟨r₂, s₂, h₁⟩
      rcases ore_condition r₂ u with ⟨r₃, s₃, h₂⟩
      have : (s : R) * ((v : R) * r₃) = (s : R) * (s₂ * s₃) :=
        by
        assoc_rw [h₁, h₂, hsu]
        symm
        apply mul_assoc
      rcases ore_left_cancel (v * r₃) (s₂ * s₃) s this with ⟨w, hw⟩
      use s₂ * s₃ * w
      use u * r₃ * w
      constructor <;> simp only [Submonoid.coe_mul]
      · assoc_rw [hru, ← hw]
        simp [mul_assoc]
      · assoc_rw [hsu, ← hw]
        simp [mul_assoc]
    · rintro ⟨r₁, s₁⟩ ⟨r₂, s₂⟩ ⟨r₃, s₃⟩ ⟨u, v, hur₁, hs₁u⟩ ⟨u', v', hur₂, hs₂u⟩
      rcases ore_condition v' u with ⟨r', s', h⟩
      use u' * s'
      use v * r'
      constructor <;> simp only [Submonoid.coe_mul]
      · assoc_rw [hur₂, h, hur₁, mul_assoc]
      · assoc_rw [hs₂u, h, hs₁u, mul_assoc]
#align ore_localization.ore_eqv OreLocalization.oreEqv

end OreLocalization

#print OreLocalization /-
/-- The ore localization of a monoid and a submonoid fulfilling the ore condition. -/
def OreLocalization (R : Type _) [Monoid R] (S : Submonoid R) [OreSet S] :=
  Quotient (OreLocalization.oreEqv R S)
#align ore_localization OreLocalization
-/

namespace OreLocalization

section Monoid

variable {R : Type _} [Monoid R] {S : Submonoid R}

variable (R S) [OreSet S]

-- mathport name: «expr [ ⁻¹]»
notation:1075 R "[" S "⁻¹]" => OreLocalization R S

attribute [local instance] ore_eqv

variable {R S}

/- warning: ore_localization.ore_div -> OreLocalization.oreDiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S], R -> (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) -> (OreLocalization.{u1} R _inst_1 S _inst_2)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S], R -> (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) -> (OreLocalization.{u1} R _inst_1 S _inst_2)
Case conversion may be inaccurate. Consider using '#align ore_localization.ore_div OreLocalization.oreDivₓ'. -/
/-- The division in the ore localization `R[S⁻¹]`, as a fraction of an element of `R` and `S`. -/
def oreDiv (r : R) (s : S) : R[S⁻¹] :=
  Quotient.mk' (r, s)
#align ore_localization.ore_div OreLocalization.oreDiv

-- mathport name: «expr /ₒ »
infixl:70 " /ₒ " => oreDiv

/- warning: ore_localization.ind -> OreLocalization.ind is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {β : (OreLocalization.{u1} R _inst_1 S _inst_2) -> Prop}, (forall (r : R) (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S), β (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r s)) -> (forall (q : OreLocalization.{u1} R _inst_1 S _inst_2), β q)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {β : (OreLocalization.{u1} R _inst_1 S _inst_2) -> Prop}, (forall (r : R) (s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)), β (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r s)) -> (forall (q : OreLocalization.{u1} R _inst_1 S _inst_2), β q)
Case conversion may be inaccurate. Consider using '#align ore_localization.ind OreLocalization.indₓ'. -/
@[elab_as_elim]
protected theorem ind {β : R[S⁻¹] → Prop} (c : ∀ (r : R) (s : S), β (r /ₒ s)) : ∀ q, β q :=
  by
  apply Quotient.ind
  rintro ⟨r, s⟩
  exact c r s
#align ore_localization.ind OreLocalization.ind

/- warning: ore_localization.ore_div_eq_iff -> OreLocalization.oreDiv_eq_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {r₁ : R} {r₂ : R} {s₁ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S} {s₂ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S}, Iff (Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₁ s₁) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₂ s₂)) (Exists.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (fun (u : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) => Exists.{succ u1} R (fun (v : R) => And (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₂ ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) u)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ v)) (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s₂) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) u)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s₁) v)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {r₁ : R} {r₂ : R} {s₁ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)} {s₂ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)}, Iff (Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₁ s₁) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₂ s₂)) (Exists.{succ u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (fun (u : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) => Exists.{succ u1} R (fun (v : R) => And (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₂ (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) u)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ v)) (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s₂) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) u)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s₁) v)))))
Case conversion may be inaccurate. Consider using '#align ore_localization.ore_div_eq_iff OreLocalization.oreDiv_eq_iffₓ'. -/
theorem oreDiv_eq_iff {r₁ r₂ : R} {s₁ s₂ : S} :
    r₁ /ₒ s₁ = r₂ /ₒ s₂ ↔ ∃ (u : S)(v : R), r₂ * u = r₁ * v ∧ (s₂ : R) * u = s₁ * v :=
  Quotient.eq''
#align ore_localization.ore_div_eq_iff OreLocalization.oreDiv_eq_iff

/- warning: ore_localization.expand -> OreLocalization.expand is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] (r : R) (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (t : R) (hst : Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s) t) S), Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r s) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r t) (Subtype.mk.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s) t) hst))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] (r : R) (s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (t : R) (hst : Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s) t) S), Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r s) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r t) (Subtype.mk.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s) t) hst))
Case conversion may be inaccurate. Consider using '#align ore_localization.expand OreLocalization.expandₓ'. -/
/-- A fraction `r /ₒ s` is equal to its expansion by an arbitrary factor `t` if `s * t ∈ S`. -/
protected theorem expand (r : R) (s : S) (t : R) (hst : (s : R) * t ∈ S) :
    r /ₒ s = r * t /ₒ ⟨s * t, hst⟩ := by
  apply Quotient.sound
  refine' ⟨s, t * s, _, _⟩ <;> dsimp <;> rw [mul_assoc] <;> rfl
#align ore_localization.expand OreLocalization.expand

/- warning: ore_localization.expand' -> OreLocalization.expand' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] (r : R) (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (s' : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S), Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r s) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s')) (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Submonoid.mul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S)) s s'))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] (r : R) (s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (s' : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)), Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r s) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s')) (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (instHMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Submonoid.mul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S)) s s'))
Case conversion may be inaccurate. Consider using '#align ore_localization.expand' OreLocalization.expand'ₓ'. -/
/-- A fraction is equal to its expansion by an factor from s. -/
protected theorem expand' (r : R) (s s' : S) : r /ₒ s = r * s' /ₒ (s * s') :=
  OreLocalization.expand r s s' (by norm_cast <;> apply SetLike.coe_mem)
#align ore_localization.expand' OreLocalization.expand'

/- warning: ore_localization.eq_of_num_factor_eq -> OreLocalization.eq_of_num_factor_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {r : R} {r' : R} {r₁ : R} {r₂ : R} {s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S} {t : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S}, (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) t)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r' ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) t))) -> (Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ r) r₂) s) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ r') r₂) s))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {r : R} {r' : R} {r₁ : R} {r₂ : R} {s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)} {t : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)}, (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) t)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r' (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) t))) -> (Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ r) r₂) s) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ r') r₂) s))
Case conversion may be inaccurate. Consider using '#align ore_localization.eq_of_num_factor_eq OreLocalization.eq_of_num_factor_eqₓ'. -/
/-- Fractions which differ by a factor of the numerator can be proven equal if
those factors expand to equal elements of `R`. -/
protected theorem eq_of_num_factor_eq {r r' r₁ r₂ : R} {s t : S} (h : r * t = r' * t) :
    r₁ * r * r₂ /ₒ s = r₁ * r' * r₂ /ₒ s :=
  by
  rcases ore_condition r₂ t with ⟨r₂', t', hr₂⟩
  calc
    r₁ * r * r₂ /ₒ s = r₁ * r * r₂ * t' /ₒ (s * t') := OreLocalization.expand _ _ t' _
    _ = r₁ * r * (r₂ * t') /ₒ (s * t') := by simp [← mul_assoc]
    _ = r₁ * r * (t * r₂') /ₒ (s * t') := by rw [hr₂]
    _ = r₁ * (r * t) * r₂' /ₒ (s * t') := by simp [← mul_assoc]
    _ = r₁ * (r' * t) * r₂' /ₒ (s * t') := by rw [h]
    _ = r₁ * r' * (t * r₂') /ₒ (s * t') := by simp [← mul_assoc]
    _ = r₁ * r' * (r₂ * t') /ₒ (s * t') := by rw [hr₂]
    _ = r₁ * r' * r₂ * t' /ₒ (s * t') := by simp [← mul_assoc]
    _ = r₁ * r' * r₂ /ₒ s := by symm <;> apply OreLocalization.expand
    
#align ore_localization.eq_of_num_factor_eq OreLocalization.eq_of_num_factor_eq

/- warning: ore_localization.lift_expand -> OreLocalization.liftExpand is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {C : Sort.{u2}} (P : R -> (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) -> C), (forall (r : R) (t : R) (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (ht : Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s) t) S), Eq.{u2} C (P r s) (P (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r t) (Subtype.mk.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s) t) ht))) -> (OreLocalization.{u1} R _inst_1 S _inst_2) -> C
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {C : Sort.{u2}} (P : R -> (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) -> C), (forall (r : R) (t : R) (s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (ht : Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s) t) S), Eq.{u2} C (P r s) (P (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r t) (Subtype.mk.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s) t) ht))) -> (OreLocalization.{u1} R _inst_1 S _inst_2) -> C
Case conversion may be inaccurate. Consider using '#align ore_localization.lift_expand OreLocalization.liftExpandₓ'. -/
/-- A function or predicate over `R` and `S` can be lifted to `R[S⁻¹]` if it is invariant
under expansion on the right. -/
def liftExpand {C : Sort _} (P : R → S → C)
    (hP : ∀ (r t : R) (s : S) (ht : (s : R) * t ∈ S), P r s = P (r * t) ⟨s * t, ht⟩) : R[S⁻¹] → C :=
  Quotient.lift (fun p : R × S => P p.1 p.2) fun p q pq =>
    by
    cases' p with r₁ s₁
    cases' q with r₂ s₂
    rcases pq with ⟨u, v, hr₂, hs₂⟩
    dsimp at *
    have s₁vS : (s₁ : R) * v ∈ S := by
      rw [← hs₂, ← S.coe_mul]
      exact SetLike.coe_mem (s₂ * u)
    replace hs₂ : s₂ * u = ⟨(s₁ : R) * v, s₁vS⟩
    · ext
      simp [hs₂]
    rw [hP r₁ v s₁ s₁vS,
      hP r₂ u s₂
        (by
          norm_cast
          rw [hs₂]
          assumption),
      hr₂]
    simpa [← hs₂]
#align ore_localization.lift_expand OreLocalization.liftExpand

/- warning: ore_localization.lift_expand_of -> OreLocalization.liftExpand_of is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {C : Sort.{u2}} {P : R -> (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) -> C} {hP : forall (r : R) (t : R) (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (ht : Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s) t) S), Eq.{u2} C (P r s) (P (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r t) (Subtype.mk.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s) t) ht))} (r : R) (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S), Eq.{u2} C (OreLocalization.liftExpand.{u1, u2} R _inst_1 S _inst_2 C P hP (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r s)) (P r s)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {C : Sort.{u2}} {P : R -> (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) -> C} {hP : forall (r : R) (t : R) (s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (ht : Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s) t) S), Eq.{u2} C (P r s) (P (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r t) (Subtype.mk.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s) t) ht))} (r : R) (s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)), Eq.{u2} C (OreLocalization.liftExpand.{u1, u2} R _inst_1 S _inst_2 C P hP (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r s)) (P r s)
Case conversion may be inaccurate. Consider using '#align ore_localization.lift_expand_of OreLocalization.liftExpand_ofₓ'. -/
@[simp]
theorem liftExpand_of {C : Sort _} {P : R → S → C}
    {hP : ∀ (r t : R) (s : S) (ht : (s : R) * t ∈ S), P r s = P (r * t) ⟨s * t, ht⟩} (r : R)
    (s : S) : liftExpand P hP (r /ₒ s) = P r s :=
  rfl
#align ore_localization.lift_expand_of OreLocalization.liftExpand_of

/- warning: ore_localization.lift₂_expand -> OreLocalization.lift₂Expand is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {C : Sort.{u2}} (P : R -> (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) -> R -> (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) -> C), (forall (r₁ : R) (t₁ : R) (s₁ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (ht₁ : Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s₁) t₁) S) (r₂ : R) (t₂ : R) (s₂ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (ht₂ : Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s₂) t₂) S), Eq.{u2} C (P r₁ s₁ r₂ s₂) (P (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ t₁) (Subtype.mk.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s₁) t₁) ht₁) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₂ t₂) (Subtype.mk.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s₂) t₂) ht₂))) -> (OreLocalization.{u1} R _inst_1 S _inst_2) -> (OreLocalization.{u1} R _inst_1 S _inst_2) -> C
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {C : Sort.{u2}} (P : R -> (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) -> R -> (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) -> C), (forall (r₁ : R) (t₁ : R) (s₁ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (ht₁ : Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s₁) t₁) S) (r₂ : R) (t₂ : R) (s₂ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (ht₂ : Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s₂) t₂) S), Eq.{u2} C (P r₁ s₁ r₂ s₂) (P (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ t₁) (Subtype.mk.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s₁) t₁) ht₁) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₂ t₂) (Subtype.mk.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s₂) t₂) ht₂))) -> (OreLocalization.{u1} R _inst_1 S _inst_2) -> (OreLocalization.{u1} R _inst_1 S _inst_2) -> C
Case conversion may be inaccurate. Consider using '#align ore_localization.lift₂_expand OreLocalization.lift₂Expandₓ'. -/
/-- A version of `lift_expand` used to simultaneously lift functions with two arguments
in ``R[S⁻¹]`.-/
def lift₂Expand {C : Sort _} (P : R → S → R → S → C)
    (hP :
      ∀ (r₁ t₁ : R) (s₁ : S) (ht₁ : (s₁ : R) * t₁ ∈ S) (r₂ t₂ : R) (s₂ : S)
        (ht₂ : (s₂ : R) * t₂ ∈ S),
        P r₁ s₁ r₂ s₂ = P (r₁ * t₁) ⟨s₁ * t₁, ht₁⟩ (r₂ * t₂) ⟨s₂ * t₂, ht₂⟩) :
    R[S⁻¹] → R[S⁻¹] → C :=
  liftExpand
    (fun r₁ s₁ =>
      liftExpand (P r₁ s₁) fun r₂ t₂ s₂ ht₂ => by simp [hP r₁ 1 s₁ (by simp) r₂ t₂ s₂ ht₂])
    fun r₁ t₁ s₁ ht₁ => by
    ext x; induction' x using OreLocalization.ind with r₂ s₂
    rw [lift_expand_of, lift_expand_of, hP r₁ t₁ s₁ ht₁ r₂ 1 s₂ (by simp)]; simp
#align ore_localization.lift₂_expand OreLocalization.lift₂Expand

/- warning: ore_localization.lift₂_expand_of -> OreLocalization.lift₂Expand_of is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {C : Sort.{u2}} {P : R -> (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) -> R -> (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) -> C} {hP : forall (r₁ : R) (t₁ : R) (s₁ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (ht₁ : Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s₁) t₁) S) (r₂ : R) (t₂ : R) (s₂ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (ht₂ : Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s₂) t₂) S), Eq.{u2} C (P r₁ s₁ r₂ s₂) (P (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ t₁) (Subtype.mk.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s₁) t₁) ht₁) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₂ t₂) (Subtype.mk.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s₂) t₂) ht₂))} (r₁ : R) (s₁ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (r₂ : R) (s₂ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S), Eq.{u2} C (OreLocalization.lift₂Expand.{u1, u2} R _inst_1 S _inst_2 C P hP (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₁ s₁) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₂ s₂)) (P r₁ s₁ r₂ s₂)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {C : Sort.{u2}} {P : R -> (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) -> R -> (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) -> C} {hP : forall (r₁ : R) (t₁ : R) (s₁ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (ht₁ : Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s₁) t₁) S) (r₂ : R) (t₂ : R) (s₂ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (ht₂ : Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s₂) t₂) S), Eq.{u2} C (P r₁ s₁ r₂ s₂) (P (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ t₁) (Subtype.mk.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s₁) t₁) ht₁) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₂ t₂) (Subtype.mk.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s₂) t₂) ht₂))} (r₁ : R) (s₁ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (r₂ : R) (s₂ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)), Eq.{u2} C (OreLocalization.lift₂Expand.{u1, u2} R _inst_1 S _inst_2 C P hP (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₁ s₁) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₂ s₂)) (P r₁ s₁ r₂ s₂)
Case conversion may be inaccurate. Consider using '#align ore_localization.lift₂_expand_of OreLocalization.lift₂Expand_ofₓ'. -/
@[simp]
theorem lift₂Expand_of {C : Sort _} {P : R → S → R → S → C}
    {hP :
      ∀ (r₁ t₁ : R) (s₁ : S) (ht₁ : (s₁ : R) * t₁ ∈ S) (r₂ t₂ : R) (s₂ : S)
        (ht₂ : (s₂ : R) * t₂ ∈ S),
        P r₁ s₁ r₂ s₂ = P (r₁ * t₁) ⟨s₁ * t₁, ht₁⟩ (r₂ * t₂) ⟨s₂ * t₂, ht₂⟩}
    (r₁ : R) (s₁ : S) (r₂ : R) (s₂ : S) : lift₂Expand P hP (r₁ /ₒ s₁) (r₂ /ₒ s₂) = P r₁ s₁ r₂ s₂ :=
  rfl
#align ore_localization.lift₂_expand_of OreLocalization.lift₂Expand_of

private def mul' (r₁ : R) (s₁ : S) (r₂ : R) (s₂ : S) : R[S⁻¹] :=
  r₁ * oreNum r₂ s₁ /ₒ (s₂ * oreDenom r₂ s₁)
#align ore_localization.mul' ore_localization.mul'

private theorem mul'_char (r₁ r₂ : R) (s₁ s₂ : S) (u : S) (v : R) (huv : r₂ * (u : R) = s₁ * v) :
    mul' r₁ s₁ r₂ s₂ = r₁ * v /ₒ (s₂ * u) :=
  by
  simp only [mul']
  have h₀ := ore_eq r₂ s₁; set v₀ := ore_num r₂ s₁; set u₀ := ore_denom r₂ s₁
  rcases ore_condition (u₀ : R) u with ⟨r₃, s₃, h₃⟩
  have :=
    calc
      (s₁ : R) * (v * r₃) = r₂ * u * r₃ := by assoc_rw [← huv] <;> symm <;> apply mul_assoc
      _ = r₂ * u₀ * s₃ := by assoc_rw [← h₃] <;> rfl
      _ = s₁ * (v₀ * s₃) := by assoc_rw [h₀] <;> apply mul_assoc
      
  rcases ore_left_cancel _ _ _ this with ⟨s₄, hs₄⟩
  symm; rw [ore_div_eq_iff]
  use s₃ * s₄; use r₃ * s₄; simp only [Submonoid.coe_mul]; constructor
  · assoc_rw [← hs₄]
    simp only [mul_assoc]
  · assoc_rw [h₃]
    simp only [mul_assoc]
#align ore_localization.mul'_char ore_localization.mul'_char

#print OreLocalization.mul /-
/-- The multiplication on the Ore localization of monoids. -/
protected def mul : R[S⁻¹] → R[S⁻¹] → R[S⁻¹] :=
  lift₂Expand mul' fun r₂ p s₂ hp r₁ r s₁ hr =>
    by
    have h₁ := ore_eq r₁ s₂
    set r₁' := ore_num r₁ s₂
    set s₂' := ore_denom r₁ s₂
    rcases ore_condition (↑s₂ * r₁') ⟨s₂ * p, hp⟩ with ⟨p', s_star, h₂⟩
    dsimp at h₂
    rcases ore_condition r (s₂' * s_star) with ⟨p_flat, s_flat, h₃⟩
    simp only [S.coe_mul] at h₃
    have : r₁ * r * s_flat = s₂ * p * (p' * p_flat) :=
      by
      rw [← mul_assoc, ← h₂, ← h₁, mul_assoc, h₃]
      simp only [mul_assoc]
    rw [mul'_char (r₂ * p) (r₁ * r) ⟨↑s₂ * p, hp⟩ ⟨↑s₁ * r, hr⟩ _ _ this]
    clear this
    have hsssp : ↑s₁ * ↑s₂' * ↑s_star * p_flat ∈ S :=
      by
      rw [mul_assoc, mul_assoc, ← mul_assoc ↑s₂', ← h₃, ← mul_assoc]
      exact S.mul_mem hr (SetLike.coe_mem s_flat)
    have : (⟨↑s₁ * r, hr⟩ : S) * s_flat = ⟨s₁ * s₂' * s_star * p_flat, hsssp⟩ :=
      by
      ext
      simp only [[anonymous], Submonoid.coe_mul]
      rw [mul_assoc, h₃, ← mul_assoc, ← mul_assoc]
    rw [this]
    clear this
    rcases ore_left_cancel (p * p') (r₁' * ↑s_star) s₂ (by simp [← mul_assoc, h₂]) with ⟨s₂'', h₂''⟩
    rw [← mul_assoc, mul_assoc r₂, OreLocalization.eq_of_num_factor_eq h₂'']
    norm_cast  at hsssp⊢
    rw [← OreLocalization.expand _ _ _ hsssp, ← mul_assoc]
    apply OreLocalization.expand
#align ore_localization.mul OreLocalization.mul
-/

instance : Mul R[S⁻¹] :=
  ⟨OreLocalization.mul⟩

/- warning: ore_localization.ore_div_mul_ore_div -> OreLocalization.oreDiv_mul_oreDiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {r₁ : R} {r₂ : R} {s₁ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S} {s₂ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S}, Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.hasMul.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₁ s₁) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₂ s₂)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ (OreLocalization.oreNum.{u1} R _inst_1 S _inst_2 r₂ s₁)) (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Submonoid.mul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S)) s₂ (OreLocalization.oreDenom.{u1} R _inst_1 S _inst_2 r₂ s₁)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {r₁ : R} {r₂ : R} {s₁ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)} {s₂ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)}, Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₁ s₁) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₂ s₂)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ (OreLocalization.oreNum.{u1} R _inst_1 S _inst_2 r₂ s₁)) (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (instHMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Submonoid.mul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S)) s₂ (OreLocalization.oreDenom.{u1} R _inst_1 S _inst_2 r₂ s₁)))
Case conversion may be inaccurate. Consider using '#align ore_localization.ore_div_mul_ore_div OreLocalization.oreDiv_mul_oreDivₓ'. -/
theorem oreDiv_mul_oreDiv {r₁ r₂ : R} {s₁ s₂ : S} :
    r₁ /ₒ s₁ * (r₂ /ₒ s₂) = r₁ * oreNum r₂ s₁ /ₒ (s₂ * oreDenom r₂ s₁) :=
  rfl
#align ore_localization.ore_div_mul_ore_div OreLocalization.oreDiv_mul_oreDiv

/- warning: ore_localization.ore_div_mul_char -> OreLocalization.oreDiv_mul_char is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] (r₁ : R) (r₂ : R) (s₁ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (s₂ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (r' : R) (s' : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S), (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₂ ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s')) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s₁) r')) -> (Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.hasMul.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₁ s₁) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₂ s₂)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ r') (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Submonoid.mul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S)) s₂ s')))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] (r₁ : R) (r₂ : R) (s₁ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (s₂ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (r' : R) (s' : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)), (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₂ (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s')) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s₁) r')) -> (Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₁ s₁) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₂ s₂)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ r') (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (instHMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Submonoid.mul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S)) s₂ s')))
Case conversion may be inaccurate. Consider using '#align ore_localization.ore_div_mul_char OreLocalization.oreDiv_mul_charₓ'. -/
/-- A characterization lemma for the multiplication on the Ore localization, allowing for a choice
of Ore numerator and Ore denominator. -/
theorem oreDiv_mul_char (r₁ r₂ : R) (s₁ s₂ : S) (r' : R) (s' : S) (huv : r₂ * (s' : R) = s₁ * r') :
    r₁ /ₒ s₁ * (r₂ /ₒ s₂) = r₁ * r' /ₒ (s₂ * s') :=
  mul'_char r₁ r₂ s₁ s₂ s' r' huv
#align ore_localization.ore_div_mul_char OreLocalization.oreDiv_mul_char

/- warning: ore_localization.ore_div_mul_char' -> OreLocalization.oreDivMulChar' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] (r₁ : R) (r₂ : R) (s₁ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (s₂ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S), PSigma.{succ u1, succ u1} R (fun (r' : R) => PSigma.{succ u1, 0} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (fun (s' : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) => And (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₂ ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s')) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s₁) r')) (Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.hasMul.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₁ s₁) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₂ s₂)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ r') (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Submonoid.mul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S)) s₂ s')))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] (r₁ : R) (r₂ : R) (s₁ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (s₂ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)), PSigma.{succ u1, succ u1} R (fun (r' : R) => PSigma.{succ u1, 0} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (fun (s' : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) => And (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₂ (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s')) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s₁) r')) (Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₁ s₁) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₂ s₂)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ r') (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (instHMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Submonoid.mul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S)) s₂ s')))))
Case conversion may be inaccurate. Consider using '#align ore_localization.ore_div_mul_char' OreLocalization.oreDivMulChar'ₓ'. -/
/-- Another characterization lemma for the multiplication on the Ore localizaion delivering
Ore witnesses and conditions bundled in a sigma type. -/
def oreDivMulChar' (r₁ r₂ : R) (s₁ s₂ : S) :
    Σ'r' : R, Σ's' : S, r₂ * (s' : R) = s₁ * r' ∧ r₁ /ₒ s₁ * (r₂ /ₒ s₂) = r₁ * r' /ₒ (s₂ * s') :=
  ⟨oreNum r₂ s₁, oreDenom r₂ s₁, ore_eq r₂ s₁, oreDiv_mul_oreDiv⟩
#align ore_localization.ore_div_mul_char' OreLocalization.oreDivMulChar'

instance : One R[S⁻¹] :=
  ⟨1 /ₒ 1⟩

/- warning: ore_localization.one_def -> OreLocalization.one_def is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S], Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OfNat.ofNat.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (OfNat.mk.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (One.one.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.hasOne.{u1} R _inst_1 S _inst_2)))) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (MulOneClass.toHasOne.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))))) (OfNat.ofNat.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) 1 (OfNat.mk.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) 1 (One.one.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Submonoid.one.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S], Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OfNat.ofNat.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (One.toOfNat1.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instOneOreLocalization.{u1} R _inst_1 S _inst_2))) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Monoid.toOne.{u1} R _inst_1))) (OfNat.ofNat.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) 1 (One.toOfNat1.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Submonoid.one.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S))))
Case conversion may be inaccurate. Consider using '#align ore_localization.one_def OreLocalization.one_defₓ'. -/
protected theorem one_def : (1 : R[S⁻¹]) = 1 /ₒ 1 :=
  rfl
#align ore_localization.one_def OreLocalization.one_def

instance : Inhabited R[S⁻¹] :=
  ⟨1⟩

/- warning: ore_localization.div_eq_one' -> OreLocalization.div_eq_one' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {r : R} (hr : Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r S), Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r (Subtype.mk.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S) r hr)) (OfNat.ofNat.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (OfNat.mk.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (One.one.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.hasOne.{u1} R _inst_1 S _inst_2))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {r : R} (hr : Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r S), Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r (Subtype.mk.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S) r hr)) (OfNat.ofNat.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (One.toOfNat1.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instOneOreLocalization.{u1} R _inst_1 S _inst_2)))
Case conversion may be inaccurate. Consider using '#align ore_localization.div_eq_one' OreLocalization.div_eq_one'ₓ'. -/
@[simp]
protected theorem div_eq_one' {r : R} (hr : r ∈ S) : r /ₒ ⟨r, hr⟩ = 1 :=
  by
  rw [OreLocalization.one_def, ore_div_eq_iff]
  exact ⟨⟨r, hr⟩, 1, by simp, by simp⟩
#align ore_localization.div_eq_one' OreLocalization.div_eq_one'

/- warning: ore_localization.div_eq_one -> OreLocalization.div_eq_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S}, Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s) s) (OfNat.ofNat.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (OfNat.mk.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (One.one.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.hasOne.{u1} R _inst_1 S _inst_2))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)}, Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s) s) (OfNat.ofNat.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (One.toOfNat1.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instOneOreLocalization.{u1} R _inst_1 S _inst_2)))
Case conversion may be inaccurate. Consider using '#align ore_localization.div_eq_one OreLocalization.div_eq_oneₓ'. -/
@[simp]
protected theorem div_eq_one {s : S} : (s : R) /ₒ s = 1 := by
  cases s <;> apply OreLocalization.div_eq_one'
#align ore_localization.div_eq_one OreLocalization.div_eq_one

/- warning: ore_localization.one_mul -> OreLocalization.one_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] (x : OreLocalization.{u1} R _inst_1 S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.hasMul.{u1} R _inst_1 S _inst_2)) (OfNat.ofNat.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (OfNat.mk.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (One.one.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.hasOne.{u1} R _inst_1 S _inst_2)))) x) x
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] (x : OreLocalization.{u1} R _inst_1 S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R _inst_1 S _inst_2)) (OfNat.ofNat.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (One.toOfNat1.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instOneOreLocalization.{u1} R _inst_1 S _inst_2))) x) x
Case conversion may be inaccurate. Consider using '#align ore_localization.one_mul OreLocalization.one_mulₓ'. -/
protected theorem one_mul (x : R[S⁻¹]) : 1 * x = x :=
  by
  induction' x using OreLocalization.ind with r s
  simp [OreLocalization.one_def, ore_div_mul_char (1 : R) r (1 : S) s r 1 (by simp)]
#align ore_localization.one_mul OreLocalization.one_mul

/- warning: ore_localization.mul_one -> OreLocalization.mul_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] (x : OreLocalization.{u1} R _inst_1 S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.hasMul.{u1} R _inst_1 S _inst_2)) x (OfNat.ofNat.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (OfNat.mk.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (One.one.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.hasOne.{u1} R _inst_1 S _inst_2))))) x
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] (x : OreLocalization.{u1} R _inst_1 S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R _inst_1 S _inst_2)) x (OfNat.ofNat.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (One.toOfNat1.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instOneOreLocalization.{u1} R _inst_1 S _inst_2)))) x
Case conversion may be inaccurate. Consider using '#align ore_localization.mul_one OreLocalization.mul_oneₓ'. -/
protected theorem mul_one (x : R[S⁻¹]) : x * 1 = x :=
  by
  induction' x using OreLocalization.ind with r s
  simp [OreLocalization.one_def, ore_div_mul_char r 1 s 1 1 s (by simp)]
#align ore_localization.mul_one OreLocalization.mul_one

#print OreLocalization.mul_assoc /-
protected theorem mul_assoc (x y z : R[S⁻¹]) : x * y * z = x * (y * z) :=
  by
  induction' x using OreLocalization.ind with r₁ s₁
  induction' y using OreLocalization.ind with r₂ s₂
  induction' z using OreLocalization.ind with r₃ s₃
  rcases ore_div_mul_char' r₁ r₂ s₁ s₂ with ⟨ra, sa, ha, ha'⟩; rw [ha']; clear ha'
  rcases ore_div_mul_char' r₂ r₃ s₂ s₃ with ⟨rb, sb, hb, hb'⟩; rw [hb']; clear hb'
  rcases ore_condition rb sa with ⟨rc, sc, hc⟩
  rw [ore_div_mul_char (r₁ * ra) r₃ (s₂ * sa) s₃ rc (sb * sc)
      (by
        simp only [Submonoid.coe_mul]
        assoc_rw [hb, hc])]
  rw [mul_assoc, ← mul_assoc s₃]
  symm; apply ore_div_mul_char
  assoc_rw [hc, ← ha]; apply mul_assoc
#align ore_localization.mul_assoc OreLocalization.mul_assoc
-/

instance : Monoid R[S⁻¹] :=
  { OreLocalization.hasMul,
    OreLocalization.hasOne with
    one_mul := OreLocalization.one_mul
    mul_one := OreLocalization.mul_one
    mul_assoc := OreLocalization.mul_assoc }

/- warning: ore_localization.mul_inv -> OreLocalization.mul_inv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (s' : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S), Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.hasMul.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s) s') (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s') s)) (OfNat.ofNat.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (OfNat.mk.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (One.one.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.hasOne.{u1} R _inst_1 S _inst_2))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] (s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (s' : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)), Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s) s') (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s') s)) (OfNat.ofNat.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) 1 (One.toOfNat1.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instOneOreLocalization.{u1} R _inst_1 S _inst_2)))
Case conversion may be inaccurate. Consider using '#align ore_localization.mul_inv OreLocalization.mul_invₓ'. -/
protected theorem mul_inv (s s' : S) : (s : R) /ₒ s' * (s' /ₒ s) = 1 := by
  simp [ore_div_mul_char (s : R) s' s' s 1 1 (by simp)]
#align ore_localization.mul_inv OreLocalization.mul_inv

/- warning: ore_localization.mul_one_div -> OreLocalization.mul_one_div is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {r : R} {s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S} {t : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S}, Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.hasMul.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r s) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (MulOneClass.toHasOne.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))))) t)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Submonoid.mul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S)) t s))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {r : R} {s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)} {t : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)}, Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r s) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Monoid.toOne.{u1} R _inst_1))) t)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (instHMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Submonoid.mul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S)) t s))
Case conversion may be inaccurate. Consider using '#align ore_localization.mul_one_div OreLocalization.mul_one_divₓ'. -/
@[simp]
protected theorem mul_one_div {r : R} {s t : S} : r /ₒ s * (1 /ₒ t) = r /ₒ (t * s) := by
  simp [ore_div_mul_char r 1 s t 1 s (by simp)]
#align ore_localization.mul_one_div OreLocalization.mul_one_div

/- warning: ore_localization.mul_cancel -> OreLocalization.mul_cancel is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {r : R} {s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S} {t : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S}, Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.hasMul.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r s) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s) t)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r t)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {r : R} {s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)} {t : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)}, Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r s) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s) t)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r t)
Case conversion may be inaccurate. Consider using '#align ore_localization.mul_cancel OreLocalization.mul_cancelₓ'. -/
@[simp]
protected theorem mul_cancel {r : R} {s t : S} : r /ₒ s * (s /ₒ t) = r /ₒ t := by
  simp [ore_div_mul_char r s s t 1 1 (by simp)]
#align ore_localization.mul_cancel OreLocalization.mul_cancel

/- warning: ore_localization.mul_cancel' -> OreLocalization.mul_cancel' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {r₁ : R} {r₂ : R} {s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S} {t : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S}, Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.hasMul.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₁ s) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s) r₂) t)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ r₂) t)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {r₁ : R} {r₂ : R} {s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)} {t : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)}, Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r₁ s) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s) r₂) t)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r₁ r₂) t)
Case conversion may be inaccurate. Consider using '#align ore_localization.mul_cancel' OreLocalization.mul_cancel'ₓ'. -/
@[simp]
protected theorem mul_cancel' {r₁ r₂ : R} {s t : S} : r₁ /ₒ s * (s * r₂ /ₒ t) = r₁ * r₂ /ₒ t := by
  simp [ore_div_mul_char r₁ (s * r₂) s t r₂ 1 (by simp)]
#align ore_localization.mul_cancel' OreLocalization.mul_cancel'

/- warning: ore_localization.div_one_mul -> OreLocalization.div_one_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {p : R} {r : R} {s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S}, Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.hasMul.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r (OfNat.ofNat.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) 1 (OfNat.mk.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) 1 (One.one.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Submonoid.one.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S))))) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 p s)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r p) s)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {p : R} {r : R} {s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)}, Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.{u1} R _inst_1 S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r (OfNat.ofNat.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) 1 (One.toOfNat1.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Submonoid.one.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S)))) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 p s)) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) r p) s)
Case conversion may be inaccurate. Consider using '#align ore_localization.div_one_mul OreLocalization.div_one_mulₓ'. -/
@[simp]
theorem div_one_mul {p r : R} {s : S} : r /ₒ 1 * (p /ₒ s) = r * p /ₒ s :=
  by--TODO use coercion r ↦ r /ₒ 1
  simp [ore_div_mul_char r p 1 s p 1 (by simp)]
#align ore_localization.div_one_mul OreLocalization.div_one_mul

/- warning: ore_localization.numerator_unit -> OreLocalization.numeratorUnit is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S], (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) -> (Units.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S], (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) -> (Units.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))
Case conversion may be inaccurate. Consider using '#align ore_localization.numerator_unit OreLocalization.numeratorUnitₓ'. -/
/-- The fraction `s /ₒ 1` as a unit in `R[S⁻¹]`, where `s : S`. -/
def numeratorUnit (s : S) : Units R[S⁻¹]
    where
  val := (s : R) /ₒ 1
  inv := (1 : R) /ₒ s
  val_inv := OreLocalization.mul_inv s 1
  inv_val := OreLocalization.mul_inv 1 s
#align ore_localization.numerator_unit OreLocalization.numeratorUnit

/- warning: ore_localization.numerator_hom -> OreLocalization.numeratorHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S], MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S], MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))
Case conversion may be inaccurate. Consider using '#align ore_localization.numerator_hom OreLocalization.numeratorHomₓ'. -/
/-- The multiplicative homomorphism from `R` to `R[S⁻¹]`, mapping `r : R` to the
fraction `r /ₒ 1`. -/
def numeratorHom : R →* R[S⁻¹] where
  toFun r := r /ₒ 1
  map_one' := rfl
  map_mul' r₁ r₂ := div_one_mul.symm
#align ore_localization.numerator_hom OreLocalization.numeratorHom

/- warning: ore_localization.numerator_hom_apply -> OreLocalization.numeratorHom_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {r : R}, Eq.{succ u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2))) (fun (_x : MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2))) => R -> (OreLocalization.{u1} R _inst_1 S _inst_2)) (MonoidHom.hasCoeToFun.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2))) (OreLocalization.numeratorHom.{u1} R _inst_1 S _inst_2) r) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r (OfNat.ofNat.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) 1 (OfNat.mk.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) 1 (One.one.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Submonoid.one.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {r : R}, Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => OreLocalization.{u1} R _inst_1 S _inst_2) r) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => OreLocalization.{u1} R _inst_1 S _inst_2) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) R (OreLocalization.{u1} R _inst_1 S _inst_2) (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (MulOneClass.toMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2)) (MonoidHom.monoidHomClass.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))))) (OreLocalization.numeratorHom.{u1} R _inst_1 S _inst_2) r) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r (OfNat.ofNat.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) 1 (One.toOfNat1.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Submonoid.one.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S))))
Case conversion may be inaccurate. Consider using '#align ore_localization.numerator_hom_apply OreLocalization.numeratorHom_applyₓ'. -/
theorem numeratorHom_apply {r : R} : numeratorHom r = r /ₒ (1 : S) :=
  rfl
#align ore_localization.numerator_hom_apply OreLocalization.numeratorHom_apply

/- warning: ore_localization.numerator_is_unit -> OreLocalization.numerator_isUnit is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S), IsUnit.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2))) (fun (_x : MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2))) => R -> (OreLocalization.{u1} R _inst_1 S _inst_2)) (MonoidHom.hasCoeToFun.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2))) (OreLocalization.numeratorHom.{u1} R _inst_1 S _inst_2) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] (s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)), IsUnit.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => OreLocalization.{u1} R _inst_1 S _inst_2) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s)) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => OreLocalization.{u1} R _inst_1 S _inst_2) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) R (OreLocalization.{u1} R _inst_1 S _inst_2) (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (MulOneClass.toMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2)) (MonoidHom.monoidHomClass.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))))) (OreLocalization.numeratorHom.{u1} R _inst_1 S _inst_2) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s))
Case conversion may be inaccurate. Consider using '#align ore_localization.numerator_is_unit OreLocalization.numerator_isUnitₓ'. -/
theorem numerator_isUnit (s : S) : IsUnit (numeratorHom (s : R) : R[S⁻¹]) :=
  ⟨numeratorUnit s, rfl⟩
#align ore_localization.numerator_is_unit OreLocalization.numerator_isUnit

section UMP

variable {T : Type _} [Monoid T]

variable (f : R →* T) (fS : S →* Units T)

variable (hf : ∀ s : S, f s = fS s)

include f fS hf

/- warning: ore_localization.universal_mul_hom -> OreLocalization.universalMulHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {T : Type.{u2}} [_inst_3 : Monoid.{u2} T] (f : MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) (fS : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)), (forall (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S), Eq.{succ u2} T (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) (fun (_x : MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) => R -> T) (MonoidHom.hasCoeToFun.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Units.{u2} T _inst_3) T (HasLiftT.mk.{succ u2, succ u2} (Units.{u2} T _inst_3) T (CoeTCₓ.coe.{succ u2, succ u2} (Units.{u2} T _inst_3) T (coeBase.{succ u2, succ u2} (Units.{u2} T _inst_3) T (Units.hasCoe.{u2} T _inst_3)))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) (fun (_x : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) => (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) -> (Units.{u2} T _inst_3)) (MonoidHom.hasCoeToFun.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) fS s))) -> (MonoidHom.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {T : Type.{u2}} [_inst_3 : Monoid.{u2} T] (f : MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) (fS : MonoidHom.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.instMulOneClassUnits.{u2} T _inst_3)), (forall (s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) R T (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (MulOneClass.toMul.{u2} T (Monoid.toMulOneClass.{u2} T _inst_3)) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3) (MonoidHom.monoidHomClass.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)))) f (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s)) (Units.val.{u2} T _inst_3 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.instMulOneClassUnits.{u2} T _inst_3)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (fun (_x : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) => Units.{u2} T _inst_3) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.instMulOneClassUnits.{u2} T _inst_3)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Units.{u2} T _inst_3) (MulOneClass.toMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S)) (MulOneClass.toMul.{u2} (Units.{u2} T _inst_3) (Units.instMulOneClassUnits.{u2} T _inst_3)) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.instMulOneClassUnits.{u2} T _inst_3)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.instMulOneClassUnits.{u2} T _inst_3) (MonoidHom.monoidHomClass.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.instMulOneClassUnits.{u2} T _inst_3)))) fS s))) -> (MonoidHom.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3))
Case conversion may be inaccurate. Consider using '#align ore_localization.universal_mul_hom OreLocalization.universalMulHomₓ'. -/
/-- The universal lift from a morphism `R →* T`, which maps elements of `S` to units of `T`,
to a morphism `R[S⁻¹] →* T`. -/
def universalMulHom : R[S⁻¹] →* T
    where
  toFun x :=
    x.liftExpand (fun r s => f r * ((fS s)⁻¹ : Units T)) fun r t s ht =>
      by
      have : (fS ⟨s * t, ht⟩ : T) = fS s * f t := by
        simp only [← hf, [anonymous], MonoidHom.map_mul]
      conv_rhs =>
        rw [MonoidHom.map_mul, ← mul_one (f r), ← Units.val_one, ← mul_left_inv (fS s)]
        rw [Units.val_mul, ← mul_assoc, mul_assoc _ ↑(fS s), ← this, mul_assoc]
      simp only [mul_one, Units.mul_inv]
  map_one' := by rw [OreLocalization.one_def, lift_expand_of] <;> simp
  map_mul' x y := by
    induction' x using OreLocalization.ind with r₁ s₁
    induction' y using OreLocalization.ind with r₂ s₂
    rcases ore_div_mul_char' r₁ r₂ s₁ s₂ with ⟨ra, sa, ha, ha'⟩; rw [ha']; clear ha'
    rw [lift_expand_of, lift_expand_of, lift_expand_of]
    conv_rhs =>
      congr
      skip
      congr
      rw [← mul_one (f r₂), ← (fS sa).mul_inv, ← mul_assoc, ← hf, ← f.map_mul, ha, f.map_mul]
    rw [mul_assoc, mul_assoc, mul_assoc, ← mul_assoc _ (f s₁), hf s₁, (fS s₁).inv_mul, one_mul,
      f.map_mul, mul_assoc, fS.map_mul, ← Units.val_mul]
    rfl
#align ore_localization.universal_mul_hom OreLocalization.universalMulHom

/- warning: ore_localization.universal_mul_hom_apply -> OreLocalization.universalMulHom_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {T : Type.{u2}} [_inst_3 : Monoid.{u2} T] (f : MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) (fS : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) (hf : forall (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S), Eq.{succ u2} T (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) (fun (_x : MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) => R -> T) (MonoidHom.hasCoeToFun.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Units.{u2} T _inst_3) T (HasLiftT.mk.{succ u2, succ u2} (Units.{u2} T _inst_3) T (CoeTCₓ.coe.{succ u2, succ u2} (Units.{u2} T _inst_3) T (coeBase.{succ u2, succ u2} (Units.{u2} T _inst_3) T (Units.hasCoe.{u2} T _inst_3)))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) (fun (_x : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) => (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) -> (Units.{u2} T _inst_3)) (MonoidHom.hasCoeToFun.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) fS s))) {r : R} {s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S}, Eq.{succ u2} T (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3)) (fun (_x : MonoidHom.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3)) => (OreLocalization.{u1} R _inst_1 S _inst_2) -> T) (MonoidHom.hasCoeToFun.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3)) (OreLocalization.universalMulHom.{u1, u2} R _inst_1 S _inst_2 T _inst_3 f fS hf) (OreLocalization.oreDiv.{u1} R _inst_1 S _inst_2 r s)) (HMul.hMul.{u2, u2, u2} T T T (instHMul.{u2} T (MulOneClass.toHasMul.{u2} T (Monoid.toMulOneClass.{u2} T _inst_3))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) (fun (_x : MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) => R -> T) (MonoidHom.hasCoeToFun.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) f r) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Units.{u2} T _inst_3) T (HasLiftT.mk.{succ u2, succ u2} (Units.{u2} T _inst_3) T (CoeTCₓ.coe.{succ u2, succ u2} (Units.{u2} T _inst_3) T (coeBase.{succ u2, succ u2} (Units.{u2} T _inst_3) T (Units.hasCoe.{u2} T _inst_3)))) (Inv.inv.{u2} (Units.{u2} T _inst_3) (Units.hasInv.{u2} T _inst_3) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) (fun (_x : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) => (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) -> (Units.{u2} T _inst_3)) (MonoidHom.hasCoeToFun.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) fS s))))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Monoid.{u2} R] {S : Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u2} R _inst_1 S] {T : Type.{u1}} [_inst_3 : Monoid.{u1} T] (f : MonoidHom.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)) (fS : MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3)) (hf : forall (s : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) (Subtype.val.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) x (SetLike.coe.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) S)) s)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)) R T (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (MulOneClass.toMul.{u1} T (Monoid.toMulOneClass.{u1} T _inst_3)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)) R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3) (MonoidHom.monoidHomClass.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)))) f (Subtype.val.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) x (SetLike.coe.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) S)) s)) (Units.val.{u1} T _inst_3 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3)) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (fun (_x : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) => Units.{u1} T _inst_3) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3)) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (MulOneClass.toMul.{u2} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S)) (MulOneClass.toMul.{u1} (Units.{u1} T _inst_3) (Units.instMulOneClassUnits.{u1} T _inst_3)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3)) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3) (MonoidHom.monoidHomClass.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3)))) fS s))) {r : R} {s : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)}, Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : OreLocalization.{u2} R _inst_1 S _inst_2) => T) (OreLocalization.oreDiv.{u2} R _inst_1 S _inst_2 r s)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (OreLocalization.{u2} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u1} T _inst_3)) (OreLocalization.{u2} R _inst_1 S _inst_2) (fun (_x : OreLocalization.{u2} R _inst_1 S _inst_2) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : OreLocalization.{u2} R _inst_1 S _inst_2) => T) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (OreLocalization.{u2} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u1} T _inst_3)) (OreLocalization.{u2} R _inst_1 S _inst_2) T (MulOneClass.toMul.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2))) (MulOneClass.toMul.{u1} T (Monoid.toMulOneClass.{u1} T _inst_3)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (OreLocalization.{u2} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u1} T _inst_3)) (OreLocalization.{u2} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u1} T _inst_3) (MonoidHom.monoidHomClass.{u2, u1} (OreLocalization.{u2} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u1} T _inst_3)))) (OreLocalization.universalMulHom.{u2, u1} R _inst_1 S _inst_2 T _inst_3 f fS hf) (OreLocalization.oreDiv.{u2} R _inst_1 S _inst_2 r s)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) r) T ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) r) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) r) (MulOneClass.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) r) (Monoid.toMulOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) r) _inst_3))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)) R T (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (MulOneClass.toMul.{u1} T (Monoid.toMulOneClass.{u1} T _inst_3)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)) R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3) (MonoidHom.monoidHomClass.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)))) f r) (Units.val.{u1} T _inst_3 (Inv.inv.{u1} (Units.{u1} T _inst_3) (Units.instInvUnits.{u1} T _inst_3) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3)) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (fun (_x : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) => Units.{u1} T _inst_3) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3)) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (MulOneClass.toMul.{u2} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S)) (MulOneClass.toMul.{u1} (Units.{u1} T _inst_3) (Units.instMulOneClassUnits.{u1} T _inst_3)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3)) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3) (MonoidHom.monoidHomClass.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3)))) fS s))))
Case conversion may be inaccurate. Consider using '#align ore_localization.universal_mul_hom_apply OreLocalization.universalMulHom_applyₓ'. -/
theorem universalMulHom_apply {r : R} {s : S} :
    universalMulHom f fS hf (r /ₒ s) = f r * ((fS s)⁻¹ : Units T) :=
  rfl
#align ore_localization.universal_mul_hom_apply OreLocalization.universalMulHom_apply

/- warning: ore_localization.universal_mul_hom_commutes -> OreLocalization.universalMulHom_commutes is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {T : Type.{u2}} [_inst_3 : Monoid.{u2} T] (f : MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) (fS : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) (hf : forall (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S), Eq.{succ u2} T (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) (fun (_x : MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) => R -> T) (MonoidHom.hasCoeToFun.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Units.{u2} T _inst_3) T (HasLiftT.mk.{succ u2, succ u2} (Units.{u2} T _inst_3) T (CoeTCₓ.coe.{succ u2, succ u2} (Units.{u2} T _inst_3) T (coeBase.{succ u2, succ u2} (Units.{u2} T _inst_3) T (Units.hasCoe.{u2} T _inst_3)))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) (fun (_x : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) => (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) -> (Units.{u2} T _inst_3)) (MonoidHom.hasCoeToFun.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) fS s))) {r : R}, Eq.{succ u2} T (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3)) (fun (_x : MonoidHom.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3)) => (OreLocalization.{u1} R _inst_1 S _inst_2) -> T) (MonoidHom.hasCoeToFun.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3)) (OreLocalization.universalMulHom.{u1, u2} R _inst_1 S _inst_2 T _inst_3 f fS hf) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2))) (fun (_x : MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2))) => R -> (OreLocalization.{u1} R _inst_1 S _inst_2)) (MonoidHom.hasCoeToFun.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2))) (OreLocalization.numeratorHom.{u1} R _inst_1 S _inst_2) r)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) (fun (_x : MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) => R -> T) (MonoidHom.hasCoeToFun.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) f r)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {T : Type.{u2}} [_inst_3 : Monoid.{u2} T] (f : MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) (fS : MonoidHom.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.instMulOneClassUnits.{u2} T _inst_3)) (hf : forall (s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) R T (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (MulOneClass.toMul.{u2} T (Monoid.toMulOneClass.{u2} T _inst_3)) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3) (MonoidHom.monoidHomClass.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)))) f (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) S)) s)) (Units.val.{u2} T _inst_3 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.instMulOneClassUnits.{u2} T _inst_3)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (fun (_x : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) => Units.{u2} T _inst_3) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.instMulOneClassUnits.{u2} T _inst_3)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Units.{u2} T _inst_3) (MulOneClass.toMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S)) (MulOneClass.toMul.{u2} (Units.{u2} T _inst_3) (Units.instMulOneClassUnits.{u2} T _inst_3)) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.instMulOneClassUnits.{u2} T _inst_3)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.instMulOneClassUnits.{u2} T _inst_3) (MonoidHom.monoidHomClass.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S)) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.instMulOneClassUnits.{u2} T _inst_3)))) fS s))) {r : R}, Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : OreLocalization.{u1} R _inst_1 S _inst_2) => T) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => OreLocalization.{u1} R _inst_1 S _inst_2) a) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) R (OreLocalization.{u1} R _inst_1 S _inst_2) (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (MulOneClass.toMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2)) (MonoidHom.monoidHomClass.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))))) (OreLocalization.numeratorHom.{u1} R _inst_1 S _inst_2) r)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3)) (OreLocalization.{u1} R _inst_1 S _inst_2) (fun (_x : OreLocalization.{u1} R _inst_1 S _inst_2) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : OreLocalization.{u1} R _inst_1 S _inst_2) => T) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3)) (OreLocalization.{u1} R _inst_1 S _inst_2) T (MulOneClass.toMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) (MulOneClass.toMul.{u2} T (Monoid.toMulOneClass.{u2} T _inst_3)) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3)) (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3) (MonoidHom.monoidHomClass.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3)))) (OreLocalization.universalMulHom.{u1, u2} R _inst_1 S _inst_2 T _inst_3 f fS hf) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => OreLocalization.{u1} R _inst_1 S _inst_2) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) R (OreLocalization.{u1} R _inst_1 S _inst_2) (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (MulOneClass.toMul.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))) R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2)) (MonoidHom.monoidHomClass.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R _inst_1 S _inst_2))))) (OreLocalization.numeratorHom.{u1} R _inst_1 S _inst_2) r)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) R T (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (MulOneClass.toMul.{u2} T (Monoid.toMulOneClass.{u2} T _inst_3)) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3) (MonoidHom.monoidHomClass.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)))) f r)
Case conversion may be inaccurate. Consider using '#align ore_localization.universal_mul_hom_commutes OreLocalization.universalMulHom_commutesₓ'. -/
theorem universalMulHom_commutes {r : R} : universalMulHom f fS hf (numeratorHom r) = f r := by
  simp [numerator_hom_apply, universal_mul_hom_apply]
#align ore_localization.universal_mul_hom_commutes OreLocalization.universalMulHom_commutes

/- warning: ore_localization.universal_mul_hom_unique -> OreLocalization.universalMulHom_unique is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Monoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u1} R _inst_1 S] {T : Type.{u2}} [_inst_3 : Monoid.{u2} T] (f : MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) (fS : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) (hf : forall (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S), Eq.{succ u2} T (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) (fun (_x : MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) => R -> T) (MonoidHom.hasCoeToFun.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) x S))))) s)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Units.{u2} T _inst_3) T (HasLiftT.mk.{succ u2, succ u2} (Units.{u2} T _inst_3) T (CoeTCₓ.coe.{succ u2, succ u2} (Units.{u2} T _inst_3) T (coeBase.{succ u2, succ u2} (Units.{u2} T _inst_3) T (Units.hasCoe.{u2} T _inst_3)))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) (fun (_x : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) => (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) -> (Units.{u2} T _inst_3)) (MonoidHom.hasCoeToFun.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1)) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1))) S) (Units.{u2} T _inst_3) (Submonoid.toMulOneClass.{u1} R (Monoid.toMulOneClass.{u1} R _inst_1) S) (Units.mulOneClass.{u2} T _inst_3)) fS s))) (φ : MonoidHom.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3)), (forall (r : R), Eq.{succ u2} T (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3)) (fun (_x : MonoidHom.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3)) => (OreLocalization.{u1} R _inst_1 S _inst_2) -> T) (MonoidHom.hasCoeToFun.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3)) φ (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2))) (fun (_x : MonoidHom.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2))) => R -> (OreLocalization.{u1} R _inst_1 S _inst_2)) (MonoidHom.hasCoeToFun.{u1, u1} R (OreLocalization.{u1} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2))) (OreLocalization.numeratorHom.{u1} R _inst_1 S _inst_2) r)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) (fun (_x : MonoidHom.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) => R -> T) (MonoidHom.hasCoeToFun.{u1, u2} R T (Monoid.toMulOneClass.{u1} R _inst_1) (Monoid.toMulOneClass.{u2} T _inst_3)) f r)) -> (Eq.{max (succ u2) (succ u1)} (MonoidHom.{u1, u2} (OreLocalization.{u1} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R _inst_1 S _inst_2) (OreLocalization.monoid.{u1} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u2} T _inst_3)) φ (OreLocalization.universalMulHom.{u1, u2} R _inst_1 S _inst_2 T _inst_3 f fS hf))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Monoid.{u2} R] {S : Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)} [_inst_2 : OreLocalization.OreSet.{u2} R _inst_1 S] {T : Type.{u1}} [_inst_3 : Monoid.{u1} T] (f : MonoidHom.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)) (fS : MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3)) (hf : forall (s : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) (Subtype.val.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) x (SetLike.coe.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) S)) s)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)) R T (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (MulOneClass.toMul.{u1} T (Monoid.toMulOneClass.{u1} T _inst_3)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)) R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3) (MonoidHom.monoidHomClass.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)))) f (Subtype.val.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) x (SetLike.coe.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) S)) s)) (Units.val.{u1} T _inst_3 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3)) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (fun (_x : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) => Units.{u1} T _inst_3) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3)) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (MulOneClass.toMul.{u2} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S)) (MulOneClass.toMul.{u1} (Units.{u1} T _inst_3) (Units.instMulOneClassUnits.{u1} T _inst_3)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3)) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3) (MonoidHom.monoidHomClass.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) R (Submonoid.instSetLikeSubmonoid.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1))) x S)) (Units.{u1} T _inst_3) (Submonoid.toMulOneClass.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1) S) (Units.instMulOneClassUnits.{u1} T _inst_3)))) fS s))) (φ : MonoidHom.{u2, u1} (OreLocalization.{u2} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u1} T _inst_3)), (forall (r : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : OreLocalization.{u2} R _inst_1 S _inst_2) => T) (FunLike.coe.{succ u2, succ u2, succ u2} (MonoidHom.{u2, u2} R (OreLocalization.{u2} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => OreLocalization.{u2} R _inst_1 S _inst_2) a) (MulHomClass.toFunLike.{u2, u2, u2} (MonoidHom.{u2, u2} R (OreLocalization.{u2} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2))) R (OreLocalization.{u2} R _inst_1 S _inst_2) (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (MulOneClass.toMul.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2))) (MonoidHomClass.toMulHomClass.{u2, u2, u2} (MonoidHom.{u2, u2} R (OreLocalization.{u2} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2))) R (OreLocalization.{u2} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2)) (MonoidHom.monoidHomClass.{u2, u2} R (OreLocalization.{u2} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2))))) (OreLocalization.numeratorHom.{u2} R _inst_1 S _inst_2) r)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (OreLocalization.{u2} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u1} T _inst_3)) (OreLocalization.{u2} R _inst_1 S _inst_2) (fun (_x : OreLocalization.{u2} R _inst_1 S _inst_2) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : OreLocalization.{u2} R _inst_1 S _inst_2) => T) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (OreLocalization.{u2} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u1} T _inst_3)) (OreLocalization.{u2} R _inst_1 S _inst_2) T (MulOneClass.toMul.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2))) (MulOneClass.toMul.{u1} T (Monoid.toMulOneClass.{u1} T _inst_3)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (OreLocalization.{u2} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u1} T _inst_3)) (OreLocalization.{u2} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u1} T _inst_3) (MonoidHom.monoidHomClass.{u2, u1} (OreLocalization.{u2} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u1} T _inst_3)))) φ (FunLike.coe.{succ u2, succ u2, succ u2} (MonoidHom.{u2, u2} R (OreLocalization.{u2} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => OreLocalization.{u2} R _inst_1 S _inst_2) _x) (MulHomClass.toFunLike.{u2, u2, u2} (MonoidHom.{u2, u2} R (OreLocalization.{u2} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2))) R (OreLocalization.{u2} R _inst_1 S _inst_2) (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (MulOneClass.toMul.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2))) (MonoidHomClass.toMulHomClass.{u2, u2, u2} (MonoidHom.{u2, u2} R (OreLocalization.{u2} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2))) R (OreLocalization.{u2} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2)) (MonoidHom.monoidHomClass.{u2, u2} R (OreLocalization.{u2} R _inst_1 S _inst_2) (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2))))) (OreLocalization.numeratorHom.{u2} R _inst_1 S _inst_2) r)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)) R T (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R _inst_1)) (MulOneClass.toMul.{u1} T (Monoid.toMulOneClass.{u1} T _inst_3)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)) R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3) (MonoidHom.monoidHomClass.{u2, u1} R T (Monoid.toMulOneClass.{u2} R _inst_1) (Monoid.toMulOneClass.{u1} T _inst_3)))) f r)) -> (Eq.{max (succ u2) (succ u1)} (MonoidHom.{u2, u1} (OreLocalization.{u2} R _inst_1 S _inst_2) T (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R _inst_1 S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R _inst_1 S _inst_2)) (Monoid.toMulOneClass.{u1} T _inst_3)) φ (OreLocalization.universalMulHom.{u2, u1} R _inst_1 S _inst_2 T _inst_3 f fS hf))
Case conversion may be inaccurate. Consider using '#align ore_localization.universal_mul_hom_unique OreLocalization.universalMulHom_uniqueₓ'. -/
/-- The universal morphism `universal_mul_hom` is unique. -/
theorem universalMulHom_unique (φ : R[S⁻¹] →* T) (huniv : ∀ r : R, φ (numeratorHom r) = f r) :
    φ = universalMulHom f fS hf := by
  ext; induction' x using OreLocalization.ind with r s
  rw [universal_mul_hom_apply, ← huniv r, numerator_hom_apply, ← mul_one (φ (r /ₒ s)), ←
    Units.val_one, ← mul_right_inv (fS s), Units.val_mul, ← mul_assoc, ← hf, ← huniv, ← φ.map_mul,
    numerator_hom_apply, OreLocalization.mul_cancel]
#align ore_localization.universal_mul_hom_unique OreLocalization.universalMulHom_unique

end UMP

end Monoid

section CommMonoid

variable {R : Type _} [CommMonoid R] {S : Submonoid R} [OreSet S]

/- warning: ore_localization.ore_div_mul_ore_div_comm -> OreLocalization.oreDiv_mul_oreDiv_comm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommMonoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))} [_inst_2 : OreLocalization.OreSet.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S] {r₁ : R} {r₂ : R} {s₁ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) S} {s₂ : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) S}, Eq.{succ u1} (OreLocalization.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.hasMul.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2)) (OreLocalization.oreDiv.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2 r₁ s₁) (OreLocalization.oreDiv.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2 r₂ s₂)) (OreLocalization.oreDiv.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) r₁ r₂) (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) S) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) S) (Submonoid.mul.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)) S)) s₁ s₂))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommMonoid.{u1} R] {S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))} [_inst_2 : OreLocalization.OreSet.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S] {r₁ : R} {r₂ : R} {s₁ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) x S)} {s₂ : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) x S)}, Eq.{succ u1} (OreLocalization.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2)) (OreLocalization.oreDiv.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2 r₁ s₁) (OreLocalization.oreDiv.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2 r₂ s₂)) (OreLocalization.oreDiv.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) r₁ r₂) (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) x S)) (instHMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)))) x S)) (Submonoid.mul.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1)) S)) s₁ s₂))
Case conversion may be inaccurate. Consider using '#align ore_localization.ore_div_mul_ore_div_comm OreLocalization.oreDiv_mul_oreDiv_commₓ'. -/
theorem oreDiv_mul_oreDiv_comm {r₁ r₂ : R} {s₁ s₂ : S} :
    r₁ /ₒ s₁ * (r₂ /ₒ s₂) = r₁ * r₂ /ₒ (s₁ * s₂) := by
  rw [ore_div_mul_char r₁ r₂ s₁ s₂ r₂ s₁ (by simp [mul_comm]), mul_comm s₂]
#align ore_localization.ore_div_mul_ore_div_comm OreLocalization.oreDiv_mul_oreDiv_comm

instance : CommMonoid R[S⁻¹] :=
  { OreLocalization.monoid with
    mul_comm := fun x y => by
      induction' x using OreLocalization.ind with r₁ s₁
      induction' y using OreLocalization.ind with r₂ s₂
      rw [ore_div_mul_ore_div_comm, ore_div_mul_ore_div_comm, mul_comm r₁, mul_comm s₁] }

variable (R S)

/- warning: ore_localization.localization_map -> OreLocalization.localizationMap is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : CommMonoid.{u1} R] (S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) [_inst_2 : OreLocalization.OreSet.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S], Submonoid.LocalizationMap.{u1, u1} R _inst_1 S (OreLocalization.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.commMonoid.{u1} R _inst_1 S _inst_2)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : CommMonoid.{u1} R] (S : Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1))) [_inst_2 : OreLocalization.OreSet.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S], Submonoid.LocalizationMap.{u1, u1} R _inst_1 S (OreLocalization.{u1} R (CommMonoid.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.instCommMonoidOreLocalizationToMonoid.{u1} R _inst_1 S _inst_2)
Case conversion may be inaccurate. Consider using '#align ore_localization.localization_map OreLocalization.localizationMapₓ'. -/
/-- The morphism `numerator_hom` is a monoid localization map in the case of commutative `R`. -/
protected def localizationMap : S.LocalizationMap R[S⁻¹]
    where
  toFun := numeratorHom
  map_one' := rfl
  map_mul' r₁ r₂ := by simp
  map_units' := numerator_isUnit
  surj' z := by
    induction' z using OreLocalization.ind with r s
    use (r, s); dsimp
    rw [numerator_hom_apply, numerator_hom_apply]; simp
  eq_iff_exists' r₁ r₂ := by
    dsimp; constructor
    · intro h
      rw [numerator_hom_apply, numerator_hom_apply, ore_div_eq_iff] at h
      rcases h with ⟨u, v, h₁, h₂⟩
      dsimp at h₂
      rw [one_mul, one_mul] at h₂
      subst h₂
      use u
      simpa only [mul_comm] using h₁.symm
    · rintro ⟨s, h⟩
      rw [numerator_hom_apply, numerator_hom_apply, ore_div_eq_iff]
      refine' ⟨s, s, _, _⟩
      · simpa [mul_comm] using h.symm
      · simp [one_mul]
#align ore_localization.localization_map OreLocalization.localizationMap

#print OreLocalization.equivMonoidLocalization /-
/-- If `R` is commutative, Ore localization and monoid localization are isomorphic. -/
protected noncomputable def equivMonoidLocalization : Localization S ≃* R[S⁻¹] :=
  Localization.mulEquivOfQuotient (OreLocalization.localizationMap R S)
#align ore_localization.equiv_monoid_localization OreLocalization.equivMonoidLocalization
-/

end CommMonoid

section Semiring

variable {R : Type _} [Semiring R] {S : Submonoid R} [OreSet S]

private def add'' (r₁ : R) (s₁ : S) (r₂ : R) (s₂ : S) : R[S⁻¹] :=
  (r₁ * oreDenom (s₁ : R) s₂ + r₂ * oreNum s₁ s₂) /ₒ (s₁ * oreDenom s₁ s₂)
#align ore_localization.add'' ore_localization.add''

private theorem add''_char (r₁ : R) (s₁ : S) (r₂ : R) (s₂ : S) (rb : R) (sb : S)
    (hb : (s₁ : R) * sb = (s₂ : R) * rb) : add'' r₁ s₁ r₂ s₂ = (r₁ * sb + r₂ * rb) /ₒ (s₁ * sb) :=
  by
  simp only [add'']
  have ha := ore_eq (s₁ : R) s₂
  set! ra := ore_num (s₁ : R) s₂ with h
  rw [← h] at *
  clear h
  -- r tilde
  set! sa := ore_denom (s₁ : R) s₂ with h
  rw [← h] at *
  clear h
  -- s tilde
  rcases ore_condition (sa : R) sb with ⟨rc, sc, hc⟩
  -- s*, r*
  have : (s₂ : R) * (rb * rc) = s₂ * (ra * sc) := by
    rw [← mul_assoc, ← hb, mul_assoc, ← hc, ← mul_assoc, ← mul_assoc, ha]
  rcases ore_left_cancel _ _ s₂ this with ⟨sd, hd⟩
  -- s#
  symm
  rw [ore_div_eq_iff]
  use sc * sd
  use rc * sd
  constructor <;> simp only [Submonoid.coe_mul]
  · noncomm_ring
    assoc_rw [hd, hc]
    noncomm_ring
  · assoc_rw [hc]
    noncomm_ring
#align ore_localization.add''_char ore_localization.add''_char

attribute [local instance] OreLocalization.oreEqv

private def add' (r₂ : R) (s₂ : S) : R[S⁻¹] → R[S⁻¹] :=
  (--plus tilde
      Quotient.lift
      fun r₁s₁ : R × S => add'' r₁s₁.1 r₁s₁.2 r₂ s₂) <|
    by
    rintro ⟨r₁', s₁'⟩ ⟨r₁, s₁⟩ ⟨sb, rb, hb, hb'⟩
    -- s*, r*
    rcases ore_condition (s₁' : R) s₂ with ⟨rc, sc, hc⟩
    --s~~, r~~
    rcases ore_condition rb sc with ⟨rd, sd, hd⟩
    -- s#, r#
    dsimp at *
    rw [add''_char _ _ _ _ rc sc hc]
    have : ↑s₁ * ↑(sb * sd) = ↑s₂ * (rc * rd) :=
      by
      simp only [Submonoid.coe_mul]
      assoc_rw [hb', hd, hc]
      noncomm_ring
    rw [add''_char _ _ _ _ (rc * rd : R) (sb * sd : S) this]
    simp only [Submonoid.coe_mul]
    assoc_rw [hb, hd]
    rw [← mul_assoc, ← add_mul, ore_div_eq_iff]
    use 1
    use rd
    constructor
    · simp
    · simp only [mul_one, Submonoid.coe_one, Submonoid.coe_mul] at this⊢
      assoc_rw [hc, this]
#align ore_localization.add' ore_localization.add'

private theorem add'_comm (r₁ r₂ : R) (s₁ s₂ : S) : add' r₁ s₁ (r₂ /ₒ s₂) = add' r₂ s₂ (r₁ /ₒ s₁) :=
  by
  simp only [add', ore_div, add'', Quotient.lift_mk, Quotient.eq']
  have hb := ore_eq (↑s₂) s₁
  set rb := ore_num (↑s₂) s₁ with h
  -- r~~
  rw [← h]
  clear h
  set sb := ore_denom (↑s₂) s₁ with h
  rw [← h]
  clear h
  -- s~~
  have ha := ore_eq (↑s₁) s₂
  set ra := ore_num (↑s₁) s₂ with h
  -- r~
  rw [← h]
  clear h
  set sa := ore_denom (↑s₁) s₂ with h
  rw [← h]
  clear h
  -- s~
  rcases ore_condition ra sb with ⟨rc, sc, hc⟩
  -- r#, s#
  have : (s₁ : R) * (rb * rc) = s₁ * (sa * sc) := by
    rw [← mul_assoc, ← hb, mul_assoc, ← hc, ← mul_assoc, ← ha, mul_assoc]
  rcases ore_left_cancel _ _ s₁ this with ⟨sd, hd⟩
  -- s+
  use sc * sd
  use rc * sd
  dsimp
  constructor
  · rw [add_mul, add_mul, add_comm]
    assoc_rw [← hd, hc]
    noncomm_ring
  · rw [mul_assoc, ← mul_assoc ↑sa, ← hd, hb]
    noncomm_ring
#align ore_localization.add'_comm ore_localization.add'_comm

/-- The addition on the Ore localization. -/
private def add : R[S⁻¹] → R[S⁻¹] → R[S⁻¹] := fun x =>
  Quotient.lift (fun rs : R × S => add' rs.1 rs.2 x)
    (by
      rintro ⟨r₁, s₁⟩ ⟨r₂, s₂⟩ hyz
      induction' x using OreLocalization.ind with r₃ s₃
      dsimp; rw [add'_comm, add'_comm r₂]
      simp [(· /ₒ ·), Quotient.sound hyz])
#align ore_localization.add ore_localization.add

instance : Add R[S⁻¹] :=
  ⟨add⟩

/- warning: ore_localization.ore_div_add_ore_div -> OreLocalization.oreDiv_add_oreDiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] {r : R} {r' : R} {s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S} {s' : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S}, Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasAdd.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r s) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r' s')) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) r ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) x S))))) (OreLocalization.oreDenom.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S))))) s) s'))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) r' (OreLocalization.oreNum.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S))))) s) s'))) (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) (Submonoid.mul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S)) s (OreLocalization.oreDenom.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S))))) s) s')))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] {r : R} {r' : R} {s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)} {s' : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)}, Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instAddOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r s) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r' s')) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) r (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) S)) (OreLocalization.oreDenom.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) S)) s) s'))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) r' (OreLocalization.oreNum.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) S)) s) s'))) (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (instHMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Submonoid.mul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S)) s (OreLocalization.oreDenom.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) S)) s) s')))
Case conversion may be inaccurate. Consider using '#align ore_localization.ore_div_add_ore_div OreLocalization.oreDiv_add_oreDivₓ'. -/
theorem oreDiv_add_oreDiv {r r' : R} {s s' : S} :
    r /ₒ s + r' /ₒ s' = (r * oreDenom (s : R) s' + r' * oreNum s s') /ₒ (s * oreDenom s s') :=
  rfl
#align ore_localization.ore_div_add_ore_div OreLocalization.oreDiv_add_oreDiv

/- warning: ore_localization.ore_div_add_char -> OreLocalization.oreDiv_add_char is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] {r : R} {r' : R} (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (s' : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (rb : R) (sb : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S), (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S))))) s) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S))))) sb)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S))))) s') rb)) -> (Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasAdd.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r s) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r' s')) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) r ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S))))) sb)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) r' rb)) (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) (Submonoid.mul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S)) s sb)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] {r : R} {r' : R} (s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (s' : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (rb : R) (sb : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)), (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) S)) s) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) S)) sb)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) S)) s') rb)) -> (Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instAddOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r s) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r' s')) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) r (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) S)) sb)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) r' rb)) (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (instHMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Submonoid.mul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S)) s sb)))
Case conversion may be inaccurate. Consider using '#align ore_localization.ore_div_add_char OreLocalization.oreDiv_add_charₓ'. -/
/-- A characterization of the addition on the Ore localizaion, allowing for arbitrary Ore
numerator and Ore denominator. -/
theorem oreDiv_add_char {r r' : R} (s s' : S) (rb : R) (sb : S) (h : (s : R) * sb = s' * rb) :
    r /ₒ s + r' /ₒ s' = (r * sb + r' * rb) /ₒ (s * sb) :=
  add''_char r s r' s' rb sb h
#align ore_localization.ore_div_add_char OreLocalization.oreDiv_add_char

/- warning: ore_localization.ore_div_add_char' -> OreLocalization.oreDivAddChar' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (r : R) (r' : R) (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (s' : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S), PSigma.{succ u1, succ u1} R (fun (r'' : R) => PSigma.{succ u1, 0} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (fun (s'' : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) => And (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S))))) s) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S))))) s'')) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S))))) s') r'')) (Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasAdd.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r s) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r' s')) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) r ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S))))) s'')) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) r' r'')) (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) (Submonoid.mul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S)) s s'')))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (r : R) (r' : R) (s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (s' : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)), PSigma.{succ u1, succ u1} R (fun (r'' : R) => PSigma.{succ u1, 0} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (fun (s'' : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) => And (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) S)) s) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) S)) s'')) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) S)) s') r'')) (Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instAddOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r s) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r' s')) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) r (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) S)) s'')) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) r' r'')) (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (instHMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Submonoid.mul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S)) s s'')))))
Case conversion may be inaccurate. Consider using '#align ore_localization.ore_div_add_char' OreLocalization.oreDivAddChar'ₓ'. -/
/-- Another characterization of the addition on the Ore localization, bundling up all witnesses
and conditions into a sigma type. -/
def oreDivAddChar' (r r' : R) (s s' : S) :
    Σ'r'' : R,
      Σ's'' : S, (s : R) * s'' = s' * r'' ∧ r /ₒ s + r' /ₒ s' = (r * s'' + r' * r'') /ₒ (s * s'') :=
  ⟨oreNum s s', oreDenom s s', ore_eq s s', oreDiv_add_oreDiv⟩
#align ore_localization.ore_div_add_char' OreLocalization.oreDivAddChar'

/- warning: ore_localization.add_ore_div -> OreLocalization.add_oreDiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] {r : R} {r' : R} {s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S}, Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasAdd.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r s) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r' s)) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) r r') s)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] {r : R} {r' : R} {s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)}, Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instAddOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r s) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r' s)) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) r r') s)
Case conversion may be inaccurate. Consider using '#align ore_localization.add_ore_div OreLocalization.add_oreDivₓ'. -/
@[simp]
theorem add_oreDiv {r r' : R} {s : S} : r /ₒ s + r' /ₒ s = (r + r') /ₒ s := by
  simp [ore_div_add_char s s 1 1 (by simp)]
#align ore_localization.add_ore_div OreLocalization.add_oreDiv

/- warning: ore_localization.add_assoc -> OreLocalization.add_assoc is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (y : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (z : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasAdd.{u1} R _inst_1 S _inst_2)) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasAdd.{u1} R _inst_1 S _inst_2)) x y) z) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasAdd.{u1} R _inst_1 S _inst_2)) x (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasAdd.{u1} R _inst_1 S _inst_2)) y z))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (y : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (z : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instAddOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instAddOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) x y) z) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instAddOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) x (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instAddOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) y z))
Case conversion may be inaccurate. Consider using '#align ore_localization.add_assoc OreLocalization.add_assocₓ'. -/
protected theorem add_assoc (x y z : R[S⁻¹]) : x + y + z = x + (y + z) :=
  by
  induction' x using OreLocalization.ind with r₁ s₁
  induction' y using OreLocalization.ind with r₂ s₂
  induction' z using OreLocalization.ind with r₃ s₃
  rcases ore_div_add_char' r₁ r₂ s₁ s₂ with ⟨ra, sa, ha, ha'⟩; rw [ha']; clear ha'
  rcases ore_div_add_char' r₂ r₃ s₂ s₃ with ⟨rb, sb, hb, hb'⟩; rw [hb']; clear hb'
  rcases ore_div_add_char' (r₁ * sa + r₂ * ra) r₃ (s₁ * sa) s₃ with ⟨rc, sc, hc, q⟩; rw [q]; clear q
  rcases ore_div_add_char' r₁ (r₂ * sb + r₃ * rb) s₁ (s₂ * sb) with ⟨rd, sd, hd, q⟩; rw [q]; clear q
  noncomm_ring; rw [add_comm (r₂ * _)]
  repeat' rw [← add_ore_div]
  congr 1
  · rcases ore_condition (sd : R) (sa * sc) with ⟨re, se, he⟩
    · simp_rw [← Submonoid.coe_mul] at hb hc hd
      assoc_rw [Subtype.coe_eq_of_eq_mk hc]
      rw [← OreLocalization.expand, Subtype.coe_eq_of_eq_mk hd, ← mul_assoc, ←
        OreLocalization.expand, Subtype.coe_eq_of_eq_mk hb]
      apply OreLocalization.expand
  congr 1
  ·
    rw [← OreLocalization.expand', ← mul_assoc, ← mul_assoc, ← OreLocalization.expand', ←
      OreLocalization.expand']
  · simp_rw [← Submonoid.coe_mul] at ha hd
    rw [Subtype.coe_eq_of_eq_mk hd, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← OreLocalization.expand,
      ← OreLocalization.expand', Subtype.coe_eq_of_eq_mk ha, ← OreLocalization.expand]
    apply OreLocalization.expand'
#align ore_localization.add_assoc OreLocalization.add_assoc

private def zero : R[S⁻¹] :=
  0 /ₒ 1
#align ore_localization.zero ore_localization.zero

instance : Zero R[S⁻¹] :=
  ⟨zero⟩

/- warning: ore_localization.zero_def -> OreLocalization.zero_def is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S], Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (OfNat.mk.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (Zero.zero.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasZero.{u1} R _inst_1 S _inst_2)))) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) 1 (OfNat.mk.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) 1 (One.one.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) S) (Submonoid.one.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S], Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (Zero.toOfNat0.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instZeroOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2))) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (OfNat.ofNat.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) x S)) 1 (One.toOfNat1.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) x S)) (Submonoid.one.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) S))))
Case conversion may be inaccurate. Consider using '#align ore_localization.zero_def OreLocalization.zero_defₓ'. -/
protected theorem zero_def : (0 : R[S⁻¹]) = 0 /ₒ 1 :=
  rfl
#align ore_localization.zero_def OreLocalization.zero_def

/- warning: ore_localization.zero_div_eq_zero -> OreLocalization.zero_div_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) s) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (OfNat.mk.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (Zero.zero.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasZero.{u1} R _inst_1 S _inst_2))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) s) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (Zero.toOfNat0.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instZeroOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)))
Case conversion may be inaccurate. Consider using '#align ore_localization.zero_div_eq_zero OreLocalization.zero_div_eq_zeroₓ'. -/
@[simp]
theorem zero_div_eq_zero (s : S) : 0 /ₒ s = 0 :=
  by
  rw [OreLocalization.zero_def, ore_div_eq_iff]
  exact ⟨s, 1, by simp⟩
#align ore_localization.zero_div_eq_zero OreLocalization.zero_div_eq_zero

/- warning: ore_localization.zero_add -> OreLocalization.zero_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasAdd.{u1} R _inst_1 S _inst_2)) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (OfNat.mk.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (Zero.zero.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasZero.{u1} R _inst_1 S _inst_2)))) x) x
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instAddOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (Zero.toOfNat0.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instZeroOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2))) x) x
Case conversion may be inaccurate. Consider using '#align ore_localization.zero_add OreLocalization.zero_addₓ'. -/
protected theorem zero_add (x : R[S⁻¹]) : 0 + x = x :=
  by
  induction x using OreLocalization.ind
  rw [← zero_div_eq_zero, add_ore_div]; simp
#align ore_localization.zero_add OreLocalization.zero_add

/- warning: ore_localization.add_comm -> OreLocalization.add_comm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (y : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasAdd.{u1} R _inst_1 S _inst_2)) x y) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasAdd.{u1} R _inst_1 S _inst_2)) y x)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (y : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instAddOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) x y) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instAddOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) y x)
Case conversion may be inaccurate. Consider using '#align ore_localization.add_comm OreLocalization.add_commₓ'. -/
protected theorem add_comm (x y : R[S⁻¹]) : x + y = y + x :=
  by
  induction x using OreLocalization.ind
  induction y using OreLocalization.ind
  change add' _ _ (_ /ₒ _) = _; apply add'_comm
#align ore_localization.add_comm OreLocalization.add_comm

instance : AddCommMonoid R[S⁻¹] :=
  { OreLocalization.hasAdd with
    add_comm := OreLocalization.add_comm
    add_assoc := OreLocalization.add_assoc
    zero := zero
    zero_add := OreLocalization.zero_add
    add_zero := fun x => by rw [OreLocalization.add_comm, OreLocalization.zero_add] }

/- warning: ore_localization.zero_mul -> OreLocalization.zero_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasMul.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (OfNat.mk.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (Zero.zero.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasZero.{u1} R _inst_1 S _inst_2)))) x) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (OfNat.mk.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (Zero.zero.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasZero.{u1} R _inst_1 S _inst_2))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (Zero.toOfNat0.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instZeroOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2))) x) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (Zero.toOfNat0.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instZeroOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)))
Case conversion may be inaccurate. Consider using '#align ore_localization.zero_mul OreLocalization.zero_mulₓ'. -/
protected theorem zero_mul (x : R[S⁻¹]) : 0 * x = 0 :=
  by
  induction' x using OreLocalization.ind with r s
  rw [OreLocalization.zero_def, ore_div_mul_char 0 r 1 s r 1 (by simp)]; simp
#align ore_localization.zero_mul OreLocalization.zero_mul

/- warning: ore_localization.mul_zero -> OreLocalization.mul_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasMul.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) x (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (OfNat.mk.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (Zero.zero.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasZero.{u1} R _inst_1 S _inst_2))))) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (OfNat.mk.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (Zero.zero.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasZero.{u1} R _inst_1 S _inst_2))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) x (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (Zero.toOfNat0.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instZeroOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)))) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) 0 (Zero.toOfNat0.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instZeroOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)))
Case conversion may be inaccurate. Consider using '#align ore_localization.mul_zero OreLocalization.mul_zeroₓ'. -/
protected theorem mul_zero (x : R[S⁻¹]) : x * 0 = 0 :=
  by
  induction' x using OreLocalization.ind with r s
  rw [OreLocalization.zero_def, ore_div_mul_char r 0 s 1 0 1 (by simp)]; simp
#align ore_localization.mul_zero OreLocalization.mul_zero

/- warning: ore_localization.left_distrib -> OreLocalization.left_distrib is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (y : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (z : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasMul.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) x (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasAdd.{u1} R _inst_1 S _inst_2)) y z)) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasAdd.{u1} R _inst_1 S _inst_2)) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasMul.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) x y) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasMul.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) x z))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (y : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (z : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) x (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instAddOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) y z)) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instAddOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) x y) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) x z))
Case conversion may be inaccurate. Consider using '#align ore_localization.left_distrib OreLocalization.left_distribₓ'. -/
protected theorem left_distrib (x y z : R[S⁻¹]) : x * (y + z) = x * y + x * z :=
  by
  induction' x using OreLocalization.ind with r₁ s₁
  induction' y using OreLocalization.ind with r₂ s₂
  induction' z using OreLocalization.ind with r₃ s₃
  rcases ore_div_add_char' r₂ r₃ s₂ s₃ with ⟨ra, sa, ha, q⟩
  rw [q]
  clear q
  rw [OreLocalization.expand' r₂ s₂ sa]
  rcases ore_div_mul_char' r₁ (r₂ * sa) s₁ (s₂ * sa) with ⟨rb, sb, hb, q⟩
  rw [q]
  clear q
  have hs₃rasb : ↑s₃ * (ra * sb) ∈ S :=
    by
    rw [← mul_assoc, ← ha]
    norm_cast
    apply SetLike.coe_mem
  rw [OreLocalization.expand _ _ _ hs₃rasb]
  have ha' : ↑(s₂ * sa * sb) = ↑s₃ * (ra * sb) := by simp [ha, ← mul_assoc]
  rw [← Subtype.coe_eq_of_eq_mk ha']
  rcases ore_div_mul_char' r₁ (r₃ * (ra * sb)) s₁ (s₂ * sa * sb) with ⟨rc, sc, hc, hc'⟩
  rw [hc']
  rw [ore_div_add_char (s₂ * sa * sb) (s₂ * sa * sb * sc) 1 sc (by simp)]
  rw [OreLocalization.expand' (r₂ * ↑sa + r₃ * ra) (s₂ * sa) (sb * sc)]
  conv_lhs =>
    congr
    skip
    congr
    rw [add_mul, S.coe_mul, ← mul_assoc, hb, ← mul_assoc, mul_assoc r₃, hc, mul_assoc, ← mul_add]
  rw [OreLocalization.mul_cancel']
  simp only [mul_one, Submonoid.coe_mul, mul_add, ← mul_assoc]
#align ore_localization.left_distrib OreLocalization.left_distrib

/- warning: ore_localization.right_distrib -> OreLocalization.right_distrib is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (y : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (z : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasMul.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasAdd.{u1} R _inst_1 S _inst_2)) x y) z) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasAdd.{u1} R _inst_1 S _inst_2)) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasMul.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) x z) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.hasMul.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) y z))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] (x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (y : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (z : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instAddOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) x y) z) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instAddOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) x z) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMulOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) y z))
Case conversion may be inaccurate. Consider using '#align ore_localization.right_distrib OreLocalization.right_distribₓ'. -/
theorem right_distrib (x y z : R[S⁻¹]) : (x + y) * z = x * z + y * z :=
  by
  induction' x using OreLocalization.ind with r₁ s₁
  induction' y using OreLocalization.ind with r₂ s₂
  induction' z using OreLocalization.ind with r₃ s₃
  rcases ore_div_add_char' r₁ r₂ s₁ s₂ with ⟨ra, sa, ha, ha'⟩; rw [ha']; clear ha'; norm_cast  at ha
  rw [OreLocalization.expand' r₁ s₁ sa]
  rw [OreLocalization.expand r₂ s₂ ra (by rw [← ha] <;> apply SetLike.coe_mem)]
  rw [← Subtype.coe_eq_of_eq_mk ha]
  repeat' rw [ore_div_mul_ore_div]; simp only [add_mul, add_ore_div]
#align ore_localization.right_distrib OreLocalization.right_distrib

instance : Semiring R[S⁻¹] :=
  { OreLocalization.addCommMonoid,
    OreLocalization.monoid with
    zero_mul := OreLocalization.zero_mul
    mul_zero := OreLocalization.mul_zero
    left_distrib := OreLocalization.left_distrib
    right_distrib := right_distrib }

section UMP

variable {T : Type _} [Semiring T]

variable (f : R →+* T) (fS : S →* Units T)

variable (hf : ∀ s : S, f s = fS s)

include f fS hf

/- warning: ore_localization.universal_hom -> OreLocalization.universalHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] {T : Type.{u2}} [_inst_3 : Semiring.{u2} T] (f : RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (fS : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))), (forall (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S), Eq.{succ u2} T (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (fun (_x : RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) => R -> T) (RingHom.hasCoeToFun.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S))))) s)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (HasLiftT.mk.{succ u2, succ u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (CoeTCₓ.coe.{succ u2, succ u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (coeBase.{succ u2, succ u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (Units.hasCoe.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (fun (_x : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) => (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) -> (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (MonoidHom.hasCoeToFun.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) fS s))) -> (RingHom.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.semiring.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] {T : Type.{u2}} [_inst_3 : Semiring.{u2} T] (f : RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (fS : MonoidHom.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.instMulOneClassUnits.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))), (forall (s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) S)) s)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) R T (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) R T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3) (RingHom.instRingHomClassRingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3))))) f (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) S)) s)) (Units.val.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.instMulOneClassUnits.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (fun (_x : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) => Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.instMulOneClassUnits.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S)) (MulOneClass.toMul.{u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Units.instMulOneClassUnits.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.instMulOneClassUnits.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.instMulOneClassUnits.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (MonoidHom.monoidHomClass.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.instMulOneClassUnits.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))))) fS s))) -> (RingHom.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3))
Case conversion may be inaccurate. Consider using '#align ore_localization.universal_hom OreLocalization.universalHomₓ'. -/
/-- The universal lift from a ring homomorphism `f : R →+* T`, which maps elements in `S` to
units of `T`, to a ring homomorphism `R[S⁻¹] →+* T`. This extends the construction on
monoids. -/
def universalHom : R[S⁻¹] →+* T :=
  {
    universalMulHom f.toMonoidHom fS
      hf with
    map_zero' :=
      by
      rw [MonoidHom.toFun_eq_coe, OreLocalization.zero_def, universal_mul_hom_apply]
      simp
    map_add' := fun x y => by
      induction' x using OreLocalization.ind with r₁ s₁
      induction' y using OreLocalization.ind with r₂ s₂
      rcases ore_div_add_char' r₁ r₂ s₁ s₂ with ⟨r₃, s₃, h₃, h₃'⟩
      rw [h₃']
      clear h₃'
      simp only [universal_mul_hom_apply, [anonymous], RingHom.toMonoidHom_eq_coe,
        MonoidHom.toFun_eq_coe]
      simp only [mul_inv_rev, MonoidHom.map_mul, RingHom.map_add, RingHom.map_mul, Units.val_mul]
      rw [add_mul, ← mul_assoc, mul_assoc (f r₁), hf, ← Units.val_mul]
      simp only [mul_one, mul_right_inv, Units.val_one]
      congr 1
      rw [mul_assoc]
      congr 1
      norm_cast  at h₃
      have h₃' := Subtype.coe_eq_of_eq_mk h₃
      rw [← Units.val_mul, ← mul_inv_rev, ← fS.map_mul, h₃']
      have hs₂r₃ : ↑s₂ * r₃ ∈ S := by
        rw [← h₃]
        exact SetLike.coe_mem (s₁ * s₃)
      apply (Units.inv_mul_cancel_left (fS s₂) _).symm.trans
      conv_lhs =>
        congr
        skip
        rw [← Units.mul_inv_cancel_left (fS ⟨s₂ * r₃, hs₂r₃⟩) (fS s₂), mul_assoc, mul_assoc]
        congr
        skip
        rw [← hf, ← mul_assoc (f s₂), ← f.map_mul]
        conv =>
          congr
          skip
          congr
          rw [← h₃]
        rw [hf, ← mul_assoc, ← h₃', Units.inv_mul]
      rw [one_mul, ← h₃', Units.mul_inv, mul_one] }
#align ore_localization.universal_hom OreLocalization.universalHom

/- warning: ore_localization.universal_hom_apply -> OreLocalization.universalHom_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] {T : Type.{u2}} [_inst_3 : Semiring.{u2} T] (f : RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (fS : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (hf : forall (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S), Eq.{succ u2} T (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (fun (_x : RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) => R -> T) (RingHom.hasCoeToFun.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S))))) s)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (HasLiftT.mk.{succ u2, succ u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (CoeTCₓ.coe.{succ u2, succ u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (coeBase.{succ u2, succ u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (Units.hasCoe.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (fun (_x : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) => (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) -> (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (MonoidHom.hasCoeToFun.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) fS s))) {r : R} {s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S}, Eq.{succ u2} T (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.semiring.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (fun (_x : RingHom.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.semiring.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) => (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) -> T) (RingHom.hasCoeToFun.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.semiring.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (OreLocalization.universalHom.{u1, u2} R _inst_1 S _inst_2 T _inst_3 f fS hf) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2 r s)) (HMul.hMul.{u2, u2, u2} T T T (instHMul.{u2} T (Distrib.toHasMul.{u2} T (NonUnitalNonAssocSemiring.toDistrib.{u2} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_3))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (fun (_x : RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) => R -> T) (RingHom.hasCoeToFun.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) f r) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (HasLiftT.mk.{succ u2, succ u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (CoeTCₓ.coe.{succ u2, succ u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (coeBase.{succ u2, succ u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (Units.hasCoe.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))))) (Inv.inv.{u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Units.hasInv.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (fun (_x : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) => (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) -> (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (MonoidHom.hasCoeToFun.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) fS s))))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] {S : Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S] {T : Type.{u1}} [_inst_3 : Semiring.{u1} T] (f : RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (fS : MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))) (hf : forall (s : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) (Subtype.val.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) x (SetLike.coe.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) S)) s)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) R T (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} T (Semiring.toNonAssocSemiring.{u1} T _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) R T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} T (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3) (RingHom.instRingHomClassRingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3))))) f (Subtype.val.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) x (SetLike.coe.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) S)) s)) (Units.val.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (fun (_x : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) => Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (MulOneClass.toMul.{u2} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S)) (MulOneClass.toMul.{u1} (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (MonoidHom.monoidHomClass.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))))) fS s))) {r : R} {s : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)}, Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) => T) (OreLocalization.oreDiv.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2 r s)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (fun (_x : OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) => T) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (NonUnitalNonAssocSemiring.toMul.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u1} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} T (Semiring.toNonAssocSemiring.{u1} T _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} T (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u1} T _inst_3) (RingHom.instRingHomClassRingHom.{u2, u1} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u1} T _inst_3))))) (OreLocalization.universalHom.{u2, u1} R _inst_1 S _inst_2 T _inst_3 f fS hf) (OreLocalization.oreDiv.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2 r s)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) r) T ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) r) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) r) (NonUnitalNonAssocSemiring.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) r) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) r) _inst_3)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) R T (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} T (Semiring.toNonAssocSemiring.{u1} T _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) R T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} T (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3) (RingHom.instRingHomClassRingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3))))) f r) (Units.val.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)) (Inv.inv.{u1} (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Units.instInvUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (fun (_x : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) => Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (MulOneClass.toMul.{u2} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S)) (MulOneClass.toMul.{u1} (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (MonoidHom.monoidHomClass.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))))) fS s))))
Case conversion may be inaccurate. Consider using '#align ore_localization.universal_hom_apply OreLocalization.universalHom_applyₓ'. -/
theorem universalHom_apply {r : R} {s : S} :
    universalHom f fS hf (r /ₒ s) = f r * ((fS s)⁻¹ : Units T) :=
  rfl
#align ore_localization.universal_hom_apply OreLocalization.universalHom_apply

/- warning: ore_localization.universal_hom_commutes -> OreLocalization.universalHom_commutes is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] {T : Type.{u2}} [_inst_3 : Semiring.{u2} T] (f : RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (fS : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (hf : forall (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S), Eq.{succ u2} T (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (fun (_x : RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) => R -> T) (RingHom.hasCoeToFun.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S))))) s)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (HasLiftT.mk.{succ u2, succ u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (CoeTCₓ.coe.{succ u2, succ u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (coeBase.{succ u2, succ u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (Units.hasCoe.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (fun (_x : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) => (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) -> (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (MonoidHom.hasCoeToFun.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) fS s))) {r : R}, Eq.{succ u2} T (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.semiring.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (fun (_x : RingHom.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.semiring.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) => (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) -> T) (RingHom.hasCoeToFun.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.semiring.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (OreLocalization.universalHom.{u1, u2} R _inst_1 S _inst_2 T _inst_3 f fS hf) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.monoid.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2))) (fun (_x : MonoidHom.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.monoid.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2))) => R -> (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) (MonoidHom.hasCoeToFun.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.monoid.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2))) (OreLocalization.numeratorHom.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) r)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (fun (_x : RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) => R -> T) (RingHom.hasCoeToFun.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) f r)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] {T : Type.{u2}} [_inst_3 : Semiring.{u2} T] (f : RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (fS : MonoidHom.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.instMulOneClassUnits.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (hf : forall (s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) S)) s)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) R T (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) R T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3) (RingHom.instRingHomClassRingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3))))) f (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) S)) s)) (Units.val.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.instMulOneClassUnits.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (fun (_x : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) => Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.instMulOneClassUnits.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (MulOneClass.toMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S)) (MulOneClass.toMul.{u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Units.instMulOneClassUnits.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.instMulOneClassUnits.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.instMulOneClassUnits.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (MonoidHom.monoidHomClass.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S)) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.instMulOneClassUnits.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))))) fS s))) {r : R}, Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) => T) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) a) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2))) R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (MulOneClass.toMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2))) R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) (MonoidHom.monoidHomClass.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2))))) (OreLocalization.numeratorHom.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) r)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (fun (_x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) => T) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (NonUnitalNonAssocSemiring.toMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u2} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3) (RingHom.instRingHomClassRingHom.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3))))) (OreLocalization.universalHom.{u1, u2} R _inst_1 S _inst_2 T _inst_3 f fS hf) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2))) R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (MulOneClass.toMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2))) R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) (MonoidHom.monoidHomClass.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2))))) (OreLocalization.numeratorHom.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) r)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) R T (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) R T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3) (RingHom.instRingHomClassRingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3))))) f r)
Case conversion may be inaccurate. Consider using '#align ore_localization.universal_hom_commutes OreLocalization.universalHom_commutesₓ'. -/
theorem universalHom_commutes {r : R} : universalHom f fS hf (numeratorHom r) = f r := by
  simp [numerator_hom_apply, universal_hom_apply]
#align ore_localization.universal_hom_commutes OreLocalization.universalHom_commutes

/- warning: ore_localization.universal_hom_unique -> OreLocalization.universalHom_unique is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S] {T : Type.{u2}} [_inst_3 : Semiring.{u2} T] (f : RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (fS : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (hf : forall (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S), Eq.{succ u2} T (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (fun (_x : RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) => R -> T) (RingHom.hasCoeToFun.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x S))))) s)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (HasLiftT.mk.{succ u2, succ u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (CoeTCₓ.coe.{succ u2, succ u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (coeBase.{succ u2, succ u2} (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) T (Units.hasCoe.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (fun (_x : MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) => (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) -> (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) (MonoidHom.hasCoeToFun.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) S) (Units.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3))) (Submonoid.toMulOneClass.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) S) (Units.mulOneClass.{u2} T (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T _inst_3)))) fS s))) (φ : RingHom.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.semiring.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3)), (forall (r : R), Eq.{succ u2} T (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.semiring.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (fun (_x : RingHom.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.semiring.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) => (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) -> T) (RingHom.hasCoeToFun.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.semiring.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) φ (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.monoid.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2))) (fun (_x : MonoidHom.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.monoid.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2))) => R -> (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2)) (MonoidHom.hasCoeToFun.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.monoid.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2))) (OreLocalization.numeratorHom.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) r)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) (fun (_x : RingHom.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) => R -> T) (RingHom.hasCoeToFun.{u1, u2} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) f r)) -> (Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) S _inst_2) (OreLocalization.semiring.{u1} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u2} T _inst_3)) φ (OreLocalization.universalHom.{u1, u2} R _inst_1 S _inst_2 T _inst_3 f fS hf))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] {S : Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))} [_inst_2 : OreLocalization.OreSet.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S] {T : Type.{u1}} [_inst_3 : Semiring.{u1} T] (f : RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (fS : MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))) (hf : forall (s : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) (Subtype.val.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) x (SetLike.coe.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) S)) s)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) R T (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} T (Semiring.toNonAssocSemiring.{u1} T _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) R T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} T (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3) (RingHom.instRingHomClassRingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3))))) f (Subtype.val.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) x (SetLike.coe.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) S)) s)) (Units.val.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (fun (_x : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) => Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (MulOneClass.toMul.{u2} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S)) (MulOneClass.toMul.{u1} (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))) (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (MonoidHom.monoidHomClass.{u2, u1} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x S)) (Units.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3))) (Submonoid.toMulOneClass.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) S) (Units.instMulOneClassUnits.{u1} T (MonoidWithZero.toMonoid.{u1} T (Semiring.toMonoidWithZero.{u1} T _inst_3)))))) fS s))) (φ : RingHom.{u2, u1} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u1} T _inst_3)), (forall (r : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) => T) (FunLike.coe.{succ u2, succ u2, succ u2} (MonoidHom.{u2, u2} R (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) a) (MulHomClass.toFunLike.{u2, u2, u2} (MonoidHom.{u2, u2} R (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2))) R (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (MulOneClass.toMul.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2))) (MonoidHomClass.toMulHomClass.{u2, u2, u2} (MonoidHom.{u2, u2} R (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2))) R (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2)) (MonoidHom.monoidHomClass.{u2, u2} R (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2))))) (OreLocalization.numeratorHom.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) r)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (fun (_x : OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) => T) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (NonUnitalNonAssocSemiring.toMul.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u1} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} T (Semiring.toNonAssocSemiring.{u1} T _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} T (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u1} T _inst_3) (RingHom.instRingHomClassRingHom.{u2, u1} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u1} T _inst_3))))) φ (FunLike.coe.{succ u2, succ u2, succ u2} (MonoidHom.{u2, u2} R (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) _x) (MulHomClass.toFunLike.{u2, u2, u2} (MonoidHom.{u2, u2} R (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2))) R (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (MulOneClass.toMul.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2))) (MonoidHomClass.toMulHomClass.{u2, u2, u2} (MonoidHom.{u2, u2} R (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2))) R (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2)) (MonoidHom.monoidHomClass.{u2, u2} R (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (Monoid.toMulOneClass.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Monoid.toMulOneClass.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2))))) (OreLocalization.numeratorHom.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) r)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => T) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) R T (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} T (Semiring.toNonAssocSemiring.{u1} T _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) R T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} T (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3) (RingHom.instRingHomClassRingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3))))) f r)) -> (Eq.{max (succ u2) (succ u1)} (RingHom.{u2, u1} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) T (Semiring.toNonAssocSemiring.{u2} (OreLocalization.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) S _inst_2) (OreLocalization.instSemiringOreLocalizationToMonoidToMonoidWithZero.{u2} R _inst_1 S _inst_2)) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) φ (OreLocalization.universalHom.{u2, u1} R _inst_1 S _inst_2 T _inst_3 f fS hf))
Case conversion may be inaccurate. Consider using '#align ore_localization.universal_hom_unique OreLocalization.universalHom_uniqueₓ'. -/
theorem universalHom_unique (φ : R[S⁻¹] →+* T) (huniv : ∀ r : R, φ (numeratorHom r) = f r) :
    φ = universalHom f fS hf :=
  RingHom.coe_monoidHom_injective <| universalMulHom_unique (RingHom.toMonoidHom f) fS hf (↑φ) huniv
#align ore_localization.universal_hom_unique OreLocalization.universalHom_unique

end UMP

end Semiring

section Ring

variable {R : Type _} [Ring R] {S : Submonoid R} [OreSet S]

/- warning: ore_localization.neg -> OreLocalization.neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))} [_inst_2 : OreLocalization.OreSet.{u1} R (Ring.toMonoid.{u1} R _inst_1) S], (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) -> (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S], (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) -> (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2)
Case conversion may be inaccurate. Consider using '#align ore_localization.neg OreLocalization.negₓ'. -/
/-- Negation on the Ore localization is defined via negation on the numerator. -/
protected def neg : R[S⁻¹] → R[S⁻¹] :=
  liftExpand (fun (r : R) (s : S) => -r /ₒ s) fun r t s ht => by
    rw [neg_mul_eq_neg_mul, ← OreLocalization.expand]
#align ore_localization.neg OreLocalization.neg

instance : Neg R[S⁻¹] :=
  ⟨OreLocalization.neg⟩

/- warning: ore_localization.neg_def -> OreLocalization.neg_def is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))} [_inst_2 : OreLocalization.OreSet.{u1} R (Ring.toMonoid.{u1} R _inst_1) S] (r : R) (s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) S), Eq.{succ u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) (Neg.neg.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.hasNeg.{u1} R _inst_1 S _inst_2) (OreLocalization.oreDiv.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2 r s)) (OreLocalization.oreDiv.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2 (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))) r) s)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S] (r : R) (s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) x S)), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (Neg.neg.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (OreLocalization.instNegOreLocalizationToMonoidToMonoidWithZeroToSemiring.{u1} R _inst_1 S _inst_2) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2 r s)) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2 (Neg.neg.{u1} R (Ring.toNeg.{u1} R _inst_1) r) s)
Case conversion may be inaccurate. Consider using '#align ore_localization.neg_def OreLocalization.neg_defₓ'. -/
@[simp]
protected theorem neg_def (r : R) (s : S) : -(r /ₒ s) = -r /ₒ s :=
  rfl
#align ore_localization.neg_def OreLocalization.neg_def

/- warning: ore_localization.add_left_neg -> OreLocalization.add_left_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))} [_inst_2 : OreLocalization.OreSet.{u1} R (Ring.toMonoid.{u1} R _inst_1) S] (x : OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.hasAdd.{u1} R (Ring.toSemiring.{u1} R _inst_1) S _inst_2)) (Neg.neg.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.hasNeg.{u1} R _inst_1 S _inst_2) x) x) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) 0 (OfNat.mk.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) 0 (Zero.zero.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.hasZero.{u1} R (Ring.toSemiring.{u1} R _inst_1) S _inst_2))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S] (x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2), Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (HAdd.hAdd.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (instHAdd.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (OreLocalization.instAddOreLocalizationToMonoidToMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1) S _inst_2)) (Neg.neg.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (OreLocalization.instNegOreLocalizationToMonoidToMonoidWithZeroToSemiring.{u1} R _inst_1 S _inst_2) x) x) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) 0 (Zero.toOfNat0.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (OreLocalization.instZeroOreLocalizationToMonoidToMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1) S _inst_2)))
Case conversion may be inaccurate. Consider using '#align ore_localization.add_left_neg OreLocalization.add_left_negₓ'. -/
protected theorem add_left_neg (x : R[S⁻¹]) : -x + x = 0 := by
  induction' x using OreLocalization.ind with r s <;> simp
#align ore_localization.add_left_neg OreLocalization.add_left_neg

instance : Ring R[S⁻¹] :=
  { OreLocalization.semiring, OreLocalization.hasNeg with
    add_left_neg := OreLocalization.add_left_neg }

open nonZeroDivisors

/- warning: ore_localization.numerator_hom_inj -> OreLocalization.numeratorHom_inj is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))} [_inst_2 : OreLocalization.OreSet.{u1} R (Ring.toMonoid.{u1} R _inst_1) S], (LE.le.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Preorder.toLE.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))))) S (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) -> (Function.Injective.{succ u1, succ u1} R (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.monoid.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2))) (fun (_x : MonoidHom.{u1, u1} R (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.monoid.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2))) => R -> (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2)) (MonoidHom.hasCoeToFun.{u1, u1} R (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2) (OreLocalization.monoid.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2))) (OreLocalization.numeratorHom.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S], (LE.le.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Preorder.toLE.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Submonoid.instCompleteLatticeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))))))) S (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) -> (Function.Injective.{succ u1, succ u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2))) R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (MulOneClass.toMul.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (MulOneClass.toMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2))) R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2)) (MonoidHom.monoidHomClass.{u1, u1} R (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Monoid.toMulOneClass.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2) (OreLocalization.instMonoidOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2))))) (OreLocalization.numeratorHom.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2)))
Case conversion may be inaccurate. Consider using '#align ore_localization.numerator_hom_inj OreLocalization.numeratorHom_injₓ'. -/
theorem numeratorHom_inj (hS : S ≤ R⁰) : Function.Injective (numeratorHom : R → R[S⁻¹]) :=
  fun r₁ r₂ h =>
  by
  rw [numerator_hom_apply, numerator_hom_apply, ore_div_eq_iff] at h
  rcases h with ⟨u, v, h₁, h₂⟩
  simp only [S.coe_one, one_mul] at h₂
  rwa [← h₂, mul_cancel_right_mem_nonZeroDivisors (hS (SetLike.coe_mem u)), eq_comm] at h₁
#align ore_localization.numerator_hom_inj OreLocalization.numeratorHom_inj

/- warning: ore_localization.nontrivial_of_non_zero_divisors -> OreLocalization.nontrivial_of_nonZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))} [_inst_2 : OreLocalization.OreSet.{u1} R (Ring.toMonoid.{u1} R _inst_1) S] [_inst_3 : Nontrivial.{u1} R], (LE.le.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Preorder.toLE.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (SetLike.partialOrder.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))))) S (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) -> (Nontrivial.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) S _inst_2))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {S : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))} [_inst_2 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S] [_inst_3 : Nontrivial.{u1} R], (LE.le.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Preorder.toLE.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Submonoid.instCompleteLatticeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))))))) S (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) -> (Nontrivial.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) S _inst_2))
Case conversion may be inaccurate. Consider using '#align ore_localization.nontrivial_of_non_zero_divisors OreLocalization.nontrivial_of_nonZeroDivisorsₓ'. -/
theorem nontrivial_of_nonZeroDivisors [Nontrivial R] (hS : S ≤ R⁰) : Nontrivial R[S⁻¹] :=
  ⟨⟨0, 1, fun h => by
      rw [OreLocalization.one_def, OreLocalization.zero_def] at h
      apply nonZeroDivisors.coe_ne_zero 1 (numerator_hom_inj hS h).symm⟩⟩
#align ore_localization.nontrivial_of_non_zero_divisors OreLocalization.nontrivial_of_nonZeroDivisors

end Ring

section DivisionRing

open nonZeroDivisors

open Classical

variable {R : Type _} [Ring R] [Nontrivial R] [OreSet R⁰]

instance : Nontrivial R[R⁰⁻¹] :=
  nontrivial_of_nonZeroDivisors (refl R⁰)

variable [NoZeroDivisors R]

noncomputable section

/- warning: ore_localization.inv -> OreLocalization.inv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] [_inst_2 : Nontrivial.{u1} R] [_inst_3 : OreLocalization.OreSet.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))] [_inst_4 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))], (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) -> (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] [_inst_2 : Nontrivial.{u1} R] [_inst_3 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))] [_inst_4 : NoZeroDivisors.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))], (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) -> (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3)
Case conversion may be inaccurate. Consider using '#align ore_localization.inv OreLocalization.invₓ'. -/
/-- The inversion of Ore fractions for a ring without zero divisors, satisying `0⁻¹ = 0` and
`(r /ₒ r')⁻¹ = r' /ₒ r` for `r ≠ 0`. -/
protected def inv : R[R⁰⁻¹] → R[R⁰⁻¹] :=
  liftExpand
    (fun r s =>
      if hr : r = (0 : R) then (0 : R[R⁰⁻¹])
      else s /ₒ ⟨r, fun _ => eq_zero_of_ne_zero_of_mul_right_eq_zero hr⟩)
    (by
      intro r t s hst
      by_cases hr : r = 0
      · simp [hr]
      · by_cases ht : t = 0
        · exfalso
          apply nonZeroDivisors.coe_ne_zero ⟨_, hst⟩
          simp [ht, MulZeroClass.mul_zero]
        · simp only [hr, ht, [anonymous], dif_neg, not_false_iff, or_self_iff, mul_eq_zero]
          apply OreLocalization.expand)
#align ore_localization.inv OreLocalization.inv

instance : Inv R[R⁰⁻¹] :=
  ⟨OreLocalization.inv⟩

/- warning: ore_localization.inv_def -> OreLocalization.inv_def is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] [_inst_2 : Nontrivial.{u1} R] [_inst_3 : OreLocalization.OreSet.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))] [_inst_4 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))] {r : R} {s : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))}, Eq.{succ u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (Inv.inv.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.hasInv.{u1} R _inst_1 _inst_2 _inst_3 _inst_4) (OreLocalization.oreDiv.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3 r s)) (dite.{succ u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (Eq.{succ u1} R r (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))))))) (Classical.propDecidable (Eq.{succ u1} R r (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))))))) (fun (hr : Eq.{succ u1} R r (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))))))) => OfNat.ofNat.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) 0 (OfNat.mk.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) 0 (Zero.zero.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.hasZero.{u1} R (Ring.toSemiring.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3)))) (fun (hr : Not (Eq.{succ u1} R r (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))))))) => OreLocalization.oreDiv.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))) x (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))))) s) (Subtype.mk.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)))) x (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) r (fun (_x : R) => eq_zero_of_ne_zero_of_mul_right_eq_zero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) _inst_4 r _x hr))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] [_inst_2 : Nontrivial.{u1} R] [_inst_3 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))] [_inst_4 : NoZeroDivisors.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))] {r : R} {s : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))) x (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))}, Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (Inv.inv.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.inv'.{u1} R _inst_1 _inst_2 _inst_3 _inst_4) (OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3 r s)) (dite.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (Eq.{succ u1} R r (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))) (Classical.propDecidable (Eq.{succ u1} R r (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) (fun (hr : Eq.{succ u1} R r (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))) => OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) 0 (Zero.toOfNat0.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.instZeroOreLocalizationToMonoidToMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3))) (fun (hr : Not (Eq.{succ u1} R r (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) => OreLocalization.oreDiv.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3 (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) s) (Subtype.mk.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))) x (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) r (fun (_x : R) => eq_zero_of_ne_zero_of_mul_right_eq_zero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) _inst_4 r _x hr))))
Case conversion may be inaccurate. Consider using '#align ore_localization.inv_def OreLocalization.inv_defₓ'. -/
protected theorem inv_def {r : R} {s : R⁰} :
    (r /ₒ s)⁻¹ =
      if hr : r = (0 : R) then (0 : R[R⁰⁻¹])
      else s /ₒ ⟨r, fun _ => eq_zero_of_ne_zero_of_mul_right_eq_zero hr⟩ :=
  rfl
#align ore_localization.inv_def OreLocalization.inv_def

/- warning: ore_localization.mul_inv_cancel -> OreLocalization.mul_inv_cancel is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] [_inst_2 : Nontrivial.{u1} R] [_inst_3 : OreLocalization.OreSet.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))] [_inst_4 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))] (x : OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3), (Ne.{succ u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) x (OfNat.ofNat.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) 0 (OfNat.mk.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) 0 (Zero.zero.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.hasZero.{u1} R (Ring.toSemiring.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3))))) -> (Eq.{succ u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (instHMul.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.hasMul.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3)) x (Inv.inv.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.hasInv.{u1} R _inst_1 _inst_2 _inst_3 _inst_4) x)) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) 1 (OfNat.mk.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) 1 (One.one.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.hasOne.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] [_inst_2 : Nontrivial.{u1} R] [_inst_3 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))] [_inst_4 : NoZeroDivisors.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))] (x : OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3), (Ne.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) x (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) 0 (Zero.toOfNat0.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.instZeroOreLocalizationToMonoidToMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3)))) -> (Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (HMul.hMul.{u1, u1, u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (instHMul.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.instMulOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3)) x (Inv.inv.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.inv'.{u1} R _inst_1 _inst_2 _inst_3 _inst_4) x)) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) 1 (One.toOfNat1.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.instOneOreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3))))
Case conversion may be inaccurate. Consider using '#align ore_localization.mul_inv_cancel OreLocalization.mul_inv_cancelₓ'. -/
protected theorem mul_inv_cancel (x : R[R⁰⁻¹]) (h : x ≠ 0) : x * x⁻¹ = 1 :=
  by
  induction' x using OreLocalization.ind with r s
  rw [OreLocalization.inv_def, OreLocalization.one_def]
  by_cases hr : r = 0
  · exfalso
    apply h
    simp [hr]
  · simp [hr]
    apply OreLocalization.div_eq_one'
#align ore_localization.mul_inv_cancel OreLocalization.mul_inv_cancel

/- warning: ore_localization.inv_zero -> OreLocalization.inv_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] [_inst_2 : Nontrivial.{u1} R] [_inst_3 : OreLocalization.OreSet.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))] [_inst_4 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))], Eq.{succ u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (Inv.inv.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.hasInv.{u1} R _inst_1 _inst_2 _inst_3 _inst_4) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) 0 (OfNat.mk.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) 0 (Zero.zero.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.hasZero.{u1} R (Ring.toSemiring.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3))))) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) 0 (OfNat.mk.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) 0 (Zero.zero.{u1} (OreLocalization.{u1} R (Ring.toMonoid.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.hasZero.{u1} R (Ring.toSemiring.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] [_inst_2 : Nontrivial.{u1} R] [_inst_3 : OreLocalization.OreSet.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))] [_inst_4 : NoZeroDivisors.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))], Eq.{succ u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (Inv.inv.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.inv'.{u1} R _inst_1 _inst_2 _inst_3 _inst_4) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) 0 (Zero.toOfNat0.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.instZeroOreLocalizationToMonoidToMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3)))) (OfNat.ofNat.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) 0 (Zero.toOfNat0.{u1} (OreLocalization.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3) (OreLocalization.instZeroOreLocalizationToMonoidToMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1) (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_3)))
Case conversion may be inaccurate. Consider using '#align ore_localization.inv_zero OreLocalization.inv_zeroₓ'. -/
protected theorem inv_zero : (0 : R[R⁰⁻¹])⁻¹ = 0 :=
  by
  rw [OreLocalization.zero_def, OreLocalization.inv_def]
  simp
#align ore_localization.inv_zero OreLocalization.inv_zero

instance : DivisionRing R[R⁰⁻¹] :=
  { OreLocalization.nontrivial, OreLocalization.hasInv,
    OreLocalization.ring with
    mul_inv_cancel := OreLocalization.mul_inv_cancel
    inv_zero := OreLocalization.inv_zero }

end DivisionRing

end OreLocalization

