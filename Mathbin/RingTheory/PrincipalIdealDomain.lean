import Mathbin.RingTheory.UniqueFactorizationDomain

/-!
# Principal ideal rings and principal ideal domains

A principal ideal ring (PIR) is a ring in which all left ideals are principal. A
principal ideal domain (PID) is an integral domain which is a principal ideal ring.

# Main definitions

Note that for principal ideal domains, one should use
`[is_domain R] [is_principal_ideal_ring R]`. There is no explicit definition of a PID.
Theorems about PID's are in the `principal_ideal_ring` namespace.

- `is_principal_ideal_ring`: a predicate on rings, saying that every left ideal is principal.
- `generator`: a generator of a principal ideal (or more generally submodule)
- `to_unique_factorization_monoid`: a PID is a unique factorization domain

# Main results

- `to_maximal_ideal`: a non-zero prime ideal in a PID is maximal.
- `euclidean_domain.to_principal_ideal_domain` : a Euclidean domain is a PID.

-/


universe u v

variable{R : Type u}{M : Type v}

open Set Function

open Submodule

open_locale Classical

section 

variable[Ringₓ R][AddCommGroupₓ M][Module R M]

/-- An `R`-submodule of `M` is principal if it is generated by one element. -/
class Submodule.IsPrincipal(S : Submodule R M) : Prop where 
  principal{} : ∃ a, S = span R {a}

instance bot_is_principal : (⊥ : Submodule R M).IsPrincipal :=
  ⟨⟨0,
      by 
        simp ⟩⟩

instance top_is_principal : (⊤ : Submodule R R).IsPrincipal :=
  ⟨⟨1, Ideal.span_singleton_one.symm⟩⟩

variable(R)

/-- A ring is a principal ideal ring if all (left) ideals are principal. -/
class IsPrincipalIdealRing(R : Type u)[Ringₓ R] : Prop where 
  principal : ∀ (S : Ideal R), S.is_principal

attribute [instance] IsPrincipalIdealRing.principal

instance (priority := 100)DivisionRing.is_principal_ideal_ring (K : Type u) [DivisionRing K] : IsPrincipalIdealRing K :=
  { principal :=
      fun S =>
        by 
          rcases Ideal.eq_bot_or_top S with (rfl | rfl) <;> infer_instance }

end 

namespace Submodule.IsPrincipal

variable[AddCommGroupₓ M]

section Ringₓ

variable[Ringₓ R][Module R M]

/-- `generator I`, if `I` is a principal submodule, is an `x ∈ M` such that `span R {x} = I` -/
noncomputable def generator (S : Submodule R M) [S.is_principal] : M :=
  Classical.some (principal S)

theorem span_singleton_generator (S : Submodule R M) [S.is_principal] : span R {generator S} = S :=
  Eq.symm (Classical.some_spec (principal S))

theorem _root_.ideal.span_singleton_generator (I : Ideal R) [I.is_principal] : Ideal.span ({generator I} : Set R) = I :=
  Eq.symm (Classical.some_spec (principal I))

@[simp]
theorem generator_mem (S : Submodule R M) [S.is_principal] : generator S ∈ S :=
  by 
    convRHS => rw [←span_singleton_generator S]
    exact subset_span (mem_singleton _)

theorem mem_iff_eq_smul_generator (S : Submodule R M) [S.is_principal] {x : M} : x ∈ S ↔ ∃ s : R, x = s • generator S :=
  by 
    simpRw [@eq_comm _ x, ←mem_span_singleton, span_singleton_generator]

theorem eq_bot_iff_generator_eq_zero (S : Submodule R M) [S.is_principal] : S = ⊥ ↔ generator S = 0 :=
  by 
    rw [←@span_singleton_eq_bot R M, span_singleton_generator]

end Ringₓ

section CommRingₓ

variable[CommRingₓ R][Module R M]

theorem mem_iff_generator_dvd (S : Ideal R) [S.is_principal] {x : R} : x ∈ S ↔ generator S ∣ x :=
  (mem_iff_eq_smul_generator S).trans
    (exists_congr
      fun a =>
        by 
          simp only [mul_commₓ, smul_eq_mul])

theorem prime_generator_of_is_prime (S : Ideal R) [Submodule.IsPrincipal S] [is_prime : S.is_prime] (ne_bot : S ≠ ⊥) :
  Prime (generator S) :=
  ⟨fun h => ne_bot ((eq_bot_iff_generator_eq_zero S).2 h),
    fun h => is_prime.ne_top (S.eq_top_of_is_unit_mem (generator_mem S) h),
    by 
      simpa only [←mem_iff_generator_dvd S] using is_prime.2⟩

theorem generator_map_dvd_of_mem {N : Submodule R M} (ϕ : M →ₗ[R] R) [(N.map ϕ).IsPrincipal] {x : M} (hx : x ∈ N) :
  generator (N.map ϕ) ∣ ϕ x :=
  by 
    rw [←mem_iff_generator_dvd, Submodule.mem_map]
    exact ⟨x, hx, rfl⟩

theorem generator_submodule_image_dvd_of_mem {N O : Submodule R M} (hNO : N ≤ O) (ϕ : O →ₗ[R] R)
  [(ϕ.submodule_image N).IsPrincipal] {x : M} (hx : x ∈ N) : generator (ϕ.submodule_image N) ∣ ϕ ⟨x, hNO hx⟩ :=
  by 
    rw [←mem_iff_generator_dvd, LinearMap.mem_submodule_image_of_le hNO]
    exact ⟨x, hx, rfl⟩

end CommRingₓ

end Submodule.IsPrincipal

namespace IsPrime

open Submodule.IsPrincipal Ideal

-- error in RingTheory.PrincipalIdealDomain: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem to_maximal_ideal
[comm_ring R]
[is_domain R]
[is_principal_ideal_ring R]
{S : ideal R}
[hpi : is_prime S]
(hS : «expr ≠ »(S, «expr⊥»())) : is_maximal S :=
is_maximal_iff.2 ⟨(ne_top_iff_one S).1 hpi.1, begin
   assume [binders (T x hST hxS hxT)],
   cases [expr (mem_iff_generator_dvd _).1 «expr $ »(hST, generator_mem S)] ["with", ident z, ident hz],
   cases [expr hpi.mem_or_mem (show «expr ∈ »(«expr * »(generator T, z), S), from «expr ▸ »(hz, generator_mem S))] [],
   { have [ident hTS] [":", expr «expr ≤ »(T, S)] [],
     rwa ["[", "<-", expr T.span_singleton_generator, ",", expr ideal.span_le, ",", expr singleton_subset_iff, "]"] [],
     exact [expr «expr $ »(hxS, hTS hxT).elim] },
   cases [expr (mem_iff_generator_dvd _).1 h] ["with", ident y, ident hy],
   have [] [":", expr «expr ≠ »(generator S, 0)] [":=", expr mt (eq_bot_iff_generator_eq_zero _).2 hS],
   rw ["[", "<-", expr mul_one (generator S), ",", expr hy, ",", expr mul_left_comm, ",", expr mul_right_inj' this, "]"] ["at", ident hz],
   exact [expr «expr ▸ »(hz.symm, T.mul_mem_right _ (generator_mem T))]
 end⟩

end IsPrime

section 

open EuclideanDomain

variable[EuclideanDomain R]

theorem mod_mem_iff {S : Ideal R} {x y : R} (hy : y ∈ S) : x % y ∈ S ↔ x ∈ S :=
  ⟨fun hxy => div_add_mod x y ▸ S.add_mem (S.mul_mem_right _ hy) hxy,
    fun hx => (mod_eq_sub_mul_div x y).symm ▸ S.sub_mem hx (S.mul_mem_right _ hy)⟩

instance (priority := 100)EuclideanDomain.to_principal_ideal_domain : IsPrincipalIdealRing R :=
  { principal :=
      fun S =>
        by 
          exact
            ⟨if h : { x:R | x ∈ S ∧ x ≠ 0 }.Nonempty then
                have wf : WellFounded (EuclideanDomain.R : R → R → Prop) := EuclideanDomain.r_well_founded 
                have hmin :
                  WellFounded.min wf { x:R | x ∈ S ∧ x ≠ 0 } h ∈ S ∧ WellFounded.min wf { x:R | x ∈ S ∧ x ≠ 0 } h ≠ 0 :=
                  WellFounded.min_mem wf { x:R | x ∈ S ∧ x ≠ 0 } h
                ⟨WellFounded.min wf { x:R | x ∈ S ∧ x ≠ 0 } h,
                  Submodule.ext$
                    fun x =>
                      ⟨fun hx =>
                          div_add_mod x (WellFounded.min wf { x:R | x ∈ S ∧ x ≠ 0 } h) ▸
                            (Ideal.mem_span_singleton.2$
                              dvd_add (dvd_mul_right _ _)$
                                have  : x % WellFounded.min wf { x:R | x ∈ S ∧ x ≠ 0 } h ∉ { x:R | x ∈ S ∧ x ≠ 0 } :=
                                  fun h₁ => WellFounded.not_lt_min wf _ h h₁ (mod_lt x hmin.2)
                                have  : x % WellFounded.min wf { x:R | x ∈ S ∧ x ≠ 0 } h = 0 :=
                                  by 
                                    finish [(mod_mem_iff hmin.1).2 hx]
                                by 
                                  simp ),
                        fun hx =>
                          let ⟨y, hy⟩ := Ideal.mem_span_singleton.1 hx 
                          hy.symm ▸ S.mul_mem_right _ hmin.1⟩⟩
              else
                ⟨0,
                  Submodule.ext$
                    fun a =>
                      by 
                        rw [←@Submodule.bot_coe R R _ _ _, span_eq, Submodule.mem_bot] <;>
                          exact
                            ⟨fun haS => by_contradiction$ fun ha0 => h ⟨a, ⟨haS, ha0⟩⟩,
                              fun h₁ => h₁.symm ▸ S.zero_mem⟩⟩⟩ }

end 

theorem IsField.is_principal_ideal_ring {R : Type _} [CommRingₓ R] (h : IsField R) : IsPrincipalIdealRing R :=
  @EuclideanDomain.to_principal_ideal_domain R (@Field.toEuclideanDomain R (h.to_field R))

namespace PrincipalIdealRing

open IsPrincipalIdealRing

-- error in RingTheory.PrincipalIdealDomain: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[priority 100] instance is_noetherian_ring [ring R] [is_principal_ideal_ring R] : is_noetherian_ring R :=
is_noetherian_ring_iff.2 ⟨assume s : ideal R, begin
   rcases [expr (is_principal_ideal_ring.principal s).principal, "with", "⟨", ident a, ",", ident rfl, "⟩"],
   rw ["[", "<-", expr finset.coe_singleton, "]"] [],
   exact [expr ⟨{a}, set_like.coe_injective rfl⟩]
 end⟩

theorem is_maximal_of_irreducible [CommRingₓ R] [IsPrincipalIdealRing R] {p : R} (hp : Irreducible p) :
  Ideal.IsMaximal (span R ({p} : Set R)) :=
  ⟨⟨mt Ideal.span_singleton_eq_top.1 hp.1,
      fun I hI =>
        by 
          rcases principal I with ⟨a, rfl⟩
          erw [Ideal.span_singleton_eq_top]
          (
            rcases Ideal.span_singleton_le_span_singleton.1 (le_of_ltₓ hI) with ⟨b, rfl⟩)
          refine' (of_irreducible_mul hp).resolve_right (mt (fun hb => _) (not_le_of_lt hI))
          erw [Ideal.span_singleton_le_span_singleton, IsUnit.mul_right_dvd hb]⟩⟩

variable[CommRingₓ R][IsDomain R][IsPrincipalIdealRing R]

theorem irreducible_iff_prime {p : R} : Irreducible p ↔ Prime p :=
  ⟨fun hp => (Ideal.span_singleton_prime hp.ne_zero).1$ (is_maximal_of_irreducible hp).IsPrime, Prime.irreducible⟩

theorem associates_irreducible_iff_prime : ∀ {p : Associates R}, Irreducible p ↔ Prime p :=
  Associates.irreducible_iff_prime_iff.1 fun _ => irreducible_iff_prime

section 

open_locale Classical

/-- `factors a` is a multiset of irreducible elements whose product is `a`, up to units -/
noncomputable def factors (a : R) : Multiset R :=
  if h : a = 0 then ∅ else Classical.some (WfDvdMonoid.exists_factors a h)

theorem factors_spec (a : R) (h : a ≠ 0) : (∀ b (_ : b ∈ factors a), Irreducible b) ∧ Associated (factors a).Prod a :=
  by 
    unfold factors 
    rw [dif_neg h]
    exact Classical.some_spec (WfDvdMonoid.exists_factors a h)

theorem ne_zero_of_mem_factors {R : Type v} [CommRingₓ R] [IsDomain R] [IsPrincipalIdealRing R] {a b : R} (ha : a ≠ 0)
  (hb : b ∈ factors a) : b ≠ 0 :=
  Irreducible.ne_zero ((factors_spec a ha).1 b hb)

theorem mem_submonoid_of_factors_subset_of_units_subset (s : Submonoid R) {a : R} (ha : a ≠ 0)
  (hfac : ∀ b (_ : b ∈ factors a), b ∈ s) (hunit : ∀ (c : Units R), (c : R) ∈ s) : a ∈ s :=
  by 
    rcases(factors_spec a ha).2 with ⟨c, hc⟩
    rw [←hc]
    exact Submonoid.mul_mem _ (Submonoid.multiset_prod_mem _ _ hfac) (hunit _)

/-- If a `ring_hom` maps all units and all factors of an element `a` into a submonoid `s`, then it
also maps `a` into that submonoid. -/
theorem ring_hom_mem_submonoid_of_factors_subset_of_units_subset {R S : Type _} [CommRingₓ R] [IsDomain R]
  [IsPrincipalIdealRing R] [Semiringₓ S] (f : R →+* S) (s : Submonoid S) (a : R) (ha : a ≠ 0)
  (h : ∀ b (_ : b ∈ factors a), f b ∈ s) (hf : ∀ (c : Units R), f c ∈ s) : f a ∈ s :=
  mem_submonoid_of_factors_subset_of_units_subset (s.comap f.to_monoid_hom) ha h hf

/-- A principal ideal domain has unique factorization -/
instance (priority := 100)to_unique_factorization_monoid : UniqueFactorizationMonoid R :=
  { (IsNoetherianRing.wf_dvd_monoid : WfDvdMonoid R) with
    irreducible_iff_prime := fun _ => PrincipalIdealRing.irreducible_iff_prime }

end 

end PrincipalIdealRing

section Surjective

open Submodule

variable{S N : Type _}[Ringₓ R][AddCommGroupₓ M][AddCommGroupₓ N][Ringₓ S]

variable[Module R M][Module R N]

theorem Submodule.IsPrincipal.of_comap (f : M →ₗ[R] N) (hf : Function.Surjective f) (S : Submodule R N)
  [hI : is_principal (S.comap f)] : is_principal S :=
  ⟨⟨f (is_principal.generator (S.comap f)),
      by 
        rw [←Set.image_singleton, ←Submodule.map_span, is_principal.span_singleton_generator,
          Submodule.map_comap_eq_of_surjective hf]⟩⟩

theorem Ideal.IsPrincipal.of_comap (f : R →+* S) (hf : Function.Surjective f) (I : Ideal S)
  [hI : is_principal (I.comap f)] : is_principal I :=
  ⟨⟨f (is_principal.generator (I.comap f)),
      by 
        rw [Ideal.submodule_span_eq, ←Set.image_singleton, ←Ideal.map_span, Ideal.span_singleton_generator,
          Ideal.map_comap_of_surjective f hf]⟩⟩

/-- The surjective image of a principal ideal ring is again a principal ideal ring. -/
theorem IsPrincipalIdealRing.of_surjective [IsPrincipalIdealRing R] (f : R →+* S) (hf : Function.Surjective f) :
  IsPrincipalIdealRing S :=
  ⟨fun I => Ideal.IsPrincipal.of_comap f hf I⟩

end Surjective

