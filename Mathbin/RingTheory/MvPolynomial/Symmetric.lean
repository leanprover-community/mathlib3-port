/-
Copyright (c) 2020 Hanting Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Hanting Zhang, Johan Commelin

! This file was ported from Lean 3 source module ring_theory.mv_polynomial.symmetric
! leanprover-community/mathlib commit 2f5b500a507264de86d666a5f87ddb976e2d8de4
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.MvPolynomial.Rename
import Mathbin.Data.MvPolynomial.CommRing
import Mathbin.Algebra.Algebra.Subalgebra.Basic

/-!
# Symmetric Polynomials and Elementary Symmetric Polynomials

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines symmetric `mv_polynomial`s and elementary symmetric `mv_polynomial`s.
We also prove some basic facts about them.

## Main declarations

* `mv_polynomial.is_symmetric`

* `mv_polynomial.symmetric_subalgebra`

* `mv_polynomial.esymm`

## Notation

+ `esymm σ R n`, is the `n`th elementary symmetric polynomial in `mv_polynomial σ R`.

As in other polynomial files, we typically use the notation:

+ `σ τ : Type*` (indexing the variables)

+ `R S : Type*` `[comm_semiring R]` `[comm_semiring S]` (the coefficients)

+ `r : R` elements of the coefficient ring

+ `i : σ`, with corresponding monomial `X i`, often denoted `X_i` by mathematicians

+ `φ ψ : mv_polynomial σ R`

-/


open Equiv (Perm)

open BigOperators

noncomputable section

namespace Multiset

variable {R : Type _} [CommSemiring R]

#print Multiset.esymm /-
/-- The `n`th elementary symmetric function evaluated at the elements of `s` -/
def esymm (s : Multiset R) (n : ℕ) : R :=
  ((s.powersetLen n).map Multiset.prod).Sum
#align multiset.esymm Multiset.esymm
-/

#print Finset.esymm_map_val /-
theorem Finset.esymm_map_val {σ} (f : σ → R) (s : Finset σ) (n : ℕ) :
    (s.val.map f).esymm n = (s.powersetLen n).Sum fun t => t.Prod f := by
  simpa only [esymm, powerset_len_map, ← Finset.map_val_val_powersetLen, map_map]
#align finset.esymm_map_val Finset.esymm_map_val
-/

end Multiset

namespace MvPolynomial

variable {σ : Type _} {R : Type _}

variable {τ : Type _} {S : Type _}

#print MvPolynomial.IsSymmetric /-
/-- A `mv_polynomial φ` is symmetric if it is invariant under
permutations of its variables by the  `rename` operation -/
def IsSymmetric [CommSemiring R] (φ : MvPolynomial σ R) : Prop :=
  ∀ e : Perm σ, rename e φ = φ
#align mv_polynomial.is_symmetric MvPolynomial.IsSymmetric
-/

variable (σ R)

#print MvPolynomial.symmetricSubalgebra /-
/-- The subalgebra of symmetric `mv_polynomial`s. -/
def symmetricSubalgebra [CommSemiring R] : Subalgebra R (MvPolynomial σ R)
    where
  carrier := setOf IsSymmetric
  algebraMap_mem' r e := rename_C e r
  mul_mem' a b ha hb e := by rw [AlgHom.map_mul, ha, hb]
  add_mem' a b ha hb e := by rw [AlgHom.map_add, ha, hb]
#align mv_polynomial.symmetric_subalgebra MvPolynomial.symmetricSubalgebra
-/

variable {σ R}

/- warning: mv_polynomial.mem_symmetric_subalgebra -> MvPolynomial.mem_symmetricSubalgebra is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (p : MvPolynomial.{u1, u2} σ R _inst_1), Iff (Membership.Mem.{max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Subalgebra.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Subalgebra.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (Subalgebra.setLike.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)))) p (MvPolynomial.symmetricSubalgebra.{u1, u2} σ R _inst_1)) (MvPolynomial.IsSymmetric.{u1, u2} σ R _inst_1 p)
but is expected to have type
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (p : MvPolynomial.{u1, u2} σ R _inst_1), Iff (Membership.mem.{max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (Subalgebra.instSetLikeSubalgebra.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)))) p (MvPolynomial.symmetricSubalgebra.{u1, u2} σ R _inst_1)) (MvPolynomial.IsSymmetric.{u1, u2} σ R _inst_1 p)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.mem_symmetric_subalgebra MvPolynomial.mem_symmetricSubalgebraₓ'. -/
@[simp]
theorem mem_symmetricSubalgebra [CommSemiring R] (p : MvPolynomial σ R) :
    p ∈ symmetricSubalgebra σ R ↔ p.IsSymmetric :=
  Iff.rfl
#align mv_polynomial.mem_symmetric_subalgebra MvPolynomial.mem_symmetricSubalgebra

namespace IsSymmetric

section CommSemiring

variable [CommSemiring R] [CommSemiring S] {φ ψ : MvPolynomial σ R}

/- warning: mv_polynomial.is_symmetric.C -> MvPolynomial.IsSymmetric.C is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (r : R), MvPolynomial.IsSymmetric.{u1, u2} σ R _inst_1 (coeFn.{max (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (RingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (fun (_x : RingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) => R -> (MvPolynomial.{u1, u2} σ R _inst_1)) (RingHom.hasCoeToFun.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (MvPolynomial.C.{u2, u1} R σ _inst_1) r)
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (r : R), MvPolynomial.IsSymmetric.{u2, u1} σ R _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u1, max (succ u2) (succ u1)} (RingHom.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u2, u1} σ R _inst_1) _x) (MulHomClass.toFunLike.{max u2 u1, u1, max u2 u1} (RingHom.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))) R (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, max u2 u1} (RingHom.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))) R (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, max u2 u1} (RingHom.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))) R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))) (RingHom.instRingHomClassRingHom.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))))) (MvPolynomial.C.{u1, u2} R σ _inst_1) r)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_symmetric.C MvPolynomial.IsSymmetric.Cₓ'. -/
@[simp]
theorem C (r : R) : IsSymmetric (C r : MvPolynomial σ R) :=
  (symmetricSubalgebra σ R).algebraMap_mem r
#align mv_polynomial.is_symmetric.C MvPolynomial.IsSymmetric.C

/- warning: mv_polynomial.is_symmetric.zero -> MvPolynomial.IsSymmetric.zero is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R], MvPolynomial.IsSymmetric.{u1, u2} σ R _inst_1 (OfNat.ofNat.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (OfNat.mk.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (Zero.zero.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MulZeroClass.toHasZero.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))))))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R], MvPolynomial.IsSymmetric.{u2, u1} σ R _inst_1 (OfNat.ofNat.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommMonoidWithZero.toZero.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toCommMonoidWithZero.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_symmetric.zero MvPolynomial.IsSymmetric.zeroₓ'. -/
@[simp]
theorem zero : IsSymmetric (0 : MvPolynomial σ R) :=
  (symmetricSubalgebra σ R).zero_mem
#align mv_polynomial.is_symmetric.zero MvPolynomial.IsSymmetric.zero

/- warning: mv_polynomial.is_symmetric.one -> MvPolynomial.IsSymmetric.one is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R], MvPolynomial.IsSymmetric.{u1, u2} σ R _inst_1 (OfNat.ofNat.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 1 (OfNat.mk.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 1 (One.one.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (AddMonoidWithOne.toOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))))))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R], MvPolynomial.IsSymmetric.{u2, u1} σ R _inst_1 (OfNat.ofNat.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) 1 (One.toOfNat1.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_symmetric.one MvPolynomial.IsSymmetric.oneₓ'. -/
@[simp]
theorem one : IsSymmetric (1 : MvPolynomial σ R) :=
  (symmetricSubalgebra σ R).one_mem
#align mv_polynomial.is_symmetric.one MvPolynomial.IsSymmetric.one

/- warning: mv_polynomial.is_symmetric.add -> MvPolynomial.IsSymmetric.add is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {φ : MvPolynomial.{u1, u2} σ R _inst_1} {ψ : MvPolynomial.{u1, u2} σ R _inst_1}, (MvPolynomial.IsSymmetric.{u1, u2} σ R _inst_1 φ) -> (MvPolynomial.IsSymmetric.{u1, u2} σ R _inst_1 ψ) -> (MvPolynomial.IsSymmetric.{u1, u2} σ R _inst_1 (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (instHAdd.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Distrib.toHasAdd.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))) φ ψ))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {φ : MvPolynomial.{u2, u1} σ R _inst_1} {ψ : MvPolynomial.{u2, u1} σ R _inst_1}, (MvPolynomial.IsSymmetric.{u2, u1} σ R _inst_1 φ) -> (MvPolynomial.IsSymmetric.{u2, u1} σ R _inst_1 ψ) -> (MvPolynomial.IsSymmetric.{u2, u1} σ R _inst_1 (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (instHAdd.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Distrib.toAdd.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))))) φ ψ))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_symmetric.add MvPolynomial.IsSymmetric.addₓ'. -/
theorem add (hφ : IsSymmetric φ) (hψ : IsSymmetric ψ) : IsSymmetric (φ + ψ) :=
  (symmetricSubalgebra σ R).add_mem hφ hψ
#align mv_polynomial.is_symmetric.add MvPolynomial.IsSymmetric.add

/- warning: mv_polynomial.is_symmetric.mul -> MvPolynomial.IsSymmetric.mul is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {φ : MvPolynomial.{u1, u2} σ R _inst_1} {ψ : MvPolynomial.{u1, u2} σ R _inst_1}, (MvPolynomial.IsSymmetric.{u1, u2} σ R _inst_1 φ) -> (MvPolynomial.IsSymmetric.{u1, u2} σ R _inst_1 ψ) -> (MvPolynomial.IsSymmetric.{u1, u2} σ R _inst_1 (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (instHMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Distrib.toHasMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))) φ ψ))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {φ : MvPolynomial.{u2, u1} σ R _inst_1} {ψ : MvPolynomial.{u2, u1} σ R _inst_1}, (MvPolynomial.IsSymmetric.{u2, u1} σ R _inst_1 φ) -> (MvPolynomial.IsSymmetric.{u2, u1} σ R _inst_1 ψ) -> (MvPolynomial.IsSymmetric.{u2, u1} σ R _inst_1 (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (instHMul.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))))) φ ψ))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_symmetric.mul MvPolynomial.IsSymmetric.mulₓ'. -/
theorem mul (hφ : IsSymmetric φ) (hψ : IsSymmetric ψ) : IsSymmetric (φ * ψ) :=
  (symmetricSubalgebra σ R).mul_mem hφ hψ
#align mv_polynomial.is_symmetric.mul MvPolynomial.IsSymmetric.mul

/- warning: mv_polynomial.is_symmetric.smul -> MvPolynomial.IsSymmetric.smul is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {φ : MvPolynomial.{u1, u2} σ R _inst_1} (r : R), (MvPolynomial.IsSymmetric.{u1, u2} σ R _inst_1 φ) -> (MvPolynomial.IsSymmetric.{u1, u2} σ R _inst_1 (SMul.smul.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (SMulZeroClass.toHasSmul.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (MulZeroClass.toHasZero.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))) (MvPolynomial.smulZeroClass.{u2, u2, u1} R R σ _inst_1 (SMulWithZero.toSmulZeroClass.{u2, u2} R R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (MulZeroClass.toSMulWithZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))))) r φ))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {φ : MvPolynomial.{u2, u1} σ R _inst_1} (r : R), (MvPolynomial.IsSymmetric.{u2, u1} σ R _inst_1 φ) -> (MvPolynomial.IsSymmetric.{u2, u1} σ R _inst_1 (HSMul.hSMul.{u1, max u2 u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (instHSMul.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) (Algebra.toSMul.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)))) r φ))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_symmetric.smul MvPolynomial.IsSymmetric.smulₓ'. -/
theorem smul (r : R) (hφ : IsSymmetric φ) : IsSymmetric (r • φ) :=
  (symmetricSubalgebra σ R).smul_mem hφ r
#align mv_polynomial.is_symmetric.smul MvPolynomial.IsSymmetric.smul

/- warning: mv_polynomial.is_symmetric.map -> MvPolynomial.IsSymmetric.map is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommSemiring.{u3} S] {φ : MvPolynomial.{u1, u2} σ R _inst_1}, (MvPolynomial.IsSymmetric.{u1, u2} σ R _inst_1 φ) -> (forall (f : RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S _inst_2))), MvPolynomial.IsSymmetric.{u1, u3} σ S _inst_2 (coeFn.{max (succ (max u1 u2)) (succ (max u1 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (RingHom.{max u1 u2, max u1 u3} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u3} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ S _inst_2) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ S _inst_2) (MvPolynomial.commSemiring.{u3, u1} S σ _inst_2)))) (fun (_x : RingHom.{max u1 u2, max u1 u3} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u3} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ S _inst_2) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ S _inst_2) (MvPolynomial.commSemiring.{u3, u1} S σ _inst_2)))) => (MvPolynomial.{u1, u2} σ R _inst_1) -> (MvPolynomial.{u1, u3} σ S _inst_2)) (RingHom.hasCoeToFun.{max u1 u2, max u1 u3} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u3} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ S _inst_2) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ S _inst_2) (MvPolynomial.commSemiring.{u3, u1} S σ _inst_2)))) (MvPolynomial.map.{u2, u3, u1} R S σ _inst_1 _inst_2 f) φ))
but is expected to have type
  forall {σ : Type.{u3}} {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommSemiring.{u1} S] {φ : MvPolynomial.{u3, u2} σ R _inst_1}, (MvPolynomial.IsSymmetric.{u3, u2} σ R _inst_1 φ) -> (forall (f : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2))), MvPolynomial.IsSymmetric.{u3, u1} σ S _inst_2 (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), max (succ u2) (succ u3), max (succ u1) (succ u3)} (RingHom.{max u2 u3, max u1 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u1} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (MvPolynomial.commSemiring.{u1, u3} S σ _inst_2)))) (MvPolynomial.{u3, u2} σ R _inst_1) (fun (_x : MvPolynomial.{u3, u2} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : MvPolynomial.{u3, u2} σ R _inst_1) => MvPolynomial.{u3, u1} σ S _inst_2) _x) (MulHomClass.toFunLike.{max (max u2 u1) u3, max u2 u3, max u1 u3} (RingHom.{max u2 u3, max u1 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u1} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (MvPolynomial.commSemiring.{u1, u3} S σ _inst_2)))) (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u1} σ S _inst_2) (NonUnitalNonAssocSemiring.toMul.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (MvPolynomial.commSemiring.{u1, u3} S σ _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max (max u2 u1) u3, max u2 u3, max u1 u3} (RingHom.{max u2 u3, max u1 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u1} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (MvPolynomial.commSemiring.{u1, u3} S σ _inst_2)))) (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u1} σ S _inst_2) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (MvPolynomial.commSemiring.{u1, u3} S σ _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max (max u2 u1) u3, max u2 u3, max u1 u3} (RingHom.{max u2 u3, max u1 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u1} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (MvPolynomial.commSemiring.{u1, u3} S σ _inst_2)))) (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u1} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (MvPolynomial.commSemiring.{u1, u3} S σ _inst_2))) (RingHom.instRingHomClassRingHom.{max u2 u3, max u1 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u1} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ S _inst_2) (MvPolynomial.commSemiring.{u1, u3} S σ _inst_2))))))) (MvPolynomial.map.{u2, u1, u3} R S σ _inst_1 _inst_2 f) φ))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_symmetric.map MvPolynomial.IsSymmetric.mapₓ'. -/
@[simp]
theorem map (hφ : IsSymmetric φ) (f : R →+* S) : IsSymmetric (map f φ) := fun e => by
  rw [← map_rename, hφ]
#align mv_polynomial.is_symmetric.map MvPolynomial.IsSymmetric.map

end CommSemiring

section CommRing

variable [CommRing R] {φ ψ : MvPolynomial σ R}

/- warning: mv_polynomial.is_symmetric.neg -> MvPolynomial.IsSymmetric.neg is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] {φ : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)}, (MvPolynomial.IsSymmetric.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1) φ) -> (MvPolynomial.IsSymmetric.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1) (Neg.neg.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (SubNegMonoid.toHasNeg.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (AddGroup.toSubNegMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (AddCommGroupWithOne.toAddGroupWithOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toAddCommGroupWithOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commRing.{u2, u1} R σ _inst_1))))))) φ))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {φ : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)}, (MvPolynomial.IsSymmetric.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1) φ) -> (MvPolynomial.IsSymmetric.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1) (Neg.neg.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNeg.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u1, u2} R σ _inst_1))) φ))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_symmetric.neg MvPolynomial.IsSymmetric.negₓ'. -/
theorem neg (hφ : IsSymmetric φ) : IsSymmetric (-φ) :=
  (symmetricSubalgebra σ R).neg_mem hφ
#align mv_polynomial.is_symmetric.neg MvPolynomial.IsSymmetric.neg

/- warning: mv_polynomial.is_symmetric.sub -> MvPolynomial.IsSymmetric.sub is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] {φ : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)} {ψ : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)}, (MvPolynomial.IsSymmetric.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1) φ) -> (MvPolynomial.IsSymmetric.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1) ψ) -> (MvPolynomial.IsSymmetric.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (instHSub.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (SubNegMonoid.toHasSub.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (AddGroup.toSubNegMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (AddCommGroupWithOne.toAddGroupWithOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toAddCommGroupWithOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commRing.{u2, u1} R σ _inst_1)))))))) φ ψ))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {φ : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)} {ψ : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)}, (MvPolynomial.IsSymmetric.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1) φ) -> (MvPolynomial.IsSymmetric.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1) ψ) -> (MvPolynomial.IsSymmetric.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u1, u2} R σ _inst_1)))) φ ψ))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_symmetric.sub MvPolynomial.IsSymmetric.subₓ'. -/
theorem sub (hφ : IsSymmetric φ) (hψ : IsSymmetric ψ) : IsSymmetric (φ - ψ) :=
  (symmetricSubalgebra σ R).sub_mem hφ hψ
#align mv_polynomial.is_symmetric.sub MvPolynomial.IsSymmetric.sub

end CommRing

end IsSymmetric

section ElementarySymmetric

open Finset

variable (σ R) [CommSemiring R] [CommSemiring S] [Fintype σ] [Fintype τ]

#print MvPolynomial.esymm /-
/-- The `n`th elementary symmetric `mv_polynomial σ R`. -/
def esymm (n : ℕ) : MvPolynomial σ R :=
  ∑ t in powersetLen n univ, ∏ i in t, X i
#align mv_polynomial.esymm MvPolynomial.esymm
-/

/- warning: mv_polynomial.esymm_eq_multiset_esymm -> MvPolynomial.esymm_eq_multiset_esymm is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) (R : Type.{u2}) [_inst_1 : CommSemiring.{u2} R] [_inst_3 : Fintype.{u1} σ], Eq.{max 1 (succ u1) (succ u2)} (Nat -> (MvPolynomial.{u1, u2} σ R _inst_1)) (MvPolynomial.esymm.{u1, u2} σ R _inst_1 _inst_3) (Multiset.esymm.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1) (Multiset.map.{u1, max u1 u2} σ (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.X.{u2, u1} R σ _inst_1) (Finset.val.{u1} σ (Finset.univ.{u1} σ _inst_3))))
but is expected to have type
  forall (σ : Type.{u2}) (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Fintype.{u2} σ], Eq.{max (succ u2) (succ u1)} (Nat -> (MvPolynomial.{u2, u1} σ R _inst_1)) (MvPolynomial.esymm.{u2, u1} σ R _inst_1 _inst_3) (Multiset.esymm.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1) (Multiset.map.{u2, max u2 u1} σ (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.X.{u1, u2} R σ _inst_1) (Finset.val.{u2} σ (Finset.univ.{u2} σ _inst_3))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.esymm_eq_multiset_esymm MvPolynomial.esymm_eq_multiset_esymmₓ'. -/
/-- The `n`th elementary symmetric `mv_polynomial σ R` is obtained by evaluating the
`n`th elementary symmetric at the `multiset` of the monomials -/
theorem esymm_eq_multiset_esymm : esymm σ R = (Finset.univ.val.map X).esymm :=
  funext fun n => (Finset.univ.esymm_map_val X n).symm
#align mv_polynomial.esymm_eq_multiset_esymm MvPolynomial.esymm_eq_multiset_esymm

/- warning: mv_polynomial.aeval_esymm_eq_multiset_esymm -> MvPolynomial.aeval_esymm_eq_multiset_esymm is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) (R : Type.{u2}) {S : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommSemiring.{u3} S] [_inst_3 : Fintype.{u1} σ] [_inst_5 : Algebra.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S _inst_2)] (f : σ -> S) (n : Nat), Eq.{succ u3} S (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (AlgHom.{u2, max u1 u2, u3} R (MvPolynomial.{u1, u2} σ R _inst_1) S _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (CommSemiring.toSemiring.{u3} S _inst_2) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)) _inst_5) (fun (_x : AlgHom.{u2, max u1 u2, u3} R (MvPolynomial.{u1, u2} σ R _inst_1) S _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (CommSemiring.toSemiring.{u3} S _inst_2) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)) _inst_5) => (MvPolynomial.{u1, u2} σ R _inst_1) -> S) ([anonymous].{u2, max u1 u2, u3} R (MvPolynomial.{u1, u2} σ R _inst_1) S _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (CommSemiring.toSemiring.{u3} S _inst_2) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)) _inst_5) (MvPolynomial.aeval.{u2, u3, u1} R S σ _inst_1 _inst_2 _inst_5 f) (MvPolynomial.esymm.{u1, u2} σ R _inst_1 _inst_3 n)) (Multiset.esymm.{u3} S _inst_2 (Multiset.map.{u1, u3} σ S f (Finset.val.{u1} σ (Finset.univ.{u1} σ _inst_3))) n)
but is expected to have type
  forall (σ : Type.{u1}) (R : Type.{u3}) {S : Type.{u2}} [_inst_1 : CommSemiring.{u3} R] [_inst_2 : CommSemiring.{u2} S] [_inst_3 : Fintype.{u1} σ] [_inst_5 : Algebra.{u3, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2)] (f : σ -> S) (n : Nat), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : MvPolynomial.{u1, u3} σ R _inst_1) => S) (MvPolynomial.esymm.{u1, u3} σ R _inst_1 _inst_3 n)) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (succ u1) (succ u3), succ u2} (AlgHom.{u3, max u3 u1, u2} R (MvPolynomial.{u1, u3} σ R _inst_1) S _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)) (CommSemiring.toSemiring.{u2} S _inst_2) (MvPolynomial.algebra.{u3, u3, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u3} R _inst_1)) _inst_5) (MvPolynomial.{u1, u3} σ R _inst_1) (fun (_x : MvPolynomial.{u1, u3} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : MvPolynomial.{u1, u3} σ R _inst_1) => S) _x) (SMulHomClass.toFunLike.{max (max u1 u2) u3, u3, max u1 u3, u2} (AlgHom.{u3, max u3 u1, u2} R (MvPolynomial.{u1, u3} σ R _inst_1) S _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)) (CommSemiring.toSemiring.{u2} S _inst_2) (MvPolynomial.algebra.{u3, u3, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u3} R _inst_1)) _inst_5) R (MvPolynomial.{u1, u3} σ R _inst_1) S (SMulZeroClass.toSMul.{u3, max u1 u3} R (MvPolynomial.{u1, u3} σ R _inst_1) (AddMonoid.toZero.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (AddCommMonoid.toAddMonoid.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))))))) (DistribSMul.toSMulZeroClass.{u3, max u1 u3} R (MvPolynomial.{u1, u3} σ R _inst_1) (AddMonoid.toAddZeroClass.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (AddCommMonoid.toAddMonoid.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))))))) (DistribMulAction.toDistribSMul.{u3, max u1 u3} R (MvPolynomial.{u1, u3} σ R _inst_1) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (AddCommMonoid.toAddMonoid.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)))))) (Module.toDistribMulAction.{u3, max u1 u3} R (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))))) (Algebra.toModule.{u3, max u1 u3} R (MvPolynomial.{u1, u3} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)) (MvPolynomial.algebra.{u3, u3, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u3} R _inst_1))))))) (SMulZeroClass.toSMul.{u3, u2} R S (AddMonoid.toZero.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))))) (DistribSMul.toSMulZeroClass.{u3, u2} R S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))))) (DistribMulAction.toDistribSMul.{u3, u2} R S (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) (Module.toDistribMulAction.{u3, u2} R S (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (Algebra.toModule.{u3, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2) _inst_5))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u1 u2) u3, u3, max u1 u3, u2} (AlgHom.{u3, max u3 u1, u2} R (MvPolynomial.{u1, u3} σ R _inst_1) S _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)) (CommSemiring.toSemiring.{u2} S _inst_2) (MvPolynomial.algebra.{u3, u3, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u3} R _inst_1)) _inst_5) R (MvPolynomial.{u1, u3} σ R _inst_1) S (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (AddCommMonoid.toAddMonoid.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)))))) (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) (Module.toDistribMulAction.{u3, max u1 u3} R (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))))) (Algebra.toModule.{u3, max u1 u3} R (MvPolynomial.{u1, u3} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)) (MvPolynomial.algebra.{u3, u3, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u3} R _inst_1)))) (Module.toDistribMulAction.{u3, u2} R S (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (Algebra.toModule.{u3, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2) _inst_5)) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max (max u1 u2) u3, u3, max u1 u3, u2} (AlgHom.{u3, max u3 u1, u2} R (MvPolynomial.{u1, u3} σ R _inst_1) S _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)) (CommSemiring.toSemiring.{u2} S _inst_2) (MvPolynomial.algebra.{u3, u3, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u3} R _inst_1)) _inst_5) R (MvPolynomial.{u1, u3} σ R _inst_1) S (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (Module.toDistribMulAction.{u3, max u1 u3} R (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))))) (Algebra.toModule.{u3, max u1 u3} R (MvPolynomial.{u1, u3} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)) (MvPolynomial.algebra.{u3, u3, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u3} R _inst_1)))) (Module.toDistribMulAction.{u3, u2} R S (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (Algebra.toModule.{u3, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2) _inst_5)) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u3, max u1 u3, u2, max (max u1 u2) u3} R (MvPolynomial.{u1, u3} σ R _inst_1) S _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)) (CommSemiring.toSemiring.{u2} S _inst_2) (MvPolynomial.algebra.{u3, u3, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u3} R _inst_1)) _inst_5 (AlgHom.{u3, max u3 u1, u2} R (MvPolynomial.{u1, u3} σ R _inst_1) S _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)) (CommSemiring.toSemiring.{u2} S _inst_2) (MvPolynomial.algebra.{u3, u3, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u3} R _inst_1)) _inst_5) (AlgHom.algHomClass.{u3, max u1 u3, u2} R (MvPolynomial.{u1, u3} σ R _inst_1) S _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)) (CommSemiring.toSemiring.{u2} S _inst_2) (MvPolynomial.algebra.{u3, u3, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u3} R _inst_1)) _inst_5))))) (MvPolynomial.aeval.{u3, u2, u1} R S σ _inst_1 _inst_2 _inst_5 f) (MvPolynomial.esymm.{u1, u3} σ R _inst_1 _inst_3 n)) (Multiset.esymm.{u2} S _inst_2 (Multiset.map.{u1, u2} σ S f (Finset.val.{u1} σ (Finset.univ.{u1} σ _inst_3))) n)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.aeval_esymm_eq_multiset_esymm MvPolynomial.aeval_esymm_eq_multiset_esymmₓ'. -/
theorem aeval_esymm_eq_multiset_esymm [Algebra R S] (f : σ → S) (n : ℕ) :
    aeval f (esymm σ R n) = (Finset.univ.val.map f).esymm n := by
  simp_rw [esymm, aeval_sum, aeval_prod, aeval_X, esymm_map_val]
#align mv_polynomial.aeval_esymm_eq_multiset_esymm MvPolynomial.aeval_esymm_eq_multiset_esymm

/- warning: mv_polynomial.esymm_eq_sum_subtype -> MvPolynomial.esymm_eq_sum_subtype is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) (R : Type.{u2}) [_inst_1 : CommSemiring.{u2} R] [_inst_3 : Fintype.{u1} σ] (n : Nat), Eq.{max (succ u1) (succ u2)} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.esymm.{u1, u2} σ R _inst_1 _inst_3 n) (Finset.sum.{max u1 u2, u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Subtype.{succ u1} (Finset.{u1} σ) (fun (s : Finset.{u1} σ) => Eq.{1} Nat (Finset.card.{u1} σ s) n)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Finset.univ.{u1} (Subtype.{succ u1} (Finset.{u1} σ) (fun (s : Finset.{u1} σ) => Eq.{1} Nat (Finset.card.{u1} σ s) n)) (Subtype.fintype.{u1} (Finset.{u1} σ) (fun (s : Finset.{u1} σ) => Eq.{1} Nat (Finset.card.{u1} σ s) n) (fun (a : Finset.{u1} σ) => Nat.decidableEq (Finset.card.{u1} σ a) n) (Finset.fintype.{u1} σ _inst_3))) (fun (t : Subtype.{succ u1} (Finset.{u1} σ) (fun (s : Finset.{u1} σ) => Eq.{1} Nat (Finset.card.{u1} σ s) n)) => Finset.prod.{max u1 u2, u1} (MvPolynomial.{u1, u2} σ R _inst_1) σ (CommSemiring.toCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} (Finset.{u1} σ) (fun (s : Finset.{u1} σ) => Eq.{1} Nat (Finset.card.{u1} σ s) n)) (Finset.{u1} σ) (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} (Finset.{u1} σ) (fun (s : Finset.{u1} σ) => Eq.{1} Nat (Finset.card.{u1} σ s) n)) (Finset.{u1} σ) (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} (Finset.{u1} σ) (fun (s : Finset.{u1} σ) => Eq.{1} Nat (Finset.card.{u1} σ s) n)) (Finset.{u1} σ) (coeBase.{succ u1, succ u1} (Subtype.{succ u1} (Finset.{u1} σ) (fun (s : Finset.{u1} σ) => Eq.{1} Nat (Finset.card.{u1} σ s) n)) (Finset.{u1} σ) (coeSubtype.{succ u1} (Finset.{u1} σ) (fun (s : Finset.{u1} σ) => Eq.{1} Nat (Finset.card.{u1} σ s) n))))) t) (fun (i : σ) => MvPolynomial.X.{u2, u1} R σ _inst_1 i)))
but is expected to have type
  forall (σ : Type.{u2}) (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Fintype.{u2} σ] (n : Nat), Eq.{max (succ u2) (succ u1)} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.esymm.{u2, u1} σ R _inst_1 _inst_3 n) (Finset.sum.{max u2 u1, u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Subtype.{succ u2} (Finset.{u2} σ) (fun (s : Finset.{u2} σ) => Eq.{1} Nat (Finset.card.{u2} σ s) n)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Finset.univ.{u2} (Subtype.{succ u2} (Finset.{u2} σ) (fun (s : Finset.{u2} σ) => Eq.{1} Nat (Finset.card.{u2} σ s) n)) (Subtype.fintype.{u2} (Finset.{u2} σ) (fun (s : Finset.{u2} σ) => Eq.{1} Nat (Finset.card.{u2} σ s) n) (fun (a : Finset.{u2} σ) => instDecidableEqNat (Finset.card.{u2} σ a) n) (Finset.fintype.{u2} σ _inst_3))) (fun (t : Subtype.{succ u2} (Finset.{u2} σ) (fun (s : Finset.{u2} σ) => Eq.{1} Nat (Finset.card.{u2} σ s) n)) => Finset.prod.{max u2 u1, u2} (MvPolynomial.{u2, u1} σ R _inst_1) σ (CommSemiring.toCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (Subtype.val.{succ u2} (Finset.{u2} σ) (fun (s : Finset.{u2} σ) => Eq.{1} Nat (Finset.card.{u2} σ s) n) t) (fun (i : σ) => MvPolynomial.X.{u1, u2} R σ _inst_1 i)))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.esymm_eq_sum_subtype MvPolynomial.esymm_eq_sum_subtypeₓ'. -/
/-- We can define `esymm σ R n` by summing over a subtype instead of over `powerset_len`. -/
theorem esymm_eq_sum_subtype (n : ℕ) :
    esymm σ R n = ∑ t : { s : Finset σ // s.card = n }, ∏ i in (t : Finset σ), X i :=
  sum_subtype _ (fun _ => mem_powerset_len_univ_iff) _
#align mv_polynomial.esymm_eq_sum_subtype MvPolynomial.esymm_eq_sum_subtype

/- warning: mv_polynomial.esymm_eq_sum_monomial -> MvPolynomial.esymm_eq_sum_monomial is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) (R : Type.{u2}) [_inst_1 : CommSemiring.{u2} R] [_inst_3 : Fintype.{u1} σ] (n : Nat), Eq.{max (succ u1) (succ u2)} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.esymm.{u1, u2} σ R _inst_1 _inst_3 n) (Finset.sum.{max u1 u2, u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Finset.{u1} σ) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Finset.powersetLen.{u1} σ n (Finset.univ.{u1} σ _inst_3)) (fun (t : Finset.{u1} σ) => coeFn.{max (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (LinearMap.{u2, u2, u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => R -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, u2, max u1 u2} R R R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.monomial.{u2, u1} R σ _inst_1 (Finset.sum.{u1, u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) σ (Finsupp.addCommMonoid.{u1, 0} σ Nat Nat.addCommMonoid) t (fun (i : σ) => Finsupp.single.{u1, 0} σ Nat Nat.hasZero i (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{u2} R 1 (OfNat.mk.{u2} R 1 (One.one.{u2} R (AddMonoidWithOne.toOne.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))))))))
but is expected to have type
  forall (σ : Type.{u2}) (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Fintype.{u2} σ] (n : Nat), Eq.{max (succ u2) (succ u1)} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.esymm.{u2, u1} σ R _inst_1 _inst_3 n) (Finset.sum.{max u2 u1, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Finset.{u2} σ) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Semiring.toNonAssocSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (CommSemiring.toSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Finset.powersetLen.{u2} σ n (Finset.univ.{u2} σ _inst_3)) (fun (t : Finset.{u2} σ) => FunLike.coe.{max (succ u2) (succ u1), succ u1, max (succ u2) (succ u1)} (LinearMap.{u1, u1, u1, max u1 u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : R) => MvPolynomial.{u2, u1} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, max u2 u1} R R R (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.monomial.{u1, u2} R σ _inst_1 (Finset.sum.{u2, u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) σ (Finsupp.addCommMonoid.{u2, 0} σ Nat Nat.addCommMonoid) t (fun (i : σ) => Finsupp.single.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) i (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.esymm_eq_sum_monomial MvPolynomial.esymm_eq_sum_monomialₓ'. -/
/-- We can define `esymm σ R n` as a sum over explicit monomials -/
theorem esymm_eq_sum_monomial (n : ℕ) :
    esymm σ R n = ∑ t in powersetLen n univ, monomial (∑ i in t, Finsupp.single i 1) 1 :=
  by
  simp_rw [monomial_sum_one]
  rfl
#align mv_polynomial.esymm_eq_sum_monomial MvPolynomial.esymm_eq_sum_monomial

/- warning: mv_polynomial.esymm_zero -> MvPolynomial.esymm_zero is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) (R : Type.{u2}) [_inst_1 : CommSemiring.{u2} R] [_inst_3 : Fintype.{u1} σ], Eq.{max (succ u1) (succ u2)} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.esymm.{u1, u2} σ R _inst_1 _inst_3 (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (OfNat.ofNat.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 1 (OfNat.mk.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 1 (One.one.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (AddMonoidWithOne.toOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))))))
but is expected to have type
  forall (σ : Type.{u2}) (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Fintype.{u2} σ], Eq.{max (succ u2) (succ u1)} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.esymm.{u2, u1} σ R _inst_1 _inst_3 (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (OfNat.ofNat.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) 1 (One.toOfNat1.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.esymm_zero MvPolynomial.esymm_zeroₓ'. -/
@[simp]
theorem esymm_zero : esymm σ R 0 = 1 := by
  simp only [esymm, powerset_len_zero, sum_singleton, prod_empty]
#align mv_polynomial.esymm_zero MvPolynomial.esymm_zero

/- warning: mv_polynomial.map_esymm -> MvPolynomial.map_esymm is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) (R : Type.{u2}) {S : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommSemiring.{u3} S] [_inst_3 : Fintype.{u1} σ] (n : Nat) (f : RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S _inst_2))), Eq.{max (succ u1) (succ u3)} (MvPolynomial.{u1, u3} σ S _inst_2) (coeFn.{max (succ (max u1 u2)) (succ (max u1 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (RingHom.{max u1 u2, max u1 u3} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u3} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ S _inst_2) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ S _inst_2) (MvPolynomial.commSemiring.{u3, u1} S σ _inst_2)))) (fun (_x : RingHom.{max u1 u2, max u1 u3} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u3} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ S _inst_2) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ S _inst_2) (MvPolynomial.commSemiring.{u3, u1} S σ _inst_2)))) => (MvPolynomial.{u1, u2} σ R _inst_1) -> (MvPolynomial.{u1, u3} σ S _inst_2)) (RingHom.hasCoeToFun.{max u1 u2, max u1 u3} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u3} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ S _inst_2) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ S _inst_2) (MvPolynomial.commSemiring.{u3, u1} S σ _inst_2)))) (MvPolynomial.map.{u2, u3, u1} R S σ _inst_1 _inst_2 f) (MvPolynomial.esymm.{u1, u2} σ R _inst_1 _inst_3 n)) (MvPolynomial.esymm.{u1, u3} σ S _inst_2 _inst_3 n)
but is expected to have type
  forall (σ : Type.{u1}) (R : Type.{u3}) {S : Type.{u2}} [_inst_1 : CommSemiring.{u3} R] [_inst_2 : CommSemiring.{u2} S] [_inst_3 : Fintype.{u1} σ] (n : Nat) (f : RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : MvPolynomial.{u1, u3} σ R _inst_1) => MvPolynomial.{u1, u2} σ S _inst_2) (MvPolynomial.esymm.{u1, u3} σ R _inst_1 _inst_3 n)) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u1), max (succ u2) (succ u1)} (RingHom.{max u3 u1, max u2 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.{u1, u2} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (MvPolynomial.commSemiring.{u2, u1} S σ _inst_2)))) (MvPolynomial.{u1, u3} σ R _inst_1) (fun (_x : MvPolynomial.{u1, u3} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : MvPolynomial.{u1, u3} σ R _inst_1) => MvPolynomial.{u1, u2} σ S _inst_2) _x) (MulHomClass.toFunLike.{max (max u3 u2) u1, max u3 u1, max u2 u1} (RingHom.{max u3 u1, max u2 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.{u1, u2} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (MvPolynomial.commSemiring.{u2, u1} S σ _inst_2)))) (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.{u1, u2} σ S _inst_2) (NonUnitalNonAssocSemiring.toMul.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (MvPolynomial.commSemiring.{u2, u1} S σ _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max (max u3 u2) u1, max u3 u1, max u2 u1} (RingHom.{max u3 u1, max u2 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.{u1, u2} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (MvPolynomial.commSemiring.{u2, u1} S σ _inst_2)))) (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.{u1, u2} σ S _inst_2) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (MvPolynomial.commSemiring.{u2, u1} S σ _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max (max u3 u2) u1, max u3 u1, max u2 u1} (RingHom.{max u3 u1, max u2 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.{u1, u2} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (MvPolynomial.commSemiring.{u2, u1} S σ _inst_2)))) (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.{u1, u2} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (MvPolynomial.commSemiring.{u2, u1} S σ _inst_2))) (RingHom.instRingHomClassRingHom.{max u3 u1, max u2 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.{u1, u2} σ S _inst_2) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ S _inst_2) (MvPolynomial.commSemiring.{u2, u1} S σ _inst_2))))))) (MvPolynomial.map.{u3, u2, u1} R S σ _inst_1 _inst_2 f) (MvPolynomial.esymm.{u1, u3} σ R _inst_1 _inst_3 n)) (MvPolynomial.esymm.{u1, u2} σ S _inst_2 _inst_3 n)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.map_esymm MvPolynomial.map_esymmₓ'. -/
theorem map_esymm (n : ℕ) (f : R →+* S) : map f (esymm σ R n) = esymm σ S n := by
  simp_rw [esymm, map_sum, map_prod, map_X]
#align mv_polynomial.map_esymm MvPolynomial.map_esymm

/- warning: mv_polynomial.rename_esymm -> MvPolynomial.rename_esymm is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) (R : Type.{u2}) {τ : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_3 : Fintype.{u1} σ] [_inst_4 : Fintype.{u3} τ] (n : Nat) (e : Equiv.{succ u1, succ u3} σ τ), Eq.{max (succ u3) (succ u2)} (MvPolynomial.{u3, u2} τ R _inst_1) (coeFn.{max (succ (max u1 u2)) (succ (max u3 u2)), max (succ (max u1 u2)) (succ (max u3 u2))} (AlgHom.{u2, max u1 u2, max u3 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u3, u2} τ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u3, u2} τ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R τ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)) (MvPolynomial.algebra.{u2, u2, u3} R R τ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (fun (_x : AlgHom.{u2, max u1 u2, max u3 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u3, u2} τ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u3, u2} τ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R τ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)) (MvPolynomial.algebra.{u2, u2, u3} R R τ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) => (MvPolynomial.{u1, u2} σ R _inst_1) -> (MvPolynomial.{u3, u2} τ R _inst_1)) ([anonymous].{u2, max u1 u2, max u3 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u3, u2} τ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u3, u2} τ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R τ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)) (MvPolynomial.algebra.{u2, u2, u3} R R τ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (MvPolynomial.rename.{u1, u3, u2} σ τ R _inst_1 (coeFn.{max 1 (max (succ u1) (succ u3)) (succ u3) (succ u1), max (succ u1) (succ u3)} (Equiv.{succ u1, succ u3} σ τ) (fun (_x : Equiv.{succ u1, succ u3} σ τ) => σ -> τ) (Equiv.hasCoeToFun.{succ u1, succ u3} σ τ) e)) (MvPolynomial.esymm.{u1, u2} σ R _inst_1 _inst_3 n)) (MvPolynomial.esymm.{u3, u2} τ R _inst_1 _inst_4 n)
but is expected to have type
  forall (σ : Type.{u3}) (R : Type.{u1}) {τ : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Fintype.{u3} σ] [_inst_4 : Fintype.{u2} τ] (n : Nat) (e : Equiv.{succ u3, succ u2} σ τ), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : MvPolynomial.{u3, u1} σ R _inst_1) => MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.esymm.{u3, u1} σ R _inst_1 _inst_3 n)) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u1), max (succ u2) (succ u1)} (AlgHom.{u1, max u1 u3, max u1 u2} R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u2, u1} τ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1)) (MvPolynomial.algebra.{u1, u1, u3} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R τ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (fun (_x : MvPolynomial.{u3, u1} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : MvPolynomial.{u3, u1} σ R _inst_1) => MvPolynomial.{u2, u1} τ R _inst_1) _x) (SMulHomClass.toFunLike.{max (max u3 u2) u1, u1, max u3 u1, max u2 u1} (AlgHom.{u1, max u1 u3, max u1 u2} R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u2, u1} τ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1)) (MvPolynomial.algebra.{u1, u1, u3} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R τ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u2, u1} τ R _inst_1) (SMulZeroClass.toSMul.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (AddMonoid.toZero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (AddCommMonoid.toAddMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))))) (DistribSMul.toSMulZeroClass.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (AddMonoid.toAddZeroClass.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (AddCommMonoid.toAddMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))))) (DistribMulAction.toDistribSMul.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (AddCommMonoid.toAddMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))))) (Module.toDistribMulAction.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (Algebra.toModule.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u3} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))))))) (SMulZeroClass.toSMul.{u1, max u2 u1} R (MvPolynomial.{u2, u1} τ R _inst_1) (AddMonoid.toZero.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (AddCommMonoid.toAddMonoid.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1))))))) (DistribSMul.toSMulZeroClass.{u1, max u2 u1} R (MvPolynomial.{u2, u1} τ R _inst_1) (AddMonoid.toAddZeroClass.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (AddCommMonoid.toAddMonoid.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1))))))) (DistribMulAction.toDistribSMul.{u1, max u2 u1} R (MvPolynomial.{u2, u1} τ R _inst_1) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (AddCommMonoid.toAddMonoid.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1)))))) (Module.toDistribMulAction.{u1, max u2 u1} R (MvPolynomial.{u2, u1} τ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1))))) (Algebra.toModule.{u1, max u2 u1} R (MvPolynomial.{u2, u1} τ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R τ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u3 u2) u1, u1, max u3 u1, max u2 u1} (AlgHom.{u1, max u1 u3, max u1 u2} R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u2, u1} τ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1)) (MvPolynomial.algebra.{u1, u1, u3} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R τ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u2, u1} τ R _inst_1) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (AddCommMonoid.toAddMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))))) (AddCommMonoid.toAddMonoid.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1)))))) (Module.toDistribMulAction.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (Algebra.toModule.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u3} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)))) (Module.toDistribMulAction.{u1, max u2 u1} R (MvPolynomial.{u2, u1} τ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1))))) (Algebra.toModule.{u1, max u2 u1} R (MvPolynomial.{u2, u1} τ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R τ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)))) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max (max u3 u2) u1, u1, max u3 u1, max u2 u1} (AlgHom.{u1, max u1 u3, max u1 u2} R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u2, u1} τ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1)) (MvPolynomial.algebra.{u1, u1, u3} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R τ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u2, u1} τ R _inst_1) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1)))) (Module.toDistribMulAction.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (Algebra.toModule.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u3} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)))) (Module.toDistribMulAction.{u1, max u2 u1} R (MvPolynomial.{u2, u1} τ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1))))) (Algebra.toModule.{u1, max u2 u1} R (MvPolynomial.{u2, u1} τ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R τ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)))) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u1, max u3 u1, max u2 u1, max (max u3 u2) u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u2, u1} τ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1)) (MvPolynomial.algebra.{u1, u1, u3} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R τ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)) (AlgHom.{u1, max u1 u3, max u1 u2} R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u2, u1} τ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1)) (MvPolynomial.algebra.{u1, u1, u3} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R τ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (AlgHom.algHomClass.{u1, max u3 u1, max u2 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u2, u1} τ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} τ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R τ _inst_1)) (MvPolynomial.algebra.{u1, u1, u3} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R τ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))))))) (MvPolynomial.rename.{u3, u2, u1} σ τ R _inst_1 (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} σ τ) σ (fun (_x : σ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : σ) => τ) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} σ τ) e)) (MvPolynomial.esymm.{u3, u1} σ R _inst_1 _inst_3 n)) (MvPolynomial.esymm.{u2, u1} τ R _inst_1 _inst_4 n)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.rename_esymm MvPolynomial.rename_esymmₓ'. -/
theorem rename_esymm (n : ℕ) (e : σ ≃ τ) : rename e (esymm σ R n) = esymm τ R n :=
  calc
    rename e (esymm σ R n) = ∑ x in powersetLen n univ, ∏ i in x, X (e i) := by
      simp_rw [esymm, map_sum, map_prod, rename_X]
    _ = ∑ t in powersetLen n (univ.map e.toEmbedding), ∏ i in t, X i := by
      simp [Finset.powersetLen_map, -Finset.map_univ_equiv]
    _ = ∑ t in powersetLen n univ, ∏ i in t, X i := by rw [Finset.map_univ_equiv]
    
#align mv_polynomial.rename_esymm MvPolynomial.rename_esymm

/- warning: mv_polynomial.esymm_is_symmetric -> MvPolynomial.esymm_isSymmetric is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) (R : Type.{u2}) [_inst_1 : CommSemiring.{u2} R] [_inst_3 : Fintype.{u1} σ] (n : Nat), MvPolynomial.IsSymmetric.{u1, u2} σ R _inst_1 (MvPolynomial.esymm.{u1, u2} σ R _inst_1 _inst_3 n)
but is expected to have type
  forall (σ : Type.{u2}) (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Fintype.{u2} σ] (n : Nat), MvPolynomial.IsSymmetric.{u2, u1} σ R _inst_1 (MvPolynomial.esymm.{u2, u1} σ R _inst_1 _inst_3 n)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.esymm_is_symmetric MvPolynomial.esymm_isSymmetricₓ'. -/
theorem esymm_isSymmetric (n : ℕ) : IsSymmetric (esymm σ R n) :=
  by
  intro
  rw [rename_esymm]
#align mv_polynomial.esymm_is_symmetric MvPolynomial.esymm_isSymmetric

/- warning: mv_polynomial.support_esymm'' -> MvPolynomial.support_esymm'' is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) (R : Type.{u2}) [_inst_1 : CommSemiring.{u2} R] [_inst_3 : Fintype.{u1} σ] (n : Nat) [_inst_5 : DecidableEq.{succ u1} σ] [_inst_6 : Nontrivial.{u2} R], Eq.{succ u1} (Finset.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) (MvPolynomial.support.{u2, u1} R σ _inst_1 (MvPolynomial.esymm.{u1, u2} σ R _inst_1 _inst_3 n)) (Finset.biUnion.{u1, u1} (Finset.{u1} σ) (Finsupp.{u1, 0} σ Nat Nat.hasZero) (fun (a : Finsupp.{u1, 0} σ Nat Nat.hasZero) (b : Finsupp.{u1, 0} σ Nat Nat.hasZero) => Finsupp.decidableEq.{u1, 0} σ Nat Nat.hasZero (fun (a : σ) (b : σ) => _inst_5 a b) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) a b) (Finset.powersetLen.{u1} σ n (Finset.univ.{u1} σ _inst_3)) (fun (t : Finset.{u1} σ) => Finsupp.support.{u1, u2} (Finsupp.{u1, 0} σ Nat Nat.hasZero) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (Finsupp.single.{u1, u2} (Finsupp.{u1, 0} σ Nat Nat.hasZero) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (Finset.sum.{u1, u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) σ (Finsupp.addCommMonoid.{u1, 0} σ Nat Nat.addCommMonoid) t (fun (i : σ) => Finsupp.single.{u1, 0} σ Nat Nat.hasZero i (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (OfNat.ofNat.{u2} R 1 (OfNat.mk.{u2} R 1 (One.one.{u2} R (AddMonoidWithOne.toOne.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))))))))
but is expected to have type
  forall (σ : Type.{u2}) (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Fintype.{u2} σ] (n : Nat) [_inst_5 : DecidableEq.{succ u2} σ] [_inst_6 : Nontrivial.{u1} R], Eq.{succ u2} (Finset.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (MvPolynomial.support.{u1, u2} R σ _inst_1 (MvPolynomial.esymm.{u2, u1} σ R _inst_1 _inst_3 n)) (Finset.biUnion.{u2, u2} (Finset.{u2} σ) (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (a : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (b : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => Finsupp.decidableEq.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) (fun (a : σ) (b : σ) => _inst_5 a b) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) a b) (Finset.powersetLen.{u2} σ n (Finset.univ.{u2} σ _inst_3)) (fun (t : Finset.{u2} σ) => Finsupp.support.{u2, u1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) R (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (Finsupp.single.{u2, u1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) R (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (Finset.sum.{u2, u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) σ (Finsupp.addCommMonoid.{u2, 0} σ Nat Nat.addCommMonoid) t (fun (i : σ) => Finsupp.single.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) i (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.support_esymm'' MvPolynomial.support_esymm''ₓ'. -/
theorem support_esymm'' (n : ℕ) [DecidableEq σ] [Nontrivial R] :
    (esymm σ R n).support =
      (powersetLen n (univ : Finset σ)).biUnion fun t =>
        (Finsupp.single (∑ i : σ in t, Finsupp.single i 1) (1 : R)).support :=
  by
  rw [esymm_eq_sum_monomial]
  simp only [← single_eq_monomial]
  convert Finsupp.support_sum_eq_biUnion (powerset_len n (univ : Finset σ)) _
  intro s t hst
  rw [Finset.disjoint_left]
  simp only [Finsupp.support_single_ne_zero _ one_ne_zero, mem_singleton]
  rintro a h rfl
  have := congr_arg Finsupp.support h
  rw [Finsupp.support_sum_eq_biUnion, Finsupp.support_sum_eq_biUnion] at this
  · simp only [Finsupp.support_single_ne_zero _ one_ne_zero, bUnion_singleton_eq_self] at this
    exact absurd this hst.symm
  all_goals intro x y; simp [Finsupp.support_single_disjoint]
#align mv_polynomial.support_esymm'' MvPolynomial.support_esymm''

/- warning: mv_polynomial.support_esymm' -> MvPolynomial.support_esymm' is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) (R : Type.{u2}) [_inst_1 : CommSemiring.{u2} R] [_inst_3 : Fintype.{u1} σ] (n : Nat) [_inst_5 : DecidableEq.{succ u1} σ] [_inst_6 : Nontrivial.{u2} R], Eq.{succ u1} (Finset.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) (MvPolynomial.support.{u2, u1} R σ _inst_1 (MvPolynomial.esymm.{u1, u2} σ R _inst_1 _inst_3 n)) (Finset.biUnion.{u1, u1} (Finset.{u1} σ) (Finsupp.{u1, 0} σ Nat Nat.hasZero) (fun (a : Finsupp.{u1, 0} σ Nat Nat.hasZero) (b : Finsupp.{u1, 0} σ Nat Nat.hasZero) => Finsupp.decidableEq.{u1, 0} σ Nat Nat.hasZero (fun (a : σ) (b : σ) => _inst_5 a b) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) a b) (Finset.powersetLen.{u1} σ n (Finset.univ.{u1} σ _inst_3)) (fun (t : Finset.{u1} σ) => Singleton.singleton.{u1, u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (Finset.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) (Finset.hasSingleton.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) (Finset.sum.{u1, u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) σ (Finsupp.addCommMonoid.{u1, 0} σ Nat Nat.addCommMonoid) t (fun (i : σ) => Finsupp.single.{u1, 0} σ Nat Nat.hasZero i (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))))
but is expected to have type
  forall (σ : Type.{u2}) (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Fintype.{u2} σ] (n : Nat) [_inst_5 : DecidableEq.{succ u2} σ] [_inst_6 : Nontrivial.{u1} R], Eq.{succ u2} (Finset.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (MvPolynomial.support.{u1, u2} R σ _inst_1 (MvPolynomial.esymm.{u2, u1} σ R _inst_1 _inst_3 n)) (Finset.biUnion.{u2, u2} (Finset.{u2} σ) (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (a : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (b : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => Finsupp.decidableEq.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) (fun (a : σ) (b : σ) => _inst_5 a b) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) a b) (Finset.powersetLen.{u2} σ n (Finset.univ.{u2} σ _inst_3)) (fun (t : Finset.{u2} σ) => Singleton.singleton.{u2, u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finset.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (Finset.instSingletonFinset.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (Finset.sum.{u2, u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) σ (Finsupp.addCommMonoid.{u2, 0} σ Nat Nat.addCommMonoid) t (fun (i : σ) => Finsupp.single.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) i (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.support_esymm' MvPolynomial.support_esymm'ₓ'. -/
theorem support_esymm' (n : ℕ) [DecidableEq σ] [Nontrivial R] :
    (esymm σ R n).support =
      (powersetLen n (univ : Finset σ)).biUnion fun t => {∑ i : σ in t, Finsupp.single i 1} :=
  by
  rw [support_esymm'']
  congr
  funext
  exact Finsupp.support_single_ne_zero _ one_ne_zero
#align mv_polynomial.support_esymm' MvPolynomial.support_esymm'

/- warning: mv_polynomial.support_esymm -> MvPolynomial.support_esymm is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) (R : Type.{u2}) [_inst_1 : CommSemiring.{u2} R] [_inst_3 : Fintype.{u1} σ] (n : Nat) [_inst_5 : DecidableEq.{succ u1} σ] [_inst_6 : Nontrivial.{u2} R], Eq.{succ u1} (Finset.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) (MvPolynomial.support.{u2, u1} R σ _inst_1 (MvPolynomial.esymm.{u1, u2} σ R _inst_1 _inst_3 n)) (Finset.image.{u1, u1} (Finset.{u1} σ) (Finsupp.{u1, 0} σ Nat Nat.hasZero) (fun (a : Finsupp.{u1, 0} σ Nat Nat.hasZero) (b : Finsupp.{u1, 0} σ Nat Nat.hasZero) => Finsupp.decidableEq.{u1, 0} σ Nat Nat.hasZero (fun (a : σ) (b : σ) => _inst_5 a b) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) a b) (fun (t : Finset.{u1} σ) => Finset.sum.{u1, u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) σ (Finsupp.addCommMonoid.{u1, 0} σ Nat Nat.addCommMonoid) t (fun (i : σ) => Finsupp.single.{u1, 0} σ Nat Nat.hasZero i (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Finset.powersetLen.{u1} σ n (Finset.univ.{u1} σ _inst_3)))
but is expected to have type
  forall (σ : Type.{u2}) (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Fintype.{u2} σ] (n : Nat) [_inst_5 : DecidableEq.{succ u2} σ] [_inst_6 : Nontrivial.{u1} R], Eq.{succ u2} (Finset.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (MvPolynomial.support.{u1, u2} R σ _inst_1 (MvPolynomial.esymm.{u2, u1} σ R _inst_1 _inst_3 n)) (Finset.image.{u2, u2} (Finset.{u2} σ) (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (a : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (b : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => Finsupp.decidableEq.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) (fun (a : σ) (b : σ) => _inst_5 a b) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) a b) (fun (t : Finset.{u2} σ) => Finset.sum.{u2, u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) σ (Finsupp.addCommMonoid.{u2, 0} σ Nat Nat.addCommMonoid) t (fun (i : σ) => Finsupp.single.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) i (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Finset.powersetLen.{u2} σ n (Finset.univ.{u2} σ _inst_3)))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.support_esymm MvPolynomial.support_esymmₓ'. -/
theorem support_esymm (n : ℕ) [DecidableEq σ] [Nontrivial R] :
    (esymm σ R n).support =
      (powersetLen n (univ : Finset σ)).image fun t => ∑ i : σ in t, Finsupp.single i 1 :=
  by
  rw [support_esymm']
  exact bUnion_singleton
#align mv_polynomial.support_esymm MvPolynomial.support_esymm

#print MvPolynomial.degrees_esymm /-
theorem degrees_esymm [Nontrivial R] (n : ℕ) (hpos : 0 < n) (hn : n ≤ Fintype.card σ) :
    (esymm σ R n).degrees = (univ : Finset σ).val := by
  classical
    have :
      (Finsupp.toMultiset ∘ fun t : Finset σ => ∑ i : σ in t, Finsupp.single i 1) = Finset.val :=
      by
      funext
      simp [Finsupp.toMultiset_sum_single]
    rw [degrees_def, support_esymm, sup_image, this, ← comp_sup_eq_sup_comp]
    · obtain ⟨k, rfl⟩ := Nat.exists_eq_succ_of_ne_zero hpos.ne'
      simpa using powerset_len_sup _ _ (Nat.lt_of_succ_le hn)
    · intros
      simp only [union_val, sup_eq_union]
      congr
    · rfl
#align mv_polynomial.degrees_esymm MvPolynomial.degrees_esymm
-/

end ElementarySymmetric

end MvPolynomial

