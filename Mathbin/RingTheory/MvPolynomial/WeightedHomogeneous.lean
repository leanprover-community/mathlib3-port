/-
Copyright (c) 2022 María Inés de Frutos-Fernández. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir, María Inés de Frutos-Fernández

! This file was ported from Lean 3 source module ring_theory.mv_polynomial.weighted_homogeneous
! leanprover-community/mathlib commit 2f5b500a507264de86d666a5f87ddb976e2d8de4
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.GradedMonoid
import Mathbin.Data.MvPolynomial.Variables

/-!
# Weighted homogeneous polynomials

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

It is possible to assign weights (in a commutative additive monoid `M`) to the variables of a
multivariate polynomial ring, so that monomials of the ring then have a weighted degree with
respect to the weights of the variables. The weights are represented by a function `w : σ → M`,
where `σ` are the indeterminates.

A multivariate polynomial `φ` is weighted homogeneous of weighted degree `m : M` if all monomials
occuring in `φ` have the same weighted degree `m`.

## Main definitions/lemmas

* `weighted_total_degree' w φ` : the weighted total degree of a multivariate polynomial with respect
to the weights `w`, taking values in `with_bot M`.

* `weighted_total_degree w φ` : When `M` has a `⊥` element, we can define the weighted total degree
of a multivariate polynomial as a function taking values in `M`.

* `is_weighted_homogeneous w φ m`: a predicate that asserts that `φ` is weighted homogeneous
of weighted degree `m` with respect to the weights `w`.

* `weighted_homogeneous_submodule R w m`: the submodule of homogeneous polynomials
of weighted degree `m`.

* `weighted_homogeneous_component w m`: the additive morphism that projects polynomials
onto their summand that is weighted homogeneous of degree `n` with respect to `w`.

* `sum_weighted_homogeneous_component`: every polynomial is the sum of its weighted homogeneous
components.
-/


noncomputable section

open BigOperators

open Set Function Finset Finsupp AddMonoidAlgebra

variable {R M : Type _} [CommSemiring R]

namespace MvPolynomial

variable {σ : Type _}

section AddCommMonoid

variable [AddCommMonoid M]

/-! ### `weighted_degree'` -/


#print MvPolynomial.weightedDegree' /-
/-- The `weighted degree'` of the finitely supported function `s : σ →₀ ℕ` is the sum
  `∑(s i)•(w i)`. -/
def weightedDegree' (w : σ → M) : (σ →₀ ℕ) →+ M :=
  (Finsupp.total σ M ℕ w).toAddMonoidHom
#align mv_polynomial.weighted_degree' MvPolynomial.weightedDegree'
-/

section SemilatticeSup

variable [SemilatticeSup M]

#print MvPolynomial.weightedTotalDegree' /-
/-- The weighted total degree of a multivariate polynomial, taking values in `with_bot M`. -/
def weightedTotalDegree' (w : σ → M) (p : MvPolynomial σ R) : WithBot M :=
  p.support.sup fun s => weightedDegree' w s
#align mv_polynomial.weighted_total_degree' MvPolynomial.weightedTotalDegree'
-/

/- warning: mv_polynomial.weighted_total_degree'_eq_bot_iff -> MvPolynomial.weightedTotalDegree'_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SemilatticeSup.{u2} M] (w : σ -> M) (p : MvPolynomial.{u3, u1} σ R _inst_1), Iff (Eq.{succ u2} (WithBot.{u2} M) (MvPolynomial.weightedTotalDegree'.{u1, u2, u3} R M _inst_1 σ _inst_2 _inst_3 w p) (Bot.bot.{u2} (WithBot.{u2} M) (WithBot.hasBot.{u2} M))) (Eq.{max (succ u3) (succ u1)} (MvPolynomial.{u3, u1} σ R _inst_1) p (OfNat.ofNat.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (OfNat.mk.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (Zero.zero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MulZeroClass.toHasZero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : SemilatticeSup.{u1} M] (w : σ -> M) (p : MvPolynomial.{u3, u2} σ R _inst_1), Iff (Eq.{succ u1} (WithBot.{u1} M) (MvPolynomial.weightedTotalDegree'.{u2, u1, u3} R M _inst_1 σ _inst_2 _inst_3 w p) (Bot.bot.{u1} (WithBot.{u1} M) (WithBot.bot.{u1} M))) (Eq.{max (succ u2) (succ u3)} (MvPolynomial.{u3, u2} σ R _inst_1) p (OfNat.ofNat.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) 0 (Zero.toOfNat0.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommMonoidWithZero.toZero.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toCommMonoidWithZero.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.weighted_total_degree'_eq_bot_iff MvPolynomial.weightedTotalDegree'_eq_bot_iffₓ'. -/
/-- The `weighted_total_degree'` of a polynomial `p` is `⊥` if and only if `p = 0`. -/
theorem weightedTotalDegree'_eq_bot_iff (w : σ → M) (p : MvPolynomial σ R) :
    weightedTotalDegree' w p = ⊥ ↔ p = 0 :=
  by
  simp only [weighted_total_degree', Finset.sup_eq_bot_iff, mem_support_iff, WithBot.coe_ne_bot,
    MvPolynomial.eq_zero_iff]
  exact forall_congr' fun _ => Classical.not_not
#align mv_polynomial.weighted_total_degree'_eq_bot_iff MvPolynomial.weightedTotalDegree'_eq_bot_iff

/- warning: mv_polynomial.weighted_total_degree'_zero -> MvPolynomial.weightedTotalDegree'_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SemilatticeSup.{u2} M] (w : σ -> M), Eq.{succ u2} (WithBot.{u2} M) (MvPolynomial.weightedTotalDegree'.{u1, u2, u3} R M _inst_1 σ _inst_2 _inst_3 w (OfNat.ofNat.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (OfNat.mk.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (Zero.zero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MulZeroClass.toHasZero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))))))))) (Bot.bot.{u2} (WithBot.{u2} M) (WithBot.hasBot.{u2} M))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] {σ : Type.{u1}} [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : SemilatticeSup.{u3} M] (w : σ -> M), Eq.{succ u3} (WithBot.{u3} M) (MvPolynomial.weightedTotalDegree'.{u2, u3, u1} R M _inst_1 σ _inst_2 _inst_3 w (OfNat.ofNat.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommMonoidWithZero.toZero.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toCommMonoidWithZero.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))) (Bot.bot.{u3} (WithBot.{u3} M) (WithBot.bot.{u3} M))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.weighted_total_degree'_zero MvPolynomial.weightedTotalDegree'_zeroₓ'. -/
/-- The `weighted_total_degree'` of the zero polynomial is `⊥`. -/
theorem weightedTotalDegree'_zero (w : σ → M) : weightedTotalDegree' w (0 : MvPolynomial σ R) = ⊥ :=
  by simp only [weighted_total_degree', support_zero, Finset.sup_empty]
#align mv_polynomial.weighted_total_degree'_zero MvPolynomial.weightedTotalDegree'_zero

section OrderBot

variable [OrderBot M]

/- warning: mv_polynomial.weighted_total_degree -> MvPolynomial.weightedTotalDegree is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SemilatticeSup.{u2} M] [_inst_4 : OrderBot.{u2} M (Preorder.toHasLe.{u2} M (PartialOrder.toPreorder.{u2} M (SemilatticeSup.toPartialOrder.{u2} M _inst_3)))], (σ -> M) -> (MvPolynomial.{u3, u1} σ R _inst_1) -> M
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SemilatticeSup.{u2} M] [_inst_4 : OrderBot.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (SemilatticeSup.toPartialOrder.{u2} M _inst_3)))], (σ -> M) -> (MvPolynomial.{u3, u1} σ R _inst_1) -> M
Case conversion may be inaccurate. Consider using '#align mv_polynomial.weighted_total_degree MvPolynomial.weightedTotalDegreeₓ'. -/
/-- When `M` has a `⊥` element, we can define the weighted total degree of a multivariate
  polynomial as a function taking values in `M`. -/
def weightedTotalDegree (w : σ → M) (p : MvPolynomial σ R) : M :=
  p.support.sup fun s => weightedDegree' w s
#align mv_polynomial.weighted_total_degree MvPolynomial.weightedTotalDegree

/- warning: mv_polynomial.weighted_total_degree_coe -> MvPolynomial.weightedTotalDegree_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SemilatticeSup.{u2} M] [_inst_4 : OrderBot.{u2} M (Preorder.toHasLe.{u2} M (PartialOrder.toPreorder.{u2} M (SemilatticeSup.toPartialOrder.{u2} M _inst_3)))] (w : σ -> M) (p : MvPolynomial.{u3, u1} σ R _inst_1), (Ne.{max (succ u3) (succ u1)} (MvPolynomial.{u3, u1} σ R _inst_1) p (OfNat.ofNat.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (OfNat.mk.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (Zero.zero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MulZeroClass.toHasZero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))))))))) -> (Eq.{succ u2} (WithBot.{u2} M) (MvPolynomial.weightedTotalDegree'.{u1, u2, u3} R M _inst_1 σ _inst_2 _inst_3 w p) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) M (WithBot.{u2} M) (HasLiftT.mk.{succ u2, succ u2} M (WithBot.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} M (WithBot.{u2} M) (WithBot.hasCoeT.{u2} M))) (MvPolynomial.weightedTotalDegree.{u1, u2, u3} R M _inst_1 σ _inst_2 _inst_3 _inst_4 w p)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : SemilatticeSup.{u1} M] [_inst_4 : OrderBot.{u1} M (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (SemilatticeSup.toPartialOrder.{u1} M _inst_3)))] (w : σ -> M) (p : MvPolynomial.{u3, u2} σ R _inst_1), (Ne.{max (succ u2) (succ u3)} (MvPolynomial.{u3, u2} σ R _inst_1) p (OfNat.ofNat.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) 0 (Zero.toOfNat0.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommMonoidWithZero.toZero.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toCommMonoidWithZero.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))))) -> (Eq.{succ u1} (WithBot.{u1} M) (MvPolynomial.weightedTotalDegree'.{u2, u1, u3} R M _inst_1 σ _inst_2 _inst_3 w p) (WithBot.some.{u1} M (MvPolynomial.weightedTotalDegree.{u2, u1, u3} R M _inst_1 σ _inst_2 _inst_3 _inst_4 w p)))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.weighted_total_degree_coe MvPolynomial.weightedTotalDegree_coeₓ'. -/
/-- This lemma relates `weighted_total_degree` and `weighted_total_degree'`. -/
theorem weightedTotalDegree_coe (w : σ → M) (p : MvPolynomial σ R) (hp : p ≠ 0) :
    weightedTotalDegree' w p = ↑(weightedTotalDegree w p) :=
  by
  rw [Ne.def, ← weighted_total_degree'_eq_bot_iff w p, ← Ne.def, WithBot.ne_bot_iff_exists] at hp
  obtain ⟨m, hm⟩ := hp
  apply le_antisymm
  · simp only [weighted_total_degree, weighted_total_degree', Finset.sup_le_iff, WithBot.coe_le_coe]
    intro b
    exact Finset.le_sup
  · simp only [weighted_total_degree]
    have hm' : weighted_total_degree' w p ≤ m := le_of_eq hm.symm
    rw [← hm]
    simpa [weighted_total_degree'] using hm'
#align mv_polynomial.weighted_total_degree_coe MvPolynomial.weightedTotalDegree_coe

/- warning: mv_polynomial.weighted_total_degree_zero -> MvPolynomial.weightedTotalDegree_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SemilatticeSup.{u2} M] [_inst_4 : OrderBot.{u2} M (Preorder.toHasLe.{u2} M (PartialOrder.toPreorder.{u2} M (SemilatticeSup.toPartialOrder.{u2} M _inst_3)))] (w : σ -> M), Eq.{succ u2} M (MvPolynomial.weightedTotalDegree.{u1, u2, u3} R M _inst_1 σ _inst_2 _inst_3 _inst_4 w (OfNat.ofNat.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (OfNat.mk.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (Zero.zero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MulZeroClass.toHasZero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))))))))) (Bot.bot.{u2} M (OrderBot.toHasBot.{u2} M (Preorder.toHasLe.{u2} M (PartialOrder.toPreorder.{u2} M (SemilatticeSup.toPartialOrder.{u2} M _inst_3))) _inst_4))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] {σ : Type.{u1}} [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : SemilatticeSup.{u3} M] [_inst_4 : OrderBot.{u3} M (Preorder.toLE.{u3} M (PartialOrder.toPreorder.{u3} M (SemilatticeSup.toPartialOrder.{u3} M _inst_3)))] (w : σ -> M), Eq.{succ u3} M (MvPolynomial.weightedTotalDegree.{u2, u3, u1} R M _inst_1 σ _inst_2 _inst_3 _inst_4 w (OfNat.ofNat.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommMonoidWithZero.toZero.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toCommMonoidWithZero.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))) (Bot.bot.{u3} M (OrderBot.toBot.{u3} M (Preorder.toLE.{u3} M (PartialOrder.toPreorder.{u3} M (SemilatticeSup.toPartialOrder.{u3} M _inst_3))) _inst_4))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.weighted_total_degree_zero MvPolynomial.weightedTotalDegree_zeroₓ'. -/
/-- The `weighted_total_degree` of the zero polynomial is `⊥`. -/
theorem weightedTotalDegree_zero (w : σ → M) : weightedTotalDegree w (0 : MvPolynomial σ R) = ⊥ :=
  by simp only [weighted_total_degree, support_zero, Finset.sup_empty]
#align mv_polynomial.weighted_total_degree_zero MvPolynomial.weightedTotalDegree_zero

/- warning: mv_polynomial.le_weighted_total_degree -> MvPolynomial.le_weightedTotalDegree is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SemilatticeSup.{u2} M] [_inst_4 : OrderBot.{u2} M (Preorder.toHasLe.{u2} M (PartialOrder.toPreorder.{u2} M (SemilatticeSup.toPartialOrder.{u2} M _inst_3)))] (w : σ -> M) {φ : MvPolynomial.{u3, u1} σ R _inst_1} {d : Finsupp.{u3, 0} σ Nat Nat.hasZero}, (Membership.Mem.{u3, u3} (Finsupp.{u3, 0} σ Nat Nat.hasZero) (Finset.{u3} (Finsupp.{u3, 0} σ Nat Nat.hasZero)) (Finset.hasMem.{u3} (Finsupp.{u3, 0} σ Nat Nat.hasZero)) d (MvPolynomial.support.{u1, u3} R σ _inst_1 φ)) -> (LE.le.{u2} M (Preorder.toHasLe.{u2} M (PartialOrder.toPreorder.{u2} M (SemilatticeSup.toPartialOrder.{u2} M _inst_3))) (coeFn.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (fun (_x : AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) => (Finsupp.{u3, 0} σ Nat Nat.hasZero) -> M) (AddMonoidHom.hasCoeToFun.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MvPolynomial.weightedDegree'.{u2, u3} M σ _inst_2 w) d) (MvPolynomial.weightedTotalDegree.{u1, u2, u3} R M _inst_1 σ _inst_2 _inst_3 _inst_4 w φ))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : SemilatticeSup.{u1} M] [_inst_4 : OrderBot.{u1} M (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (SemilatticeSup.toPartialOrder.{u1} M _inst_3)))] (w : σ -> M) {φ : MvPolynomial.{u3, u2} σ R _inst_1} {d : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)}, (Membership.mem.{u3, u3} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finset.{u3} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (Finset.instMembershipFinset.{u3} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) d (MvPolynomial.support.{u2, u3} R σ _inst_1 φ)) -> (LE.le.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) d) (Preorder.toLE.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) d) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) d) (SemilatticeSup.toPartialOrder.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) d) _inst_3))) (FunLike.coe.{max (succ u1) (succ u3), succ u3, succ u1} (AddMonoidHom.{u3, u1} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (_x : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) _x) (AddHomClass.toFunLike.{max u1 u3, u3, u1} (AddMonoidHom.{u3, u1} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (AddZeroClass.toAdd.{u3} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u1 u3, u3, u1} (AddMonoidHom.{u3, u1} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (AddMonoidHom.addMonoidHomClass.{u3, u1} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (MvPolynomial.weightedDegree'.{u1, u3} M σ _inst_2 w) d) (MvPolynomial.weightedTotalDegree.{u2, u1, u3} R M _inst_1 σ _inst_2 _inst_3 _inst_4 w φ))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.le_weighted_total_degree MvPolynomial.le_weightedTotalDegreeₓ'. -/
theorem le_weightedTotalDegree (w : σ → M) {φ : MvPolynomial σ R} {d : σ →₀ ℕ}
    (hd : d ∈ φ.support) : weightedDegree' w d ≤ φ.weightedTotalDegree w :=
  le_sup hd
#align mv_polynomial.le_weighted_total_degree MvPolynomial.le_weightedTotalDegree

end OrderBot

end SemilatticeSup

#print MvPolynomial.IsWeightedHomogeneous /-
/-- A multivariate polynomial `φ` is weighted homogeneous of weighted degree `m` if all monomials
  occuring in `φ` have weighted degree `m`. -/
def IsWeightedHomogeneous (w : σ → M) (φ : MvPolynomial σ R) (m : M) : Prop :=
  ∀ ⦃d⦄, coeff d φ ≠ 0 → weightedDegree' w d = m
#align mv_polynomial.is_weighted_homogeneous MvPolynomial.IsWeightedHomogeneous
-/

variable (R)

#print MvPolynomial.weightedHomogeneousSubmodule /-
/-- The submodule of homogeneous `mv_polynomial`s of degree `n`. -/
def weightedHomogeneousSubmodule (w : σ → M) (m : M) : Submodule R (MvPolynomial σ R)
    where
  carrier := { x | x.IsWeightedHomogeneous w m }
  smul_mem' r a ha c hc := by
    rw [coeff_smul] at hc
    exact ha (right_ne_zero_of_mul hc)
  zero_mem' d hd := False.elim (hd <| coeff_zero _)
  add_mem' a b ha hb c hc := by
    rw [coeff_add] at hc
    obtain h | h : coeff c a ≠ 0 ∨ coeff c b ≠ 0 :=
      by
      contrapose! hc
      simp only [hc, add_zero]
    · exact ha h
    · exact hb h
#align mv_polynomial.weighted_homogeneous_submodule MvPolynomial.weightedHomogeneousSubmodule
-/

/- warning: mv_polynomial.mem_weighted_homogeneous_submodule -> MvPolynomial.mem_weightedHomogeneousSubmodule is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] (w : σ -> M) (m : M) (p : MvPolynomial.{u3, u1} σ R _inst_1), Iff (Membership.Mem.{max u3 u1, max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Submodule.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{max u3 u1, max u3 u1} (Submodule.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.{u3, u1} σ R _inst_1) (Submodule.setLike.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) p (MvPolynomial.weightedHomogeneousSubmodule.{u1, u2, u3} R M _inst_1 σ _inst_2 w m)) (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w p m)
but is expected to have type
  forall (R : Type.{u2}) {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u1} M] (w : σ -> M) (m : M) (p : MvPolynomial.{u3, u2} σ R _inst_1), Iff (Membership.mem.{max u2 u3, max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Submodule.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{max u2 u3, max u2 u3} (Submodule.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.{u3, u2} σ R _inst_1) (Submodule.setLike.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) p (MvPolynomial.weightedHomogeneousSubmodule.{u2, u1, u3} R M _inst_1 σ _inst_2 w m)) (MvPolynomial.IsWeightedHomogeneous.{u2, u1, u3} R M _inst_1 σ _inst_2 w p m)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.mem_weighted_homogeneous_submodule MvPolynomial.mem_weightedHomogeneousSubmoduleₓ'. -/
@[simp]
theorem mem_weightedHomogeneousSubmodule (w : σ → M) (m : M) (p : MvPolynomial σ R) :
    p ∈ weightedHomogeneousSubmodule R w m ↔ p.IsWeightedHomogeneous w m :=
  Iff.rfl
#align mv_polynomial.mem_weighted_homogeneous_submodule MvPolynomial.mem_weightedHomogeneousSubmodule

variable (R)

/- warning: mv_polynomial.weighted_homogeneous_submodule_eq_finsupp_supported -> MvPolynomial.weightedHomogeneousSubmodule_eq_finsupp_supported is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] (w : σ -> M) (m : M), Eq.{succ (max u3 u1)} (Submodule.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.weightedHomogeneousSubmodule.{u1, u2, u3} R M _inst_1 σ _inst_2 w m) (Finsupp.supported.{u3, u1, u1} (Finsupp.{u3, 0} σ Nat Nat.hasZero) R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (setOf.{u3} (Finsupp.{u3, 0} σ Nat Nat.hasZero) (fun (d : Finsupp.{u3, 0} σ Nat Nat.hasZero) => Eq.{succ u2} M (coeFn.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (fun (_x : AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) => (Finsupp.{u3, 0} σ Nat Nat.hasZero) -> M) (AddMonoidHom.hasCoeToFun.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MvPolynomial.weightedDegree'.{u2, u3} M σ _inst_2 w) d) m)))
but is expected to have type
  forall (R : Type.{u3}) {M : Type.{u1}} [_inst_1 : CommSemiring.{u3} R] {σ : Type.{u2}} [_inst_2 : AddCommMonoid.{u1} M] (w : σ -> M) (m : M), Eq.{max (succ u3) (succ u2)} (Submodule.{u3, max u3 u2} R (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (MvPolynomial.weightedHomogeneousSubmodule.{u3, u1, u2} R M _inst_1 σ _inst_2 w m) (Finsupp.supported.{u2, u3, u3} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) R R (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (setOf.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (d : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) d) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (AddMonoidHom.{u2, u1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (_x : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) _x) (AddHomClass.toFunLike.{max u1 u2, u2, u1} (AddMonoidHom.{u2, u1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (AddZeroClass.toAdd.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, u1} (AddMonoidHom.{u2, u1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (AddMonoidHom.addMonoidHomClass.{u2, u1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (MvPolynomial.weightedDegree'.{u1, u2} M σ _inst_2 w) d) m)))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.weighted_homogeneous_submodule_eq_finsupp_supported MvPolynomial.weightedHomogeneousSubmodule_eq_finsupp_supportedₓ'. -/
/-- The submodule ` weighted_homogeneous_submodule R w m` of homogeneous `mv_polynomial`s of
  degree `n` is equal to the `R`-submodule of all `p : (σ →₀ ℕ) →₀ R` such that
  `p.support ⊆ {d | weighted_degree' w d = m}`. While equal, the former has a
  convenient definitional reduction. -/
theorem weightedHomogeneousSubmodule_eq_finsupp_supported (w : σ → M) (m : M) :
    weightedHomogeneousSubmodule R w m = Finsupp.supported _ R { d | weightedDegree' w d = m } :=
  by
  ext
  simp only [mem_supported, Set.subset_def, Finsupp.mem_support_iff, mem_coe]
  rfl
#align mv_polynomial.weighted_homogeneous_submodule_eq_finsupp_supported MvPolynomial.weightedHomogeneousSubmodule_eq_finsupp_supported

variable {R}

/- warning: mv_polynomial.weighted_homogeneous_submodule_mul -> MvPolynomial.weightedHomogeneousSubmodule_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] (w : σ -> M) (m : M) (n : M), LE.le.{max u3 u1} (Submodule.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Preorder.toHasLe.{max u3 u1} (Submodule.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (PartialOrder.toPreorder.{max u3 u1} (Submodule.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (SetLike.partialOrder.{max u3 u1, max u3 u1} (Submodule.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.{u3, u1} σ R _inst_1) (Submodule.setLike.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (HMul.hMul.{max u3 u1, max u3 u1, max u3 u1} (Submodule.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Submodule.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Submodule.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (instHMul.{max u3 u1} (Submodule.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Submodule.mul.{u1, max u3 u1} R _inst_1 (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u3} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)))) (MvPolynomial.weightedHomogeneousSubmodule.{u1, u2, u3} R M _inst_1 σ _inst_2 w m) (MvPolynomial.weightedHomogeneousSubmodule.{u1, u2, u3} R M _inst_1 σ _inst_2 w n)) (MvPolynomial.weightedHomogeneousSubmodule.{u1, u2, u3} R M _inst_1 σ _inst_2 w (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) m n))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u3} R] {σ : Type.{u2}} [_inst_2 : AddCommMonoid.{u1} M] (w : σ -> M) (m : M) (n : M), LE.le.{max u3 u2} (Submodule.{u3, max u3 u2} R (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (Preorder.toLE.{max u3 u2} (Submodule.{u3, max u3 u2} R (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (PartialOrder.toPreorder.{max u3 u2} (Submodule.{u3, max u3 u2} R (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (OmegaCompletePartialOrder.toPartialOrder.{max u3 u2} (Submodule.{u3, max u3 u2} R (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (CompleteLattice.instOmegaCompletePartialOrder.{max u3 u2} (Submodule.{u3, max u3 u2} R (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (Submodule.completeLattice.{u3, max u3 u2} R (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))))))) (HMul.hMul.{max u3 u2, max u3 u2, max u3 u2} (Submodule.{u3, max u3 u2} R (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (Submodule.{u3, max u3 u2} R (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (Submodule.{u3, max u3 u2} R (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (instHMul.{max u3 u2} (Submodule.{u3, max u3 u2} R (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (Submodule.mul.{u3, max u3 u2} R _inst_1 (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1)) (MvPolynomial.algebra.{u3, u3, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u3} R _inst_1)))) (MvPolynomial.weightedHomogeneousSubmodule.{u3, u1, u2} R M _inst_1 σ _inst_2 w m) (MvPolynomial.weightedHomogeneousSubmodule.{u3, u1, u2} R M _inst_1 σ _inst_2 w n)) (MvPolynomial.weightedHomogeneousSubmodule.{u3, u1, u2} R M _inst_1 σ _inst_2 w (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))) m n))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.weighted_homogeneous_submodule_mul MvPolynomial.weightedHomogeneousSubmodule_mulₓ'. -/
/-- The submodule generated by products `Pm *Pn` of weighted homogeneous polynomials of degrees `m`
  and `n` is contained in the submodule of weighted homogeneous polynomials of degree `m + n`. -/
theorem weightedHomogeneousSubmodule_mul (w : σ → M) (m n : M) :
    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n ≤
      weightedHomogeneousSubmodule R w (m + n) :=
  by
  rw [Submodule.mul_le]
  intro φ hφ ψ hψ c hc
  rw [coeff_mul] at hc
  obtain ⟨⟨d, e⟩, hde, H⟩ := Finset.exists_ne_zero_of_sum_ne_zero hc
  have aux : coeff d φ ≠ 0 ∧ coeff e ψ ≠ 0 :=
    by
    contrapose! H
    by_cases h : coeff d φ = 0 <;>
      simp_all only [Ne.def, not_false_iff, MulZeroClass.zero_mul, MulZeroClass.mul_zero]
  rw [← finsupp.mem_antidiagonal.mp hde, ← hφ aux.1, ← hψ aux.2, map_add]
#align mv_polynomial.weighted_homogeneous_submodule_mul MvPolynomial.weightedHomogeneousSubmodule_mul

/- warning: mv_polynomial.is_weighted_homogeneous_monomial -> MvPolynomial.isWeightedHomogeneous_monomial is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] (w : σ -> M) (d : Finsupp.{u3, 0} σ Nat Nat.hasZero) (r : R) {m : M}, (Eq.{succ u2} M (coeFn.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (fun (_x : AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) => (Finsupp.{u3, 0} σ Nat Nat.hasZero) -> M) (AddMonoidHom.hasCoeToFun.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MvPolynomial.weightedDegree'.{u2, u3} M σ _inst_2 w) d) m) -> (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w (coeFn.{max (succ u1) (succ (max u3 u1)), max (succ u1) (succ (max u3 u1))} (LinearMap.{u1, u1, u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (fun (_x : LinearMap.{u1, u1, u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) => R -> (MvPolynomial.{u3, u1} σ R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, u1, max u3 u1} R R R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.monomial.{u1, u3} R σ _inst_1 d) r) m)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] (w : σ -> M) (d : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (r : R) {m : M}, (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) d) (FunLike.coe.{max (succ u2) (succ u3), succ u3, succ u2} (AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (_x : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) _x) (AddHomClass.toFunLike.{max u2 u3, u3, u2} (AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (AddZeroClass.toAdd.{u3} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u3, u2} (AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoidHom.addMonoidHomClass.{u3, u2} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) (MvPolynomial.weightedDegree'.{u2, u3} M σ _inst_2 w) d) m) -> (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w (FunLike.coe.{max (succ u3) (succ u1), succ u1, max (succ u3) (succ u1)} (LinearMap.{u1, u1, u1, max u1 u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u3} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : R) => MvPolynomial.{u3, u1} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, max u3 u1} R R R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u3} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.monomial.{u1, u3} R σ _inst_1 d) r) m)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_weighted_homogeneous_monomial MvPolynomial.isWeightedHomogeneous_monomialₓ'. -/
/-- Monomials are weighted homogeneous. -/
theorem isWeightedHomogeneous_monomial (w : σ → M) (d : σ →₀ ℕ) (r : R) {m : M}
    (hm : weightedDegree' w d = m) : IsWeightedHomogeneous w (monomial d r) m := by
  classical
    intro c hc
    rw [coeff_monomial] at hc
    split_ifs  at hc with h
    · subst c
      exact hm
    · contradiction
#align mv_polynomial.is_weighted_homogeneous_monomial MvPolynomial.isWeightedHomogeneous_monomial

/- warning: mv_polynomial.is_weighted_homogeneous_of_total_degree_zero -> MvPolynomial.isWeightedHomogeneous_of_total_degree_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SemilatticeSup.{u2} M] [_inst_4 : OrderBot.{u2} M (Preorder.toHasLe.{u2} M (PartialOrder.toPreorder.{u2} M (SemilatticeSup.toPartialOrder.{u2} M _inst_3)))] (w : σ -> M) {p : MvPolynomial.{u3, u1} σ R _inst_1}, (Eq.{succ u2} M (MvPolynomial.weightedTotalDegree.{u1, u2, u3} R M _inst_1 σ _inst_2 _inst_3 _inst_4 w p) (Bot.bot.{u2} M (OrderBot.toHasBot.{u2} M (Preorder.toHasLe.{u2} M (PartialOrder.toPreorder.{u2} M (SemilatticeSup.toPartialOrder.{u2} M _inst_3))) _inst_4))) -> (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w p (Bot.bot.{u2} M (OrderBot.toHasBot.{u2} M (Preorder.toHasLe.{u2} M (PartialOrder.toPreorder.{u2} M (SemilatticeSup.toPartialOrder.{u2} M _inst_3))) _inst_4)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u3}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u2}} [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : SemilatticeSup.{u3} M] [_inst_4 : OrderBot.{u3} M (Preorder.toLE.{u3} M (PartialOrder.toPreorder.{u3} M (SemilatticeSup.toPartialOrder.{u3} M _inst_3)))] (w : σ -> M) {p : MvPolynomial.{u2, u1} σ R _inst_1}, (Eq.{succ u3} M (MvPolynomial.weightedTotalDegree.{u1, u3, u2} R M _inst_1 σ _inst_2 _inst_3 _inst_4 w p) (Bot.bot.{u3} M (OrderBot.toBot.{u3} M (Preorder.toLE.{u3} M (PartialOrder.toPreorder.{u3} M (SemilatticeSup.toPartialOrder.{u3} M _inst_3))) _inst_4))) -> (MvPolynomial.IsWeightedHomogeneous.{u1, u3, u2} R M _inst_1 σ _inst_2 w p (Bot.bot.{u3} M (OrderBot.toBot.{u3} M (Preorder.toLE.{u3} M (PartialOrder.toPreorder.{u3} M (SemilatticeSup.toPartialOrder.{u3} M _inst_3))) _inst_4)))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_weighted_homogeneous_of_total_degree_zero MvPolynomial.isWeightedHomogeneous_of_total_degree_zeroₓ'. -/
/-- A polynomial of weighted_total_degree `⊥` is weighted_homogeneous of degree `⊥`. -/
theorem isWeightedHomogeneous_of_total_degree_zero [SemilatticeSup M] [OrderBot M] (w : σ → M)
    {p : MvPolynomial σ R} (hp : weightedTotalDegree w p = (⊥ : M)) :
    IsWeightedHomogeneous w p (⊥ : M) := by
  intro d hd
  have h := weighted_total_degree_coe w p (mv_polynomial.ne_zero_iff.mpr ⟨d, hd⟩)
  simp only [weighted_total_degree', hp] at h
  rw [eq_bot_iff, ← WithBot.coe_le_coe, ← h]
  exact Finset.le_sup (mem_support_iff.mpr hd)
#align mv_polynomial.is_weighted_homogeneous_of_total_degree_zero MvPolynomial.isWeightedHomogeneous_of_total_degree_zero

/- warning: mv_polynomial.is_weighted_homogeneous_C -> MvPolynomial.isWeightedHomogeneous_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] (w : σ -> M) (r : R), MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w (coeFn.{max (succ u1) (succ (max u3 u1)), max (succ u1) (succ (max u3 u1))} (RingHom.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))) (fun (_x : RingHom.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))) => R -> (MvPolynomial.{u3, u1} σ R _inst_1)) (RingHom.hasCoeToFun.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))) (MvPolynomial.C.{u1, u3} R σ _inst_1) r) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u3} R] {σ : Type.{u1}} [_inst_2 : AddCommMonoid.{u2} M] (w : σ -> M) (r : R), MvPolynomial.IsWeightedHomogeneous.{u3, u2, u1} R M _inst_1 σ _inst_2 w (FunLike.coe.{max (succ u1) (succ u3), succ u3, max (succ u1) (succ u3)} (RingHom.{u3, max u3 u1} R (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u3} σ R _inst_1) _x) (MulHomClass.toFunLike.{max u1 u3, u3, max u1 u3} (RingHom.{u3, max u3 u1} R (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u3} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u3, max u1 u3} (RingHom.{u3, max u3 u1} R (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u3, u3, max u1 u3} (RingHom.{u3, max u3 u1} R (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))) (RingHom.instRingHomClassRingHom.{u3, max u1 u3} R (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))))))) (MvPolynomial.C.{u3, u1} R σ _inst_1) r) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_weighted_homogeneous_C MvPolynomial.isWeightedHomogeneous_Cₓ'. -/
/-- Constant polynomials are weighted homogeneous of degree 0. -/
theorem isWeightedHomogeneous_C (w : σ → M) (r : R) :
    IsWeightedHomogeneous w (C r : MvPolynomial σ R) 0 :=
  isWeightedHomogeneous_monomial _ _ _ (map_zero _)
#align mv_polynomial.is_weighted_homogeneous_C MvPolynomial.isWeightedHomogeneous_C

variable (R)

/- warning: mv_polynomial.is_weighted_homogeneous_zero -> MvPolynomial.isWeightedHomogeneous_zero is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] (w : σ -> M) (m : M), MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w (OfNat.ofNat.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (OfNat.mk.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (Zero.zero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MulZeroClass.toHasZero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))))))) m
but is expected to have type
  forall (R : Type.{u3}) {M : Type.{u2}} [_inst_1 : CommSemiring.{u3} R] {σ : Type.{u1}} [_inst_2 : AddCommMonoid.{u2} M] (w : σ -> M) (m : M), MvPolynomial.IsWeightedHomogeneous.{u3, u2, u1} R M _inst_1 σ _inst_2 w (OfNat.ofNat.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) 0 (Zero.toOfNat0.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommMonoidWithZero.toZero.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toCommMonoidWithZero.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))))) m
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_weighted_homogeneous_zero MvPolynomial.isWeightedHomogeneous_zeroₓ'. -/
/-- 0 is weighted homogeneous of any degree. -/
theorem isWeightedHomogeneous_zero (w : σ → M) (m : M) :
    IsWeightedHomogeneous w (0 : MvPolynomial σ R) m :=
  (weightedHomogeneousSubmodule R w m).zero_mem
#align mv_polynomial.is_weighted_homogeneous_zero MvPolynomial.isWeightedHomogeneous_zero

/- warning: mv_polynomial.is_weighted_homogeneous_one -> MvPolynomial.isWeightedHomogeneous_one is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] (w : σ -> M), MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w (OfNat.ofNat.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 1 (OfNat.mk.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 1 (One.one.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (AddMonoidWithOne.toOne.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))))))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))
but is expected to have type
  forall (R : Type.{u3}) {M : Type.{u2}} [_inst_1 : CommSemiring.{u3} R] {σ : Type.{u1}} [_inst_2 : AddCommMonoid.{u2} M] (w : σ -> M), MvPolynomial.IsWeightedHomogeneous.{u3, u2, u1} R M _inst_1 σ _inst_2 w (OfNat.ofNat.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) 1 (One.toOfNat1.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toOne.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))))) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_weighted_homogeneous_one MvPolynomial.isWeightedHomogeneous_oneₓ'. -/
/-- 1 is weighted homogeneous of degree 0. -/
theorem isWeightedHomogeneous_one (w : σ → M) : IsWeightedHomogeneous w (1 : MvPolynomial σ R) 0 :=
  isWeightedHomogeneous_C _ _
#align mv_polynomial.is_weighted_homogeneous_one MvPolynomial.isWeightedHomogeneous_one

/- warning: mv_polynomial.is_weighted_homogeneous_X -> MvPolynomial.isWeightedHomogeneous_X is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] (w : σ -> M) (i : σ), MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w (MvPolynomial.X.{u1, u3} R σ _inst_1 i) (w i)
but is expected to have type
  forall (R : Type.{u3}) {M : Type.{u2}} [_inst_1 : CommSemiring.{u3} R] {σ : Type.{u1}} [_inst_2 : AddCommMonoid.{u2} M] (w : σ -> M) (i : σ), MvPolynomial.IsWeightedHomogeneous.{u3, u2, u1} R M _inst_1 σ _inst_2 w (MvPolynomial.X.{u3, u1} R σ _inst_1 i) (w i)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_weighted_homogeneous_X MvPolynomial.isWeightedHomogeneous_Xₓ'. -/
/-- An indeterminate `i : σ` is weighted homogeneous of degree `w i`. -/
theorem isWeightedHomogeneous_X (w : σ → M) (i : σ) :
    IsWeightedHomogeneous w (X i : MvPolynomial σ R) (w i) :=
  by
  apply is_weighted_homogeneous_monomial
  simp only [weighted_degree', LinearMap.toAddMonoidHom_coe, total_single, one_nsmul]
#align mv_polynomial.is_weighted_homogeneous_X MvPolynomial.isWeightedHomogeneous_X

namespace IsWeightedHomogeneous

variable {R} {φ ψ : MvPolynomial σ R} {m n : M}

/- warning: mv_polynomial.is_weighted_homogeneous.coeff_eq_zero -> MvPolynomial.IsWeightedHomogeneous.coeff_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] {φ : MvPolynomial.{u3, u1} σ R _inst_1} {n : M} {w : σ -> M}, (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w φ n) -> (forall (d : Finsupp.{u3, 0} σ Nat Nat.hasZero), (Ne.{succ u2} M (coeFn.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (fun (_x : AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) => (Finsupp.{u3, 0} σ Nat Nat.hasZero) -> M) (AddMonoidHom.hasCoeToFun.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MvPolynomial.weightedDegree'.{u2, u3} M σ _inst_2 w) d) n) -> (Eq.{succ u1} R (MvPolynomial.coeff.{u1, u3} R σ _inst_1 d φ) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))))))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u3} R] {σ : Type.{u1}} [_inst_2 : AddCommMonoid.{u2} M] {φ : MvPolynomial.{u1, u3} σ R _inst_1} {n : M} {w : σ -> M}, (MvPolynomial.IsWeightedHomogeneous.{u3, u2, u1} R M _inst_1 σ _inst_2 w φ n) -> (forall (d : Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)), (Ne.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) d) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (AddMonoidHom.{u1, u2} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u1, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (_x : Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) _x) (AddHomClass.toFunLike.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u1, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (AddZeroClass.toAdd.{u1} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.addZeroClass.{u1, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u1, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u1, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (AddMonoidHom.addMonoidHomClass.{u1, u2} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u1, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) (MvPolynomial.weightedDegree'.{u2, u1} M σ _inst_2 w) d) n) -> (Eq.{succ u3} R (MvPolynomial.coeff.{u3, u1} R σ _inst_1 d φ) (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R _inst_1))))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_weighted_homogeneous.coeff_eq_zero MvPolynomial.IsWeightedHomogeneous.coeff_eq_zeroₓ'. -/
/-- The weighted degree of a weighted homogeneous polynomial controls its support. -/
theorem coeff_eq_zero {w : σ → M} (hφ : IsWeightedHomogeneous w φ n) (d : σ →₀ ℕ)
    (hd : weightedDegree' w d ≠ n) : coeff d φ = 0 :=
  by
  have aux := mt (@hφ d) hd
  rwa [Classical.not_not] at aux
#align mv_polynomial.is_weighted_homogeneous.coeff_eq_zero MvPolynomial.IsWeightedHomogeneous.coeff_eq_zero

/- warning: mv_polynomial.is_weighted_homogeneous.inj_right -> MvPolynomial.IsWeightedHomogeneous.inj_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] {φ : MvPolynomial.{u3, u1} σ R _inst_1} {m : M} {n : M} {w : σ -> M}, (Ne.{max (succ u3) (succ u1)} (MvPolynomial.{u3, u1} σ R _inst_1) φ (OfNat.ofNat.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (OfNat.mk.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (Zero.zero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MulZeroClass.toHasZero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))))))))) -> (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w φ m) -> (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w φ n) -> (Eq.{succ u2} M m n)
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u3} R] {σ : Type.{u2}} [_inst_2 : AddCommMonoid.{u1} M] {φ : MvPolynomial.{u2, u3} σ R _inst_1} {m : M} {n : M} {w : σ -> M}, (Ne.{max (succ u3) (succ u2)} (MvPolynomial.{u2, u3} σ R _inst_1) φ (OfNat.ofNat.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) 0 (Zero.toOfNat0.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommMonoidWithZero.toZero.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toCommMonoidWithZero.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1)))))) -> (MvPolynomial.IsWeightedHomogeneous.{u3, u1, u2} R M _inst_1 σ _inst_2 w φ m) -> (MvPolynomial.IsWeightedHomogeneous.{u3, u1, u2} R M _inst_1 σ _inst_2 w φ n) -> (Eq.{succ u1} M m n)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_weighted_homogeneous.inj_right MvPolynomial.IsWeightedHomogeneous.inj_rightₓ'. -/
/-- The weighted degree of a nonzero weighted homogeneous polynomial is well-defined. -/
theorem inj_right {w : σ → M} (hφ : φ ≠ 0) (hm : IsWeightedHomogeneous w φ m)
    (hn : IsWeightedHomogeneous w φ n) : m = n :=
  by
  obtain ⟨d, hd⟩ : ∃ d, coeff d φ ≠ 0 := exists_coeff_ne_zero hφ
  rw [← hm hd, ← hn hd]
#align mv_polynomial.is_weighted_homogeneous.inj_right MvPolynomial.IsWeightedHomogeneous.inj_right

/- warning: mv_polynomial.is_weighted_homogeneous.add -> MvPolynomial.IsWeightedHomogeneous.add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] {φ : MvPolynomial.{u3, u1} σ R _inst_1} {ψ : MvPolynomial.{u3, u1} σ R _inst_1} {n : M} {w : σ -> M}, (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w φ n) -> (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w ψ n) -> (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w (HAdd.hAdd.{max u3 u1, max u3 u1, max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (instHAdd.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Distrib.toHasAdd.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))))) φ ψ) n)
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u3} R] {σ : Type.{u1}} [_inst_2 : AddCommMonoid.{u2} M] {φ : MvPolynomial.{u1, u3} σ R _inst_1} {ψ : MvPolynomial.{u1, u3} σ R _inst_1} {n : M} {w : σ -> M}, (MvPolynomial.IsWeightedHomogeneous.{u3, u2, u1} R M _inst_1 σ _inst_2 w φ n) -> (MvPolynomial.IsWeightedHomogeneous.{u3, u2, u1} R M _inst_1 σ _inst_2 w ψ n) -> (MvPolynomial.IsWeightedHomogeneous.{u3, u2, u1} R M _inst_1 σ _inst_2 w (HAdd.hAdd.{max u3 u1, max u3 u1, max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.{u1, u3} σ R _inst_1) (instHAdd.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (Distrib.toAdd.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))))))) φ ψ) n)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_weighted_homogeneous.add MvPolynomial.IsWeightedHomogeneous.addₓ'. -/
/-- The sum of two weighted homogeneous polynomials of degree `n` is weighted homogeneous of
  weighted degree `n`. -/
theorem add {w : σ → M} (hφ : IsWeightedHomogeneous w φ n) (hψ : IsWeightedHomogeneous w ψ n) :
    IsWeightedHomogeneous w (φ + ψ) n :=
  (weightedHomogeneousSubmodule R w n).add_mem hφ hψ
#align mv_polynomial.is_weighted_homogeneous.add MvPolynomial.IsWeightedHomogeneous.add

/- warning: mv_polynomial.is_weighted_homogeneous.sum -> MvPolynomial.IsWeightedHomogeneous.sum is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] {ι : Type.{u4}} (s : Finset.{u4} ι) (φ : ι -> (MvPolynomial.{u3, u1} σ R _inst_1)) (n : M) {w : σ -> M}, (forall (i : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w (φ i) n)) -> (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w (Finset.sum.{max u3 u1, u4} (MvPolynomial.{u3, u1} σ R _inst_1) ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) s (fun (i : ι) => φ i)) n)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u1} M] {ι : Type.{u4}} (s : Finset.{u4} ι) (φ : ι -> (MvPolynomial.{u3, u2} σ R _inst_1)) (n : M) {w : σ -> M}, (forall (i : ι), (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i s) -> (MvPolynomial.IsWeightedHomogeneous.{u2, u1, u3} R M _inst_1 σ _inst_2 w (φ i) n)) -> (MvPolynomial.IsWeightedHomogeneous.{u2, u1, u3} R M _inst_1 σ _inst_2 w (Finset.sum.{max u3 u2, u4} (MvPolynomial.{u3, u2} σ R _inst_1) ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) s (fun (i : ι) => φ i)) n)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_weighted_homogeneous.sum MvPolynomial.IsWeightedHomogeneous.sumₓ'. -/
/-- The sum of weighted homogeneous polynomials of degree `n` is weighted homogeneous of
  weighted degree `n`. -/
theorem sum {ι : Type _} (s : Finset ι) (φ : ι → MvPolynomial σ R) (n : M) {w : σ → M}
    (h : ∀ i ∈ s, IsWeightedHomogeneous w (φ i) n) : IsWeightedHomogeneous w (∑ i in s, φ i) n :=
  (weightedHomogeneousSubmodule R w n).sum_mem h
#align mv_polynomial.is_weighted_homogeneous.sum MvPolynomial.IsWeightedHomogeneous.sum

/- warning: mv_polynomial.is_weighted_homogeneous.mul -> MvPolynomial.IsWeightedHomogeneous.mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] {φ : MvPolynomial.{u3, u1} σ R _inst_1} {ψ : MvPolynomial.{u3, u1} σ R _inst_1} {m : M} {n : M} {w : σ -> M}, (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w φ m) -> (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w ψ n) -> (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w (HMul.hMul.{max u3 u1, max u3 u1, max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (instHMul.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Distrib.toHasMul.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))))) φ ψ) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) m n))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u3} R] {σ : Type.{u1}} [_inst_2 : AddCommMonoid.{u2} M] {φ : MvPolynomial.{u1, u3} σ R _inst_1} {ψ : MvPolynomial.{u1, u3} σ R _inst_1} {m : M} {n : M} {w : σ -> M}, (MvPolynomial.IsWeightedHomogeneous.{u3, u2, u1} R M _inst_1 σ _inst_2 w φ m) -> (MvPolynomial.IsWeightedHomogeneous.{u3, u2, u1} R M _inst_1 σ _inst_2 w ψ n) -> (MvPolynomial.IsWeightedHomogeneous.{u3, u2, u1} R M _inst_1 σ _inst_2 w (HMul.hMul.{max u3 u1, max u3 u1, max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.{u1, u3} σ R _inst_1) (instHMul.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1)))))) φ ψ) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) m n))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_weighted_homogeneous.mul MvPolynomial.IsWeightedHomogeneous.mulₓ'. -/
/-- The product of weighted homogeneous polynomials of weighted degrees `m` and `n` is weighted
  homogeneous of weighted degree `m + n`. -/
theorem mul {w : σ → M} (hφ : IsWeightedHomogeneous w φ m) (hψ : IsWeightedHomogeneous w ψ n) :
    IsWeightedHomogeneous w (φ * ψ) (m + n) :=
  weightedHomogeneousSubmodule_mul w m n <| Submodule.mul_mem_mul hφ hψ
#align mv_polynomial.is_weighted_homogeneous.mul MvPolynomial.IsWeightedHomogeneous.mul

/- warning: mv_polynomial.is_weighted_homogeneous.prod -> MvPolynomial.IsWeightedHomogeneous.prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] {ι : Type.{u4}} (s : Finset.{u4} ι) (φ : ι -> (MvPolynomial.{u3, u1} σ R _inst_1)) (n : ι -> M) {w : σ -> M}, (forall (i : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w (φ i) (n i))) -> (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w (Finset.prod.{max u3 u1, u4} (MvPolynomial.{u3, u1} σ R _inst_1) ι (CommSemiring.toCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)) s (fun (i : ι) => φ i)) (Finset.sum.{u2, u4} M ι _inst_2 s (fun (i : ι) => n i)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u1} M] {ι : Type.{u4}} (s : Finset.{u4} ι) (φ : ι -> (MvPolynomial.{u3, u2} σ R _inst_1)) (n : ι -> M) {w : σ -> M}, (forall (i : ι), (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i s) -> (MvPolynomial.IsWeightedHomogeneous.{u2, u1, u3} R M _inst_1 σ _inst_2 w (φ i) (n i))) -> (MvPolynomial.IsWeightedHomogeneous.{u2, u1, u3} R M _inst_1 σ _inst_2 w (Finset.prod.{max u3 u2, u4} (MvPolynomial.{u3, u2} σ R _inst_1) ι (CommSemiring.toCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)) s (fun (i : ι) => φ i)) (Finset.sum.{u1, u4} M ι _inst_2 s (fun (i : ι) => n i)))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_weighted_homogeneous.prod MvPolynomial.IsWeightedHomogeneous.prodₓ'. -/
/-- A product of weighted homogeneous polynomials is weighted homogeneous, with weighted degree
  equal to the sum of the weighted degrees. -/
theorem prod {ι : Type _} (s : Finset ι) (φ : ι → MvPolynomial σ R) (n : ι → M) {w : σ → M} :
    (∀ i ∈ s, IsWeightedHomogeneous w (φ i) (n i)) →
      IsWeightedHomogeneous w (∏ i in s, φ i) (∑ i in s, n i) :=
  by
  classical
    apply Finset.induction_on s
    · intro
      simp only [is_weighted_homogeneous_one, Finset.sum_empty, Finset.prod_empty]
    · intro i s his IH h
      simp only [his, Finset.prod_insert, Finset.sum_insert, not_false_iff]
      apply (h i (Finset.mem_insert_self _ _)).mul (IH _)
      intro j hjs
      exact h j (Finset.mem_insert_of_mem hjs)
#align mv_polynomial.is_weighted_homogeneous.prod MvPolynomial.IsWeightedHomogeneous.prod

/- warning: mv_polynomial.is_weighted_homogeneous.weighted_total_degree -> MvPolynomial.IsWeightedHomogeneous.weighted_total_degree is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] {φ : MvPolynomial.{u3, u1} σ R _inst_1} {n : M} [_inst_3 : SemilatticeSup.{u2} M] {w : σ -> M}, (MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w φ n) -> (Ne.{max (succ u3) (succ u1)} (MvPolynomial.{u3, u1} σ R _inst_1) φ (OfNat.ofNat.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (OfNat.mk.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (Zero.zero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MulZeroClass.toHasZero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))))))))) -> (Eq.{succ u2} (WithBot.{u2} M) (MvPolynomial.weightedTotalDegree'.{u1, u2, u3} R M _inst_1 σ _inst_2 _inst_3 w φ) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) M (WithBot.{u2} M) (HasLiftT.mk.{succ u2, succ u2} M (WithBot.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} M (WithBot.{u2} M) (WithBot.hasCoeT.{u2} M))) n))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] {σ : Type.{u1}} [_inst_2 : AddCommMonoid.{u3} M] {φ : MvPolynomial.{u1, u2} σ R _inst_1} {n : M} [_inst_3 : SemilatticeSup.{u3} M] {w : σ -> M}, (MvPolynomial.IsWeightedHomogeneous.{u2, u3, u1} R M _inst_1 σ _inst_2 w φ n) -> (Ne.{max (succ u2) (succ u1)} (MvPolynomial.{u1, u2} σ R _inst_1) φ (OfNat.ofNat.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommMonoidWithZero.toZero.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toCommMonoidWithZero.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))) -> (Eq.{succ u3} (WithBot.{u3} M) (MvPolynomial.weightedTotalDegree'.{u2, u3, u1} R M _inst_1 σ _inst_2 _inst_3 w φ) (WithBot.some.{u3} M n))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_weighted_homogeneous.weighted_total_degree MvPolynomial.IsWeightedHomogeneous.weighted_total_degreeₓ'. -/
/-- A non zero weighted homogeneous polynomial of weighted degree `n` has weighted total degree
  `n`. -/
theorem weighted_total_degree [SemilatticeSup M] {w : σ → M} (hφ : IsWeightedHomogeneous w φ n)
    (h : φ ≠ 0) : weightedTotalDegree' w φ = n :=
  by
  simp only [weighted_total_degree']
  apply le_antisymm
  · simp only [Finset.sup_le_iff, mem_support_iff, WithBot.coe_le_coe]
    exact fun d hd => le_of_eq (hφ hd)
  · obtain ⟨d, hd⟩ : ∃ d, coeff d φ ≠ 0 := exists_coeff_ne_zero h
    simp only [← hφ hd, Finsupp.sum]
    replace hd := finsupp.mem_support_iff.mpr hd
    exact Finset.le_sup hd
#align mv_polynomial.is_weighted_homogeneous.weighted_total_degree MvPolynomial.IsWeightedHomogeneous.weighted_total_degree

#print MvPolynomial.IsWeightedHomogeneous.WeightedHomogeneousSubmodule.gcomm_monoid /-
/-- The weighted homogeneous submodules form a graded monoid. -/
instance WeightedHomogeneousSubmodule.gcomm_monoid {w : σ → M} :
    SetLike.GradedMonoid (weightedHomogeneousSubmodule R w)
    where
  one_mem := isWeightedHomogeneous_one R w
  mul_mem i j xi xj := IsWeightedHomogeneous.mul
#align mv_polynomial.is_weighted_homogeneous.weighted_homogeneous_submodule.gcomm_monoid MvPolynomial.IsWeightedHomogeneous.WeightedHomogeneousSubmodule.gcomm_monoid
-/

end IsWeightedHomogeneous

variable {R}

#print MvPolynomial.weightedHomogeneousComponent /-
/-- `weighted_homogeneous_component w n φ` is the part of `φ` that is weighted homogeneous of
  weighted degree `n`, with respect to the weights `w`.
  See `sum_weighted_homogeneous_component` for the statement that `φ` is equal to the sum
  of all its weighted homogeneous components. -/
def weightedHomogeneousComponent (w : σ → M) (n : M) : MvPolynomial σ R →ₗ[R] MvPolynomial σ R :=
  (Submodule.subtype _).comp <| Finsupp.restrictDom _ _ { d | weightedDegree' w d = n }
#align mv_polynomial.weighted_homogeneous_component MvPolynomial.weightedHomogeneousComponent
-/

section WeightedHomogeneousComponent

variable {w : σ → M} (n : M) (φ ψ : MvPolynomial σ R)

/- warning: mv_polynomial.coeff_weighted_homogeneous_component -> MvPolynomial.coeff_weightedHomogeneousComponent is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] {w : σ -> M} (n : M) (φ : MvPolynomial.{u3, u1} σ R _inst_1) [_inst_3 : DecidableEq.{succ u2} M] (d : Finsupp.{u3, 0} σ Nat Nat.hasZero), Eq.{succ u1} R (MvPolynomial.coeff.{u1, u3} R σ _inst_1 d (coeFn.{succ (max u3 u1), succ (max u3 u1)} (LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (fun (_x : LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) => (MvPolynomial.{u3, u1} σ R _inst_1) -> (MvPolynomial.{u3, u1} σ R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, max u3 u1, max u3 u1} R R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u1, u2, u3} R M _inst_1 σ _inst_2 w n) φ)) (ite.{succ u1} R (Eq.{succ u2} M (coeFn.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (fun (_x : AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) => (Finsupp.{u3, 0} σ Nat Nat.hasZero) -> M) (AddMonoidHom.hasCoeToFun.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MvPolynomial.weightedDegree'.{u2, u3} M σ _inst_2 w) d) n) (_inst_3 (coeFn.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (fun (_x : AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) => (Finsupp.{u3, 0} σ Nat Nat.hasZero) -> M) (AddMonoidHom.hasCoeToFun.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MvPolynomial.weightedDegree'.{u2, u3} M σ _inst_2 w) d) n) (MvPolynomial.coeff.{u1, u3} R σ _inst_1 d φ) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u1} M] {w : σ -> M} (n : M) (φ : MvPolynomial.{u3, u2} σ R _inst_1) (_inst_3 : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)), Eq.{succ u2} R (MvPolynomial.coeff.{u2, u3} R σ _inst_1 _inst_3 (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (succ u3) (succ u2)} (LinearMap.{u2, u2, max u2 u3, max u2 u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.{u3, u2} σ R _inst_1) (fun (a : MvPolynomial.{u3, u2} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u3, u2} σ R _inst_1) => MvPolynomial.{u3, u2} σ R _inst_1) a) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, max u3 u2} R R (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u2, u1, u3} R M _inst_1 σ _inst_2 w n) φ)) (ite.{succ u2} R (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) _inst_3) (FunLike.coe.{max (succ u1) (succ u3), succ u3, succ u1} (AddMonoidHom.{u3, u1} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (a : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) a) (AddHomClass.toFunLike.{max u1 u3, u3, u1} (AddMonoidHom.{u3, u1} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (AddZeroClass.toAdd.{u3} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u1 u3, u3, u1} (AddMonoidHom.{u3, u1} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (AddMonoidHom.addMonoidHomClass.{u3, u1} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (MvPolynomial.weightedDegree'.{u1, u3} M σ _inst_2 w) _inst_3) n) (Classical.propDecidable (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) _inst_3) (FunLike.coe.{max (succ u1) (succ u3), succ u3, succ u1} (AddMonoidHom.{u3, u1} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (a : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) a) (AddHomClass.toFunLike.{max u1 u3, u3, u1} (AddMonoidHom.{u3, u1} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (AddZeroClass.toAdd.{u3} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u1 u3, u3, u1} (AddMonoidHom.{u3, u1} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (AddMonoidHom.addMonoidHomClass.{u3, u1} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (MvPolynomial.weightedDegree'.{u1, u3} M σ _inst_2 w) _inst_3) n)) (MvPolynomial.coeff.{u2, u3} R σ _inst_1 _inst_3 φ) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.coeff_weighted_homogeneous_component MvPolynomial.coeff_weightedHomogeneousComponentₓ'. -/
theorem coeff_weightedHomogeneousComponent [DecidableEq M] (d : σ →₀ ℕ) :
    coeff d (weightedHomogeneousComponent w n φ) =
      if weightedDegree' w d = n then coeff d φ else 0 :=
  Finsupp.filter_apply (fun d : σ →₀ ℕ => weightedDegree' w d = n) φ d
#align mv_polynomial.coeff_weighted_homogeneous_component MvPolynomial.coeff_weightedHomogeneousComponent

/- warning: mv_polynomial.weighted_homogeneous_component_apply -> MvPolynomial.weightedHomogeneousComponent_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] {w : σ -> M} (n : M) (φ : MvPolynomial.{u3, u1} σ R _inst_1) [_inst_3 : DecidableEq.{succ u2} M], Eq.{max (succ u3) (succ u1)} (MvPolynomial.{u3, u1} σ R _inst_1) (coeFn.{succ (max u3 u1), succ (max u3 u1)} (LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (fun (_x : LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) => (MvPolynomial.{u3, u1} σ R _inst_1) -> (MvPolynomial.{u3, u1} σ R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, max u3 u1, max u3 u1} R R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u1, u2, u3} R M _inst_1 σ _inst_2 w n) φ) (Finset.sum.{max u3 u1, u3} (MvPolynomial.{u3, u1} σ R _inst_1) (Finsupp.{u3, 0} σ Nat Nat.hasZero) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (Finset.filter.{u3} (Finsupp.{u3, 0} σ Nat Nat.hasZero) (fun (d : Finsupp.{u3, 0} σ Nat Nat.hasZero) => Eq.{succ u2} M (coeFn.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (fun (_x : AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) => (Finsupp.{u3, 0} σ Nat Nat.hasZero) -> M) (AddMonoidHom.hasCoeToFun.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MvPolynomial.weightedDegree'.{u2, u3} M σ _inst_2 w) d) n) (fun (a : Finsupp.{u3, 0} σ Nat Nat.hasZero) => _inst_3 (coeFn.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (fun (_x : AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) => (Finsupp.{u3, 0} σ Nat Nat.hasZero) -> M) (AddMonoidHom.hasCoeToFun.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MvPolynomial.weightedDegree'.{u2, u3} M σ _inst_2 w) a) n) (MvPolynomial.support.{u1, u3} R σ _inst_1 φ)) (fun (d : Finsupp.{u3, 0} σ Nat Nat.hasZero) => coeFn.{max (succ u1) (succ (max u3 u1)), max (succ u1) (succ (max u3 u1))} (LinearMap.{u1, u1, u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (fun (_x : LinearMap.{u1, u1, u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) => R -> (MvPolynomial.{u3, u1} σ R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, u1, max u3 u1} R R R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.monomial.{u1, u3} R σ _inst_1 d) (MvPolynomial.coeff.{u1, u3} R σ _inst_1 d φ)))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u3} R] {σ : Type.{u2}} [_inst_2 : AddCommMonoid.{u1} M] {w : σ -> M} (n : M) (φ : MvPolynomial.{u2, u3} σ R _inst_1), Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u3} σ R _inst_1) => MvPolynomial.{u2, u3} σ R _inst_1) φ) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u3, u3, max u3 u2, max u3 u2} R R (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.{u2, u3} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (MvPolynomial.{u2, u3} σ R _inst_1) (fun (a : MvPolynomial.{u2, u3} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u3} σ R _inst_1) => MvPolynomial.{u2, u3} σ R _inst_1) a) (LinearMap.instFunLikeLinearMap.{u3, u3, max u2 u3, max u2 u3} R R (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u3, u1, u2} R M _inst_1 σ _inst_2 w n) φ) (Finset.sum.{max u3 u2, u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (Finset.filter.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (d : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) d) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (AddMonoidHom.{u2, u1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (a : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) a) (AddHomClass.toFunLike.{max u1 u2, u2, u1} (AddMonoidHom.{u2, u1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (AddZeroClass.toAdd.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, u1} (AddMonoidHom.{u2, u1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (AddMonoidHom.addMonoidHomClass.{u2, u1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (MvPolynomial.weightedDegree'.{u1, u2} M σ _inst_2 w) d) n) (fun (a : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => Classical.propDecidable ((fun (d : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) d) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (AddMonoidHom.{u2, u1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (a : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) a) (AddHomClass.toFunLike.{max u1 u2, u2, u1} (AddMonoidHom.{u2, u1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (AddZeroClass.toAdd.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, u1} (AddMonoidHom.{u2, u1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (AddMonoidHom.addMonoidHomClass.{u2, u1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u2, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (MvPolynomial.weightedDegree'.{u1, u2} M σ _inst_2 w) d) n) a)) (MvPolynomial.support.{u3, u2} R σ _inst_1 φ)) (fun (d : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u3, u3, u3, max u3 u2} R R (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) R (MvPolynomial.{u2, u3} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : R) => MvPolynomial.{u2, u3} σ R _inst_1) a) (LinearMap.instFunLikeLinearMap.{u3, u3, u3, max u2 u3} R R R (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (MvPolynomial.monomial.{u3, u2} R σ _inst_1 d) (MvPolynomial.coeff.{u3, u2} R σ _inst_1 d φ)))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.weighted_homogeneous_component_apply MvPolynomial.weightedHomogeneousComponent_applyₓ'. -/
theorem weightedHomogeneousComponent_apply [DecidableEq M] :
    weightedHomogeneousComponent w n φ =
      ∑ d in φ.support.filterₓ fun d => weightedDegree' w d = n, monomial d (coeff d φ) :=
  Finsupp.filter_eq_sum (fun d : σ →₀ ℕ => weightedDegree' w d = n) φ
#align mv_polynomial.weighted_homogeneous_component_apply MvPolynomial.weightedHomogeneousComponent_apply

/- warning: mv_polynomial.weighted_homogeneous_component_is_weighted_homogeneous -> MvPolynomial.weightedHomogeneousComponent_isWeightedHomogeneous is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] {w : σ -> M} (n : M) (φ : MvPolynomial.{u3, u1} σ R _inst_1), MvPolynomial.IsWeightedHomogeneous.{u1, u2, u3} R M _inst_1 σ _inst_2 w (coeFn.{succ (max u3 u1), succ (max u3 u1)} (LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (fun (_x : LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) => (MvPolynomial.{u3, u1} σ R _inst_1) -> (MvPolynomial.{u3, u1} σ R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, max u3 u1, max u3 u1} R R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u1, u2, u3} R M _inst_1 σ _inst_2 w n) φ) n
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u3} R] {σ : Type.{u1}} [_inst_2 : AddCommMonoid.{u2} M] {w : σ -> M} (n : M) (φ : MvPolynomial.{u1, u3} σ R _inst_1), MvPolynomial.IsWeightedHomogeneous.{u3, u2, u1} R M _inst_1 σ _inst_2 w (FunLike.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3), max (succ u1) (succ u3)} (LinearMap.{u3, u3, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.{u1, u3} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u1} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (MvPolynomial.module.{u3, u3, u1} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (MvPolynomial.{u1, u3} σ R _inst_1) (fun (_x : MvPolynomial.{u1, u3} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u3} σ R _inst_1) => MvPolynomial.{u1, u3} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u1 u3, max u1 u3} R R (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u1, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u1} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u1} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (MvPolynomial.module.{u3, u3, u1} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u3, u2, u1} R M _inst_1 σ _inst_2 w n) φ) n
Case conversion may be inaccurate. Consider using '#align mv_polynomial.weighted_homogeneous_component_is_weighted_homogeneous MvPolynomial.weightedHomogeneousComponent_isWeightedHomogeneousₓ'. -/
/-- The `n` weighted homogeneous component of a polynomial is weighted homogeneous of
weighted degree `n`. -/
theorem weightedHomogeneousComponent_isWeightedHomogeneous :
    (weightedHomogeneousComponent w n φ).IsWeightedHomogeneous w n := by
  classical
    intro d hd
    contrapose! hd
    rw [coeff_weighted_homogeneous_component, if_neg hd]
#align mv_polynomial.weighted_homogeneous_component_is_weighted_homogeneous MvPolynomial.weightedHomogeneousComponent_isWeightedHomogeneous

/- warning: mv_polynomial.weighted_homogeneous_component_C_mul -> MvPolynomial.weightedHomogeneousComponent_C_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] {w : σ -> M} (φ : MvPolynomial.{u3, u1} σ R _inst_1) (n : M) (r : R), Eq.{max (succ u3) (succ u1)} (MvPolynomial.{u3, u1} σ R _inst_1) (coeFn.{succ (max u3 u1), succ (max u3 u1)} (LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (fun (_x : LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) => (MvPolynomial.{u3, u1} σ R _inst_1) -> (MvPolynomial.{u3, u1} σ R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, max u3 u1, max u3 u1} R R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u1, u2, u3} R M _inst_1 σ _inst_2 w n) (HMul.hMul.{max u3 u1, max u3 u1, max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (instHMul.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Distrib.toHasMul.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))))) (coeFn.{max (succ u1) (succ (max u3 u1)), max (succ u1) (succ (max u3 u1))} (RingHom.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))) (fun (_x : RingHom.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))) => R -> (MvPolynomial.{u3, u1} σ R _inst_1)) (RingHom.hasCoeToFun.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))) (MvPolynomial.C.{u1, u3} R σ _inst_1) r) φ)) (HMul.hMul.{max u3 u1, max u3 u1, max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (instHMul.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Distrib.toHasMul.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))))) (coeFn.{max (succ u1) (succ (max u3 u1)), max (succ u1) (succ (max u3 u1))} (RingHom.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))) (fun (_x : RingHom.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))) => R -> (MvPolynomial.{u3, u1} σ R _inst_1)) (RingHom.hasCoeToFun.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))) (MvPolynomial.C.{u1, u3} R σ _inst_1) r) (coeFn.{succ (max u3 u1), succ (max u3 u1)} (LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (fun (_x : LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) => (MvPolynomial.{u3, u1} σ R _inst_1) -> (MvPolynomial.{u3, u1} σ R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, max u3 u1, max u3 u1} R R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u1, u2, u3} R M _inst_1 σ _inst_2 w n) φ))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u1} M] {w : σ -> M} (φ : MvPolynomial.{u3, u2} σ R _inst_1) (n : M) (r : R), Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u3, u2} σ R _inst_1) => MvPolynomial.{u3, u2} σ R _inst_1) (HMul.hMul.{max u2 u3, max u2 u3, max u3 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u2} σ R _inst_1) (instHMul.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (NonUnitalNonAssocSemiring.toMul.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (Semiring.toNonAssocSemiring.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (CommSemiring.toSemiring.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))))) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (RingHom.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) a) (MulHomClass.toFunLike.{max u3 u2, u2, max u3 u2} (RingHom.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) R (MvPolynomial.{u3, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{max u3 u2} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u2, max u3 u2} (RingHom.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) R (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u2, max u3 u2} (RingHom.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))) (RingHom.instRingHomClassRingHom.{u2, max u3 u2} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))))) (MvPolynomial.C.{u2, u3} R σ _inst_1) r) φ)) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (succ u3) (succ u2)} (LinearMap.{u2, u2, max u2 u3, max u2 u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.{u3, u2} σ R _inst_1) (fun (_x : MvPolynomial.{u3, u2} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u3, u2} σ R _inst_1) => MvPolynomial.{u3, u2} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, max u3 u2} R R (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u2, u1, u3} R M _inst_1 σ _inst_2 w n) (HMul.hMul.{max u2 u3, max u2 u3, max u3 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u2} σ R _inst_1) (instHMul.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (NonUnitalNonAssocSemiring.toMul.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (Semiring.toNonAssocSemiring.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (CommSemiring.toSemiring.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))))) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (RingHom.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) _x) (MulHomClass.toFunLike.{max u3 u2, u2, max u3 u2} (RingHom.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) R (MvPolynomial.{u3, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{max u3 u2} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u2, max u3 u2} (RingHom.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) R (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u2, max u3 u2} (RingHom.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))) (RingHom.instRingHomClassRingHom.{u2, max u3 u2} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))))) (MvPolynomial.C.{u2, u3} R σ _inst_1) r) φ)) (HMul.hMul.{max u2 u3, max u2 u3, max u3 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u3, u2} σ R _inst_1) => MvPolynomial.{u3, u2} σ R _inst_1) φ) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u3, u2} σ R _inst_1) => MvPolynomial.{u3, u2} σ R _inst_1) (HMul.hMul.{max u2 u3, max u2 u3, max u3 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u2} σ R _inst_1) (instHMul.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (NonUnitalNonAssocSemiring.toMul.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (Semiring.toNonAssocSemiring.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (CommSemiring.toSemiring.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))))) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (RingHom.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) a) (MulHomClass.toFunLike.{max u3 u2, u2, max u3 u2} (RingHom.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) R (MvPolynomial.{u3, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{max u3 u2} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u2, max u3 u2} (RingHom.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) R (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u2, max u3 u2} (RingHom.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))) (RingHom.instRingHomClassRingHom.{u2, max u3 u2} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))))) (MvPolynomial.C.{u2, u3} R σ _inst_1) r) φ)) (instHMul.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (NonUnitalNonAssocSemiring.toMul.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (Semiring.toNonAssocSemiring.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (CommSemiring.toSemiring.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) r) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))))) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (RingHom.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u3, u2} σ R _inst_1) _x) (MulHomClass.toFunLike.{max u3 u2, u2, max u3 u2} (RingHom.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) R (MvPolynomial.{u3, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{max u3 u2} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u2, max u3 u2} (RingHom.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) R (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u2, max u3 u2} (RingHom.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))) R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))) (RingHom.instRingHomClassRingHom.{u2, max u3 u2} R (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))))) (MvPolynomial.C.{u2, u3} R σ _inst_1) r) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (succ u3) (succ u2)} (LinearMap.{u2, u2, max u2 u3, max u2 u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.{u3, u2} σ R _inst_1) (fun (_x : MvPolynomial.{u3, u2} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u3, u2} σ R _inst_1) => MvPolynomial.{u3, u2} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, max u3 u2} R R (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u2, u1, u3} R M _inst_1 σ _inst_2 w n) φ))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.weighted_homogeneous_component_C_mul MvPolynomial.weightedHomogeneousComponent_C_mulₓ'. -/
@[simp]
theorem weightedHomogeneousComponent_C_mul (n : M) (r : R) :
    weightedHomogeneousComponent w n (C r * φ) = C r * weightedHomogeneousComponent w n φ := by
  simp only [C_mul', LinearMap.map_smul]
#align mv_polynomial.weighted_homogeneous_component_C_mul MvPolynomial.weightedHomogeneousComponent_C_mul

/- warning: mv_polynomial.weighted_homogeneous_component_eq_zero' -> MvPolynomial.weightedHomogeneousComponent_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] {w : σ -> M} (n : M) (φ : MvPolynomial.{u3, u1} σ R _inst_1), (forall (d : Finsupp.{u3, 0} σ Nat Nat.hasZero), (Membership.Mem.{u3, u3} (Finsupp.{u3, 0} σ Nat Nat.hasZero) (Finset.{u3} (Finsupp.{u3, 0} σ Nat Nat.hasZero)) (Finset.hasMem.{u3} (Finsupp.{u3, 0} σ Nat Nat.hasZero)) d (MvPolynomial.support.{u1, u3} R σ _inst_1 φ)) -> (Ne.{succ u2} M (coeFn.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (fun (_x : AddMonoidHom.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) => (Finsupp.{u3, 0} σ Nat Nat.hasZero) -> M) (AddMonoidHom.hasCoeToFun.{u3, u2} (Finsupp.{u3, 0} σ Nat Nat.hasZero) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MvPolynomial.weightedDegree'.{u2, u3} M σ _inst_2 w) d) n)) -> (Eq.{max (succ u3) (succ u1)} (MvPolynomial.{u3, u1} σ R _inst_1) (coeFn.{succ (max u3 u1), succ (max u3 u1)} (LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (fun (_x : LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) => (MvPolynomial.{u3, u1} σ R _inst_1) -> (MvPolynomial.{u3, u1} σ R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, max u3 u1, max u3 u1} R R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u1, u2, u3} R M _inst_1 σ _inst_2 w n) φ) (OfNat.ofNat.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (OfNat.mk.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (Zero.zero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MulZeroClass.toHasZero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u1} M] {w : σ -> M} (n : M) (φ : MvPolynomial.{u3, u2} σ R _inst_1), (forall (d : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)), (Membership.mem.{u3, u3} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finset.{u3} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (Finset.instMembershipFinset.{u3} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) d (MvPolynomial.support.{u2, u3} R σ _inst_1 φ)) -> (Ne.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) d) (FunLike.coe.{max (succ u1) (succ u3), succ u3, succ u1} (AddMonoidHom.{u3, u1} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (_x : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => M) _x) (AddHomClass.toFunLike.{max u1 u3, u3, u1} (AddMonoidHom.{u3, u1} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (AddZeroClass.toAdd.{u3} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u1 u3, u3, u1} (AddMonoidHom.{u3, u1} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (AddMonoidHom.addMonoidHomClass.{u3, u1} (Finsupp.{u3, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) M (Finsupp.addZeroClass.{u3, 0} σ Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (MvPolynomial.weightedDegree'.{u1, u3} M σ _inst_2 w) d) n)) -> (Eq.{max (succ u2) (succ u3)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u3, u2} σ R _inst_1) => MvPolynomial.{u3, u2} σ R _inst_1) φ) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (succ u3) (succ u2)} (LinearMap.{u2, u2, max u2 u3, max u2 u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.{u3, u2} σ R _inst_1) (fun (_x : MvPolynomial.{u3, u2} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u3, u2} σ R _inst_1) => MvPolynomial.{u3, u2} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, max u3 u2} R R (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u2, u1, u3} R M _inst_1 σ _inst_2 w n) φ) (OfNat.ofNat.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u3, u2} σ R _inst_1) => MvPolynomial.{u3, u2} σ R _inst_1) φ) 0 (Zero.toOfNat0.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u3, u2} σ R _inst_1) => MvPolynomial.{u3, u2} σ R _inst_1) φ) (CommMonoidWithZero.toZero.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u3, u2} σ R _inst_1) => MvPolynomial.{u3, u2} σ R _inst_1) φ) (CommSemiring.toCommMonoidWithZero.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u3, u2} σ R _inst_1) => MvPolynomial.{u3, u2} σ R _inst_1) φ) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.weighted_homogeneous_component_eq_zero' MvPolynomial.weightedHomogeneousComponent_eq_zero'ₓ'. -/
theorem weightedHomogeneousComponent_eq_zero'
    (h : ∀ d : σ →₀ ℕ, d ∈ φ.support → weightedDegree' w d ≠ n) :
    weightedHomogeneousComponent w n φ = 0 := by
  classical
    rw [weighted_homogeneous_component_apply, sum_eq_zero]
    intro d hd
    rw [mem_filter] at hd
    exfalso
    exact h _ hd.1 hd.2
#align mv_polynomial.weighted_homogeneous_component_eq_zero' MvPolynomial.weightedHomogeneousComponent_eq_zero'

/- warning: mv_polynomial.weighted_homogeneous_component_eq_zero -> MvPolynomial.weightedHomogeneousComponent_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] {w : σ -> M} (n : M) (φ : MvPolynomial.{u3, u1} σ R _inst_1) [_inst_3 : SemilatticeSup.{u2} M] [_inst_4 : OrderBot.{u2} M (Preorder.toHasLe.{u2} M (PartialOrder.toPreorder.{u2} M (SemilatticeSup.toPartialOrder.{u2} M _inst_3)))], (LT.lt.{u2} M (Preorder.toHasLt.{u2} M (PartialOrder.toPreorder.{u2} M (SemilatticeSup.toPartialOrder.{u2} M _inst_3))) (MvPolynomial.weightedTotalDegree.{u1, u2, u3} R M _inst_1 σ _inst_2 _inst_3 _inst_4 w φ) n) -> (Eq.{max (succ u3) (succ u1)} (MvPolynomial.{u3, u1} σ R _inst_1) (coeFn.{succ (max u3 u1), succ (max u3 u1)} (LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (fun (_x : LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) => (MvPolynomial.{u3, u1} σ R _inst_1) -> (MvPolynomial.{u3, u1} σ R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, max u3 u1, max u3 u1} R R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u1, u2, u3} R M _inst_1 σ _inst_2 w n) φ) (OfNat.ofNat.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (OfNat.mk.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (Zero.zero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MulZeroClass.toHasZero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] {σ : Type.{u1}} [_inst_2 : AddCommMonoid.{u3} M] {w : σ -> M} (n : M) (φ : MvPolynomial.{u1, u2} σ R _inst_1) [_inst_3 : SemilatticeSup.{u3} M] [_inst_4 : OrderBot.{u3} M (Preorder.toLE.{u3} M (PartialOrder.toPreorder.{u3} M (SemilatticeSup.toPartialOrder.{u3} M _inst_3)))], (LT.lt.{u3} M (Preorder.toLT.{u3} M (PartialOrder.toPreorder.{u3} M (SemilatticeSup.toPartialOrder.{u3} M _inst_3))) (MvPolynomial.weightedTotalDegree.{u2, u3, u1} R M _inst_1 σ _inst_2 _inst_3 _inst_4 w φ) n) -> (Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) φ) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u2 u1, max u2 u1} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.{u1, u2} σ R _inst_1) (fun (_x : MvPolynomial.{u1, u2} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u1 u2, max u1 u2} R R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u2, u3, u1} R M _inst_1 σ _inst_2 w n) φ) (OfNat.ofNat.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) φ) 0 (Zero.toOfNat0.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) φ) (CommMonoidWithZero.toZero.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) φ) (CommSemiring.toCommMonoidWithZero.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) φ) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.weighted_homogeneous_component_eq_zero MvPolynomial.weightedHomogeneousComponent_eq_zeroₓ'. -/
theorem weightedHomogeneousComponent_eq_zero [SemilatticeSup M] [OrderBot M]
    (h : weightedTotalDegree w φ < n) : weightedHomogeneousComponent w n φ = 0 := by
  classical
    rw [weighted_homogeneous_component_apply, sum_eq_zero]
    intro d hd
    rw [mem_filter] at hd
    exfalso
    apply lt_irrefl n
    nth_rw 1 [← hd.2]
    exact lt_of_le_of_lt (le_weighted_total_degree w hd.1) h
#align mv_polynomial.weighted_homogeneous_component_eq_zero MvPolynomial.weightedHomogeneousComponent_eq_zero

/- warning: mv_polynomial.weighted_homogeneous_component_finsupp -> MvPolynomial.weightedHomogeneousComponent_finsupp is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] {w : σ -> M} (φ : MvPolynomial.{u3, u1} σ R _inst_1), Set.Finite.{u2} M (Function.support.{u2, max u3 u1} M (MvPolynomial.{u3, u1} σ R _inst_1) (MulZeroClass.toHasZero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))))) (fun (m : M) => coeFn.{succ (max u3 u1), succ (max u3 u1)} (LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (fun (_x : LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) => (MvPolynomial.{u3, u1} σ R _inst_1) -> (MvPolynomial.{u3, u1} σ R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, max u3 u1, max u3 u1} R R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u1, u2, u3} R M _inst_1 σ _inst_2 w m) φ))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] {σ : Type.{u1}} [_inst_2 : AddCommMonoid.{u3} M] {w : σ -> M} (φ : MvPolynomial.{u1, u2} σ R _inst_1), Set.Finite.{u3} M (Function.support.{u3, max u2 u1} M ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) φ) (CommMonoidWithZero.toZero.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) φ) (CommSemiring.toCommMonoidWithZero.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) φ) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (fun (m : M) => FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u2 u1, max u2 u1} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.{u1, u2} σ R _inst_1) (fun (_x : MvPolynomial.{u1, u2} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u1 u2, max u1 u2} R R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u2, u3, u1} R M _inst_1 σ _inst_2 w m) φ))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.weighted_homogeneous_component_finsupp MvPolynomial.weightedHomogeneousComponent_finsuppₓ'. -/
theorem weightedHomogeneousComponent_finsupp :
    (Function.support fun m => weightedHomogeneousComponent w m φ).Finite :=
  by
  suffices
    (Function.support fun m => weighted_homogeneous_component w m φ) ⊆
      (fun d => weighted_degree' w d) '' φ.support
    by
    exact finite.subset ((fun d : σ →₀ ℕ => (weighted_degree' w) d) '' ↑(support φ)).toFinite this
  intro m hm
  by_contra hm'
  apply hm
  simp only [mem_support, Ne.def] at hm
  simp only [Set.mem_image, not_exists, not_and] at hm'
  exact weighted_homogeneous_component_eq_zero' m φ hm'
#align mv_polynomial.weighted_homogeneous_component_finsupp MvPolynomial.weightedHomogeneousComponent_finsupp

variable (w)

/- warning: mv_polynomial.sum_weighted_homogeneous_component -> MvPolynomial.sum_weightedHomogeneousComponent is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] (w : σ -> M) (φ : MvPolynomial.{u3, u1} σ R _inst_1), Eq.{succ (max u3 u1)} (MvPolynomial.{u3, u1} σ R _inst_1) (finsum.{max u3 u1, succ u2} (MvPolynomial.{u3, u1} σ R _inst_1) M (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (fun (m : M) => coeFn.{succ (max u3 u1), succ (max u3 u1)} (LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (fun (_x : LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) => (MvPolynomial.{u3, u1} σ R _inst_1) -> (MvPolynomial.{u3, u1} σ R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, max u3 u1, max u3 u1} R R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u1, u2, u3} R M _inst_1 σ _inst_2 w m) φ)) φ
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u3} R] {σ : Type.{u2}} [_inst_2 : AddCommMonoid.{u1} M] (w : σ -> M) (φ : MvPolynomial.{u2, u3} σ R _inst_1), Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u3} σ R _inst_1) => MvPolynomial.{u2, u3} σ R _inst_1) φ) (finsum.{max u3 u2, succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u3} σ R _inst_1) => MvPolynomial.{u2, u3} σ R _inst_1) φ) M (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u3} σ R _inst_1) => MvPolynomial.{u2, u3} σ R _inst_1) φ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u3} σ R _inst_1) => MvPolynomial.{u2, u3} σ R _inst_1) φ) (Semiring.toNonAssocSemiring.{max u3 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u3} σ R _inst_1) => MvPolynomial.{u2, u3} σ R _inst_1) φ) (CommSemiring.toSemiring.{max u3 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u3} σ R _inst_1) => MvPolynomial.{u2, u3} σ R _inst_1) φ) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (fun (m : M) => FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u3, u3, max u3 u2, max u3 u2} R R (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.{u2, u3} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (MvPolynomial.{u2, u3} σ R _inst_1) (fun (_x : MvPolynomial.{u2, u3} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u3} σ R _inst_1) => MvPolynomial.{u2, u3} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u2 u3, max u2 u3} R R (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u2} (MvPolynomial.{u2, u3} σ R _inst_1) (MvPolynomial.commSemiring.{u3, u2} R σ _inst_1))))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (MvPolynomial.module.{u3, u3, u2} R R σ (CommSemiring.toSemiring.{u3} R _inst_1) _inst_1 (Semiring.toModule.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u3, u1, u2} R M _inst_1 σ _inst_2 w m) φ)) φ
Case conversion may be inaccurate. Consider using '#align mv_polynomial.sum_weighted_homogeneous_component MvPolynomial.sum_weightedHomogeneousComponentₓ'. -/
/-- Every polynomial is the sum of its weighted homogeneous components. -/
theorem sum_weightedHomogeneousComponent :
    (finsum fun m => weightedHomogeneousComponent w m φ) = φ := by
  classical
    rw [finsum_eq_sum _ (weighted_homogeneous_component_finsupp φ)]
    ext1 d
    simp only [coeff_sum, coeff_weighted_homogeneous_component]
    rw [Finset.sum_eq_single (weighted_degree' w d)]
    · rw [if_pos rfl]
    · intro m hm hm'
      rw [if_neg hm'.symm]
    · intro hm
      rw [if_pos rfl]
      simp only [finite.mem_to_finset, mem_support, Ne.def, Classical.not_not] at hm
      have := coeff_weighted_homogeneous_component (_ : M) φ d
      rw [hm, if_pos rfl, coeff_zero] at this
      exact this.symm
#align mv_polynomial.sum_weighted_homogeneous_component MvPolynomial.sum_weightedHomogeneousComponent

variable {w}

/- warning: mv_polynomial.weighted_homogeneous_component_weighted_homogeneous_polynomial -> MvPolynomial.weightedHomogeneousComponent_weighted_homogeneous_polynomial is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u2} M] {w : σ -> M} [_inst_3 : DecidableEq.{succ u2} M] (m : M) (n : M) (p : MvPolynomial.{u3, u1} σ R _inst_1), (Membership.Mem.{max u3 u1, max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Submodule.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (SetLike.hasMem.{max u3 u1, max u3 u1} (Submodule.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.{u3, u1} σ R _inst_1) (Submodule.setLike.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) p (MvPolynomial.weightedHomogeneousSubmodule.{u1, u2, u3} R M _inst_1 σ _inst_2 w n)) -> (Eq.{max (succ u3) (succ u1)} (MvPolynomial.{u3, u1} σ R _inst_1) (coeFn.{succ (max u3 u1), succ (max u3 u1)} (LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (fun (_x : LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) => (MvPolynomial.{u3, u1} σ R _inst_1) -> (MvPolynomial.{u3, u1} σ R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, max u3 u1, max u3 u1} R R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u1, u2, u3} R M _inst_1 σ _inst_2 w m) p) (ite.{max (succ u3) (succ u1)} (MvPolynomial.{u3, u1} σ R _inst_1) (Eq.{succ u2} M m n) (_inst_3 m n) p (OfNat.ofNat.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (OfNat.mk.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) 0 (Zero.zero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MulZeroClass.toHasZero.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))))))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {σ : Type.{u3}} [_inst_2 : AddCommMonoid.{u1} M] {w : σ -> M} (_inst_3 : M) (m : M) (n : MvPolynomial.{u3, u2} σ R _inst_1), (Membership.mem.{max u2 u3, max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Submodule.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (SetLike.instMembership.{max u2 u3, max u2 u3} (Submodule.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.{u3, u2} σ R _inst_1) (Submodule.setLike.{u2, max u2 u3} R (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) n (MvPolynomial.weightedHomogeneousSubmodule.{u2, u1, u3} R M _inst_1 σ _inst_2 w m)) -> (Eq.{max (succ u2) (succ u3)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u3, u2} σ R _inst_1) => MvPolynomial.{u3, u2} σ R _inst_1) n) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (succ u3) (succ u2)} (LinearMap.{u2, u2, max u2 u3, max u2 u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.{u3, u2} σ R _inst_1) (fun (a : MvPolynomial.{u3, u2} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u3, u2} σ R _inst_1) => MvPolynomial.{u3, u2} σ R _inst_1) a) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, max u3 u2} R R (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u3} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u2, u1, u3} R M _inst_1 σ _inst_2 w _inst_3) n) (ite.{max (succ u2) (succ u3)} (MvPolynomial.{u3, u2} σ R _inst_1) (Eq.{succ u1} M _inst_3 m) (Classical.propDecidable (Eq.{succ u1} M _inst_3 m)) n (OfNat.ofNat.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) 0 (Zero.toOfNat0.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommMonoidWithZero.toZero.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (CommSemiring.toCommMonoidWithZero.{max u2 u3} (MvPolynomial.{u3, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u3} R σ _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.weighted_homogeneous_component_weighted_homogeneous_polynomial MvPolynomial.weightedHomogeneousComponent_weighted_homogeneous_polynomialₓ'. -/
/-- The weighted homogeneous components of a weighted homogeneous polynomial. -/
theorem weightedHomogeneousComponent_weighted_homogeneous_polynomial [DecidableEq M] (m n : M)
    (p : MvPolynomial σ R) (h : p ∈ weightedHomogeneousSubmodule R w n) :
    weightedHomogeneousComponent w m p = if m = n then p else 0 :=
  by
  simp only [mem_weighted_homogeneous_submodule] at h
  ext x
  rw [coeff_weighted_homogeneous_component]
  by_cases zero_coeff : coeff x p = 0
  · split_ifs
    all_goals simp only [zero_coeff, coeff_zero]
  · rw [h zero_coeff]
    simp only [show n = m ↔ m = n from eq_comm]
    split_ifs with h1
    · rfl
    · simp only [coeff_zero]
#align mv_polynomial.weighted_homogeneous_component_weighted_homogeneous_polynomial MvPolynomial.weightedHomogeneousComponent_weighted_homogeneous_polynomial

end WeightedHomogeneousComponent

end AddCommMonoid

section CanonicallyOrderedAddMonoid

variable [CanonicallyOrderedAddMonoid M] {w : σ → M} (φ : MvPolynomial σ R)

/- warning: mv_polynomial.weighted_homogeneous_component_zero -> MvPolynomial.weightedHomogeneousComponent_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {σ : Type.{u3}} [_inst_2 : CanonicallyOrderedAddMonoid.{u2} M] {w : σ -> M} (φ : MvPolynomial.{u3, u1} σ R _inst_1) [_inst_3 : NoZeroSMulDivisors.{0, u2} Nat M Nat.hasZero (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} M _inst_2))))) (AddMonoid.SMul.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} M _inst_2))))], (forall (i : σ), Ne.{succ u2} M (w i) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} M _inst_2))))))))) -> (Eq.{max (succ u3) (succ u1)} (MvPolynomial.{u3, u1} σ R _inst_1) (coeFn.{succ (max u3 u1), succ (max u3 u1)} (LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (fun (_x : LinearMap.{u1, u1, max u3 u1, max u3 u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) => (MvPolynomial.{u3, u1} σ R _inst_1) -> (MvPolynomial.{u3, u1} σ R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, max u3 u1, max u3 u1} R R (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u3} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u1, u2, u3} R M _inst_1 σ (OrderedAddCommMonoid.toAddCommMonoid.{u2} M (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} M _inst_2)) w (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} M _inst_2))))))))) φ) (coeFn.{max (succ u1) (succ (max u3 u1)), max (succ u1) (succ (max u3 u1))} (RingHom.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))) (fun (_x : RingHom.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))) => R -> (MvPolynomial.{u3, u1} σ R _inst_1)) (RingHom.hasCoeToFun.{u1, max u3 u1} R (MvPolynomial.{u3, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u3 u1} (MvPolynomial.{u3, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u3} R σ _inst_1)))) (MvPolynomial.C.{u1, u3} R σ _inst_1) (MvPolynomial.coeff.{u1, u3} R σ _inst_1 (OfNat.ofNat.{u3} (Finsupp.{u3, 0} σ Nat Nat.hasZero) 0 (OfNat.mk.{u3} (Finsupp.{u3, 0} σ Nat Nat.hasZero) 0 (Zero.zero.{u3} (Finsupp.{u3, 0} σ Nat Nat.hasZero) (Finsupp.zero.{u3, 0} σ Nat Nat.hasZero)))) φ)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] {σ : Type.{u1}} [_inst_2 : CanonicallyOrderedAddMonoid.{u3} M] {w : σ -> M} (φ : MvPolynomial.{u1, u2} σ R _inst_1) [_inst_3 : NoZeroSMulDivisors.{0, u3} Nat M (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (OrderedAddCommMonoid.toAddCommMonoid.{u3} M (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u3} M _inst_2)))) (AddMonoid.SMul.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (OrderedAddCommMonoid.toAddCommMonoid.{u3} M (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u3} M _inst_2))))], (forall (i : σ), Ne.{succ u3} M (w i) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (OrderedAddCommMonoid.toAddCommMonoid.{u3} M (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u3} M _inst_2))))))) -> (Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) φ) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u2 u1, max u2 u1} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.{u1, u2} σ R _inst_1) (fun (_x : MvPolynomial.{u1, u2} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u1 u2, max u1 u2} R R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.weightedHomogeneousComponent.{u2, u3, u1} R M _inst_1 σ (OrderedAddCommMonoid.toAddCommMonoid.{u3} M (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u3} M _inst_2)) w (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (OrderedAddCommMonoid.toAddCommMonoid.{u3} M (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u3} M _inst_2))))))) φ) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R _inst_1) _x) (MulHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (RingHom.instRingHomClassRingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))) (MvPolynomial.C.{u2, u1} R σ _inst_1) (MvPolynomial.coeff.{u2, u1} R σ _inst_1 (OfNat.ofNat.{u1} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) 0 (Zero.toOfNat0.{u1} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.zero.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)))) φ)))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.weighted_homogeneous_component_zero MvPolynomial.weightedHomogeneousComponent_zeroₓ'. -/
/-- If `M` is a `canonically_ordered_add_monoid`, then the `weighted_homogeneous_component`
  of weighted degree `0` of a polynomial is its constant coefficient. -/
@[simp]
theorem weightedHomogeneousComponent_zero [NoZeroSMulDivisors ℕ M] (hw : ∀ i : σ, w i ≠ 0) :
    weightedHomogeneousComponent w 0 φ = C (coeff 0 φ) := by
  classical
    ext1 d
    rcases em (d = 0) with (rfl | hd)
    · simp only [coeff_weighted_homogeneous_component, if_pos, map_zero, coeff_zero_C]
    · rw [coeff_weighted_homogeneous_component, if_neg, coeff_C, if_neg (Ne.symm hd)]
      simp only [weighted_degree', LinearMap.toAddMonoidHom_coe, Finsupp.total_apply, Finsupp.sum,
        sum_eq_zero_iff, Finsupp.mem_support_iff, Ne.def, smul_eq_zero, not_forall, not_or,
        and_self_left, exists_prop]
      simp only [Finsupp.ext_iff, Finsupp.coe_zero, Pi.zero_apply, not_forall] at hd
      obtain ⟨i, hi⟩ := hd
      exact ⟨i, hi, hw i⟩
#align mv_polynomial.weighted_homogeneous_component_zero MvPolynomial.weightedHomogeneousComponent_zero

end CanonicallyOrderedAddMonoid

end MvPolynomial

