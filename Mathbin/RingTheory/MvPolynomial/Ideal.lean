/-
Copyright (c) 2023 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser

! This file was ported from Lean 3 source module ring_theory.mv_polynomial.ideal
! leanprover-community/mathlib commit 4f81bc21e32048db7344b7867946e992cf5f68cc
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.MonoidAlgebra.Ideal
import Mathbin.Data.MvPolynomial.Division

/-!
# Lemmas about ideals of `mv_polynomial`

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Notably this contains results about monomial ideals.

## Main results

* `mv_polynomial.mem_ideal_span_monomial_image`
* `mv_polynomial.mem_ideal_span_X_image`
-/


variable {σ R : Type _}

namespace MvPolynomial

variable [CommSemiring R]

/- warning: mv_polynomial.mem_ideal_span_monomial_image -> MvPolynomial.mem_ideal_span_monomial_image is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align mv_polynomial.mem_ideal_span_monomial_image MvPolynomial.mem_ideal_span_monomial_imageₓ'. -/
/-- `x` is in a monomial ideal generated by `s` iff every element of of its support dominates one of
the generators. Note that `si ≤ xi` is analogous to saying that the monomial corresponding to `si`
divides the monomial corresponding to `xi`. -/
theorem mem_ideal_span_monomial_image {x : MvPolynomial σ R} {s : Set (σ →₀ ℕ)} :
    x ∈ Ideal.span ((fun s => monomial s (1 : R)) '' s) ↔ ∀ xi ∈ x.support, ∃ si ∈ s, si ≤ xi :=
  by
  refine' add_monoid_algebra.mem_ideal_span_of'_image.trans _
  simp_rw [le_iff_exists_add, add_comm]
  rfl
#align mv_polynomial.mem_ideal_span_monomial_image MvPolynomial.mem_ideal_span_monomial_image

/- warning: mv_polynomial.mem_ideal_span_monomial_image_iff_dvd -> MvPolynomial.mem_ideal_span_monomial_image_iff_dvd is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align mv_polynomial.mem_ideal_span_monomial_image_iff_dvd MvPolynomial.mem_ideal_span_monomial_image_iff_dvdₓ'. -/
theorem mem_ideal_span_monomial_image_iff_dvd {x : MvPolynomial σ R} {s : Set (σ →₀ ℕ)} :
    x ∈ Ideal.span ((fun s => monomial s (1 : R)) '' s) ↔
      ∀ xi ∈ x.support, ∃ si ∈ s, monomial si 1 ∣ monomial xi (x.coeff xi) :=
  by
  refine' mem_ideal_span_monomial_image.trans (forall₂_congr fun xi hxi => _)
  simp_rw [monomial_dvd_monomial, one_dvd, and_true_iff, mem_support_iff.mp hxi, false_or_iff]
#align mv_polynomial.mem_ideal_span_monomial_image_iff_dvd MvPolynomial.mem_ideal_span_monomial_image_iff_dvd

/- warning: mv_polynomial.mem_ideal_span_X_image -> MvPolynomial.mem_ideal_span_X_image is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {x : MvPolynomial.{u1, u2} σ R _inst_1} {s : Set.{u1} σ}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Ideal.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Ideal.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (Submodule.setLike.{max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) x (Ideal.span.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (Set.image.{u1, max u1 u2} σ (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.X.{u2, u1} R σ _inst_1) s))) (forall (m : Finsupp.{u1, 0} σ Nat Nat.hasZero), (Membership.Mem.{u1, u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (Finset.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) (Finset.hasMem.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) m (MvPolynomial.support.{u2, u1} R σ _inst_1 x)) -> (Exists.{succ u1} σ (fun (i : σ) => Exists.{0} (Membership.Mem.{u1, u1} σ (Set.{u1} σ) (Set.hasMem.{u1} σ) i s) (fun (H : Membership.Mem.{u1, u1} σ (Set.{u1} σ) (Set.hasMem.{u1} σ) i s) => Ne.{1} Nat (coeFn.{succ u1, succ u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (fun (_x : Finsupp.{u1, 0} σ Nat Nat.hasZero) => σ -> Nat) (Finsupp.coeFun.{u1, 0} σ Nat Nat.hasZero) m i) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))))))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : MvPolynomial.{u2, u1} σ R _inst_1} {s : Set.{u2} σ}, Iff (Membership.mem.{max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Ideal.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Ideal.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (Submodule.setLike.{max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) x (Ideal.span.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (Set.image.{u2, max u2 u1} σ (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.X.{u1, u2} R σ _inst_1) s))) (forall (m : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)), (Membership.mem.{u2, u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finset.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (Finset.instMembershipFinset.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) m (MvPolynomial.support.{u1, u2} R σ _inst_1 x)) -> (Exists.{succ u2} σ (fun (i : σ) => And (Membership.mem.{u2, u2} σ (Set.{u2} σ) (Set.instMembershipSet.{u2} σ) i s) (Ne.{1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : σ) => Nat) i) (FunLike.coe.{succ u2, succ u2, 1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) σ (fun (a : σ) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : σ) => Nat) a) (Finsupp.funLike.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) m i) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : σ) => Nat) i) 0 (instOfNatNat 0))))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.mem_ideal_span_X_image MvPolynomial.mem_ideal_span_X_imageₓ'. -/
/-- `x` is in a monomial ideal generated by variables `X` iff every element of of its support
has a component in `s`. -/
theorem mem_ideal_span_X_image {x : MvPolynomial σ R} {s : Set σ} :
    x ∈ Ideal.span (MvPolynomial.X '' s : Set (MvPolynomial σ R)) ↔
      ∀ m ∈ x.support, ∃ i ∈ s, (m : σ →₀ ℕ) i ≠ 0 :=
  by
  have := @mem_ideal_span_monomial_image σ R _ _ ((fun i => Finsupp.single i 1) '' s)
  rw [Set.image_image] at this
  refine' this.trans _
  simp [Nat.one_le_iff_ne_zero]
#align mv_polynomial.mem_ideal_span_X_image MvPolynomial.mem_ideal_span_X_image

end MvPolynomial

