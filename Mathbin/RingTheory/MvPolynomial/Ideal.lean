/-
Copyright (c) 2023 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser

! This file was ported from Lean 3 source module ring_theory.mv_polynomial.ideal
! leanprover-community/mathlib commit 4f81bc21e32048db7344b7867946e992cf5f68cc
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.MonoidAlgebra.Ideal
import Mathbin.Data.MvPolynomial.Division

/-!
# Lemmas about ideals of `mv_polynomial`

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Notably this contains results about monomial ideals.

## Main results

* `mv_polynomial.mem_ideal_span_monomial_image`
* `mv_polynomial.mem_ideal_span_X_image`
-/


variable {σ R : Type _}

namespace MvPolynomial

variable [CommSemiring R]

/- warning: mv_polynomial.mem_ideal_span_monomial_image -> MvPolynomial.mem_ideal_span_monomial_image is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {x : MvPolynomial.{u1, u2} σ R _inst_1} {s : Set.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Ideal.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Ideal.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (Submodule.setLike.{max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) x (Ideal.span.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (Set.image.{u1, max u1 u2} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (MvPolynomial.{u1, u2} σ R _inst_1) (fun (s : Finsupp.{u1, 0} σ Nat Nat.hasZero) => coeFn.{max (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (LinearMap.{u2, u2, u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => R -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, u2, max u1 u2} R R R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.monomial.{u2, u1} R σ _inst_1 s) (OfNat.ofNat.{u2} R 1 (OfNat.mk.{u2} R 1 (One.one.{u2} R (AddMonoidWithOne.toOne.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))))))) s))) (forall (xi : Finsupp.{u1, 0} σ Nat Nat.hasZero), (Membership.Mem.{u1, u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (Finset.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) (Finset.hasMem.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) xi (MvPolynomial.support.{u2, u1} R σ _inst_1 x)) -> (Exists.{succ u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (fun (si : Finsupp.{u1, 0} σ Nat Nat.hasZero) => Exists.{0} (Membership.Mem.{u1, u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (Set.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) (Set.hasMem.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) si s) (fun (H : Membership.Mem.{u1, u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (Set.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) (Set.hasMem.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) si s) => LE.le.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (Finsupp.hasLe.{u1, 0} σ Nat Nat.hasZero Nat.hasLe) si xi))))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : MvPolynomial.{u2, u1} σ R _inst_1} {s : Set.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))}, Iff (Membership.mem.{max u2 u1, max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Ideal.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (CommSemiring.toSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Ideal.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (CommSemiring.toSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Submodule.setLike.{max u2 u1, max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (CommSemiring.toSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Semiring.toNonAssocSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (CommSemiring.toSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (CommSemiring.toSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) x (Ideal.span.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (CommSemiring.toSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (Set.image.{u2, max u1 u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (fun (s : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => FunLike.coe.{max (succ u2) (succ u1), succ u1, max (succ u2) (succ u1)} (LinearMap.{u1, u1, u1, max u1 u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, max u2 u1} R R R (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.monomial.{u1, u2} R σ _inst_1 s) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) s))) (forall (xi : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)), (Membership.mem.{u2, u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finset.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (Finset.instMembershipFinset.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) xi (MvPolynomial.support.{u1, u2} R σ _inst_1 x)) -> (Exists.{succ u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (si : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => And (Membership.mem.{u2, u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Set.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (Set.instMembershipSet.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) si s) (LE.le.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.instLEFinsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) instLENat) si xi))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.mem_ideal_span_monomial_image MvPolynomial.mem_ideal_span_monomial_imageₓ'. -/
/-- `x` is in a monomial ideal generated by `s` iff every element of of its support dominates one of
the generators. Note that `si ≤ xi` is analogous to saying that the monomial corresponding to `si`
divides the monomial corresponding to `xi`. -/
theorem mem_ideal_span_monomial_image {x : MvPolynomial σ R} {s : Set (σ →₀ ℕ)} :
    x ∈ Ideal.span ((fun s => monomial s (1 : R)) '' s) ↔ ∀ xi ∈ x.support, ∃ si ∈ s, si ≤ xi :=
  by
  refine' add_monoid_algebra.mem_ideal_span_of'_image.trans _
  simp_rw [le_iff_exists_add, add_comm]
  rfl
#align mv_polynomial.mem_ideal_span_monomial_image MvPolynomial.mem_ideal_span_monomial_image

/- warning: mv_polynomial.mem_ideal_span_monomial_image_iff_dvd -> MvPolynomial.mem_ideal_span_monomial_image_iff_dvd is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {x : MvPolynomial.{u1, u2} σ R _inst_1} {s : Set.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Ideal.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Ideal.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (Submodule.setLike.{max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) x (Ideal.span.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (Set.image.{u1, max u1 u2} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (MvPolynomial.{u1, u2} σ R _inst_1) (fun (s : Finsupp.{u1, 0} σ Nat Nat.hasZero) => coeFn.{max (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (LinearMap.{u2, u2, u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => R -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, u2, max u1 u2} R R R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.monomial.{u2, u1} R σ _inst_1 s) (OfNat.ofNat.{u2} R 1 (OfNat.mk.{u2} R 1 (One.one.{u2} R (AddMonoidWithOne.toOne.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))))))) s))) (forall (xi : Finsupp.{u1, 0} σ Nat Nat.hasZero), (Membership.Mem.{u1, u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (Finset.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) (Finset.hasMem.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) xi (MvPolynomial.support.{u2, u1} R σ _inst_1 x)) -> (Exists.{succ u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (fun (si : Finsupp.{u1, 0} σ Nat Nat.hasZero) => Exists.{0} (Membership.Mem.{u1, u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (Set.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) (Set.hasMem.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) si s) (fun (H : Membership.Mem.{u1, u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (Set.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) (Set.hasMem.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) si s) => Dvd.Dvd.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (semigroupDvd.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (SemigroupWithZero.toSemigroup.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalSemiring.toSemigroupWithZero.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalCommSemiring.toNonUnitalSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toNonUnitalCommSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))) (coeFn.{max (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (LinearMap.{u2, u2, u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => R -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, u2, max u1 u2} R R R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.monomial.{u2, u1} R σ _inst_1 si) (OfNat.ofNat.{u2} R 1 (OfNat.mk.{u2} R 1 (One.one.{u2} R (AddMonoidWithOne.toOne.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))))))) (coeFn.{max (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (LinearMap.{u2, u2, u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => R -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, u2, max u1 u2} R R R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.monomial.{u2, u1} R σ _inst_1 xi) (MvPolynomial.coeff.{u2, u1} R σ _inst_1 xi x))))))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : MvPolynomial.{u2, u1} σ R _inst_1} {s : Set.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))}, Iff (Membership.mem.{max u2 u1, max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Ideal.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (CommSemiring.toSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Ideal.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (CommSemiring.toSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Submodule.setLike.{max u2 u1, max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (CommSemiring.toSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Semiring.toNonAssocSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (CommSemiring.toSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (CommSemiring.toSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) x (Ideal.span.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (CommSemiring.toSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (Set.image.{u2, max u1 u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (fun (s : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => FunLike.coe.{max (succ u2) (succ u1), succ u1, max (succ u2) (succ u1)} (LinearMap.{u1, u1, u1, max u1 u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, max u2 u1} R R R (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.monomial.{u1, u2} R σ _inst_1 s) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) s))) (forall (xi : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)), (Membership.mem.{u2, u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finset.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (Finset.instMembershipFinset.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) xi (MvPolynomial.support.{u1, u2} R σ _inst_1 x)) -> (Exists.{succ u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (si : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => And (Membership.mem.{u2, u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Set.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (Set.instMembershipSet.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) si s) (Dvd.dvd.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (semigroupDvd.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (SemigroupWithZero.toSemigroup.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (NonUnitalSemiring.toSemigroupWithZero.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (NonUnitalCommSemiring.toNonUnitalSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (CommSemiring.toNonUnitalCommSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u1, max (succ u2) (succ u1)} (LinearMap.{u1, u1, u1, max u1 u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, max u2 u1} R R R (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.monomial.{u1, u2} R σ _inst_1 si) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (FunLike.coe.{max (succ u2) (succ u1), succ u1, max (succ u2) (succ u1)} (LinearMap.{u1, u1, u1, max u1 u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : R) => MvPolynomial.{u2, u1} σ R _inst_1) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, max u2 u1} R R R (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.monomial.{u1, u2} R σ _inst_1 xi) (MvPolynomial.coeff.{u1, u2} R σ _inst_1 xi x))))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.mem_ideal_span_monomial_image_iff_dvd MvPolynomial.mem_ideal_span_monomial_image_iff_dvdₓ'. -/
theorem mem_ideal_span_monomial_image_iff_dvd {x : MvPolynomial σ R} {s : Set (σ →₀ ℕ)} :
    x ∈ Ideal.span ((fun s => monomial s (1 : R)) '' s) ↔
      ∀ xi ∈ x.support, ∃ si ∈ s, monomial si 1 ∣ monomial xi (x.coeff xi) :=
  by
  refine' mem_ideal_span_monomial_image.trans (forall₂_congr fun xi hxi => _)
  simp_rw [monomial_dvd_monomial, one_dvd, and_true_iff, mem_support_iff.mp hxi, false_or_iff]
#align mv_polynomial.mem_ideal_span_monomial_image_iff_dvd MvPolynomial.mem_ideal_span_monomial_image_iff_dvd

/- warning: mv_polynomial.mem_ideal_span_X_image -> MvPolynomial.mem_ideal_span_X_image is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {x : MvPolynomial.{u1, u2} σ R _inst_1} {s : Set.{u1} σ}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Ideal.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Ideal.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (Submodule.setLike.{max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) x (Ideal.span.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (Set.image.{u1, max u1 u2} σ (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.X.{u2, u1} R σ _inst_1) s))) (forall (m : Finsupp.{u1, 0} σ Nat Nat.hasZero), (Membership.Mem.{u1, u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (Finset.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) (Finset.hasMem.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) m (MvPolynomial.support.{u2, u1} R σ _inst_1 x)) -> (Exists.{succ u1} σ (fun (i : σ) => Exists.{0} (Membership.Mem.{u1, u1} σ (Set.{u1} σ) (Set.hasMem.{u1} σ) i s) (fun (H : Membership.Mem.{u1, u1} σ (Set.{u1} σ) (Set.hasMem.{u1} σ) i s) => Ne.{1} Nat (coeFn.{succ u1, succ u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (fun (_x : Finsupp.{u1, 0} σ Nat Nat.hasZero) => σ -> Nat) (Finsupp.coeFun.{u1, 0} σ Nat Nat.hasZero) m i) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))))))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : MvPolynomial.{u2, u1} σ R _inst_1} {s : Set.{u2} σ}, Iff (Membership.mem.{max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Ideal.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Ideal.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (Submodule.setLike.{max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) x (Ideal.span.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (Set.image.{u2, max u2 u1} σ (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.X.{u1, u2} R σ _inst_1) s))) (forall (m : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)), (Membership.mem.{u2, u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finset.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (Finset.instMembershipFinset.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) m (MvPolynomial.support.{u1, u2} R σ _inst_1 x)) -> (Exists.{succ u2} σ (fun (i : σ) => And (Membership.mem.{u2, u2} σ (Set.{u2} σ) (Set.instMembershipSet.{u2} σ) i s) (Ne.{1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : σ) => Nat) i) (FunLike.coe.{succ u2, succ u2, 1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) σ (fun (a : σ) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : σ) => Nat) a) (Finsupp.funLike.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) m i) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : σ) => Nat) i) 0 (instOfNatNat 0))))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.mem_ideal_span_X_image MvPolynomial.mem_ideal_span_X_imageₓ'. -/
/-- `x` is in a monomial ideal generated by variables `X` iff every element of of its support
has a component in `s`. -/
theorem mem_ideal_span_X_image {x : MvPolynomial σ R} {s : Set σ} :
    x ∈ Ideal.span (MvPolynomial.X '' s : Set (MvPolynomial σ R)) ↔
      ∀ m ∈ x.support, ∃ i ∈ s, (m : σ →₀ ℕ) i ≠ 0 :=
  by
  have := @mem_ideal_span_monomial_image σ R _ _ ((fun i => Finsupp.single i 1) '' s)
  rw [Set.image_image] at this
  refine' this.trans _
  simp [Nat.one_le_iff_ne_zero]
#align mv_polynomial.mem_ideal_span_X_image MvPolynomial.mem_ideal_span_X_image

end MvPolynomial

