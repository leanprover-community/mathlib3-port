/-
Copyright (c) 2020 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin, Eric Wieser

! This file was ported from Lean 3 source module ring_theory.mv_polynomial.homogeneous
! leanprover-community/mathlib commit 1b0a28e1c93409dbf6d69526863cd9984ef652ce
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.DirectSum.Internal
import Mathbin.Algebra.GradedMonoid
import Mathbin.Data.MvPolynomial.Variables

/-!
# Homogeneous polynomials

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

A multivariate polynomial `φ` is homogeneous of degree `n`
if all monomials occuring in `φ` have degree `n`.

## Main definitions/lemmas

* `is_homogeneous φ n`: a predicate that asserts that `φ` is homogeneous of degree `n`.
* `homogeneous_submodule σ R n`: the submodule of homogeneous polynomials of degree `n`.
* `homogeneous_component n`: the additive morphism that projects polynomials onto
  their summand that is homogeneous of degree `n`.
* `sum_homogeneous_component`: every polynomial is the sum of its homogeneous components

-/


open BigOperators

namespace MvPolynomial

variable {σ : Type _} {τ : Type _} {R : Type _} {S : Type _}

#print MvPolynomial.IsHomogeneous /-
/-
TODO
* create definition for `∑ i in d.support, d i`
* show that `mv_polynomial σ R ≃ₐ[R] ⨁ i, homogeneous_submodule σ R i`
-/
/-- A multivariate polynomial `φ` is homogeneous of degree `n`
if all monomials occuring in `φ` have degree `n`. -/
def IsHomogeneous [CommSemiring R] (φ : MvPolynomial σ R) (n : ℕ) :=
  ∀ ⦃d⦄, coeff d φ ≠ 0 → (∑ i in d.support, d i) = n
#align mv_polynomial.is_homogeneous MvPolynomial.IsHomogeneous
-/

variable (σ R)

#print MvPolynomial.homogeneousSubmodule /-
/-- The submodule of homogeneous `mv_polynomial`s of degree `n`. -/
def homogeneousSubmodule [CommSemiring R] (n : ℕ) : Submodule R (MvPolynomial σ R)
    where
  carrier := { x | x.Homogeneous n }
  smul_mem' r a ha c hc := by
    rw [coeff_smul] at hc
    apply ha
    intro h
    apply hc
    rw [h]
    exact smul_zero r
  zero_mem' d hd := False.elim (hd <| coeff_zero _)
  add_mem' a b ha hb c hc := by
    rw [coeff_add] at hc
    obtain h | h : coeff c a ≠ 0 ∨ coeff c b ≠ 0 :=
      by
      contrapose! hc
      simp only [hc, add_zero]
    · exact ha h
    · exact hb h
#align mv_polynomial.homogeneous_submodule MvPolynomial.homogeneousSubmodule
-/

variable {σ R}

#print MvPolynomial.mem_homogeneousSubmodule /-
@[simp]
theorem mem_homogeneousSubmodule [CommSemiring R] (n : ℕ) (p : MvPolynomial σ R) :
    p ∈ homogeneousSubmodule σ R n ↔ p.Homogeneous n :=
  Iff.rfl
#align mv_polynomial.mem_homogeneous_submodule MvPolynomial.mem_homogeneousSubmodule
-/

variable (σ R)

#print MvPolynomial.homogeneousSubmodule_eq_finsupp_supported /-
/-- While equal, the former has a convenient definitional reduction. -/
theorem homogeneousSubmodule_eq_finsupp_supported [CommSemiring R] (n : ℕ) :
    homogeneousSubmodule σ R n = Finsupp.supported _ R { d | (∑ i in d.support, d i) = n } :=
  by
  ext
  rw [Finsupp.mem_supported, Set.subset_def]
  simp only [Finsupp.mem_support_iff, Finset.mem_coe]
  rfl
#align mv_polynomial.homogeneous_submodule_eq_finsupp_supported MvPolynomial.homogeneousSubmodule_eq_finsupp_supported
-/

variable {σ R}

/- warning: mv_polynomial.homogeneous_submodule_mul -> MvPolynomial.homogeneousSubmodule_mul is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (m : Nat) (n : Nat), LE.le.{max u1 u2} (Submodule.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Preorder.toHasLe.{max u1 u2} (Submodule.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (PartialOrder.toPreorder.{max u1 u2} (Submodule.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (CompleteSemilatticeInf.toPartialOrder.{max u1 u2} (Submodule.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (CompleteLattice.toCompleteSemilatticeInf.{max u1 u2} (Submodule.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Submodule.completeLattice.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))))) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Submodule.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Submodule.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Submodule.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (instHMul.{max u1 u2} (Submodule.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Submodule.mul.{u2, max u1 u2} R _inst_1 (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)))) (MvPolynomial.homogeneousSubmodule.{u1, u2} σ R _inst_1 m) (MvPolynomial.homogeneousSubmodule.{u1, u2} σ R _inst_1 n)) (MvPolynomial.homogeneousSubmodule.{u1, u2} σ R _inst_1 (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m n))
but is expected to have type
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (m : Nat) (n : Nat), LE.le.{max u1 u2} (Submodule.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Preorder.toLE.{max u1 u2} (Submodule.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (PartialOrder.toPreorder.{max u1 u2} (Submodule.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (OmegaCompletePartialOrder.toPartialOrder.{max u1 u2} (Submodule.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (CompleteLattice.instOmegaCompletePartialOrder.{max u1 u2} (Submodule.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Submodule.completeLattice.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))))) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Submodule.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Submodule.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Submodule.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (instHMul.{max u1 u2} (Submodule.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Submodule.mul.{u2, max u1 u2} R _inst_1 (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)))) (MvPolynomial.homogeneousSubmodule.{u1, u2} σ R _inst_1 m) (MvPolynomial.homogeneousSubmodule.{u1, u2} σ R _inst_1 n)) (MvPolynomial.homogeneousSubmodule.{u1, u2} σ R _inst_1 (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m n))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.homogeneous_submodule_mul MvPolynomial.homogeneousSubmodule_mulₓ'. -/
theorem homogeneousSubmodule_mul [CommSemiring R] (m n : ℕ) :
    homogeneousSubmodule σ R m * homogeneousSubmodule σ R n ≤ homogeneousSubmodule σ R (m + n) :=
  by
  rw [Submodule.mul_le]
  intro φ hφ ψ hψ c hc
  rw [coeff_mul] at hc
  obtain ⟨⟨d, e⟩, hde, H⟩ := Finset.exists_ne_zero_of_sum_ne_zero hc
  have aux : coeff d φ ≠ 0 ∧ coeff e ψ ≠ 0 :=
    by
    contrapose! H
    by_cases h : coeff d φ = 0 <;>
      simp_all only [Ne.def, not_false_iff, MulZeroClass.zero_mul, MulZeroClass.mul_zero]
  specialize hφ aux.1
  specialize hψ aux.2
  rw [Finsupp.mem_antidiagonal] at hde
  classical
    have hd' : d.support ⊆ d.support ∪ e.support := Finset.subset_union_left _ _
    have he' : e.support ⊆ d.support ∪ e.support := Finset.subset_union_right _ _
    rw [← hde, ← hφ, ← hψ, Finset.sum_subset Finsupp.support_add, Finset.sum_subset hd',
      Finset.sum_subset he', ← Finset.sum_add_distrib]
    · congr
    all_goals intro i hi; apply finsupp.not_mem_support_iff.mp
#align mv_polynomial.homogeneous_submodule_mul MvPolynomial.homogeneousSubmodule_mul

section

variable [CommSemiring R]

variable {σ R}

/- warning: mv_polynomial.is_homogeneous_monomial -> MvPolynomial.isHomogeneous_monomial is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (d : Finsupp.{u1, 0} σ Nat Nat.hasZero) (r : R) (n : Nat), (Eq.{1} Nat (Finset.sum.{0, u1} Nat σ Nat.addCommMonoid (Finsupp.support.{u1, 0} σ Nat Nat.hasZero d) (fun (i : σ) => coeFn.{succ u1, succ u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (fun (_x : Finsupp.{u1, 0} σ Nat Nat.hasZero) => σ -> Nat) (Finsupp.coeFun.{u1, 0} σ Nat Nat.hasZero) d i)) n) -> (MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 (coeFn.{max (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (LinearMap.{u2, u2, u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => R -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, u2, max u1 u2} R R R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.monomial.{u2, u1} R σ _inst_1 d) r) n)
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (d : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (r : R) (n : Nat), (Eq.{1} Nat (Finset.sum.{0, u2} Nat σ Nat.addCommMonoid (Finsupp.support.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) d) (fun (i : σ) => FunLike.coe.{succ u2, succ u2, 1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) σ (fun (_x : σ) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : σ) => Nat) _x) (Finsupp.funLike.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) d i)) n) -> (MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u1, max (succ u2) (succ u1)} (LinearMap.{u1, u1, u1, max u1 u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : R) => MvPolynomial.{u2, u1} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, max u2 u1} R R R (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.monomial.{u1, u2} R σ _inst_1 d) r) n)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_homogeneous_monomial MvPolynomial.isHomogeneous_monomialₓ'. -/
theorem isHomogeneous_monomial (d : σ →₀ ℕ) (r : R) (n : ℕ) (hn : (∑ i in d.support, d i) = n) :
    IsHomogeneous (monomial d r) n := by
  intro c hc
  classical
    rw [coeff_monomial] at hc
    split_ifs  at hc with h
    · subst c
      exact hn
    · contradiction
#align mv_polynomial.is_homogeneous_monomial MvPolynomial.isHomogeneous_monomial

variable (σ) {R}

/- warning: mv_polynomial.is_homogeneous_of_total_degree_zero -> MvPolynomial.isHomogeneous_of_totalDegree_zero is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {p : MvPolynomial.{u1, u2} σ R _inst_1}, (Eq.{1} Nat (MvPolynomial.totalDegree.{u2, u1} R σ _inst_1 p) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> (MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 p (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))
but is expected to have type
  forall (σ : Type.{u2}) {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : MvPolynomial.{u2, u1} σ R _inst_1}, (Eq.{1} Nat (MvPolynomial.totalDegree.{u1, u2} R σ _inst_1 p) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> (MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 p (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_homogeneous_of_total_degree_zero MvPolynomial.isHomogeneous_of_totalDegree_zeroₓ'. -/
theorem isHomogeneous_of_totalDegree_zero {p : MvPolynomial σ R} (hp : p.totalDegree = 0) :
    IsHomogeneous p 0 := by
  erw [total_degree, Finset.sup_eq_bot_iff] at hp
  -- we have to do this in two steps to stop simp changing bot to zero
  simp_rw [mem_support_iff] at hp
  exact hp
#align mv_polynomial.is_homogeneous_of_total_degree_zero MvPolynomial.isHomogeneous_of_totalDegree_zero

/- warning: mv_polynomial.is_homogeneous_C -> MvPolynomial.isHomogeneous_C is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (r : R), MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 (coeFn.{max (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (RingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (fun (_x : RingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) => R -> (MvPolynomial.{u1, u2} σ R _inst_1)) (RingHom.hasCoeToFun.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (MvPolynomial.C.{u2, u1} R σ _inst_1) r) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))
but is expected to have type
  forall (σ : Type.{u2}) {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (r : R), MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u1, max (succ u2) (succ u1)} (RingHom.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u2, u1} σ R _inst_1) _x) (MulHomClass.toFunLike.{max u2 u1, u1, max u2 u1} (RingHom.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))) R (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, max u2 u1} (RingHom.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))) R (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, max u2 u1} (RingHom.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))) R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))) (RingHom.instRingHomClassRingHom.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))))) (MvPolynomial.C.{u1, u2} R σ _inst_1) r) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_homogeneous_C MvPolynomial.isHomogeneous_Cₓ'. -/
theorem isHomogeneous_C (r : R) : IsHomogeneous (C r : MvPolynomial σ R) 0 :=
  by
  apply is_homogeneous_monomial
  simp only [Finsupp.zero_apply, Finset.sum_const_zero]
#align mv_polynomial.is_homogeneous_C MvPolynomial.isHomogeneous_C

variable (σ R)

/- warning: mv_polynomial.is_homogeneous_zero -> MvPolynomial.isHomogeneous_zero is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) (R : Type.{u2}) [_inst_1 : CommSemiring.{u2} R] (n : Nat), MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 (OfNat.ofNat.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (OfNat.mk.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (Zero.zero.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MulZeroClass.toHasZero.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))))) n
but is expected to have type
  forall (σ : Type.{u2}) (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] (n : Nat), MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 (OfNat.ofNat.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommMonoidWithZero.toZero.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toCommMonoidWithZero.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) n
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_homogeneous_zero MvPolynomial.isHomogeneous_zeroₓ'. -/
theorem isHomogeneous_zero (n : ℕ) : IsHomogeneous (0 : MvPolynomial σ R) n :=
  (homogeneousSubmodule σ R n).zero_mem
#align mv_polynomial.is_homogeneous_zero MvPolynomial.isHomogeneous_zero

/- warning: mv_polynomial.is_homogeneous_one -> MvPolynomial.isHomogeneous_one is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) (R : Type.{u2}) [_inst_1 : CommSemiring.{u2} R], MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 (OfNat.ofNat.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 1 (OfNat.mk.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 1 (One.one.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (AddMonoidWithOne.toOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))))) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))
but is expected to have type
  forall (σ : Type.{u2}) (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R], MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 (OfNat.ofNat.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) 1 (One.toOfNat1.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_homogeneous_one MvPolynomial.isHomogeneous_oneₓ'. -/
theorem isHomogeneous_one : IsHomogeneous (1 : MvPolynomial σ R) 0 :=
  isHomogeneous_C _ _
#align mv_polynomial.is_homogeneous_one MvPolynomial.isHomogeneous_one

variable {σ} (R)

/- warning: mv_polynomial.is_homogeneous_X -> MvPolynomial.isHomogeneous_X is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} (R : Type.{u2}) [_inst_1 : CommSemiring.{u2} R] (i : σ), MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 (MvPolynomial.X.{u2, u1} R σ _inst_1 i) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))
but is expected to have type
  forall {σ : Type.{u2}} (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] (i : σ), MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 (MvPolynomial.X.{u1, u2} R σ _inst_1 i) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_homogeneous_X MvPolynomial.isHomogeneous_Xₓ'. -/
theorem isHomogeneous_X (i : σ) : IsHomogeneous (X i : MvPolynomial σ R) 1 :=
  by
  apply is_homogeneous_monomial
  simp only [Finsupp.support_single_ne_zero _ one_ne_zero, Finset.sum_singleton]
  exact Finsupp.single_eq_same
#align mv_polynomial.is_homogeneous_X MvPolynomial.isHomogeneous_X

end

namespace IsHomogeneous

variable [CommSemiring R] {φ ψ : MvPolynomial σ R} {m n : ℕ}

/- warning: mv_polynomial.is_homogeneous.coeff_eq_zero -> MvPolynomial.IsHomogeneous.coeff_eq_zero is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {φ : MvPolynomial.{u1, u2} σ R _inst_1} {n : Nat}, (MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 φ n) -> (forall (d : Finsupp.{u1, 0} σ Nat Nat.hasZero), (Ne.{1} Nat (Finset.sum.{0, u1} Nat σ Nat.addCommMonoid (Finsupp.support.{u1, 0} σ Nat Nat.hasZero d) (fun (i : σ) => coeFn.{succ u1, succ u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (fun (_x : Finsupp.{u1, 0} σ Nat Nat.hasZero) => σ -> Nat) (Finsupp.coeFun.{u1, 0} σ Nat Nat.hasZero) d i)) n) -> (Eq.{succ u2} R (MvPolynomial.coeff.{u2, u1} R σ _inst_1 d φ) (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))))))))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {φ : MvPolynomial.{u2, u1} σ R _inst_1} {n : Nat}, (MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 φ n) -> (forall (d : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)), (Ne.{1} Nat (Finset.sum.{0, u2} Nat σ Nat.addCommMonoid (Finsupp.support.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) d) (fun (i : σ) => FunLike.coe.{succ u2, succ u2, 1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) σ (fun (_x : σ) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : σ) => Nat) _x) (Finsupp.funLike.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) d i)) n) -> (Eq.{succ u1} R (MvPolynomial.coeff.{u1, u2} R σ _inst_1 d φ) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1))))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_homogeneous.coeff_eq_zero MvPolynomial.IsHomogeneous.coeff_eq_zeroₓ'. -/
theorem coeff_eq_zero (hφ : IsHomogeneous φ n) (d : σ →₀ ℕ) (hd : (∑ i in d.support, d i) ≠ n) :
    coeff d φ = 0 := by
  have aux := mt (@hφ d) hd
  classical rwa [Classical.not_not] at aux
#align mv_polynomial.is_homogeneous.coeff_eq_zero MvPolynomial.IsHomogeneous.coeff_eq_zero

/- warning: mv_polynomial.is_homogeneous.inj_right -> MvPolynomial.IsHomogeneous.inj_right is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {φ : MvPolynomial.{u1, u2} σ R _inst_1} {m : Nat} {n : Nat}, (MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 φ m) -> (MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 φ n) -> (Ne.{max (succ u1) (succ u2)} (MvPolynomial.{u1, u2} σ R _inst_1) φ (OfNat.ofNat.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (OfNat.mk.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (Zero.zero.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MulZeroClass.toHasZero.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))))))) -> (Eq.{1} Nat m n)
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {φ : MvPolynomial.{u2, u1} σ R _inst_1} {m : Nat} {n : Nat}, (MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 φ m) -> (MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 φ n) -> (Ne.{max (succ u2) (succ u1)} (MvPolynomial.{u2, u1} σ R _inst_1) φ (OfNat.ofNat.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommMonoidWithZero.toZero.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toCommMonoidWithZero.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))))) -> (Eq.{1} Nat m n)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_homogeneous.inj_right MvPolynomial.IsHomogeneous.inj_rightₓ'. -/
theorem inj_right (hm : IsHomogeneous φ m) (hn : IsHomogeneous φ n) (hφ : φ ≠ 0) : m = n :=
  by
  obtain ⟨d, hd⟩ : ∃ d, coeff d φ ≠ 0 := exists_coeff_ne_zero hφ
  rw [← hm hd, ← hn hd]
#align mv_polynomial.is_homogeneous.inj_right MvPolynomial.IsHomogeneous.inj_right

/- warning: mv_polynomial.is_homogeneous.add -> MvPolynomial.IsHomogeneous.add is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {φ : MvPolynomial.{u1, u2} σ R _inst_1} {ψ : MvPolynomial.{u1, u2} σ R _inst_1} {n : Nat}, (MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 φ n) -> (MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 ψ n) -> (MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (instHAdd.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Distrib.toHasAdd.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))) φ ψ) n)
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {φ : MvPolynomial.{u2, u1} σ R _inst_1} {ψ : MvPolynomial.{u2, u1} σ R _inst_1} {n : Nat}, (MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 φ n) -> (MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 ψ n) -> (MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (instHAdd.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Distrib.toAdd.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))))) φ ψ) n)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_homogeneous.add MvPolynomial.IsHomogeneous.addₓ'. -/
theorem add (hφ : IsHomogeneous φ n) (hψ : IsHomogeneous ψ n) : IsHomogeneous (φ + ψ) n :=
  (homogeneousSubmodule σ R n).add_mem hφ hψ
#align mv_polynomial.is_homogeneous.add MvPolynomial.IsHomogeneous.add

/- warning: mv_polynomial.is_homogeneous.sum -> MvPolynomial.IsHomogeneous.sum is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {ι : Type.{u3}} (s : Finset.{u3} ι) (φ : ι -> (MvPolynomial.{u1, u2} σ R _inst_1)) (n : Nat), (forall (i : ι), (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) -> (MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 (φ i) n)) -> (MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 (Finset.sum.{max u1 u2, u3} (MvPolynomial.{u1, u2} σ R _inst_1) ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) s (fun (i : ι) => φ i)) n)
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {ι : Type.{u3}} (s : Finset.{u3} ι) (φ : ι -> (MvPolynomial.{u2, u1} σ R _inst_1)) (n : Nat), (forall (i : ι), (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) -> (MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 (φ i) n)) -> (MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 (Finset.sum.{max u1 u2, u3} (MvPolynomial.{u2, u1} σ R _inst_1) ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) s (fun (i : ι) => φ i)) n)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_homogeneous.sum MvPolynomial.IsHomogeneous.sumₓ'. -/
theorem sum {ι : Type _} (s : Finset ι) (φ : ι → MvPolynomial σ R) (n : ℕ)
    (h : ∀ i ∈ s, IsHomogeneous (φ i) n) : IsHomogeneous (∑ i in s, φ i) n :=
  (homogeneousSubmodule σ R n).sum_mem h
#align mv_polynomial.is_homogeneous.sum MvPolynomial.IsHomogeneous.sum

/- warning: mv_polynomial.is_homogeneous.mul -> MvPolynomial.IsHomogeneous.mul is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {φ : MvPolynomial.{u1, u2} σ R _inst_1} {ψ : MvPolynomial.{u1, u2} σ R _inst_1} {m : Nat} {n : Nat}, (MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 φ m) -> (MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 ψ n) -> (MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (instHMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Distrib.toHasMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))) φ ψ) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m n))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {φ : MvPolynomial.{u2, u1} σ R _inst_1} {ψ : MvPolynomial.{u2, u1} σ R _inst_1} {m : Nat} {n : Nat}, (MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 φ m) -> (MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 ψ n) -> (MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (instHMul.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))))) φ ψ) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m n))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_homogeneous.mul MvPolynomial.IsHomogeneous.mulₓ'. -/
theorem mul (hφ : IsHomogeneous φ m) (hψ : IsHomogeneous ψ n) : IsHomogeneous (φ * ψ) (m + n) :=
  homogeneousSubmodule_mul m n <| Submodule.mul_mem_mul hφ hψ
#align mv_polynomial.is_homogeneous.mul MvPolynomial.IsHomogeneous.mul

/- warning: mv_polynomial.is_homogeneous.prod -> MvPolynomial.IsHomogeneous.prod is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {ι : Type.{u3}} (s : Finset.{u3} ι) (φ : ι -> (MvPolynomial.{u1, u2} σ R _inst_1)) (n : ι -> Nat), (forall (i : ι), (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) -> (MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 (φ i) (n i))) -> (MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 (Finset.prod.{max u1 u2, u3} (MvPolynomial.{u1, u2} σ R _inst_1) ι (CommSemiring.toCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) s (fun (i : ι) => φ i)) (Finset.sum.{0, u3} Nat ι Nat.addCommMonoid s (fun (i : ι) => n i)))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {ι : Type.{u3}} (s : Finset.{u3} ι) (φ : ι -> (MvPolynomial.{u2, u1} σ R _inst_1)) (n : ι -> Nat), (forall (i : ι), (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) -> (MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 (φ i) (n i))) -> (MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 (Finset.prod.{max u1 u2, u3} (MvPolynomial.{u2, u1} σ R _inst_1) ι (CommSemiring.toCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) s (fun (i : ι) => φ i)) (Finset.sum.{0, u3} Nat ι Nat.addCommMonoid s (fun (i : ι) => n i)))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_homogeneous.prod MvPolynomial.IsHomogeneous.prodₓ'. -/
theorem prod {ι : Type _} (s : Finset ι) (φ : ι → MvPolynomial σ R) (n : ι → ℕ)
    (h : ∀ i ∈ s, IsHomogeneous (φ i) (n i)) : IsHomogeneous (∏ i in s, φ i) (∑ i in s, n i) := by
  classical
    revert h
    apply Finset.induction_on s
    · intro
      simp only [is_homogeneous_one, Finset.sum_empty, Finset.prod_empty]
    · intro i s his IH h
      simp only [his, Finset.prod_insert, Finset.sum_insert, not_false_iff]
      apply (h i (Finset.mem_insert_self _ _)).mul (IH _)
      intro j hjs
      exact h j (Finset.mem_insert_of_mem hjs)
#align mv_polynomial.is_homogeneous.prod MvPolynomial.IsHomogeneous.prod

/- warning: mv_polynomial.is_homogeneous.total_degree -> MvPolynomial.IsHomogeneous.totalDegree is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {φ : MvPolynomial.{u1, u2} σ R _inst_1} {n : Nat}, (MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 φ n) -> (Ne.{max (succ u1) (succ u2)} (MvPolynomial.{u1, u2} σ R _inst_1) φ (OfNat.ofNat.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (OfNat.mk.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (Zero.zero.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MulZeroClass.toHasZero.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))))))) -> (Eq.{1} Nat (MvPolynomial.totalDegree.{u2, u1} R σ _inst_1 φ) n)
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {φ : MvPolynomial.{u2, u1} σ R _inst_1} {n : Nat}, (MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 φ n) -> (Ne.{max (succ u2) (succ u1)} (MvPolynomial.{u2, u1} σ R _inst_1) φ (OfNat.ofNat.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommMonoidWithZero.toZero.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toCommMonoidWithZero.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))))) -> (Eq.{1} Nat (MvPolynomial.totalDegree.{u1, u2} R σ _inst_1 φ) n)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.is_homogeneous.total_degree MvPolynomial.IsHomogeneous.totalDegreeₓ'. -/
theorem totalDegree (hφ : IsHomogeneous φ n) (h : φ ≠ 0) : totalDegree φ = n :=
  by
  rw [total_degree]
  apply le_antisymm
  · apply Finset.sup_le
    intro d hd
    rw [mem_support_iff] at hd
    rw [Finsupp.sum, hφ hd]
  · obtain ⟨d, hd⟩ : ∃ d, coeff d φ ≠ 0 := exists_coeff_ne_zero h
    simp only [← hφ hd, Finsupp.sum]
    replace hd := finsupp.mem_support_iff.mpr hd
    exact Finset.le_sup hd
#align mv_polynomial.is_homogeneous.total_degree MvPolynomial.IsHomogeneous.totalDegree

#print MvPolynomial.IsHomogeneous.HomogeneousSubmodule.gcommSemiring /-
/--
The homogeneous submodules form a graded ring. This instance is used by `direct_sum.comm_semiring`
and `direct_sum.algebra`. -/
instance HomogeneousSubmodule.gcommSemiring : SetLike.GradedMonoid (homogeneousSubmodule σ R)
    where
  one_mem := isHomogeneous_one σ R
  mul_mem i j xi xj := IsHomogeneous.mul
#align mv_polynomial.is_homogeneous.homogeneous_submodule.gcomm_semiring MvPolynomial.IsHomogeneous.HomogeneousSubmodule.gcommSemiring
-/

open DirectSum

noncomputable example : CommSemiring (⨁ i, homogeneousSubmodule σ R i) :=
  inferInstance

noncomputable example : Algebra R (⨁ i, homogeneousSubmodule σ R i) :=
  inferInstance

end IsHomogeneous

section

noncomputable section

open Finset

#print MvPolynomial.homogeneousComponent /-
/-- `homogeneous_component n φ` is the part of `φ` that is homogeneous of degree `n`.
See `sum_homogeneous_component` for the statement that `φ` is equal to the sum
of all its homogeneous components. -/
def homogeneousComponent [CommSemiring R] (n : ℕ) : MvPolynomial σ R →ₗ[R] MvPolynomial σ R :=
  (Submodule.subtype _).comp <| Finsupp.restrictDom _ _ { d | (∑ i in d.support, d i) = n }
#align mv_polynomial.homogeneous_component MvPolynomial.homogeneousComponent
-/

section HomogeneousComponent

open Finset

variable [CommSemiring R] (n : ℕ) (φ ψ : MvPolynomial σ R)

/- warning: mv_polynomial.coeff_homogeneous_component -> MvPolynomial.coeff_homogeneousComponent is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (n : Nat) (φ : MvPolynomial.{u1, u2} σ R _inst_1) (d : Finsupp.{u1, 0} σ Nat Nat.hasZero), Eq.{succ u2} R (MvPolynomial.coeff.{u2, u1} R σ _inst_1 d (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => (MvPolynomial.{u1, u2} σ R _inst_1) -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} R R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u1, u2} σ R _inst_1 n) φ)) (ite.{succ u2} R (Eq.{1} Nat (Finset.sum.{0, u1} Nat σ Nat.addCommMonoid (Finsupp.support.{u1, 0} σ Nat Nat.hasZero d) (fun (i : σ) => coeFn.{succ u1, succ u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (fun (_x : Finsupp.{u1, 0} σ Nat Nat.hasZero) => σ -> Nat) (Finsupp.coeFun.{u1, 0} σ Nat Nat.hasZero) d i)) n) (Nat.decidableEq (Finset.sum.{0, u1} Nat σ Nat.addCommMonoid (Finsupp.support.{u1, 0} σ Nat Nat.hasZero d) (fun (i : σ) => coeFn.{succ u1, succ u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (fun (_x : Finsupp.{u1, 0} σ Nat Nat.hasZero) => σ -> Nat) (Finsupp.coeFun.{u1, 0} σ Nat Nat.hasZero) d i)) n) (MvPolynomial.coeff.{u2, u1} R σ _inst_1 d φ) (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))))))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (n : Nat) (φ : MvPolynomial.{u2, u1} σ R _inst_1) (d : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)), Eq.{succ u1} R (MvPolynomial.coeff.{u1, u2} R σ _inst_1 d (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u1, u1, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.{u2, u1} σ R _inst_1) (fun (_x : MvPolynomial.{u2, u1} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u1 u2, max u1 u2} R R (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u2, u1} σ R _inst_1 n) φ)) (ite.{succ u1} R (Eq.{1} Nat (Finset.sum.{0, u2} Nat σ Nat.addCommMonoid (Finsupp.support.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) d) (fun (i : σ) => FunLike.coe.{succ u2, succ u2, 1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) σ (fun (_x : σ) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : σ) => Nat) _x) (Finsupp.funLike.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) d i)) n) (instDecidableEqNat (Finset.sum.{0, u2} Nat σ Nat.addCommMonoid (Finsupp.support.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) d) (fun (i : σ) => FunLike.coe.{succ u2, succ u2, 1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) σ (fun (_x : σ) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : σ) => Nat) _x) (Finsupp.funLike.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) d i)) n) (MvPolynomial.coeff.{u1, u2} R σ _inst_1 d φ) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.coeff_homogeneous_component MvPolynomial.coeff_homogeneousComponentₓ'. -/
theorem coeff_homogeneousComponent (d : σ →₀ ℕ) :
    coeff d (homogeneousComponent n φ) = if (∑ i in d.support, d i) = n then coeff d φ else 0 := by
  convert Finsupp.filter_apply (fun d : σ →₀ ℕ => (∑ i in d.support, d i) = n) φ d
#align mv_polynomial.coeff_homogeneous_component MvPolynomial.coeff_homogeneousComponent

/- warning: mv_polynomial.homogeneous_component_apply -> MvPolynomial.homogeneousComponent_apply is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (n : Nat) (φ : MvPolynomial.{u1, u2} σ R _inst_1), Eq.{max (succ u1) (succ u2)} (MvPolynomial.{u1, u2} σ R _inst_1) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => (MvPolynomial.{u1, u2} σ R _inst_1) -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} R R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u1, u2} σ R _inst_1 n) φ) (Finset.sum.{max u1 u2, u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Finsupp.{u1, 0} σ Nat Nat.hasZero) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Finset.filter.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (fun (d : Finsupp.{u1, 0} σ Nat Nat.hasZero) => Eq.{1} Nat (Finset.sum.{0, u1} Nat σ Nat.addCommMonoid (Finsupp.support.{u1, 0} σ Nat Nat.hasZero d) (fun (i : σ) => coeFn.{succ u1, succ u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (fun (_x : Finsupp.{u1, 0} σ Nat Nat.hasZero) => σ -> Nat) (Finsupp.coeFun.{u1, 0} σ Nat Nat.hasZero) d i)) n) (fun (a : Finsupp.{u1, 0} σ Nat Nat.hasZero) => Nat.decidableEq (Finset.sum.{0, u1} Nat σ Nat.addCommMonoid (Finsupp.support.{u1, 0} σ Nat Nat.hasZero a) (fun (i : σ) => coeFn.{succ u1, succ u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (fun (_x : Finsupp.{u1, 0} σ Nat Nat.hasZero) => σ -> Nat) (Finsupp.coeFun.{u1, 0} σ Nat Nat.hasZero) a i)) n) (MvPolynomial.support.{u2, u1} R σ _inst_1 φ)) (fun (d : Finsupp.{u1, 0} σ Nat Nat.hasZero) => coeFn.{max (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (LinearMap.{u2, u2, u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => R -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, u2, max u1 u2} R R R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.monomial.{u2, u1} R σ _inst_1 d) (MvPolynomial.coeff.{u2, u1} R σ _inst_1 d φ)))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (n : Nat) (φ : MvPolynomial.{u2, u1} σ R _inst_1), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) φ) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u1, u1, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.{u2, u1} σ R _inst_1) (fun (_x : MvPolynomial.{u2, u1} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u1 u2, max u1 u2} R R (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u2, u1} σ R _inst_1 n) φ) (Finset.sum.{max u2 u1, u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Finset.filter.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (d : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => Eq.{1} Nat (Finset.sum.{0, u2} Nat σ Nat.addCommMonoid (Finsupp.support.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) d) (fun (i : σ) => FunLike.coe.{succ u2, succ u2, 1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) σ (fun (_x : σ) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : σ) => Nat) _x) (Finsupp.funLike.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) d i)) n) (fun (a : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => instDecidableEqNat (Finset.sum.{0, u2} Nat σ Nat.addCommMonoid (Finsupp.support.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) a) (fun (i : σ) => FunLike.coe.{succ u2, succ u2, 1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) σ (fun (_x : σ) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : σ) => Nat) _x) (Finsupp.funLike.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) a i)) n) (MvPolynomial.support.{u1, u2} R σ _inst_1 φ)) (fun (d : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => FunLike.coe.{max (succ u2) (succ u1), succ u1, max (succ u2) (succ u1)} (LinearMap.{u1, u1, u1, max u1 u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : R) => MvPolynomial.{u2, u1} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, max u2 u1} R R R (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.monomial.{u1, u2} R σ _inst_1 d) (MvPolynomial.coeff.{u1, u2} R σ _inst_1 d φ)))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.homogeneous_component_apply MvPolynomial.homogeneousComponent_applyₓ'. -/
theorem homogeneousComponent_apply :
    homogeneousComponent n φ =
      ∑ d in φ.support.filterₓ fun d => (∑ i in d.support, d i) = n, monomial d (coeff d φ) :=
  by convert Finsupp.filter_eq_sum (fun d : σ →₀ ℕ => (∑ i in d.support, d i) = n) φ
#align mv_polynomial.homogeneous_component_apply MvPolynomial.homogeneousComponent_apply

/- warning: mv_polynomial.homogeneous_component_is_homogeneous -> MvPolynomial.homogeneousComponent_isHomogeneous is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (n : Nat) (φ : MvPolynomial.{u1, u2} σ R _inst_1), MvPolynomial.IsHomogeneous.{u1, u2} σ R _inst_1 (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => (MvPolynomial.{u1, u2} σ R _inst_1) -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} R R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u1, u2} σ R _inst_1 n) φ) n
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (n : Nat) (φ : MvPolynomial.{u2, u1} σ R _inst_1), MvPolynomial.IsHomogeneous.{u2, u1} σ R _inst_1 (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u1, u1, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.{u2, u1} σ R _inst_1) (fun (_x : MvPolynomial.{u2, u1} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u1 u2, max u1 u2} R R (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u2, u1} σ R _inst_1 n) φ) n
Case conversion may be inaccurate. Consider using '#align mv_polynomial.homogeneous_component_is_homogeneous MvPolynomial.homogeneousComponent_isHomogeneousₓ'. -/
theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n φ).Homogeneous n :=
  by
  intro d hd
  contrapose! hd
  rw [coeff_homogeneous_component, if_neg hd]
#align mv_polynomial.homogeneous_component_is_homogeneous MvPolynomial.homogeneousComponent_isHomogeneous

/- warning: mv_polynomial.homogeneous_component_zero -> MvPolynomial.homogeneousComponent_zero is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (φ : MvPolynomial.{u1, u2} σ R _inst_1), Eq.{max (succ u1) (succ u2)} (MvPolynomial.{u1, u2} σ R _inst_1) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => (MvPolynomial.{u1, u2} σ R _inst_1) -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} R R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u1, u2} σ R _inst_1 (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) φ) (coeFn.{max (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (RingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (fun (_x : RingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) => R -> (MvPolynomial.{u1, u2} σ R _inst_1)) (RingHom.hasCoeToFun.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (MvPolynomial.C.{u2, u1} R σ _inst_1) (MvPolynomial.coeff.{u2, u1} R σ _inst_1 (OfNat.ofNat.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) 0 (OfNat.mk.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) 0 (Zero.zero.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (Finsupp.zero.{u1, 0} σ Nat Nat.hasZero)))) φ))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (φ : MvPolynomial.{u2, u1} σ R _inst_1), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) φ) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u1, u1, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.{u2, u1} σ R _inst_1) (fun (_x : MvPolynomial.{u2, u1} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u1 u2, max u1 u2} R R (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u2, u1} σ R _inst_1 (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) φ) (FunLike.coe.{max (succ u2) (succ u1), succ u1, max (succ u2) (succ u1)} (RingHom.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u2, u1} σ R _inst_1) _x) (MulHomClass.toFunLike.{max u2 u1, u1, max u2 u1} (RingHom.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))) R (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, max u2 u1} (RingHom.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))) R (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, max u2 u1} (RingHom.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))) R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))) (RingHom.instRingHomClassRingHom.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))))) (MvPolynomial.C.{u1, u2} R σ _inst_1) (MvPolynomial.coeff.{u1, u2} R σ _inst_1 (OfNat.ofNat.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) 0 (Zero.toOfNat0.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.zero.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)))) φ))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.homogeneous_component_zero MvPolynomial.homogeneousComponent_zeroₓ'. -/
@[simp]
theorem homogeneousComponent_zero : homogeneousComponent 0 φ = C (coeff 0 φ) :=
  by
  ext1 d
  rcases em (d = 0) with (rfl | hd)
  ·
    classical simp only [coeff_homogeneous_component, sum_eq_zero_iff, Finsupp.zero_apply, if_true,
        coeff_C, eq_self_iff_true, forall_true_iff]
  · rw [coeff_homogeneous_component, if_neg, coeff_C, if_neg (Ne.symm hd)]
    simp only [Finsupp.ext_iff, Finsupp.zero_apply] at hd
    simp [hd]
#align mv_polynomial.homogeneous_component_zero MvPolynomial.homogeneousComponent_zero

/- warning: mv_polynomial.homogeneous_component_C_mul -> MvPolynomial.homogeneousComponent_C_mul is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (φ : MvPolynomial.{u1, u2} σ R _inst_1) (n : Nat) (r : R), Eq.{max (succ u1) (succ u2)} (MvPolynomial.{u1, u2} σ R _inst_1) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => (MvPolynomial.{u1, u2} σ R _inst_1) -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} R R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u1, u2} σ R _inst_1 n) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (instHMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Distrib.toHasMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))) (coeFn.{max (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (RingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (fun (_x : RingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) => R -> (MvPolynomial.{u1, u2} σ R _inst_1)) (RingHom.hasCoeToFun.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (MvPolynomial.C.{u2, u1} R σ _inst_1) r) φ)) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (instHMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Distrib.toHasMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))) (coeFn.{max (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (RingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (fun (_x : RingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) => R -> (MvPolynomial.{u1, u2} σ R _inst_1)) (RingHom.hasCoeToFun.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (MvPolynomial.C.{u2, u1} R σ _inst_1) r) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => (MvPolynomial.{u1, u2} σ R _inst_1) -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} R R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u1, u2} σ R _inst_1 n) φ))
but is expected to have type
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (φ : MvPolynomial.{u1, u2} σ R _inst_1) (n : Nat) (r : R), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) (HMul.hMul.{max u2 u1, max u1 u2, max u2 u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (instHMul.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (Semiring.toNonAssocSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (CommSemiring.toSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) a) (MulHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (RingHom.instRingHomClassRingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))) (MvPolynomial.C.{u2, u1} R σ _inst_1) r) φ)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (LinearMap.{u2, u2, max u2 u1, max u2 u1} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.{u1, u2} σ R _inst_1) (fun (_x : MvPolynomial.{u1, u2} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u2 u1, max u2 u1} R R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u1, u2} σ R _inst_1 n) (HMul.hMul.{max u2 u1, max u1 u2, max u2 u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (instHMul.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (Semiring.toNonAssocSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (CommSemiring.toSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) _x) (MulHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (RingHom.instRingHomClassRingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))) (MvPolynomial.C.{u2, u1} R σ _inst_1) r) φ)) (HMul.hMul.{max u2 u1, max u1 u2, max u2 u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) φ) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) (HMul.hMul.{max u2 u1, max u1 u2, max u2 u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (instHMul.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (Semiring.toNonAssocSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (CommSemiring.toSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) a) (MulHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (RingHom.instRingHomClassRingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))) (MvPolynomial.C.{u2, u1} R σ _inst_1) r) φ)) (instHMul.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (Semiring.toNonAssocSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (CommSemiring.toSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => MvPolynomial.{u1, u2} σ R _inst_1) _x) (MulHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (RingHom.instRingHomClassRingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))) (MvPolynomial.C.{u2, u1} R σ _inst_1) r) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (LinearMap.{u2, u2, max u2 u1, max u2 u1} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.{u1, u2} σ R _inst_1) (fun (_x : MvPolynomial.{u1, u2} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u2 u1, max u2 u1} R R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u1, u2} σ R _inst_1 n) φ))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.homogeneous_component_C_mul MvPolynomial.homogeneousComponent_C_mulₓ'. -/
@[simp]
theorem homogeneousComponent_C_mul (n : ℕ) (r : R) :
    homogeneousComponent n (C r * φ) = C r * homogeneousComponent n φ := by
  simp only [C_mul', LinearMap.map_smul]
#align mv_polynomial.homogeneous_component_C_mul MvPolynomial.homogeneousComponent_C_mul

/- warning: mv_polynomial.homogeneous_component_eq_zero' -> MvPolynomial.homogeneousComponent_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (n : Nat) (φ : MvPolynomial.{u1, u2} σ R _inst_1), (forall (d : Finsupp.{u1, 0} σ Nat Nat.hasZero), (Membership.Mem.{u1, u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (Finset.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) (Finset.hasMem.{u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero)) d (MvPolynomial.support.{u2, u1} R σ _inst_1 φ)) -> (Ne.{1} Nat (Finset.sum.{0, u1} Nat σ Nat.addCommMonoid (Finsupp.support.{u1, 0} σ Nat Nat.hasZero d) (fun (i : σ) => coeFn.{succ u1, succ u1} (Finsupp.{u1, 0} σ Nat Nat.hasZero) (fun (_x : Finsupp.{u1, 0} σ Nat Nat.hasZero) => σ -> Nat) (Finsupp.coeFun.{u1, 0} σ Nat Nat.hasZero) d i)) n)) -> (Eq.{max (succ u1) (succ u2)} (MvPolynomial.{u1, u2} σ R _inst_1) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => (MvPolynomial.{u1, u2} σ R _inst_1) -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} R R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u1, u2} σ R _inst_1 n) φ) (OfNat.ofNat.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (OfNat.mk.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (Zero.zero.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MulZeroClass.toHasZero.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))))))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (n : Nat) (φ : MvPolynomial.{u2, u1} σ R _inst_1), (forall (d : Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)), (Membership.mem.{u2, u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finset.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (Finset.instMembershipFinset.{u2} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) d (MvPolynomial.support.{u1, u2} R σ _inst_1 φ)) -> (Ne.{1} Nat (Finset.sum.{0, u2} Nat σ Nat.addCommMonoid (Finsupp.support.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) d) (fun (i : σ) => FunLike.coe.{succ u2, succ u2, 1} (Finsupp.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) σ (fun (_x : σ) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : σ) => Nat) _x) (Finsupp.funLike.{u2, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) d i)) n)) -> (Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) φ) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u1, u1, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.{u2, u1} σ R _inst_1) (fun (_x : MvPolynomial.{u2, u1} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u1 u2, max u1 u2} R R (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u2, u1} σ R _inst_1 n) φ) (OfNat.ofNat.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) φ) 0 (Zero.toOfNat0.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) φ) (CommMonoidWithZero.toZero.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) φ) (CommSemiring.toCommMonoidWithZero.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) φ) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.homogeneous_component_eq_zero' MvPolynomial.homogeneousComponent_eq_zero'ₓ'. -/
theorem homogeneousComponent_eq_zero'
    (h : ∀ d : σ →₀ ℕ, d ∈ φ.support → (∑ i in d.support, d i) ≠ n) :
    homogeneousComponent n φ = 0 :=
  by
  rw [homogeneous_component_apply, sum_eq_zero]
  intro d hd; rw [mem_filter] at hd
  exfalso; exact h _ hd.1 hd.2
#align mv_polynomial.homogeneous_component_eq_zero' MvPolynomial.homogeneousComponent_eq_zero'

/- warning: mv_polynomial.homogeneous_component_eq_zero -> MvPolynomial.homogeneousComponent_eq_zero is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (n : Nat) (φ : MvPolynomial.{u1, u2} σ R _inst_1), (LT.lt.{0} Nat Nat.hasLt (MvPolynomial.totalDegree.{u2, u1} R σ _inst_1 φ) n) -> (Eq.{max (succ u1) (succ u2)} (MvPolynomial.{u1, u2} σ R _inst_1) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => (MvPolynomial.{u1, u2} σ R _inst_1) -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} R R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u1, u2} σ R _inst_1 n) φ) (OfNat.ofNat.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (OfNat.mk.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (Zero.zero.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MulZeroClass.toHasZero.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))))))
but is expected to have type
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (n : Nat) (φ : MvPolynomial.{u1, u2} σ R _inst_1), (LT.lt.{0} Nat instLTNat (MvPolynomial.totalDegree.{u2, u1} R σ _inst_1 φ) n) -> (Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) φ) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (LinearMap.{u2, u2, max u2 u1, max u2 u1} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.{u1, u2} σ R _inst_1) (fun (_x : MvPolynomial.{u1, u2} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u2 u1, max u2 u1} R R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u1, u2} σ R _inst_1 n) φ) (OfNat.ofNat.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) φ) 0 (Zero.toOfNat0.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) φ) (CommMonoidWithZero.toZero.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) φ) (CommSemiring.toCommMonoidWithZero.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u1, u2} σ R _inst_1) => MvPolynomial.{u1, u2} σ R _inst_1) φ) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.homogeneous_component_eq_zero MvPolynomial.homogeneousComponent_eq_zeroₓ'. -/
theorem homogeneousComponent_eq_zero (h : φ.totalDegree < n) : homogeneousComponent n φ = 0 :=
  by
  apply homogeneous_component_eq_zero'
  rw [total_degree, Finset.sup_lt_iff] at h
  · intro d hd
    exact ne_of_lt (h d hd)
  · exact lt_of_le_of_lt (Nat.zero_le _) h
#align mv_polynomial.homogeneous_component_eq_zero MvPolynomial.homogeneousComponent_eq_zero

/- warning: mv_polynomial.sum_homogeneous_component -> MvPolynomial.sum_homogeneousComponent is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (φ : MvPolynomial.{u1, u2} σ R _inst_1), Eq.{succ (max u1 u2)} (MvPolynomial.{u1, u2} σ R _inst_1) (Finset.sum.{max u1 u2, 0} (MvPolynomial.{u1, u2} σ R _inst_1) Nat (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Finset.range (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (MvPolynomial.totalDegree.{u2, u1} R σ _inst_1 φ) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (fun (i : Nat) => coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => (MvPolynomial.{u1, u2} σ R _inst_1) -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} R R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u1, u2} σ R _inst_1 i) φ)) φ
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (φ : MvPolynomial.{u2, u1} σ R _inst_1), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) φ) (Finset.sum.{max u2 u1, 0} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) φ) Nat (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) φ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) φ) (Semiring.toNonAssocSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) φ) (CommSemiring.toSemiring.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) φ) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (Finset.range (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (MvPolynomial.totalDegree.{u1, u2} R σ _inst_1 φ) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (fun (i : Nat) => FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u1, u1, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.{u2, u1} σ R _inst_1) (fun (_x : MvPolynomial.{u2, u1} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u1 u2, max u1 u2} R R (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u2, u1} σ R _inst_1 i) φ)) φ
Case conversion may be inaccurate. Consider using '#align mv_polynomial.sum_homogeneous_component MvPolynomial.sum_homogeneousComponentₓ'. -/
theorem sum_homogeneousComponent :
    (∑ i in range (φ.totalDegree + 1), homogeneousComponent i φ) = φ :=
  by
  ext1 d
  suffices φ.total_degree < d.support.sum d → 0 = coeff d φ by
    simpa [coeff_sum, coeff_homogeneous_component]
  exact fun h => (coeff_eq_zero_of_total_degree_lt h).symm
#align mv_polynomial.sum_homogeneous_component MvPolynomial.sum_homogeneousComponent

/- warning: mv_polynomial.homogeneous_component_homogeneous_polynomial -> MvPolynomial.homogeneousComponent_homogeneous_polynomial is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (m : Nat) (n : Nat) (p : MvPolynomial.{u1, u2} σ R _inst_1), (Membership.Mem.{max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Submodule.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submodule.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.{u1, u2} σ R _inst_1) (Submodule.setLike.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) p (MvPolynomial.homogeneousSubmodule.{u1, u2} σ R _inst_1 n)) -> (Eq.{max (succ u1) (succ u2)} (MvPolynomial.{u1, u2} σ R _inst_1) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) => (MvPolynomial.{u1, u2} σ R _inst_1) -> (MvPolynomial.{u1, u2} σ R _inst_1)) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} R R (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (MvPolynomial.module.{u2, u2, u1} R R σ (CommSemiring.toSemiring.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u1, u2} σ R _inst_1 m) p) (ite.{max (succ u1) (succ u2)} (MvPolynomial.{u1, u2} σ R _inst_1) (Eq.{1} Nat m n) (Nat.decidableEq m n) p (OfNat.ofNat.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (OfNat.mk.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) 0 (Zero.zero.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MulZeroClass.toHasZero.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMulZeroClass.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))))))))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (m : Nat) (n : Nat) (p : MvPolynomial.{u2, u1} σ R _inst_1), (Membership.mem.{max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Submodule.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.{u2, u1} σ R _inst_1) (Submodule.setLike.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) p (MvPolynomial.homogeneousSubmodule.{u2, u1} σ R _inst_1 n)) -> (Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) p) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u1, u1, max u1 u2, max u1 u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.{u2, u1} σ R _inst_1) (fun (_x : MvPolynomial.{u2, u1} σ R _inst_1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : MvPolynomial.{u2, u1} σ R _inst_1) => MvPolynomial.{u2, u1} σ R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u1 u2, max u1 u2} R R (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1))))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MvPolynomial.module.{u1, u1, u2} R R σ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_1 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MvPolynomial.homogeneousComponent.{u2, u1} σ R _inst_1 m) p) (ite.{max (succ u2) (succ u1)} (MvPolynomial.{u2, u1} σ R _inst_1) (Eq.{1} Nat m n) (instDecidableEqNat m n) p (OfNat.ofNat.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommMonoidWithZero.toZero.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (CommSemiring.toCommMonoidWithZero.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.homogeneous_component_homogeneous_polynomial MvPolynomial.homogeneousComponent_homogeneous_polynomialₓ'. -/
theorem homogeneousComponent_homogeneous_polynomial (m n : ℕ) (p : MvPolynomial σ R)
    (h : p ∈ homogeneousSubmodule σ R n) : homogeneousComponent m p = if m = n then p else 0 :=
  by
  simp only [mem_homogeneous_submodule] at h
  ext x
  rw [coeff_homogeneous_component]
  by_cases zero_coeff : coeff x p = 0
  · split_ifs
    all_goals simp only [zero_coeff, coeff_zero]
  · rw [h zero_coeff]
    simp only [show n = m ↔ m = n from eq_comm]
    split_ifs with h1
    · rfl
    · simp only [coeff_zero]
#align mv_polynomial.homogeneous_component_homogeneous_polynomial MvPolynomial.homogeneousComponent_homogeneous_polynomial

end HomogeneousComponent

end

end MvPolynomial

