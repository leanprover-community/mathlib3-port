/-
Copyright (c) 2020 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin, Chris Hughes

! This file was ported from Lean 3 source module ring_theory.integral_domain
! leanprover-community/mathlib commit 6e70e0d419bf686784937d64ed4bfde866ff229e
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Polynomial.RingDivision
import Mathbin.GroupTheory.SpecificGroups.Cyclic
import Mathbin.Algebra.GeomSum

/-!
# Integral domains

Assorted theorems about integral domains.

## Main theorems

* `is_cyclic_of_subgroup_is_domain`: A finite subgroup of the units of an integral domain is cyclic.
* `fintype.field_of_domain`: A finite integral domain is a field.

## TODO

Prove Wedderburn's little theorem, which shows that all finite division rings are actually fields.

## Tags

integral domain, finite integral domain, finite field
-/


section

open Finset Polynomial Function

open BigOperators Nat

section CancelMonoidWithZero

-- There doesn't seem to be a better home for these right now
variable {M : Type _} [CancelMonoidWithZero M] [Finite M]

/- warning: mul_right_bijective_of_finite₀ -> mul_right_bijective_of_finite₀ is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : CancelMonoidWithZero.{u1} M] [_inst_2 : Finite.{succ u1} M] {a : M}, (Ne.{succ u1} M a (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (CancelMonoidWithZero.toMonoidWithZero.{u1} M _inst_1)))))))) -> (Function.Bijective.{succ u1, succ u1} M M (fun (b : M) => HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulZeroClass.toHasMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (CancelMonoidWithZero.toMonoidWithZero.{u1} M _inst_1))))) a b))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : CancelMonoidWithZero.{u1} M] [_inst_2 : Finite.{succ u1} M] {a : M}, (Ne.{succ u1} M a (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M (CancelMonoidWithZero.toMonoidWithZero.{u1} M _inst_1))))) -> (Function.Bijective.{succ u1, succ u1} M M (fun (b : M) => HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulZeroClass.toMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (CancelMonoidWithZero.toMonoidWithZero.{u1} M _inst_1))))) a b))
Case conversion may be inaccurate. Consider using '#align mul_right_bijective_of_finite₀ mul_right_bijective_of_finite₀ₓ'. -/
theorem mul_right_bijective_of_finite₀ {a : M} (ha : a ≠ 0) : Bijective fun b => a * b :=
  Finite.injective_iff_bijective.1 <| mul_right_injective₀ ha
#align mul_right_bijective_of_finite₀ mul_right_bijective_of_finite₀

/- warning: mul_left_bijective_of_finite₀ -> mul_left_bijective_of_finite₀ is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : CancelMonoidWithZero.{u1} M] [_inst_2 : Finite.{succ u1} M] {a : M}, (Ne.{succ u1} M a (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (MulZeroClass.toHasZero.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (CancelMonoidWithZero.toMonoidWithZero.{u1} M _inst_1)))))))) -> (Function.Bijective.{succ u1, succ u1} M M (fun (b : M) => HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulZeroClass.toHasMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (CancelMonoidWithZero.toMonoidWithZero.{u1} M _inst_1))))) b a))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : CancelMonoidWithZero.{u1} M] [_inst_2 : Finite.{succ u1} M] {a : M}, (Ne.{succ u1} M a (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (MonoidWithZero.toZero.{u1} M (CancelMonoidWithZero.toMonoidWithZero.{u1} M _inst_1))))) -> (Function.Bijective.{succ u1, succ u1} M M (fun (b : M) => HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulZeroClass.toMul.{u1} M (MulZeroOneClass.toMulZeroClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (CancelMonoidWithZero.toMonoidWithZero.{u1} M _inst_1))))) b a))
Case conversion may be inaccurate. Consider using '#align mul_left_bijective_of_finite₀ mul_left_bijective_of_finite₀ₓ'. -/
theorem mul_left_bijective_of_finite₀ {a : M} (ha : a ≠ 0) : Bijective fun b => b * a :=
  Finite.injective_iff_bijective.1 <| mul_left_injective₀ ha
#align mul_left_bijective_of_finite₀ mul_left_bijective_of_finite₀

#print Fintype.groupWithZeroOfCancel /-
/-- Every finite nontrivial cancel_monoid_with_zero is a group_with_zero. -/
def Fintype.groupWithZeroOfCancel (M : Type _) [CancelMonoidWithZero M] [DecidableEq M] [Fintype M]
    [Nontrivial M] : GroupWithZero M :=
  { ‹Nontrivial M›,
    ‹CancelMonoidWithZero
        M› with
    inv := fun a => if h : a = 0 then 0 else Fintype.bijInv (mul_right_bijective_of_finite₀ h) 1
    mul_inv_cancel := fun a ha => by
      simp [Inv.inv, dif_neg ha]
      exact Fintype.rightInverse_bijInv _ _
    inv_zero := by simp [Inv.inv, dif_pos rfl] }
#align fintype.group_with_zero_of_cancel Fintype.groupWithZeroOfCancel
-/

/- warning: exists_eq_pow_of_mul_eq_pow_of_coprime -> exists_eq_pow_of_mul_eq_pow_of_coprime is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : CommSemiring.{u1} R] [_inst_4 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3)] [_inst_5 : GCDMonoid.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R _inst_3 _inst_4)] [_inst_6 : Unique.{succ u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3))))] {a : R} {b : R} {c : R} {n : Nat}, (IsCoprime.{u1} R _inst_3 a b) -> (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3)))))) a b) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3))))) c n)) -> (Exists.{succ u1} R (fun (d : R) => Eq.{succ u1} R a (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3))))) d n)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : CommSemiring.{u1} R] [_inst_4 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3)] [_inst_5 : GCDMonoid.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R _inst_3 _inst_4)] [_inst_6 : Unique.{succ u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3))))] {a : R} {b : R} {c : R} {n : Nat}, (IsCoprime.{u1} R _inst_3 a b) -> (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3))))) a b) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3))))) c n)) -> (Exists.{succ u1} R (fun (d : R) => Eq.{succ u1} R a (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3))))) d n)))
Case conversion may be inaccurate. Consider using '#align exists_eq_pow_of_mul_eq_pow_of_coprime exists_eq_pow_of_mul_eq_pow_of_coprimeₓ'. -/
theorem exists_eq_pow_of_mul_eq_pow_of_coprime {R : Type _} [CommSemiring R] [IsDomain R]
    [GCDMonoid R] [Unique Rˣ] {a b c : R} {n : ℕ} (cp : IsCoprime a b) (h : a * b = c ^ n) :
    ∃ d : R, a = d ^ n :=
  by
  refine' exists_eq_pow_of_mul_eq_pow (isUnit_of_dvd_one _ _) h
  obtain ⟨x, y, hxy⟩ := cp
  rw [← hxy]
  exact
    dvd_add (dvd_mul_of_dvd_right (gcd_dvd_left _ _) _) (dvd_mul_of_dvd_right (gcd_dvd_right _ _) _)
#align exists_eq_pow_of_mul_eq_pow_of_coprime exists_eq_pow_of_mul_eq_pow_of_coprime

/- warning: finset.exists_eq_pow_of_mul_eq_pow_of_coprime -> Finset.exists_eq_pow_of_mul_eq_pow_of_coprime is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} [_inst_3 : CommSemiring.{u2} R] [_inst_4 : IsDomain.{u2} R (CommSemiring.toSemiring.{u2} R _inst_3)] [_inst_5 : GCDMonoid.{u2} R (IsDomain.toCancelCommMonoidWithZero.{u2} R _inst_3 _inst_4)] [_inst_6 : Unique.{succ u2} (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_3))))] {n : Nat} {c : R} {s : Finset.{u1} ι} {f : ι -> R}, (forall (i : ι), (Membership.Mem.{u1, u1} ι (Finset.{u1} ι) (Finset.hasMem.{u1} ι) i s) -> (forall (j : ι), (Membership.Mem.{u1, u1} ι (Finset.{u1} ι) (Finset.hasMem.{u1} ι) j s) -> (Ne.{succ u1} ι i j) -> (IsCoprime.{u2} R _inst_3 (f i) (f j)))) -> (Eq.{succ u2} R (Finset.prod.{u2, u1} R ι (CommSemiring.toCommMonoid.{u2} R _inst_3) s (fun (i : ι) => f i)) (HPow.hPow.{u2, 0, u2} R Nat R (instHPow.{u2, 0} R Nat (Monoid.Pow.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_3))))) c n)) -> (forall (i : ι), (Membership.Mem.{u1, u1} ι (Finset.{u1} ι) (Finset.hasMem.{u1} ι) i s) -> (Exists.{succ u2} R (fun (d : R) => Eq.{succ u2} R (f i) (HPow.hPow.{u2, 0, u2} R Nat R (instHPow.{u2, 0} R Nat (Monoid.Pow.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_3))))) d n))))
but is expected to have type
  forall {ι : Type.{u2}} {R : Type.{u1}} [_inst_3 : CommSemiring.{u1} R] [_inst_4 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3)] [_inst_5 : GCDMonoid.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R _inst_3 _inst_4)] [_inst_6 : Unique.{succ u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3))))] {n : Nat} {c : R} {s : Finset.{u2} ι} {f : ι -> R}, (forall (i : ι), (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) i s) -> (forall (j : ι), (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) j s) -> (Ne.{succ u2} ι i j) -> (IsCoprime.{u1} R _inst_3 (f i) (f j)))) -> (Eq.{succ u1} R (Finset.prod.{u1, u2} R ι (CommSemiring.toCommMonoid.{u1} R _inst_3) s (fun (i : ι) => f i)) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3))))) c n)) -> (forall (i : ι), (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) i s) -> (Exists.{succ u1} R (fun (d : R) => Eq.{succ u1} R (f i) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3))))) d n))))
Case conversion may be inaccurate. Consider using '#align finset.exists_eq_pow_of_mul_eq_pow_of_coprime Finset.exists_eq_pow_of_mul_eq_pow_of_coprimeₓ'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (i j «expr ∈ » s) -/
theorem Finset.exists_eq_pow_of_mul_eq_pow_of_coprime {ι R : Type _} [CommSemiring R] [IsDomain R]
    [GCDMonoid R] [Unique Rˣ] {n : ℕ} {c : R} {s : Finset ι} {f : ι → R}
    (h : ∀ (i) (_ : i ∈ s) (j) (_ : j ∈ s), i ≠ j → IsCoprime (f i) (f j))
    (hprod : (∏ i in s, f i) = c ^ n) : ∀ i ∈ s, ∃ d : R, f i = d ^ n := by
  classical
    intro i hi
    rw [← insert_erase hi, prod_insert (not_mem_erase i s)] at hprod
    refine'
      exists_eq_pow_of_mul_eq_pow_of_coprime
        (IsCoprime.prod_right fun j hj => h i hi j (erase_subset i s hj) fun hij => _) hprod
    rw [hij] at hj
    exact (s.not_mem_erase _) hj
#align finset.exists_eq_pow_of_mul_eq_pow_of_coprime Finset.exists_eq_pow_of_mul_eq_pow_of_coprime

end CancelMonoidWithZero

variable {R : Type _} {G : Type _}

section Ring

variable [Ring R] [IsDomain R] [Fintype R]

#print Fintype.divisionRingOfIsDomain /-
/-- Every finite domain is a division ring.

TODO: Prove Wedderburn's little theorem,
which shows a finite domain is in fact commutative, hence a field. -/
def Fintype.divisionRingOfIsDomain (R : Type _) [Ring R] [IsDomain R] [DecidableEq R] [Fintype R] :
    DivisionRing R :=
  { show GroupWithZero R from Fintype.groupWithZeroOfCancel R, ‹Ring R› with }
#align fintype.division_ring_of_is_domain Fintype.divisionRingOfIsDomain
-/

#print Fintype.fieldOfDomain /-
/-- Every finite commutative domain is a field.

TODO: Prove Wedderburn's little theorem, which shows a finite domain is automatically commutative,
dropping one assumption from this theorem. -/
def Fintype.fieldOfDomain (R) [CommRing R] [IsDomain R] [DecidableEq R] [Fintype R] : Field R :=
  { Fintype.groupWithZeroOfCancel R, ‹CommRing R› with }
#align fintype.field_of_domain Fintype.fieldOfDomain
-/

#print Finite.isField_of_domain /-
theorem Finite.isField_of_domain (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=
  by
  cases nonempty_fintype R
  exact @Field.toIsField R (@Fintype.fieldOfDomain R _ _ (Classical.decEq R) _)
#align finite.is_field_of_domain Finite.isField_of_domain
-/

end Ring

variable [CommRing R] [IsDomain R] [Group G]

/- warning: card_nth_roots_subgroup_units -> card_nthRoots_subgroup_units is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {G : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] [_inst_3 : Group.{u2} G] [_inst_4 : Fintype.{u2} G] (f : MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))), (Function.Injective.{succ u2, succ u1} G R (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (fun (_x : MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) => G -> R) (MonoidHom.hasCoeToFun.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) f)) -> (forall {n : Nat}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (forall (g₀ : G), LE.le.{0} Nat Nat.hasLe (Finset.card.{u2} G (Sep.sep.{u2, u2} G (Finset.{u2} G) (Finset.hasSep.{u2} G) (fun (g : G) => Eq.{succ u2} G (HPow.hPow.{u2, 0, u2} G Nat G (instHPow.{u2, 0} G Nat (Monoid.Pow.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)))) g n) g₀) (Finset.univ.{u2} G _inst_4))) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u1} R) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u1} R) (Polynomial.nthRoots.{u1} R _inst_1 _inst_2 n (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (fun (_x : MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) => G -> R) (MonoidHom.hasCoeToFun.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) f g₀)))))
but is expected to have type
  forall {R : Type.{u1}} {G : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))] [_inst_3 : Group.{u2} G] [_inst_4 : Fintype.{u2} G] [f : DecidableEq.{succ u2} G] (hf : MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))), (Function.Injective.{succ u2, succ u1} G R (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) a) (MulHomClass.toFunLike.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) G R (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)))) (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (MonoidHom.monoidHomClass.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) hf)) -> (forall {hn : Nat}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) hn) -> (forall (g₀ : G), LE.le.{0} Nat instLENat (Finset.card.{u2} G (Finset.filter.{u2} G (fun (g : G) => Eq.{succ u2} G (HPow.hPow.{u2, 0, u2} G Nat G (instHPow.{u2, 0} G Nat (Monoid.Pow.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)))) g hn) g₀) (fun (a : G) => f (HPow.hPow.{u2, 0, u2} G Nat G (instHPow.{u2, 0} G Nat (Monoid.Pow.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)))) a hn) g₀) (Finset.univ.{u2} G _inst_4))) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀))))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (fun (a : Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) => Nat) a) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀))))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) Nat (AddZeroClass.toAdd.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀))))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀))))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀))))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀)) (Polynomial.nthRoots.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) g₀) _inst_1 _inst_2 hn (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) a) (MulHomClass.toFunLike.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) G R (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)))) (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (MonoidHom.monoidHomClass.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) hf g₀)))))
Case conversion may be inaccurate. Consider using '#align card_nth_roots_subgroup_units card_nthRoots_subgroup_unitsₓ'. -/
theorem card_nthRoots_subgroup_units [Fintype G] (f : G →* R) (hf : Injective f) {n : ℕ}
    (hn : 0 < n) (g₀ : G) :
    ({ g ∈ univ | g ^ n = g₀ } : Finset G).card ≤ (nthRoots n (f g₀)).card :=
  by
  haveI : DecidableEq R := Classical.decEq _
  refine' le_trans _ (nth_roots n (f g₀)).toFinset_card_le
  apply card_le_card_of_inj_on f
  · intro g hg
    rw [sep_def, mem_filter] at hg
    rw [Multiset.mem_toFinset, mem_nth_roots hn, ← f.map_pow, hg.2]
  · intros
    apply hf
    assumption
#align card_nth_roots_subgroup_units card_nthRoots_subgroup_units

/- warning: is_cyclic_of_subgroup_is_domain -> isCyclic_of_subgroup_isDomain is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {G : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] [_inst_3 : Group.{u2} G] [_inst_4 : Finite.{succ u2} G] (f : MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))), (Function.Injective.{succ u2, succ u1} G R (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (fun (_x : MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) => G -> R) (MonoidHom.hasCoeToFun.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) f)) -> (IsCyclic.{u2} G _inst_3)
but is expected to have type
  forall {R : Type.{u1}} {G : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))] [_inst_3 : Group.{u2} G] [_inst_4 : Finite.{succ u2} G] (f : MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))), (Function.Injective.{succ u2, succ u1} G R (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) _x) (MulHomClass.toFunLike.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) G R (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)))) (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (MonoidHom.monoidHomClass.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) f)) -> (IsCyclic.{u2} G _inst_3)
Case conversion may be inaccurate. Consider using '#align is_cyclic_of_subgroup_is_domain isCyclic_of_subgroup_isDomainₓ'. -/
/-- A finite subgroup of the unit group of an integral domain is cyclic. -/
theorem isCyclic_of_subgroup_isDomain [Finite G] (f : G →* R) (hf : Injective f) : IsCyclic G := by
  classical
    cases nonempty_fintype G
    apply isCyclic_of_card_pow_eq_one_le
    intro n hn
    convert le_trans (card_nthRoots_subgroup_units f hf hn 1) (card_nth_roots n (f 1))
#align is_cyclic_of_subgroup_is_domain isCyclic_of_subgroup_isDomain

/-- The unit group of a finite integral domain is cyclic.

To support `ℤˣ` and other infinite monoids with finite groups of units, this requires only
`finite Rˣ` rather than deducing it from `finite R`. -/
instance [Finite Rˣ] : IsCyclic Rˣ :=
  isCyclic_of_subgroup_isDomain (Units.coeHom R) <| Units.ext

section

variable (S : Subgroup Rˣ) [Finite S]

/- warning: subgroup_units_cyclic -> subgroup_units_cyclic is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (S : Subgroup.{u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Units.group.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) [_inst_4 : Finite.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Units.group.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Units.group.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Subgroup.setLike.{u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Units.group.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))))) S)], IsCyclic.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Units.group.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Units.group.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Subgroup.setLike.{u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Units.group.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))))) S) (Subgroup.toGroup.{u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Units.group.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))) S)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))] (S : Subgroup.{u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Units.instGroupUnits.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) [_inst_4 : Finite.{succ u1} (Subtype.{succ u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (fun (x : Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) => Membership.mem.{u1, u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Subgroup.{u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Units.instGroupUnits.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Units.instGroupUnits.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Subgroup.instSetLikeSubgroup.{u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Units.instGroupUnits.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))))) x S))], IsCyclic.{u1} (Subtype.{succ u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (fun (x : Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) => Membership.mem.{u1, u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Subgroup.{u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Units.instGroupUnits.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Units.instGroupUnits.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Subgroup.instSetLikeSubgroup.{u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Units.instGroupUnits.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))))) x S)) (Subgroup.toGroup.{u1} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Units.instGroupUnits.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) S)
Case conversion may be inaccurate. Consider using '#align subgroup_units_cyclic subgroup_units_cyclicₓ'. -/
/-- A finite subgroup of the units of an integral domain is cyclic. -/
instance subgroup_units_cyclic : IsCyclic S :=
  by
  refine' isCyclic_of_subgroup_isDomain ⟨(coe : S → R), _, _⟩ (units.ext.comp Subtype.val_injective)
  · simp
  · intros
    simp
#align subgroup_units_cyclic subgroup_units_cyclic

end

section EuclideanDivision

namespace Polynomial

open Polynomial

variable (K : Type) [Field K] [Algebra R[X] K] [IsFractionRing R[X] K]

/- warning: polynomial.div_eq_quo_add_rem_div -> Polynomial.div_eq_quo_add_rem_div is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (K : Type) [_inst_4 : Field.{0} K] [_inst_5 : Algebra.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) K (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toSemiring.{0} K (DivisionRing.toRing.{0} K (Field.toDivisionRing.{0} K _inst_4)))] [_inst_6 : IsFractionRing.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1) K (EuclideanDomain.toCommRing.{0} K (Field.toEuclideanDomain.{0} K _inst_4)) _inst_5] (f : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) {g : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) g) -> (Exists.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (q : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) => Exists.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (r : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) => And (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toHasLt.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) r) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) g)) (Eq.{1} K (HDiv.hDiv.{0, 0, 0} K K K (instHDiv.{0} K (DivInvMonoid.toHasDiv.{0} K (DivisionRing.toDivInvMonoid.{0} K (Field.toDivisionRing.{0} K _inst_4)))) ((fun (a : Type.{u1}) (b : Type) [self : HasLiftT.{succ u1, 1} a b] => self.0) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) K (algebraMap.coeHTCT.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) K (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toSemiring.{0} K (DivisionRing.toRing.{0} K (Field.toDivisionRing.{0} K _inst_4))) _inst_5) f) ((fun (a : Type.{u1}) (b : Type) [self : HasLiftT.{succ u1, 1} a b] => self.0) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) K (algebraMap.coeHTCT.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) K (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toSemiring.{0} K (DivisionRing.toRing.{0} K (Field.toDivisionRing.{0} K _inst_4))) _inst_5) g)) (HAdd.hAdd.{0, 0, 0} K K K (instHAdd.{0} K (Distrib.toHasAdd.{0} K (Ring.toDistrib.{0} K (DivisionRing.toRing.{0} K (Field.toDivisionRing.{0} K _inst_4))))) ((fun (a : Type.{u1}) (b : Type) [self : HasLiftT.{succ u1, 1} a b] => self.0) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) K (algebraMap.coeHTCT.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) K (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toSemiring.{0} K (DivisionRing.toRing.{0} K (Field.toDivisionRing.{0} K _inst_4))) _inst_5) q) (HDiv.hDiv.{0, 0, 0} K K K (instHDiv.{0} K (DivInvMonoid.toHasDiv.{0} K (DivisionRing.toDivInvMonoid.{0} K (Field.toDivisionRing.{0} K _inst_4)))) ((fun (a : Type.{u1}) (b : Type) [self : HasLiftT.{succ u1, 1} a b] => self.0) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) K (algebraMap.coeHTCT.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) K (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toSemiring.{0} K (DivisionRing.toRing.{0} K (Field.toDivisionRing.{0} K _inst_4))) _inst_5) r) ((fun (a : Type.{u1}) (b : Type) [self : HasLiftT.{succ u1, 1} a b] => self.0) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) K (algebraMap.coeHTCT.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) K (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toSemiring.{0} K (DivisionRing.toRing.{0} K (Field.toDivisionRing.{0} K _inst_4))) _inst_5) g)))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))] (K : Type) [_inst_4 : Field.{0} K] [_inst_5 : Algebra.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4)))] [_inst_6 : IsFractionRing.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1) K (EuclideanDomain.toCommRing.{0} K (Field.toEuclideanDomain.{0} K _inst_4)) _inst_5] (f : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) {g : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))}, (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) g) -> (Exists.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (fun (q : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => Exists.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (fun (r : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => And (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) r) (Polynomial.degree.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) g)) (Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) f) (HDiv.hDiv.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) f) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) g) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) f) (instHDiv.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) f) (Field.toDiv.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) f) _inst_4)) (FunLike.coe.{succ u1, succ u1, 1} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (fun (a : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) a) (MulHomClass.toFunLike.{u1, u1, 0} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{0} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} K (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, 0} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} K (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, 0} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4)))) (RingHom.instRingHomClassRingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4)))))))) (algebraMap.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))) _inst_5) f) (FunLike.coe.{succ u1, succ u1, 1} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (fun (a : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) a) (MulHomClass.toFunLike.{u1, u1, 0} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{0} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} K (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, 0} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} K (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, 0} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4)))) (RingHom.instRingHomClassRingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4)))))))) (algebraMap.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))) _inst_5) g)) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) q) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) r) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) q) (instHAdd.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) q) (Distrib.toAdd.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) q) (NonUnitalNonAssocSemiring.toDistrib.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) q) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) q) (NonAssocRing.toNonUnitalNonAssocRing.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) q) (Ring.toNonAssocRing.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) q) (DivisionRing.toRing.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) q) (Field.toDivisionRing.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) q) _inst_4)))))))) (FunLike.coe.{succ u1, succ u1, 1} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (fun (a : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) a) (MulHomClass.toFunLike.{u1, u1, 0} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{0} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} K (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, 0} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} K (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, 0} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4)))) (RingHom.instRingHomClassRingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4)))))))) (algebraMap.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))) _inst_5) q) (HDiv.hDiv.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) r) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) g) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) r) (instHDiv.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) r) (Field.toDiv.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) r) _inst_4)) (FunLike.coe.{succ u1, succ u1, 1} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (fun (a : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) a) (MulHomClass.toFunLike.{u1, u1, 0} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{0} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} K (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, 0} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} K (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, 0} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4)))) (RingHom.instRingHomClassRingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4)))))))) (algebraMap.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))) _inst_5) r) (FunLike.coe.{succ u1, succ u1, 1} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (fun (a : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => K) a) (MulHomClass.toFunLike.{u1, u1, 0} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{0} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} K (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, 0} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} K (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, 0} (RingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4)))) (RingHom.instRingHomClassRingHom.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommSemiring.toSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{0} K (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4)))))))) (algebraMap.{u1, 0} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) K (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (DivisionSemiring.toSemiring.{0} K (Semifield.toDivisionSemiring.{0} K (Field.toSemifield.{0} K _inst_4))) _inst_5) g)))))))
Case conversion may be inaccurate. Consider using '#align polynomial.div_eq_quo_add_rem_div Polynomial.div_eq_quo_add_rem_divₓ'. -/
theorem div_eq_quo_add_rem_div (f : R[X]) {g : R[X]} (hg : g.Monic) :
    ∃ q r : R[X], r.degree < g.degree ∧ (↑f : K) / ↑g = ↑q + ↑r / ↑g :=
  by
  refine' ⟨f /ₘ g, f %ₘ g, _, _⟩
  · exact degree_mod_by_monic_lt _ hg
  · have hg' : (↑g : K) ≠ 0 := by exact_mod_cast monic.ne_zero hg
    field_simp [hg']
    norm_cast
    rw [add_comm, mul_comm, mod_by_monic_add_div f hg]
#align polynomial.div_eq_quo_add_rem_div Polynomial.div_eq_quo_add_rem_div

end Polynomial

end EuclideanDivision

variable [Fintype G]

/- warning: card_fiber_eq_of_mem_range -> card_fiber_eq_of_mem_range is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] [_inst_4 : Fintype.{u1} G] {H : Type.{u2}} [_inst_5 : Group.{u2} H] [_inst_6 : DecidableEq.{succ u2} H] (f : MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) {x : H} {y : H}, (Membership.Mem.{u2, u2} H (Set.{u2} H) (Set.hasMem.{u2} H) x (Set.range.{u2, succ u1} H G (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) (fun (_x : MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) => G -> H) (MonoidHom.hasCoeToFun.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) f))) -> (Membership.Mem.{u2, u2} H (Set.{u2} H) (Set.hasMem.{u2} H) y (Set.range.{u2, succ u1} H G (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) (fun (_x : MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) => G -> H) (MonoidHom.hasCoeToFun.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) f))) -> (Eq.{1} Nat (Finset.card.{u1} G (Finset.filter.{u1} G (fun (g : G) => Eq.{succ u2} H (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) (fun (_x : MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) => G -> H) (MonoidHom.hasCoeToFun.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) f g) x) (fun (a : G) => _inst_6 (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) (fun (_x : MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) => G -> H) (MonoidHom.hasCoeToFun.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) f a) x) (Finset.univ.{u1} G _inst_4))) (Finset.card.{u1} G (Finset.filter.{u1} G (fun (g : G) => Eq.{succ u2} H (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) (fun (_x : MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) => G -> H) (MonoidHom.hasCoeToFun.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) f g) y) (fun (a : G) => _inst_6 (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) (fun (_x : MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) => G -> H) (MonoidHom.hasCoeToFun.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) f a) y) (Finset.univ.{u1} G _inst_4))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_3 : Group.{u1} G] [_inst_4 : Fintype.{u1} G] {H : Type.{u2}} [_inst_5 : Group.{u2} H] [_inst_6 : DecidableEq.{succ u2} H] (f : MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) {x : H} {y : H}, (Membership.mem.{u2, u2} H (Set.{u2} H) (Set.instMembershipSet.{u2} H) x (Set.range.{u2, succ u1} H G (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => H) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5))) (MonoidHom.monoidHomClass.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))))) f))) -> (Membership.mem.{u2, u2} H (Set.{u2} H) (Set.instMembershipSet.{u2} H) y (Set.range.{u2, succ u1} H G (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => H) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5))) (MonoidHom.monoidHomClass.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))))) f))) -> (Eq.{1} Nat (Finset.card.{u1} G (Finset.filter.{u1} G (fun (g : G) => Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => H) g) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => H) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5))) (MonoidHom.monoidHomClass.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))))) f g) x) (fun (a : G) => _inst_6 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => H) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5))) (MonoidHom.monoidHomClass.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))))) f a) x) (Finset.univ.{u1} G _inst_4))) (Finset.card.{u1} G (Finset.filter.{u1} G (fun (g : G) => Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => H) g) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => H) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5))) (MonoidHom.monoidHomClass.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))))) f g) y) (fun (a : G) => _inst_6 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => H) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))) G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5))) (MonoidHom.monoidHomClass.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_5)))))) f a) y) (Finset.univ.{u1} G _inst_4))))
Case conversion may be inaccurate. Consider using '#align card_fiber_eq_of_mem_range card_fiber_eq_of_mem_rangeₓ'. -/
theorem card_fiber_eq_of_mem_range {H : Type _} [Group H] [DecidableEq H] (f : G →* H) {x y : H}
    (hx : x ∈ Set.range f) (hy : y ∈ Set.range f) :
    (univ.filterₓ fun g => f g = x).card = (univ.filterₓ fun g => f g = y).card :=
  by
  rcases hx with ⟨x, rfl⟩
  rcases hy with ⟨y, rfl⟩
  refine' card_congr (fun g _ => g * x⁻¹ * y) _ _ fun g hg => ⟨g * y⁻¹ * x, _⟩
  ·
    simp (config := { contextual := true }) only [mem_filter, one_mul, MonoidHom.map_mul, mem_univ,
      mul_right_inv, eq_self_iff_true, MonoidHom.map_mul_inv, and_self_iff, forall_true_iff]
  · simp only [mul_left_inj, imp_self, forall₂_true_iff]
  · simp only [true_and_iff, mem_filter, mem_univ] at hg
    simp only [hg, mem_filter, one_mul, MonoidHom.map_mul, mem_univ, mul_right_inv,
      eq_self_iff_true, exists_prop_of_true, MonoidHom.map_mul_inv, and_self_iff,
      mul_inv_cancel_right, inv_mul_cancel_right]
#align card_fiber_eq_of_mem_range card_fiber_eq_of_mem_range

/- warning: sum_hom_units_eq_zero -> sum_hom_units_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {G : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] [_inst_3 : Group.{u2} G] [_inst_4 : Fintype.{u2} G] (f : MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))), (Ne.{max (succ u1) (succ u2)} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) f (OfNat.ofNat.{max u1 u2} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) 1 (OfNat.mk.{max u1 u2} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) 1 (One.one.{max u1 u2} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MonoidHom.hasOne.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))) -> (Eq.{succ u1} R (Finset.sum.{u1, u2} R G (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Finset.univ.{u2} G _inst_4) (fun (g : G) => coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (fun (_x : MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) => G -> R) (MonoidHom.hasCoeToFun.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) f g)) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))))
but is expected to have type
  forall {R : Type.{u1}} {G : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))] [_inst_3 : Group.{u2} G] [_inst_4 : Fintype.{u2} G] (f : MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))), (Ne.{max (succ u1) (succ u2)} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) f (OfNat.ofNat.{max u1 u2} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) 1 (One.toOfNat1.{max u1 u2} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (instOneMonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))))))) -> (Eq.{succ u1} R (Finset.sum.{u1, u2} R G (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Finset.univ.{u2} G _inst_4) (fun (g : G) => FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) _x) (MulHomClass.toFunLike.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) G R (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)))) (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (MonoidHom.monoidHomClass.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) f g)) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2))))))
Case conversion may be inaccurate. Consider using '#align sum_hom_units_eq_zero sum_hom_units_eq_zeroₓ'. -/
/-- In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero.
-/
theorem sum_hom_units_eq_zero (f : G →* R) (hf : f ≠ 1) : (∑ g : G, f g) = 0 := by
  classical
    obtain ⟨x, hx⟩ :
      ∃ x : MonoidHom.range f.to_hom_units,
        ∀ y : MonoidHom.range f.to_hom_units, y ∈ Submonoid.powers x
    exact IsCyclic.exists_monoid_generator
    have hx1 : x ≠ 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ⟨f.to_hom_units g, g, rfl⟩ with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x : R) - 1 ≠ 0
    exact fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.to_hom_units g = 1).card
    calc
      (∑ g : G, f g) = ∑ g : G, f.to_hom_units g := rfl
      _ =
          ∑ u : Rˣ in univ.image f.to_hom_units,
            (univ.filter fun g => f.to_hom_units g = u).card • u :=
        (sum_comp (coe : Rˣ → R) f.to_hom_units)
      _ = ∑ u : Rˣ in univ.image f.to_hom_units, c • u :=
        (sum_congr rfl fun u hu => congr_arg₂ _ _ rfl)
      -- remaining goal 1, proven below
          _ =
          ∑ b : MonoidHom.range f.to_hom_units, c • ↑b :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c • ∑ b : MonoidHom.range f.to_hom_units, (b : R) := smul_sum.symm
      _ = c • 0 := (congr_arg₂ _ rfl _)
      -- remaining goal 2, proven below
          _ =
          0 :=
        smul_zero _
      
    · -- remaining goal 1
      show (univ.filter fun g : G => f.to_hom_units g = u).card = c
      apply card_fiber_eq_of_mem_range f.to_hom_units
      · simpa only [mem_image, mem_univ, exists_prop_of_true, Set.mem_range] using hu
      · exact ⟨1, f.to_hom_units.map_one⟩
    -- remaining goal 2
    show (∑ b : MonoidHom.range f.to_hom_units, (b : R)) = 0
    calc
      (∑ b : MonoidHom.range f.to_hom_units, (b : R)) = ∑ n in range (orderOf x), x ^ n :=
        Eq.symm <|
          sum_bij (fun n _ => x ^ n) (by simp only [mem_univ, forall_true_iff])
            (by
              simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow, Units.val_pow_eq_pow_val,
                coe_coe])
            (fun m n hm hn =>
              pow_injective_of_lt_orderOf _ (by simpa only [mem_range] using hm)
                (by simpa only [mem_range] using hn))
            fun b hb =>
            let ⟨n, hn⟩ := hx b
            ⟨n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)), by
              rw [← pow_eq_mod_orderOf, hn]⟩
      _ = 0 := _
      
    rw [← mul_left_inj' hx1, MulZeroClass.zero_mul, geom_sum_mul, coe_coe]
    norm_cast
    simp [pow_orderOf_eq_one]
#align sum_hom_units_eq_zero sum_hom_units_eq_zero

/- warning: sum_hom_units -> sum_hom_units is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {G : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] [_inst_3 : Group.{u2} G] [_inst_4 : Fintype.{u2} G] (f : MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) [_inst_5 : Decidable (Eq.{max (succ u1) (succ u2)} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) f (OfNat.ofNat.{max u1 u2} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) 1 (OfNat.mk.{max u1 u2} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) 1 (One.one.{max u1 u2} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MonoidHom.hasOne.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))))], Eq.{succ u1} R (Finset.sum.{u1, u2} R G (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Finset.univ.{u2} G _inst_4) (fun (g : G) => coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (fun (_x : MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) => G -> R) (MonoidHom.hasCoeToFun.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) f g)) (ite.{succ u1} R (Eq.{max (succ u1) (succ u2)} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) f (OfNat.ofNat.{max u1 u2} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) 1 (OfNat.mk.{max u1 u2} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) 1 (One.one.{max u1 u2} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MonoidHom.hasOne.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))) _inst_5 ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Fintype.card.{u2} G _inst_4)) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))))
but is expected to have type
  forall {R : Type.{u1}} {G : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))] [_inst_3 : Group.{u2} G] [_inst_4 : Fintype.{u2} G] (f : MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) [_inst_5 : Decidable (Eq.{max (succ u1) (succ u2)} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) f (OfNat.ofNat.{max u1 u2} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) 1 (One.toOfNat1.{max u1 u2} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (instOneMonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))))], Eq.{succ u1} R (Finset.sum.{u1, u2} R G (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Finset.univ.{u2} G _inst_4) (fun (g : G) => FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : G) => R) _x) (MulHomClass.toFunLike.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) G R (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)))) (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u2, u1} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (MonoidHom.monoidHomClass.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) f g)) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (ite.{1} Nat (Eq.{max (succ u1) (succ u2)} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) f (OfNat.ofNat.{max u1 u2} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) 1 (One.toOfNat1.{max u1 u2} (MonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (instOneMonoidHom.{u2, u1} G R (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))))))) _inst_5 (Fintype.card.{u2} G _inst_4) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))
Case conversion may be inaccurate. Consider using '#align sum_hom_units sum_hom_unitsₓ'. -/
/-- In an integral domain, a sum indexed by a homomorphism from a finite group is zero,
unless the homomorphism is trivial, in which case the sum is equal to the cardinality of the group.
-/
theorem sum_hom_units (f : G →* R) [Decidable (f = 1)] :
    (∑ g : G, f g) = if f = 1 then Fintype.card G else 0 :=
  by
  split_ifs with h h
  · simp [h, card_univ]
  · exact sum_hom_units_eq_zero f h
#align sum_hom_units sum_hom_units

end

