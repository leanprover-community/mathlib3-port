/-
Copyright (c) 2021 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes

! This file was ported from Lean 3 source module ring_theory.algebraic_independent
! leanprover-community/mathlib commit 0b7c740e25651db0ba63648fbae9f9d6f941e31b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.RingTheory.Adjoin.Basic
import Mathbin.LinearAlgebra.LinearIndependent
import Mathbin.RingTheory.MvPolynomial.Basic
import Mathbin.Data.MvPolynomial.Supported
import Mathbin.RingTheory.Algebraic
import Mathbin.Data.MvPolynomial.Equiv

/-!
# Algebraic Independence

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines algebraic independence of a family of element of an `R` algebra

## Main definitions

* `algebraic_independent` - `algebraic_independent R x` states the family of elements `x`
  is algebraically independent over `R`, meaning that the canonical map out of the multivariable
  polynomial ring is injective.

* `algebraic_independent.repr` - The canonical map from the subalgebra generated by an
  algebraic independent family into the polynomial ring.

## References

* [Stacks: Transcendence](https://stacks.math.columbia.edu/tag/030D)

## TODO
Prove that a ring is an algebraic extension of the subalgebra generated by a transcendence basis.

## Tags
transcendence basis, transcendence degree, transcendence

-/


noncomputable section

open Function Set Subalgebra MvPolynomial Algebra

open Classical BigOperators

universe x u v w

variable {ι : Type _} {ι' : Type _} (R : Type _) {K : Type _}

variable {A : Type _} {A' A'' : Type _} {V : Type u} {V' : Type _}

variable (x : ι → A)

variable [CommRing R] [CommRing A] [CommRing A'] [CommRing A'']

variable [Algebra R A] [Algebra R A'] [Algebra R A'']

variable {a b : R}

#print AlgebraicIndependent /-
/-- `algebraic_independent R x` states the family of elements `x`
  is algebraically independent over `R`, meaning that the canonical
  map out of the multivariable polynomial ring is injective. -/
def AlgebraicIndependent : Prop :=
  Injective (MvPolynomial.aeval x : MvPolynomial ι R →ₐ[R] A)
#align algebraic_independent AlgebraicIndependent
-/

variable {R} {x}

/- warning: algebraic_independent_iff_ker_eq_bot -> algebraicIndependent_iff_ker_eq_bot is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2))], Iff (AlgebraicIndependent.{u1, u2, u3} ι R A x _inst_1 _inst_2 _inst_5) (Eq.{succ (max u1 u2)} (Ideal.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R ι (CommRing.toCommSemiring.{u2} R _inst_1)))) (RingHom.ker.{max u1 u2, u3, max (max u1 u2) u3} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) A (RingHom.{max u1 u2, u3} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) A (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R ι (CommRing.toCommSemiring.{u2} R _inst_1)))) (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)))) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R ι (CommRing.toCommSemiring.{u2} R _inst_1))) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) (RingHom.ringHomClass.{max u1 u2, u3} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) A (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R ι (CommRing.toCommSemiring.{u2} R _inst_1)))) (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)))) (AlgHom.toRingHom.{u2, max u1 u2, u3} R (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R ι (CommRing.toCommSemiring.{u2} R _inst_1))) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) (MvPolynomial.algebra.{u2, u2, u1} R R ι (CommRing.toCommSemiring.{u2} R _inst_1) (CommRing.toCommSemiring.{u2} R _inst_1) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) _inst_5 (MvPolynomial.aeval.{u2, u3, u1} R A ι (CommRing.toCommSemiring.{u2} R _inst_1) (CommRing.toCommSemiring.{u3} A _inst_2) _inst_5 x))) (Bot.bot.{max u1 u2} (Ideal.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R ι (CommRing.toCommSemiring.{u2} R _inst_1)))) (Submodule.hasBot.{max u1 u2, max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R ι (CommRing.toCommSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R ι (CommRing.toCommSemiring.{u2} R _inst_1)))))) (Semiring.toModule.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R ι (CommRing.toCommSemiring.{u2} R _inst_1)))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {A : Type.{u1}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))], Iff (AlgebraicIndependent.{u3, u2, u1} ι R A x _inst_1 _inst_2 _inst_5) (Eq.{max (succ u3) (succ u2)} (Ideal.{max u3 u2} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u3} R ι (CommRing.toCommSemiring.{u2} R _inst_1)))) (RingHom.ker.{max u3 u2, u1, max (max u3 u2) u1} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) A (RingHom.{max u3 u2, u1} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) A (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u3} R ι (CommRing.toCommSemiring.{u2} R _inst_1)))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u3} R ι (CommRing.toCommSemiring.{u2} R _inst_1))) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (RingHom.instRingHomClassRingHom.{max u3 u2, u1} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) A (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u3} R ι (CommRing.toCommSemiring.{u2} R _inst_1)))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) (AlgHom.toRingHom.{u2, max u3 u2, u1} R (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u3} R ι (CommRing.toCommSemiring.{u2} R _inst_1))) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (MvPolynomial.algebra.{u2, u2, u3} R R ι (CommRing.toCommSemiring.{u2} R _inst_1) (CommRing.toCommSemiring.{u2} R _inst_1) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) _inst_5 (MvPolynomial.aeval.{u2, u1, u3} R A ι (CommRing.toCommSemiring.{u2} R _inst_1) (CommRing.toCommSemiring.{u1} A _inst_2) _inst_5 x))) (Bot.bot.{max u3 u2} (Ideal.{max u3 u2} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u3} R ι (CommRing.toCommSemiring.{u2} R _inst_1)))) (Submodule.instBotSubmodule.{max u3 u2, max u3 u2} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u3} R ι (CommRing.toCommSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u2} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u2} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u2} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u3} R ι (CommRing.toCommSemiring.{u2} R _inst_1)))))) (Semiring.toModule.{max u3 u2} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u3} (MvPolynomial.{u3, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u3} R ι (CommRing.toCommSemiring.{u2} R _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align algebraic_independent_iff_ker_eq_bot algebraicIndependent_iff_ker_eq_botₓ'. -/
theorem algebraicIndependent_iff_ker_eq_bot :
    AlgebraicIndependent R x ↔
      (MvPolynomial.aeval x : MvPolynomial ι R →ₐ[R] A).toRingHom.ker = ⊥ :=
  RingHom.injective_iff_ker_eq_bot _
#align algebraic_independent_iff_ker_eq_bot algebraicIndependent_iff_ker_eq_bot

/- warning: algebraic_independent_iff -> algebraicIndependent_iff is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent_iff algebraicIndependent_iffₓ'. -/
theorem algebraicIndependent_iff :
    AlgebraicIndependent R x ↔
      ∀ p : MvPolynomial ι R, MvPolynomial.aeval (x : ι → A) p = 0 → p = 0 :=
  injective_iff_map_eq_zero _
#align algebraic_independent_iff algebraicIndependent_iff

/- warning: algebraic_independent.eq_zero_of_aeval_eq_zero -> AlgebraicIndependent.eq_zero_of_aeval_eq_zero is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent.eq_zero_of_aeval_eq_zero AlgebraicIndependent.eq_zero_of_aeval_eq_zeroₓ'. -/
theorem AlgebraicIndependent.eq_zero_of_aeval_eq_zero (h : AlgebraicIndependent R x) :
    ∀ p : MvPolynomial ι R, MvPolynomial.aeval (x : ι → A) p = 0 → p = 0 :=
  algebraicIndependent_iff.1 h
#align algebraic_independent.eq_zero_of_aeval_eq_zero AlgebraicIndependent.eq_zero_of_aeval_eq_zero

/- warning: algebraic_independent_iff_injective_aeval -> algebraicIndependent_iff_injective_aeval is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent_iff_injective_aeval algebraicIndependent_iff_injective_aevalₓ'. -/
theorem algebraicIndependent_iff_injective_aeval :
    AlgebraicIndependent R x ↔ Injective (MvPolynomial.aeval x : MvPolynomial ι R →ₐ[R] A) :=
  Iff.rfl
#align algebraic_independent_iff_injective_aeval algebraicIndependent_iff_injective_aeval

/- warning: algebraic_independent_empty_type_iff -> algebraicIndependent_empty_type_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2))] [_inst_8 : IsEmpty.{succ u1} ι], Iff (AlgebraicIndependent.{u1, u2, u3} ι R A x _inst_1 _inst_2 _inst_5) (Function.Injective.{succ u2, succ u3} R A (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)))) (fun (_x : RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)))) => R -> A) (RingHom.hasCoeToFun.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)))) (algebraMap.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5)))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {A : Type.{u1}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] [_inst_8 : IsEmpty.{succ u3} ι], Iff (AlgebraicIndependent.{u3, u2, u1} ι R A x _inst_1 _inst_2 _inst_5) (Function.Injective.{succ u2, succ u1} R A (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))))))) (algebraMap.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5)))
Case conversion may be inaccurate. Consider using '#align algebraic_independent_empty_type_iff algebraicIndependent_empty_type_iffₓ'. -/
@[simp]
theorem algebraicIndependent_empty_type_iff [IsEmpty ι] :
    AlgebraicIndependent R x ↔ Injective (algebraMap R A) :=
  by
  have : aeval x = (Algebra.ofId R A).comp (@isEmptyAlgEquiv R ι _ _).toAlgHom :=
    by
    ext i
    exact IsEmpty.elim' ‹IsEmpty ι› i
  rw [AlgebraicIndependent, this, ←
    injective.of_comp_iff' _ (@is_empty_alg_equiv R ι _ _).Bijective]
  rfl
#align algebraic_independent_empty_type_iff algebraicIndependent_empty_type_iff

namespace AlgebraicIndependent

variable (hx : AlgebraicIndependent R x)

include hx

/- warning: algebraic_independent.algebra_map_injective -> AlgebraicIndependent.algebraMap_injective is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2))], (AlgebraicIndependent.{u1, u2, u3} ι R A x _inst_1 _inst_2 _inst_5) -> (Function.Injective.{succ u2, succ u3} R A (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)))) (fun (_x : RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)))) => R -> A) (RingHom.hasCoeToFun.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)))) (algebraMap.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5)))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {A : Type.{u1}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))], (AlgebraicIndependent.{u3, u2, u1} ι R A x _inst_1 _inst_2 _inst_5) -> (Function.Injective.{succ u2, succ u1} R A (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))))))) (algebraMap.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5)))
Case conversion may be inaccurate. Consider using '#align algebraic_independent.algebra_map_injective AlgebraicIndependent.algebraMap_injectiveₓ'. -/
theorem algebraMap_injective : Injective (algebraMap R A) := by
  simpa [← MvPolynomial.algebraMap_eq, Function.comp] using
    (injective.of_comp_iff (algebraicIndependent_iff_injective_aeval.1 hx) MvPolynomial.C).2
      (MvPolynomial.C_injective _ _)
#align algebraic_independent.algebra_map_injective AlgebraicIndependent.algebraMap_injective

/- warning: algebraic_independent.linear_independent -> AlgebraicIndependent.linearIndependent is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2))], (AlgebraicIndependent.{u1, u2, u3} ι R A x _inst_1 _inst_2 _inst_5) -> (LinearIndependent.{u1, u2, u3} ι R A x (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} A (NonUnitalNonAssocRing.toAddCommGroup.{u3} A (NonAssocRing.toNonUnitalNonAssocRing.{u3} A (Ring.toNonAssocRing.{u3} A (CommRing.toRing.{u3} A _inst_2))))) (Algebra.toModule.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {A : Type.{u1}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))], (AlgebraicIndependent.{u3, u2, u1} ι R A x _inst_1 _inst_2 _inst_5) -> (LinearIndependent.{u3, u2, u1} ι R A x (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5))
Case conversion may be inaccurate. Consider using '#align algebraic_independent.linear_independent AlgebraicIndependent.linearIndependentₓ'. -/
theorem linearIndependent : LinearIndependent R x :=
  by
  rw [linearIndependent_iff_injective_total]
  have : Finsupp.total ι A R x = (MvPolynomial.aeval x).toLinearMap.comp (Finsupp.total ι _ R X) :=
    by
    ext
    simp
  rw [this]
  refine' hx.comp _
  rw [← linearIndependent_iff_injective_total]
  exact linear_independent_X _ _
#align algebraic_independent.linear_independent AlgebraicIndependent.linearIndependent

/- warning: algebraic_independent.injective -> AlgebraicIndependent.injective is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2))], (AlgebraicIndependent.{u1, u2, u3} ι R A x _inst_1 _inst_2 _inst_5) -> (forall [_inst_8 : Nontrivial.{u2} R], Function.Injective.{succ u1, succ u3} ι A x)
but is expected to have type
  forall {ι : Type.{u2}} {R : Type.{u3}} {A : Type.{u1}} {x : ι -> A} [_inst_1 : CommRing.{u3} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u3, u1} R A (CommRing.toCommSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))], (AlgebraicIndependent.{u2, u3, u1} ι R A x _inst_1 _inst_2 _inst_5) -> (forall [_inst_8 : Nontrivial.{u3} R], Function.Injective.{succ u2, succ u1} ι A x)
Case conversion may be inaccurate. Consider using '#align algebraic_independent.injective AlgebraicIndependent.injectiveₓ'. -/
protected theorem injective [Nontrivial R] : Injective x :=
  hx.LinearIndependent.Injective
#align algebraic_independent.injective AlgebraicIndependent.injective

/- warning: algebraic_independent.ne_zero -> AlgebraicIndependent.ne_zero is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2))], (AlgebraicIndependent.{u1, u2, u3} ι R A x _inst_1 _inst_2 _inst_5) -> (forall [_inst_8 : Nontrivial.{u2} R] (i : ι), Ne.{succ u3} A (x i) (OfNat.ofNat.{u3} A 0 (OfNat.mk.{u3} A 0 (Zero.zero.{u3} A (MulZeroClass.toHasZero.{u3} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} A (NonAssocRing.toNonUnitalNonAssocRing.{u3} A (Ring.toNonAssocRing.{u3} A (CommRing.toRing.{u3} A _inst_2))))))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {A : Type.{u1}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))], (AlgebraicIndependent.{u3, u2, u1} ι R A x _inst_1 _inst_2 _inst_5) -> (forall [_inst_8 : Nontrivial.{u2} R] (i : ι), Ne.{succ u1} A (x i) (OfNat.ofNat.{u1} A 0 (Zero.toOfNat0.{u1} A (CommMonoidWithZero.toZero.{u1} A (CommSemiring.toCommMonoidWithZero.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))))))
Case conversion may be inaccurate. Consider using '#align algebraic_independent.ne_zero AlgebraicIndependent.ne_zeroₓ'. -/
theorem ne_zero [Nontrivial R] (i : ι) : x i ≠ 0 :=
  hx.LinearIndependent.NeZero i
#align algebraic_independent.ne_zero AlgebraicIndependent.ne_zero

/- warning: algebraic_independent.comp -> AlgebraicIndependent.comp is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {ι' : Type.{u2}} {R : Type.{u3}} {A : Type.{u4}} {x : ι -> A} [_inst_1 : CommRing.{u3} R] [_inst_2 : CommRing.{u4} A] [_inst_5 : Algebra.{u3, u4} R A (CommRing.toCommSemiring.{u3} R _inst_1) (Ring.toSemiring.{u4} A (CommRing.toRing.{u4} A _inst_2))], (AlgebraicIndependent.{u1, u3, u4} ι R A x _inst_1 _inst_2 _inst_5) -> (forall (f : ι' -> ι), (Function.Injective.{succ u2, succ u1} ι' ι f) -> (AlgebraicIndependent.{u2, u3, u4} ι' R A (Function.comp.{succ u2, succ u1, succ u4} ι' ι A x f) _inst_1 _inst_2 _inst_5))
but is expected to have type
  forall {ι : Type.{u3}} {ι' : Type.{u4}} {R : Type.{u2}} {A : Type.{u1}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))], (AlgebraicIndependent.{u3, u2, u1} ι R A x _inst_1 _inst_2 _inst_5) -> (forall (f : ι' -> ι), (Function.Injective.{succ u4, succ u3} ι' ι f) -> (AlgebraicIndependent.{u4, u2, u1} ι' R A (Function.comp.{succ u4, succ u3, succ u1} ι' ι A x f) _inst_1 _inst_2 _inst_5))
Case conversion may be inaccurate. Consider using '#align algebraic_independent.comp AlgebraicIndependent.compₓ'. -/
theorem comp (f : ι' → ι) (hf : Function.Injective f) : AlgebraicIndependent R (x ∘ f) := fun p q =>
  by simpa [aeval_rename, (rename_injective f hf).eq_iff] using @hx (rename f p) (rename f q)
#align algebraic_independent.comp AlgebraicIndependent.comp

#print AlgebraicIndependent.coe_range /-
theorem coe_range : AlgebraicIndependent R (coe : range x → A) := by
  simpa using hx.comp _ (range_splitting_injective x)
#align algebraic_independent.coe_range AlgebraicIndependent.coe_range
-/

/- warning: algebraic_independent.map -> AlgebraicIndependent.map is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent.map AlgebraicIndependent.mapₓ'. -/
theorem map {f : A →ₐ[R] A'} (hf_inj : Set.InjOn f (adjoin R (range x))) :
    AlgebraicIndependent R (f ∘ x) :=
  by
  have : aeval (f ∘ x) = f.comp (aeval x) := by ext <;> simp
  have h : ∀ p : MvPolynomial ι R, aeval x p ∈ (@aeval R _ _ _ _ _ (coe : range x → A)).range :=
    by
    intro p
    rw [AlgHom.mem_range]
    refine' ⟨MvPolynomial.rename (cod_restrict x (range x) mem_range_self) p, _⟩
    simp [Function.comp, aeval_rename]
  intro x y hxy
  rw [this] at hxy
  rw [adjoin_eq_range] at hf_inj
  exact hx (hf_inj (h x) (h y) hxy)
#align algebraic_independent.map AlgebraicIndependent.map

/- warning: algebraic_independent.map' -> AlgebraicIndependent.map' is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent.map' AlgebraicIndependent.map'ₓ'. -/
theorem map' {f : A →ₐ[R] A'} (hf_inj : Injective f) : AlgebraicIndependent R (f ∘ x) :=
  hx.map (injOn_of_injective hf_inj _)
#align algebraic_independent.map' AlgebraicIndependent.map'

omit hx

/- warning: algebraic_independent.of_comp -> AlgebraicIndependent.of_comp is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent.of_comp AlgebraicIndependent.of_compₓ'. -/
theorem of_comp (f : A →ₐ[R] A') (hfv : AlgebraicIndependent R (f ∘ x)) :
    AlgebraicIndependent R x :=
  by
  have : aeval (f ∘ x) = f.comp (aeval x) := by ext <;> simp
  rw [AlgebraicIndependent, this] at hfv <;> exact hfv.of_comp
#align algebraic_independent.of_comp AlgebraicIndependent.of_comp

end AlgebraicIndependent

open AlgebraicIndependent

/- warning: alg_hom.algebraic_independent_iff -> AlgHom.algebraicIndependent_iff is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align alg_hom.algebraic_independent_iff AlgHom.algebraicIndependent_iffₓ'. -/
theorem AlgHom.algebraicIndependent_iff (f : A →ₐ[R] A') (hf : Injective f) :
    AlgebraicIndependent R (f ∘ x) ↔ AlgebraicIndependent R x :=
  ⟨fun h => h.of_comp f, fun h => h.map (injOn_of_injective hf _)⟩
#align alg_hom.algebraic_independent_iff AlgHom.algebraicIndependent_iff

/- warning: algebraic_independent_of_subsingleton -> algebraicIndependent_of_subsingleton is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2))] [_inst_8 : Subsingleton.{succ u2} R], AlgebraicIndependent.{u1, u2, u3} ι R A x _inst_1 _inst_2 _inst_5
but is expected to have type
  forall {ι : Type.{u2}} {R : Type.{u3}} {A : Type.{u1}} {x : ι -> A} [_inst_1 : CommRing.{u3} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u3, u1} R A (CommRing.toCommSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] [_inst_8 : Subsingleton.{succ u3} R], AlgebraicIndependent.{u2, u3, u1} ι R A x _inst_1 _inst_2 _inst_5
Case conversion may be inaccurate. Consider using '#align algebraic_independent_of_subsingleton algebraicIndependent_of_subsingletonₓ'. -/
@[nontriviality]
theorem algebraicIndependent_of_subsingleton [Subsingleton R] : AlgebraicIndependent R x :=
  algebraicIndependent_iff.2 fun l hl => Subsingleton.elim _ _
#align algebraic_independent_of_subsingleton algebraicIndependent_of_subsingleton

/- warning: algebraic_independent_equiv -> algebraicIndependent_equiv is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {ι' : Type.{u2}} {R : Type.{u3}} {A : Type.{u4}} [_inst_1 : CommRing.{u3} R] [_inst_2 : CommRing.{u4} A] [_inst_5 : Algebra.{u3, u4} R A (CommRing.toCommSemiring.{u3} R _inst_1) (Ring.toSemiring.{u4} A (CommRing.toRing.{u4} A _inst_2))] (e : Equiv.{succ u1, succ u2} ι ι') {f : ι' -> A}, Iff (AlgebraicIndependent.{u1, u3, u4} ι R A (Function.comp.{succ u1, succ u2, succ u4} ι ι' A f (coeFn.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1), max (succ u1) (succ u2)} (Equiv.{succ u1, succ u2} ι ι') (fun (_x : Equiv.{succ u1, succ u2} ι ι') => ι -> ι') (Equiv.hasCoeToFun.{succ u1, succ u2} ι ι') e)) _inst_1 _inst_2 _inst_5) (AlgebraicIndependent.{u2, u3, u4} ι' R A f _inst_1 _inst_2 _inst_5)
but is expected to have type
  forall {ι : Type.{u4}} {ι' : Type.{u3}} {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] (e : Equiv.{succ u4, succ u3} ι ι') {f : ι' -> A}, Iff (AlgebraicIndependent.{u4, u2, u1} ι R A (Function.comp.{succ u4, succ u3, succ u1} ι ι' A f (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} ι ι') ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : ι) => ι') _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} ι ι') e)) _inst_1 _inst_2 _inst_5) (AlgebraicIndependent.{u3, u2, u1} ι' R A f _inst_1 _inst_2 _inst_5)
Case conversion may be inaccurate. Consider using '#align algebraic_independent_equiv algebraicIndependent_equivₓ'. -/
theorem algebraicIndependent_equiv (e : ι ≃ ι') {f : ι' → A} :
    AlgebraicIndependent R (f ∘ e) ↔ AlgebraicIndependent R f :=
  ⟨fun h => Function.comp.right_id f ▸ e.self_comp_symm ▸ h.comp _ e.symm.Injective, fun h =>
    h.comp _ e.Injective⟩
#align algebraic_independent_equiv algebraicIndependent_equiv

/- warning: algebraic_independent_equiv' -> algebraicIndependent_equiv' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {ι' : Type.{u2}} {R : Type.{u3}} {A : Type.{u4}} [_inst_1 : CommRing.{u3} R] [_inst_2 : CommRing.{u4} A] [_inst_5 : Algebra.{u3, u4} R A (CommRing.toCommSemiring.{u3} R _inst_1) (Ring.toSemiring.{u4} A (CommRing.toRing.{u4} A _inst_2))] (e : Equiv.{succ u1, succ u2} ι ι') {f : ι' -> A} {g : ι -> A}, (Eq.{max (succ u1) (succ u4)} (ι -> A) (Function.comp.{succ u1, succ u2, succ u4} ι ι' A f (coeFn.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1), max (succ u1) (succ u2)} (Equiv.{succ u1, succ u2} ι ι') (fun (_x : Equiv.{succ u1, succ u2} ι ι') => ι -> ι') (Equiv.hasCoeToFun.{succ u1, succ u2} ι ι') e)) g) -> (Iff (AlgebraicIndependent.{u1, u3, u4} ι R A g _inst_1 _inst_2 _inst_5) (AlgebraicIndependent.{u2, u3, u4} ι' R A f _inst_1 _inst_2 _inst_5))
but is expected to have type
  forall {ι : Type.{u4}} {ι' : Type.{u3}} {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_5 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (e : Equiv.{succ u4, succ u3} ι ι') {f : ι' -> A} {g : ι -> A}, (Eq.{max (succ u4) (succ u2)} (ι -> A) (Function.comp.{succ u4, succ u3, succ u2} ι ι' A f (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} ι ι') ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : ι) => ι') _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} ι ι') e)) g) -> (Iff (AlgebraicIndependent.{u4, u1, u2} ι R A g _inst_1 _inst_2 _inst_5) (AlgebraicIndependent.{u3, u1, u2} ι' R A f _inst_1 _inst_2 _inst_5))
Case conversion may be inaccurate. Consider using '#align algebraic_independent_equiv' algebraicIndependent_equiv'ₓ'. -/
theorem algebraicIndependent_equiv' (e : ι ≃ ι') {f : ι' → A} {g : ι → A} (h : f ∘ e = g) :
    AlgebraicIndependent R g ↔ AlgebraicIndependent R f :=
  h ▸ algebraicIndependent_equiv e
#align algebraic_independent_equiv' algebraicIndependent_equiv'

#print algebraicIndependent_subtype_range /-
theorem algebraicIndependent_subtype_range {ι} {f : ι → A} (hf : Injective f) :
    AlgebraicIndependent R (coe : range f → A) ↔ AlgebraicIndependent R f :=
  Iff.symm <| algebraicIndependent_equiv' (Equiv.ofInjective f hf) rfl
#align algebraic_independent_subtype_range algebraicIndependent_subtype_range
-/

alias algebraicIndependent_subtype_range ↔ AlgebraicIndependent.of_subtype_range _
#align algebraic_independent.of_subtype_range AlgebraicIndependent.of_subtype_range

#print algebraicIndependent_image /-
theorem algebraicIndependent_image {ι} {s : Set ι} {f : ι → A} (hf : Set.InjOn f s) :
    (AlgebraicIndependent R fun x : s => f x) ↔ AlgebraicIndependent R fun x : f '' s => (x : A) :=
  algebraicIndependent_equiv' (Equiv.Set.imageOfInjOn _ _ hf) rfl
#align algebraic_independent_image algebraicIndependent_image
-/

/- warning: algebraic_independent_adjoin -> algebraicIndependent_adjoin is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2))], (AlgebraicIndependent.{u1, u2, u3} ι R A x _inst_1 _inst_2 _inst_5) -> (AlgebraicIndependent.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) A (Subalgebra.setLike.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5)) (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) (fun (i : ι) => Subtype.mk.{succ u3} A (fun (x_1 : A) => Membership.Mem.{u3, u3} A (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) (SetLike.hasMem.{u3, u3} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) A (Subalgebra.setLike.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5)) x_1 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) (x i) (Algebra.subset_adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x) (x i) (Set.mem_range_self.{u3, succ u1} A ι x i))) _inst_1 (Subalgebra.toCommRing.{u2, u3} R A _inst_1 _inst_2 _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) (Subalgebra.algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {A : Type.{u1}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))], (AlgebraicIndependent.{u3, u2, u1} ι R A x _inst_1 _inst_2 _inst_5) -> (AlgebraicIndependent.{u3, u2, u1} ι R (Subtype.{succ u1} A (fun (x_1 : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5)) x_1 (Algebra.adjoin.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5 (Set.range.{u1, succ u3} A ι x)))) (fun (i : ι) => Subtype.mk.{succ u1} A (fun (x_1 : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5)) x_1 (Algebra.adjoin.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5 (Set.range.{u1, succ u3} A ι x))) (x i) (Algebra.subset_adjoin.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5 (Set.range.{u1, succ u3} A ι x) (x i) (Set.mem_range_self.{succ u3, u1} A ι x i))) _inst_1 (Subalgebra.toCommRing.{u2, u1} R A _inst_1 _inst_2 _inst_5 (Algebra.adjoin.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5 (Set.range.{u1, succ u3} A ι x))) (Subalgebra.algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5 (Algebra.adjoin.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5 (Set.range.{u1, succ u3} A ι x))))
Case conversion may be inaccurate. Consider using '#align algebraic_independent_adjoin algebraicIndependent_adjoinₓ'. -/
theorem algebraicIndependent_adjoin (hs : AlgebraicIndependent R x) :
    @AlgebraicIndependent ι R (adjoin R (range x))
      (fun i : ι => ⟨x i, subset_adjoin (mem_range_self i)⟩) _ _ _ :=
  AlgebraicIndependent.of_comp (adjoin R (range x)).val hs
#align algebraic_independent_adjoin algebraicIndependent_adjoin

/- warning: algebraic_independent.restrict_scalars -> AlgebraicIndependent.restrictScalars is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent.restrict_scalars AlgebraicIndependent.restrictScalarsₓ'. -/
/-- A set of algebraically independent elements in an algebra `A` over a ring `K` is also
algebraically independent over a subring `R` of `K`. -/
theorem AlgebraicIndependent.restrictScalars {K : Type _} [CommRing K] [Algebra R K] [Algebra K A]
    [IsScalarTower R K A] (hinj : Function.Injective (algebraMap R K))
    (ai : AlgebraicIndependent K x) : AlgebraicIndependent R x :=
  by
  have :
    (aeval x : MvPolynomial ι K →ₐ[K] A).toRingHom.comp (MvPolynomial.map (algebraMap R K)) =
      (aeval x : MvPolynomial ι R →ₐ[R] A).toRingHom :=
    by ext <;> simp [algebra_map_eq_smul_one]
  show injective (aeval x).toRingHom
  rw [← this]
  exact injective.comp ai (MvPolynomial.map_injective _ hinj)
#align algebraic_independent.restrict_scalars AlgebraicIndependent.restrictScalars

#print algebraicIndependent_finset_map_embedding_subtype /-
/-- Every finite subset of an algebraically independent set is algebraically independent. -/
theorem algebraicIndependent_finset_map_embedding_subtype (s : Set A)
    (li : AlgebraicIndependent R (coe : s → A)) (t : Finset s) :
    AlgebraicIndependent R (coe : Finset.map (Embedding.subtype s) t → A) :=
  by
  let f : t.map (embedding.subtype s) → s := fun x =>
    ⟨x.1, by
      obtain ⟨x, h⟩ := x
      rw [Finset.mem_map] at h
      obtain ⟨a, ha, rfl⟩ := h
      simp only [Subtype.coe_prop, embedding.coe_subtype]⟩
  convert AlgebraicIndependent.comp li f _
  rintro ⟨x, hx⟩ ⟨y, hy⟩
  rw [Finset.mem_map] at hx hy
  obtain ⟨a, ha, rfl⟩ := hx
  obtain ⟨b, hb, rfl⟩ := hy
  simp only [imp_self, Subtype.mk_eq_mk]
#align algebraic_independent_finset_map_embedding_subtype algebraicIndependent_finset_map_embedding_subtype
-/

/- warning: algebraic_independent_bounded_of_finset_algebraic_independent_bounded -> algebraicIndependent_bounded_of_finset_algebraicIndependent_bounded is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_5 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] {n : Nat}, (forall (s : Finset.{u2} A), (AlgebraicIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Finset.{u2} A) Type.{u2} (Finset.hasCoeToSort.{u2} A) s) R A (fun (i : coeSort.{succ u2, succ (succ u2)} (Finset.{u2} A) Type.{u2} (Finset.hasCoeToSort.{u2} A) s) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Finset.{u2} A) Type.{u2} (Finset.hasCoeToSort.{u2} A) s) A (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Finset.{u2} A) Type.{u2} (Finset.hasCoeToSort.{u2} A) s) A (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Finset.{u2} A) Type.{u2} (Finset.hasCoeToSort.{u2} A) s) A (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Finset.{u2} A) Type.{u2} (Finset.hasCoeToSort.{u2} A) s) A (coeSubtype.{succ u2} A (fun (x : A) => Membership.Mem.{u2, u2} A (Finset.{u2} A) (Finset.hasMem.{u2} A) x s))))) i) _inst_1 _inst_2 _inst_5) -> (LE.le.{0} Nat Nat.hasLe (Finset.card.{u2} A s) n)) -> (forall (s : Set.{u2} A), (AlgebraicIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) s) R A ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) s) A (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) s) A (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) s) A (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) s) A (coeSubtype.{succ u2} A (fun (x : A) => Membership.Mem.{u2, u2} A (Set.{u2} A) (Set.hasMem.{u2} A) x s)))))) _inst_1 _inst_2 _inst_5) -> (LE.le.{succ u2} Cardinal.{u2} Cardinal.hasLe.{u2} (Cardinal.mk.{u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) s)) ((fun (a : Type) (b : Type.{succ u2}) [self : HasLiftT.{1, succ (succ u2)} a b] => self.0) Nat Cardinal.{u2} (HasLiftT.mk.{1, succ (succ u2)} Nat Cardinal.{u2} (CoeTCₓ.coe.{1, succ (succ u2)} Nat Cardinal.{u2} (Nat.castCoe.{succ u2} Cardinal.{u2} Cardinal.hasNatCast.{u2}))) n)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_5 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] {n : Nat}, (forall (s : Finset.{u2} A), (AlgebraicIndependent.{u2, u1, u2} (Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (Finset.{u2} A) (Finset.instMembershipFinset.{u2} A) x s)) R A (fun (i : Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (Finset.{u2} A) (Finset.instMembershipFinset.{u2} A) x s)) => Subtype.val.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (Finset.{u2} A) (Finset.instMembershipFinset.{u2} A) x s) i) _inst_1 _inst_2 _inst_5) -> (LE.le.{0} Nat instLENat (Finset.card.{u2} A s) n)) -> (forall (s : Set.{u2} A), (AlgebraicIndependent.{u2, u1, u2} (Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (Set.{u2} A) (Set.instMembershipSet.{u2} A) x s)) R A (Subtype.val.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (Set.{u2} A) (Set.instMembershipSet.{u2} A) x s)) _inst_1 _inst_2 _inst_5) -> (LE.le.{succ u2} Cardinal.{u2} Cardinal.instLECardinal.{u2} (Cardinal.mk.{u2} (Set.Elem.{u2} A s)) (Nat.cast.{succ u2} Cardinal.{u2} Cardinal.instNatCastCardinal.{u2} n)))
Case conversion may be inaccurate. Consider using '#align algebraic_independent_bounded_of_finset_algebraic_independent_bounded algebraicIndependent_bounded_of_finset_algebraicIndependent_boundedₓ'. -/
/-- If every finite set of algebraically independent element has cardinality at most `n`,
then the same is true for arbitrary sets of algebraically independent elements.
-/
theorem algebraicIndependent_bounded_of_finset_algebraicIndependent_bounded {n : ℕ}
    (H : ∀ s : Finset A, (AlgebraicIndependent R fun i : s => (i : A)) → s.card ≤ n) :
    ∀ s : Set A, AlgebraicIndependent R (coe : s → A) → Cardinal.mk s ≤ n :=
  by
  intro s li
  apply Cardinal.card_le_of
  intro t
  rw [← Finset.card_map (embedding.subtype s)]
  apply H
  apply algebraicIndependent_finset_map_embedding_subtype _ li
#align algebraic_independent_bounded_of_finset_algebraic_independent_bounded algebraicIndependent_bounded_of_finset_algebraicIndependent_bounded

section Subtype

/- warning: algebraic_independent.restrict_of_comp_subtype -> AlgebraicIndependent.restrict_of_comp_subtype is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2))] {s : Set.{u1} ι}, (AlgebraicIndependent.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) R A (Function.comp.{succ u1, succ u1, succ u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι A x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x s))))))) _inst_1 _inst_2 _inst_5) -> (AlgebraicIndependent.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) R A (Set.restrict.{u1, u3} ι (fun (ᾰ : ι) => A) s x) _inst_1 _inst_2 _inst_5)
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {A : Type.{u1}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] {s : Set.{u3} ι}, (AlgebraicIndependent.{u3, u2, u1} (Set.Elem.{u3} ι s) R A (Function.comp.{succ u3, succ u3, succ u1} (Set.Elem.{u3} ι s) ι A x (Subtype.val.{succ u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) x s))) _inst_1 _inst_2 _inst_5) -> (AlgebraicIndependent.{u3, u2, u1} (Set.Elem.{u3} ι s) R A (Set.restrict.{u3, u1} ι (fun (ᾰ : ι) => A) s x) _inst_1 _inst_2 _inst_5)
Case conversion may be inaccurate. Consider using '#align algebraic_independent.restrict_of_comp_subtype AlgebraicIndependent.restrict_of_comp_subtypeₓ'. -/
theorem AlgebraicIndependent.restrict_of_comp_subtype {s : Set ι}
    (hs : AlgebraicIndependent R (x ∘ coe : s → A)) : AlgebraicIndependent R (s.restrict x) :=
  hs
#align algebraic_independent.restrict_of_comp_subtype AlgebraicIndependent.restrict_of_comp_subtype

variable (R A)

/- warning: algebraic_independent_empty_iff -> algebraicIndependent_empty_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_5 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))], Iff (AlgebraicIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (EmptyCollection.emptyCollection.{u2} (Set.{u2} A) (Set.hasEmptyc.{u2} A))) R A (fun (x : coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (EmptyCollection.emptyCollection.{u2} (Set.{u2} A) (Set.hasEmptyc.{u2} A))) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (EmptyCollection.emptyCollection.{u2} (Set.{u2} A) (Set.hasEmptyc.{u2} A))) A (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (EmptyCollection.emptyCollection.{u2} (Set.{u2} A) (Set.hasEmptyc.{u2} A))) A (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (EmptyCollection.emptyCollection.{u2} (Set.{u2} A) (Set.hasEmptyc.{u2} A))) A (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (EmptyCollection.emptyCollection.{u2} (Set.{u2} A) (Set.hasEmptyc.{u2} A))) A (coeSubtype.{succ u2} A (fun (x : A) => Membership.Mem.{u2, u2} A (Set.{u2} A) (Set.hasMem.{u2} A) x (EmptyCollection.emptyCollection.{u2} (Set.{u2} A) (Set.hasEmptyc.{u2} A))))))) x) _inst_1 _inst_2 _inst_5) (Function.Injective.{succ u1, succ u2} R A (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (algebraMap.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_5)))
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_5 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))], Iff (AlgebraicIndependent.{u2, u1, u2} (Subtype.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (Set.{u2} A) (Set.instMembershipSet.{u2} A) x (EmptyCollection.emptyCollection.{u2} (Set.{u2} A) (Set.instEmptyCollectionSet.{u2} A)))) R A (Subtype.val.{succ u2} A (fun (x : A) => Membership.mem.{u2, u2} A (Set.{u2} A) (Set.instMembershipSet.{u2} A) x (EmptyCollection.emptyCollection.{u2} (Set.{u2} A) (Set.instEmptyCollectionSet.{u2} A)))) _inst_1 _inst_2 _inst_5) (Function.Injective.{succ u1, succ u2} R A (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))))) (algebraMap.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_5)))
Case conversion may be inaccurate. Consider using '#align algebraic_independent_empty_iff algebraicIndependent_empty_iffₓ'. -/
theorem algebraicIndependent_empty_iff :
    AlgebraicIndependent R (fun x => x : (∅ : Set A) → A) ↔ Injective (algebraMap R A) := by simp
#align algebraic_independent_empty_iff algebraicIndependent_empty_iff

variable {R A}

#print AlgebraicIndependent.mono /-
theorem AlgebraicIndependent.mono {t s : Set A} (h : t ⊆ s)
    (hx : AlgebraicIndependent R (fun x => x : s → A)) :
    AlgebraicIndependent R (fun x => x : t → A) := by
  simpa [Function.comp] using hx.comp (inclusion h) (inclusion_injective h)
#align algebraic_independent.mono AlgebraicIndependent.mono
-/

end Subtype

/- warning: algebraic_independent.to_subtype_range -> AlgebraicIndependent.to_subtype_range is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_5 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] {ι : Type.{u3}} {f : ι -> A}, (AlgebraicIndependent.{u3, u1, u2} ι R A f _inst_1 _inst_2 _inst_5) -> (AlgebraicIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (Set.range.{u2, succ u3} A ι f)) R A ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (Set.range.{u2, succ u3} A ι f)) A (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (Set.range.{u2, succ u3} A ι f)) A (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (Set.range.{u2, succ u3} A ι f)) A (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (Set.range.{u2, succ u3} A ι f)) A (coeSubtype.{succ u2} A (fun (x : A) => Membership.Mem.{u2, u2} A (Set.{u2} A) (Set.hasMem.{u2} A) x (Set.range.{u2, succ u3} A ι f))))))) _inst_1 _inst_2 _inst_5)
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] {ι : Type.{u3}} {f : ι -> A}, (AlgebraicIndependent.{u3, u2, u1} ι R A f _inst_1 _inst_2 _inst_5) -> (AlgebraicIndependent.{u1, u2, u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Set.{u1} A) (Set.instMembershipSet.{u1} A) x (Set.range.{u1, succ u3} A ι f))) R A (Subtype.val.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Set.{u1} A) (Set.instMembershipSet.{u1} A) x (Set.range.{u1, succ u3} A ι f))) _inst_1 _inst_2 _inst_5)
Case conversion may be inaccurate. Consider using '#align algebraic_independent.to_subtype_range AlgebraicIndependent.to_subtype_rangeₓ'. -/
theorem AlgebraicIndependent.to_subtype_range {ι} {f : ι → A} (hf : AlgebraicIndependent R f) :
    AlgebraicIndependent R (coe : range f → A) :=
  by
  nontriviality R
  · rwa [algebraicIndependent_subtype_range hf.injective]
#align algebraic_independent.to_subtype_range AlgebraicIndependent.to_subtype_range

/- warning: algebraic_independent.to_subtype_range' -> AlgebraicIndependent.to_subtype_range' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_5 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] {ι : Type.{u3}} {f : ι -> A}, (AlgebraicIndependent.{u3, u1, u2} ι R A f _inst_1 _inst_2 _inst_5) -> (forall {t : Set.{u2} A}, (Eq.{succ u2} (Set.{u2} A) (Set.range.{u2, succ u3} A ι f) t) -> (AlgebraicIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) t) R A ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) t) A (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) t) A (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) t) A (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) t) A (coeSubtype.{succ u2} A (fun (x : A) => Membership.Mem.{u2, u2} A (Set.{u2} A) (Set.hasMem.{u2} A) x t)))))) _inst_1 _inst_2 _inst_5))
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] {ι : Type.{u3}} {f : ι -> A}, (AlgebraicIndependent.{u3, u2, u1} ι R A f _inst_1 _inst_2 _inst_5) -> (forall {t : Set.{u1} A}, (Eq.{succ u1} (Set.{u1} A) (Set.range.{u1, succ u3} A ι f) t) -> (AlgebraicIndependent.{u1, u2, u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Set.{u1} A) (Set.instMembershipSet.{u1} A) x t)) R A (Subtype.val.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Set.{u1} A) (Set.instMembershipSet.{u1} A) x t)) _inst_1 _inst_2 _inst_5))
Case conversion may be inaccurate. Consider using '#align algebraic_independent.to_subtype_range' AlgebraicIndependent.to_subtype_range'ₓ'. -/
theorem AlgebraicIndependent.to_subtype_range' {ι} {f : ι → A} (hf : AlgebraicIndependent R f) {t}
    (ht : range f = t) : AlgebraicIndependent R (coe : t → A) :=
  ht ▸ hf.to_subtype_range
#align algebraic_independent.to_subtype_range' AlgebraicIndependent.to_subtype_range'

/- warning: algebraic_independent_comp_subtype -> algebraicIndependent_comp_subtype is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent_comp_subtype algebraicIndependent_comp_subtypeₓ'. -/
theorem algebraicIndependent_comp_subtype {s : Set ι} :
    AlgebraicIndependent R (x ∘ coe : s → A) ↔
      ∀ p ∈ MvPolynomial.supported R s, aeval x p = 0 → p = 0 :=
  by
  have : (aeval (x ∘ coe : s → A) : _ →ₐ[R] _) = (aeval x).comp (rename coe) := by ext <;> simp
  have : ∀ p : MvPolynomial s R, rename (coe : s → ι) p = 0 ↔ p = 0 :=
    (injective_iff_map_eq_zero' (rename (coe : s → ι) : MvPolynomial s R →ₐ[R] _).toRingHom).1
      (rename_injective _ Subtype.val_injective)
  simp [algebraicIndependent_iff, supported_eq_range_rename, *]
#align algebraic_independent_comp_subtype algebraicIndependent_comp_subtype

/- warning: algebraic_independent_subtype -> algebraicIndependent_subtype is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent_subtype algebraicIndependent_subtypeₓ'. -/
theorem algebraicIndependent_subtype {s : Set A} :
    AlgebraicIndependent R (fun x => x : s → A) ↔
      ∀ p : MvPolynomial A R, p ∈ MvPolynomial.supported R s → aeval id p = 0 → p = 0 :=
  by apply @algebraicIndependent_comp_subtype _ _ _ id
#align algebraic_independent_subtype algebraicIndependent_subtype

/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/
#print algebraicIndependent_of_finite /-
theorem algebraicIndependent_of_finite (s : Set A)
    (H : ∀ (t) (_ : t ⊆ s), t.Finite → AlgebraicIndependent R (fun x => x : t → A)) :
    AlgebraicIndependent R (fun x => x : s → A) :=
  algebraicIndependent_subtype.2 fun p hp =>
    algebraicIndependent_subtype.1 (H _ (mem_supported.1 hp) (Finset.finite_toSet _)) _ (by simp)
#align algebraic_independent_of_finite algebraicIndependent_of_finite
-/

/- warning: algebraic_independent.image_of_comp -> AlgebraicIndependent.image_of_comp is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_5 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] {ι : Type.{u3}} {ι' : Type.{u4}} (s : Set.{u3} ι) (f : ι -> ι') (g : ι' -> A), (AlgebraicIndependent.{u3, u1, u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) R A (fun (x : coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) => g (f ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (coeSubtype.{succ u3} ι (fun (x : ι) => Membership.Mem.{u3, u3} ι (Set.{u3} ι) (Set.hasMem.{u3} ι) x s))))) x))) _inst_1 _inst_2 _inst_5) -> (AlgebraicIndependent.{u4, u1, u2} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι') Type.{u4} (Set.hasCoeToSort.{u4} ι') (Set.image.{u3, u4} ι ι' f s)) R A (fun (x : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι') Type.{u4} (Set.hasCoeToSort.{u4} ι') (Set.image.{u3, u4} ι ι' f s)) => g ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι') Type.{u4} (Set.hasCoeToSort.{u4} ι') (Set.image.{u3, u4} ι ι' f s)) ι' (HasLiftT.mk.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι') Type.{u4} (Set.hasCoeToSort.{u4} ι') (Set.image.{u3, u4} ι ι' f s)) ι' (CoeTCₓ.coe.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι') Type.{u4} (Set.hasCoeToSort.{u4} ι') (Set.image.{u3, u4} ι ι' f s)) ι' (coeBase.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι') Type.{u4} (Set.hasCoeToSort.{u4} ι') (Set.image.{u3, u4} ι ι' f s)) ι' (coeSubtype.{succ u4} ι' (fun (x : ι') => Membership.Mem.{u4, u4} ι' (Set.{u4} ι') (Set.hasMem.{u4} ι') x (Set.image.{u3, u4} ι ι' f s)))))) x)) _inst_1 _inst_2 _inst_5)
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] {ι : Type.{u4}} {ι' : Type.{u3}} (s : Set.{u4} ι) (f : ι -> ι') (g : ι' -> A), (AlgebraicIndependent.{u4, u2, u1} (Set.Elem.{u4} ι s) R A (fun (x : Set.Elem.{u4} ι s) => g (f (Subtype.val.{succ u4} ι (fun (x : ι) => Membership.mem.{u4, u4} ι (Set.{u4} ι) (Set.instMembershipSet.{u4} ι) x s) x))) _inst_1 _inst_2 _inst_5) -> (AlgebraicIndependent.{u3, u2, u1} (Set.Elem.{u3} ι' (Set.image.{u4, u3} ι ι' f s)) R A (fun (x : Set.Elem.{u3} ι' (Set.image.{u4, u3} ι ι' f s)) => g (Subtype.val.{succ u3} ι' (fun (x : ι') => Membership.mem.{u3, u3} ι' (Set.{u3} ι') (Set.instMembershipSet.{u3} ι') x (Set.image.{u4, u3} ι ι' f s)) x)) _inst_1 _inst_2 _inst_5)
Case conversion may be inaccurate. Consider using '#align algebraic_independent.image_of_comp AlgebraicIndependent.image_of_compₓ'. -/
theorem AlgebraicIndependent.image_of_comp {ι ι'} (s : Set ι) (f : ι → ι') (g : ι' → A)
    (hs : AlgebraicIndependent R fun x : s => g (f x)) :
    AlgebraicIndependent R fun x : f '' s => g x :=
  by
  nontriviality R
  have : inj_on f s := inj_on_iff_injective.2 hs.injective.of_comp
  exact (algebraicIndependent_equiv' (Equiv.Set.imageOfInjOn f s this) rfl).1 hs
#align algebraic_independent.image_of_comp AlgebraicIndependent.image_of_comp

/- warning: algebraic_independent.image -> AlgebraicIndependent.image is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_5 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] {ι : Type.{u3}} {s : Set.{u3} ι} {f : ι -> A}, (AlgebraicIndependent.{u3, u1, u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) R A (fun (x : coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) => f ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (coeSubtype.{succ u3} ι (fun (x : ι) => Membership.Mem.{u3, u3} ι (Set.{u3} ι) (Set.hasMem.{u3} ι) x s))))) x)) _inst_1 _inst_2 _inst_5) -> (AlgebraicIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (Set.image.{u3, u2} ι A f s)) R A (fun (x : coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (Set.image.{u3, u2} ι A f s)) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (Set.image.{u3, u2} ι A f s)) A (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (Set.image.{u3, u2} ι A f s)) A (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (Set.image.{u3, u2} ι A f s)) A (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) (Set.image.{u3, u2} ι A f s)) A (coeSubtype.{succ u2} A (fun (x : A) => Membership.Mem.{u2, u2} A (Set.{u2} A) (Set.hasMem.{u2} A) x (Set.image.{u3, u2} ι A f s)))))) x) _inst_1 _inst_2 _inst_5)
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] {ι : Type.{u3}} {s : Set.{u3} ι} {f : ι -> A}, (AlgebraicIndependent.{u3, u2, u1} (Set.Elem.{u3} ι s) R A (fun (x : Set.Elem.{u3} ι s) => f (Subtype.val.{succ u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) x s) x)) _inst_1 _inst_2 _inst_5) -> (AlgebraicIndependent.{u1, u2, u1} (Set.Elem.{u1} A (Set.image.{u3, u1} ι A f s)) R A (fun (x : Set.Elem.{u1} A (Set.image.{u3, u1} ι A f s)) => Subtype.val.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Set.{u1} A) (Set.instMembershipSet.{u1} A) x (Set.image.{u3, u1} ι A f s)) x) _inst_1 _inst_2 _inst_5)
Case conversion may be inaccurate. Consider using '#align algebraic_independent.image AlgebraicIndependent.imageₓ'. -/
theorem AlgebraicIndependent.image {ι} {s : Set ι} {f : ι → A}
    (hs : AlgebraicIndependent R fun x : s => f x) :
    AlgebraicIndependent R fun x : f '' s => (x : A) := by
  convert AlgebraicIndependent.image_of_comp s f id hs
#align algebraic_independent.image AlgebraicIndependent.image

#print algebraicIndependent_iUnion_of_directed /-
theorem algebraicIndependent_iUnion_of_directed {η : Type _} [Nonempty η] {s : η → Set A}
    (hs : Directed (· ⊆ ·) s) (h : ∀ i, AlgebraicIndependent R (fun x => x : s i → A)) :
    AlgebraicIndependent R (fun x => x : (⋃ i, s i) → A) :=
  by
  refine' algebraicIndependent_of_finite (⋃ i, s i) fun t ht ft => _
  rcases finite_subset_Union ft ht with ⟨I, fi, hI⟩
  rcases hs.finset_le fi.to_finset with ⟨i, hi⟩
  exact (h i).mono (subset.trans hI <| Union₂_subset fun j hj => hi j (fi.mem_to_finset.2 hj))
#align algebraic_independent_Union_of_directed algebraicIndependent_iUnion_of_directed
-/

#print algebraicIndependent_sUnion_of_directed /-
theorem algebraicIndependent_sUnion_of_directed {s : Set (Set A)} (hsn : s.Nonempty)
    (hs : DirectedOn (· ⊆ ·) s)
    (h : ∀ a ∈ s, AlgebraicIndependent R (fun x => x : (a : Set A) → A)) :
    AlgebraicIndependent R (fun x => x : ⋃₀ s → A) := by
  letI : Nonempty s := nonempty.to_subtype hsn <;> rw [sUnion_eq_Union] <;>
    exact algebraicIndependent_iUnion_of_directed hs.directed_coe (by simpa using h)
#align algebraic_independent_sUnion_of_directed algebraicIndependent_sUnion_of_directed
-/

#print exists_maximal_algebraicIndependent /-
theorem exists_maximal_algebraicIndependent (s t : Set A) (hst : s ⊆ t)
    (hs : AlgebraicIndependent R (coe : s → A)) :
    ∃ u : Set A,
      AlgebraicIndependent R (coe : u → A) ∧
        s ⊆ u ∧ u ⊆ t ∧ ∀ x : Set A, AlgebraicIndependent R (coe : x → A) → u ⊆ x → x ⊆ t → x = u :=
  by
  rcases zorn_subset_nonempty { u : Set A | AlgebraicIndependent R (coe : u → A) ∧ s ⊆ u ∧ u ⊆ t }
      (fun c hc chainc hcn =>
        ⟨⋃₀ c,
          by
          refine'
            ⟨⟨algebraicIndependent_sUnion_of_directed hcn chainc.directed_on fun a ha => (hc ha).1,
                _, _⟩,
              _⟩
          · cases' hcn with x hx
            exact subset_sUnion_of_subset _ x (hc hx).2.1 hx
          · exact sUnion_subset fun x hx => (hc hx).2.2
          · intro s
            exact subset_sUnion_of_mem⟩)
      s ⟨hs, Set.Subset.refl s, hst⟩ with
    ⟨u, ⟨huai, hsu, hut⟩, hsu, hx⟩
  use u, huai, hsu, hut
  intro x hxai huv hxt
  exact hx _ ⟨hxai, trans hsu huv, hxt⟩ huv
#align exists_maximal_algebraic_independent exists_maximal_algebraicIndependent
-/

section repr

variable (hx : AlgebraicIndependent R x)

/- warning: algebraic_independent.aeval_equiv -> AlgebraicIndependent.aevalEquiv is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2))], (AlgebraicIndependent.{u1, u2, u3} ι R A x _inst_1 _inst_2 _inst_5) -> (AlgEquiv.{u2, max u1 u2, u3} R (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (coeSort.{succ u3, succ (succ u3)} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) A (Subalgebra.setLike.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5)) (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commRing.{u2, u1} R ι _inst_1))) (Subalgebra.toSemiring.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) (MvPolynomial.algebra.{u2, u2, u1} R R ι (CommRing.toCommSemiring.{u2} R _inst_1) (CommRing.toCommSemiring.{u2} R _inst_1) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Subalgebra.algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))))
but is expected to have type
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2))], (AlgebraicIndependent.{u1, u2, u3} ι R A x _inst_1 _inst_2 _inst_5) -> (AlgEquiv.{u2, max u2 u1, u3} R (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (Subtype.{succ u3} A (fun (x_1 : A) => Membership.mem.{u3, u3} A (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5) (SetLike.instMembership.{u3, u3} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5) A (Subalgebra.instSetLikeSubalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5)) x_1 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x)))) (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R ι (CommRing.toCommSemiring.{u2} R _inst_1))) (Subalgebra.toSemiring.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) (MvPolynomial.algebra.{u2, u2, u1} R R ι (CommRing.toCommSemiring.{u2} R _inst_1) (CommRing.toCommSemiring.{u2} R _inst_1) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Subalgebra.algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))))
Case conversion may be inaccurate. Consider using '#align algebraic_independent.aeval_equiv AlgebraicIndependent.aevalEquivₓ'. -/
/-- Canonical isomorphism between polynomials and the subalgebra generated by
  algebraically independent elements. -/
@[simps]
def AlgebraicIndependent.aevalEquiv (hx : AlgebraicIndependent R x) :
    MvPolynomial ι R ≃ₐ[R] Algebra.adjoin R (range x) :=
  by
  apply
    AlgEquiv.ofBijective (AlgHom.codRestrict (@aeval R A ι _ _ _ x) (Algebra.adjoin R (range x)) _)
  swap
  · intro x
    rw [adjoin_range_eq_range_aeval]
    exact AlgHom.mem_range_self _ _
  · constructor
    · exact (AlgHom.injective_codRestrict _ _ _).2 hx
    · rintro ⟨x, hx⟩
      rw [adjoin_range_eq_range_aeval] at hx
      rcases hx with ⟨y, rfl⟩
      use y
      ext
      simp
#align algebraic_independent.aeval_equiv AlgebraicIndependent.aevalEquiv

/- warning: algebraic_independent.algebra_map_aeval_equiv -> AlgebraicIndependent.algebraMap_aevalEquiv is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent.algebra_map_aeval_equiv AlgebraicIndependent.algebraMap_aevalEquivₓ'. -/
@[simp]
theorem AlgebraicIndependent.algebraMap_aevalEquiv (hx : AlgebraicIndependent R x)
    (p : MvPolynomial ι R) :
    algebraMap (Algebra.adjoin R (range x)) A (hx.aevalEquiv p) = aeval x p :=
  rfl
#align algebraic_independent.algebra_map_aeval_equiv AlgebraicIndependent.algebraMap_aevalEquiv

/- warning: algebraic_independent.repr -> AlgebraicIndependent.repr is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2))], (AlgebraicIndependent.{u1, u2, u3} ι R A x _inst_1 _inst_2 _inst_5) -> (AlgHom.{u2, u3, max u1 u2} R (coeSort.{succ u3, succ (succ u3)} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) A (Subalgebra.setLike.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5)) (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toCommSemiring.{u2} R _inst_1) (Subalgebra.toSemiring.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) (Ring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commRing.{u2, u1} R ι _inst_1))) (Subalgebra.algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) (MvPolynomial.algebra.{u2, u2, u1} R R ι (CommRing.toCommSemiring.{u2} R _inst_1) (CommRing.toCommSemiring.{u2} R _inst_1) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))
but is expected to have type
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2))], (AlgebraicIndependent.{u1, u2, u3} ι R A x _inst_1 _inst_2 _inst_5) -> (AlgHom.{u2, u3, max u2 u1} R (Subtype.{succ u3} A (fun (x_1 : A) => Membership.mem.{u3, u3} A (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5) (SetLike.instMembership.{u3, u3} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5) A (Subalgebra.instSetLikeSubalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5)) x_1 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x)))) (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toCommSemiring.{u2} R _inst_1) (Subalgebra.toSemiring.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} ι R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R ι (CommRing.toCommSemiring.{u2} R _inst_1))) (Subalgebra.algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) (MvPolynomial.algebra.{u2, u2, u1} R R ι (CommRing.toCommSemiring.{u2} R _inst_1) (CommRing.toCommSemiring.{u2} R _inst_1) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align algebraic_independent.repr AlgebraicIndependent.reprₓ'. -/
/-- The canonical map from the subalgebra generated by an algebraic independent family
  into the polynomial ring.  -/
def AlgebraicIndependent.repr (hx : AlgebraicIndependent R x) :
    Algebra.adjoin R (range x) →ₐ[R] MvPolynomial ι R :=
  hx.aevalEquiv.symm
#align algebraic_independent.repr AlgebraicIndependent.repr

/- warning: algebraic_independent.aeval_repr -> AlgebraicIndependent.aeval_repr is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent.aeval_repr AlgebraicIndependent.aeval_reprₓ'. -/
@[simp]
theorem AlgebraicIndependent.aeval_repr (p) : aeval x (hx.repr p) = p :=
  Subtype.ext_iff.1 (AlgEquiv.apply_symm_apply hx.aevalEquiv p)
#align algebraic_independent.aeval_repr AlgebraicIndependent.aeval_repr

/- warning: algebraic_independent.aeval_comp_repr -> AlgebraicIndependent.aeval_comp_repr is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent.aeval_comp_repr AlgebraicIndependent.aeval_comp_reprₓ'. -/
theorem AlgebraicIndependent.aeval_comp_repr : (aeval x).comp hx.repr = Subalgebra.val _ :=
  AlgHom.ext <| hx.aeval_repr
#align algebraic_independent.aeval_comp_repr AlgebraicIndependent.aeval_comp_repr

/- warning: algebraic_independent.repr_ker -> AlgebraicIndependent.repr_ker is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent.repr_ker AlgebraicIndependent.repr_kerₓ'. -/
theorem AlgebraicIndependent.repr_ker :
    (hx.repr : adjoin R (range x) →+* MvPolynomial ι R).ker = ⊥ :=
  (RingHom.injective_iff_ker_eq_bot _).1 (AlgEquiv.injective _)
#align algebraic_independent.repr_ker AlgebraicIndependent.repr_ker

end repr

/- warning: algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin -> AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2))], (AlgebraicIndependent.{u1, u2, u3} ι R A x _inst_1 _inst_2 _inst_5) -> (RingEquiv.{max u1 u2, u3} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (Polynomial.{u3} (coeSort.{succ u3, succ (succ u3)} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) A (Subalgebra.setLike.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5)) (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) (Subalgebra.toSemiring.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x)))) (Distrib.toHasMul.{max u1 u2} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toDistrib.{max u1 u2} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u1 u2} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commRing.{u2, u1} R (Option.{u1} ι) _inst_1)))) (Distrib.toHasAdd.{max u1 u2} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toDistrib.{max u1 u2} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u1 u2} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commRing.{u2, u1} R (Option.{u1} ι) _inst_1)))) (Polynomial.mul'.{u3} (coeSort.{succ u3, succ (succ u3)} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) A (Subalgebra.setLike.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5)) (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) (Subalgebra.toSemiring.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x)))) (Polynomial.add'.{u3} (coeSort.{succ u3, succ (succ u3)} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) A (Subalgebra.setLike.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5)) (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) (Subalgebra.toSemiring.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x)))))
but is expected to have type
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2))], (AlgebraicIndependent.{u1, u2, u3} ι R A x _inst_1 _inst_2 _inst_5) -> (RingEquiv.{max u2 u1, u3} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (Polynomial.{u3} (Subtype.{succ u3} A (fun (x_1 : A) => Membership.mem.{u3, u3} A (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5) (SetLike.instMembership.{u3, u3} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5) A (Subalgebra.instSetLikeSubalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5)) x_1 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x)))) (Subalgebra.toSemiring.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x)))) (NonUnitalNonAssocRing.toMul.{max u1 u2} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonAssocRing.toNonUnitalNonAssocRing.{max u1 u2} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toNonAssocRing.{max u1 u2} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u1 u2} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R (Option.{u1} ι) _inst_1))))) (Polynomial.mul'.{u3} (Subtype.{succ u3} A (fun (x_1 : A) => Membership.mem.{u3, u3} A (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5) (SetLike.instMembership.{u3, u3} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5) A (Subalgebra.instSetLikeSubalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5)) x_1 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x)))) (Subalgebra.toSemiring.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x)))) (Distrib.toAdd.{max u1 u2} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toDistrib.{max u1 u2} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonAssocRing.toNonUnitalNonAssocRing.{max u1 u2} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toNonAssocRing.{max u1 u2} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u1 u2} (MvPolynomial.{u1, u2} (Option.{u1} ι) R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R (Option.{u1} ι) _inst_1))))))) (Polynomial.add'.{u3} (Subtype.{succ u3} A (fun (x_1 : A) => Membership.mem.{u3, u3} A (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5) (SetLike.instMembership.{u3, u3} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5) A (Subalgebra.instSetLikeSubalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5)) x_1 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x)))) (Subalgebra.toSemiring.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x)))))
Case conversion may be inaccurate. Consider using '#align algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoinₓ'. -/
-- TODO - make this an `alg_equiv`
/-- The isomorphism between `mv_polynomial (option ι) R` and the polynomial ring over
the algebra generated by an algebraically independent family.  -/
def AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin (hx : AlgebraicIndependent R x) :
    MvPolynomial (Option ι) R ≃+* Polynomial (adjoin R (Set.range x)) :=
  (MvPolynomial.optionEquivLeft _ _).toRingEquiv.trans
    (Polynomial.mapEquiv hx.aevalEquiv.toRingEquiv)
#align algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin

/- warning: algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_apply -> AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_apply AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_applyₓ'. -/
@[simp]
theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply
    (hx : AlgebraicIndependent R x) (y) :
    hx.mvPolynomialOptionEquivPolynomialAdjoin y =
      Polynomial.map (hx.aevalEquiv : MvPolynomial ι R →+* adjoin R (range x))
        (aeval (fun o : Option ι => o.elim Polynomial.X fun s : ι => Polynomial.C (X s)) y) :=
  rfl
#align algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_apply AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply

/- warning: algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_C -> AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_C is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_C AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_Cₓ'. -/
@[simp]
theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_C
    (hx : AlgebraicIndependent R x) (r) :
    hx.mvPolynomialOptionEquivPolynomialAdjoin (C r) = Polynomial.C (algebraMap _ _ r) := by
  rw [AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply, aeval_C,
    IsScalarTower.algebraMap_apply R (MvPolynomial ι R), ← Polynomial.C_eq_algebraMap,
    Polynomial.map_C, RingHom.coe_coe, AlgEquiv.commutes]
#align algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_C AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_C

/- warning: algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_X_none -> AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_none is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_X_none AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_noneₓ'. -/
@[simp]
theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_none
    (hx : AlgebraicIndependent R x) :
    hx.mvPolynomialOptionEquivPolynomialAdjoin (X none) = Polynomial.X := by
  rw [AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply, aeval_X, Option.elim',
    Polynomial.map_X]
#align algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_X_none AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_none

/- warning: algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_X_some -> AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_some is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_X_some AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_someₓ'. -/
@[simp]
theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_some
    (hx : AlgebraicIndependent R x) (i) :
    hx.mvPolynomialOptionEquivPolynomialAdjoin (X (some i)) = Polynomial.C (hx.aevalEquiv (X i)) :=
  by
  rw [AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply, aeval_X, Option.elim',
    Polynomial.map_C, RingHom.coe_coe]
#align algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_X_some AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_some

/- warning: algebraic_independent.aeval_comp_mv_polynomial_option_equiv_polynomial_adjoin -> AlgebraicIndependent.aeval_comp_mvPolynomialOptionEquivPolynomialAdjoin is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align algebraic_independent.aeval_comp_mv_polynomial_option_equiv_polynomial_adjoin AlgebraicIndependent.aeval_comp_mvPolynomialOptionEquivPolynomialAdjoinₓ'. -/
theorem AlgebraicIndependent.aeval_comp_mvPolynomialOptionEquivPolynomialAdjoin
    (hx : AlgebraicIndependent R x) (a : A) :
    RingHom.comp
        (↑(Polynomial.aeval a : Polynomial (adjoin R (Set.range x)) →ₐ[_] A) :
          Polynomial (adjoin R (Set.range x)) →+* A)
        hx.mvPolynomialOptionEquivPolynomialAdjoin.toRingHom =
      ↑(MvPolynomial.aeval fun o : Option ι => o.elim a x : MvPolynomial (Option ι) R →ₐ[R] A) :=
  by
  refine' MvPolynomial.ringHom_ext _ _ <;>
    simp only [RingHom.comp_apply, RingEquiv.toRingHom_eq_coe, RingEquiv.coe_toRingHom,
      AlgHom.coe_toRingHom, AlgHom.coe_toRingHom]
  · intro r
    rw [hx.mv_polynomial_option_equiv_polynomial_adjoin_C, aeval_C, Polynomial.aeval_C,
      IsScalarTower.algebraMap_apply R (adjoin R (range x)) A]
  · rintro (⟨⟩ | ⟨i⟩)
    ·
      rw [hx.mv_polynomial_option_equiv_polynomial_adjoin_X_none, aeval_X, Polynomial.aeval_X,
        Option.elim']
    ·
      rw [hx.mv_polynomial_option_equiv_polynomial_adjoin_X_some, Polynomial.aeval_C,
        hx.algebra_map_aeval_equiv, aeval_X, aeval_X, Option.elim']
#align algebraic_independent.aeval_comp_mv_polynomial_option_equiv_polynomial_adjoin AlgebraicIndependent.aeval_comp_mvPolynomialOptionEquivPolynomialAdjoin

/- warning: algebraic_independent.option_iff -> AlgebraicIndependent.option_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2))], (AlgebraicIndependent.{u1, u2, u3} ι R A x _inst_1 _inst_2 _inst_5) -> (forall (a : A), Iff (AlgebraicIndependent.{u1, u2, u3} (Option.{u1} ι) R A (fun (o : Option.{u1} ι) => Option.elim'.{u1, u3} ι A a x o) _inst_1 _inst_2 _inst_5) (Not (IsAlgebraic.{u3, u3} (coeSort.{succ u3, succ (succ u3)} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) A (Subalgebra.setLike.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5)) (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) A (Subalgebra.toCommRing.{u2, u3} R A _inst_1 _inst_2 _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) (CommRing.toRing.{u3} A _inst_2) (Subalgebra.toAlgebra.{u3, u2, u3} A R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommRing.toCommSemiring.{u3} A _inst_2) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Algebra.id.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) a)))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {A : Type.{u1}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))], (AlgebraicIndependent.{u3, u2, u1} ι R A x _inst_1 _inst_2 _inst_5) -> (forall (a : A), Iff (AlgebraicIndependent.{u3, u2, u1} (Option.{u3} ι) R A (fun (o : Option.{u3} ι) => Option.elim.{u3, succ u1} ι A o a x) _inst_1 _inst_2 _inst_5) (Not (IsAlgebraic.{u1, u1} (Subtype.{succ u1} A (fun (x_1 : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5)) x_1 (Algebra.adjoin.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5 (Set.range.{u1, succ u3} A ι x)))) A (Subalgebra.toCommRing.{u2, u1} R A _inst_1 _inst_2 _inst_5 (Algebra.adjoin.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5 (Set.range.{u1, succ u3} A ι x))) (CommRing.toRing.{u1} A _inst_2) (Subalgebra.toAlgebra.{u1, u2, u1} A R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommRing.toCommSemiring.{u1} A _inst_2) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) _inst_5 (Algebra.id.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Algebra.adjoin.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5 (Set.range.{u1, succ u3} A ι x))) a)))
Case conversion may be inaccurate. Consider using '#align algebraic_independent.option_iff AlgebraicIndependent.option_iffₓ'. -/
theorem AlgebraicIndependent.option_iff (hx : AlgebraicIndependent R x) (a : A) :
    (AlgebraicIndependent R fun o : Option ι => o.elim a x) ↔
      ¬IsAlgebraic (adjoin R (Set.range x)) a :=
  by
  erw [algebraicIndependent_iff_injective_aeval, isAlgebraic_iff_not_injective, Classical.not_not, ←
    AlgHom.coe_toRingHom, ← hx.aeval_comp_mv_polynomial_option_equiv_polynomial_adjoin,
    RingHom.coe_comp, injective.of_comp_iff' _ (RingEquiv.bijective _), AlgHom.coe_toRingHom]
#align algebraic_independent.option_iff AlgebraicIndependent.option_iff

variable (R)

#print IsTranscendenceBasis /-
/-- A family is a transcendence basis if it is a maximal algebraically independent subset.
-/
def IsTranscendenceBasis (x : ι → A) : Prop :=
  AlgebraicIndependent R x ∧
    ∀ (s : Set A) (i' : AlgebraicIndependent R (coe : s → A)) (h : range x ≤ s), range x = s
#align is_transcendence_basis IsTranscendenceBasis
-/

/- warning: exists_is_transcendence_basis -> exists_isTranscendenceBasis is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {A : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_5 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))], (Function.Injective.{succ u1, succ u2} R A (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (algebraMap.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_5))) -> (Exists.{succ u2} (Set.{u2} A) (fun (s : Set.{u2} A) => IsTranscendenceBasis.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) s) R A _inst_1 _inst_2 _inst_5 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) s) A (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) s) A (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) s) A (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} A) Type.{u2} (Set.hasCoeToSort.{u2} A) s) A (coeSubtype.{succ u2} A (fun (x : A) => Membership.Mem.{u2, u2} A (Set.{u2} A) (Set.hasMem.{u2} A) x s))))))))
but is expected to have type
  forall (R : Type.{u2}) {A : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))], (Function.Injective.{succ u2, succ u1} R A (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)))) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))))))) (algebraMap.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5))) -> (Exists.{succ u1} (Set.{u1} A) (fun (s : Set.{u1} A) => IsTranscendenceBasis.{u1, u2, u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Set.{u1} A) (Set.instMembershipSet.{u1} A) x s)) R A _inst_1 _inst_2 _inst_5 (Subtype.val.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Set.{u1} A) (Set.instMembershipSet.{u1} A) x s))))
Case conversion may be inaccurate. Consider using '#align exists_is_transcendence_basis exists_isTranscendenceBasisₓ'. -/
theorem exists_isTranscendenceBasis (h : Injective (algebraMap R A)) :
    ∃ s : Set A, IsTranscendenceBasis R (coe : s → A) :=
  by
  cases'
    exists_maximal_algebraicIndependent (∅ : Set A) Set.univ (Set.subset_univ _)
      ((algebraicIndependent_empty_iff R A).2 h) with
    s hs
  use s, hs.1
  intro t ht hr
  simp only [Subtype.range_coe_subtype, set_of_mem_eq] at *
  exact Eq.symm (hs.2.2.2 t ht hr (Set.subset_univ _))
#align exists_is_transcendence_basis exists_isTranscendenceBasis

variable {R}

#print AlgebraicIndependent.isTranscendenceBasis_iff /-
theorem AlgebraicIndependent.isTranscendenceBasis_iff {ι : Type w} {R : Type u} [CommRing R]
    [Nontrivial R] {A : Type v} [CommRing A] [Algebra R A] {x : ι → A}
    (i : AlgebraicIndependent R x) :
    IsTranscendenceBasis R x ↔
      ∀ (κ : Type v) (w : κ → A) (i' : AlgebraicIndependent R w) (j : ι → κ) (h : w ∘ j = x),
        Surjective j :=
  by
  fconstructor
  · rintro p κ w i' j rfl
    have p := p.2 (range w) i'.coe_range (range_comp_subset_range _ _)
    rw [range_comp, ← @image_univ _ _ w] at p
    exact range_iff_surjective.mp (image_injective.mpr i'.injective p)
  · intro p
    use i
    intro w i' h
    specialize
      p w (coe : w → A) i' (fun i => ⟨x i, range_subset_iff.mp h i⟩)
        (by
          ext
          simp)
    have q := congr_arg (fun s => (coe : w → A) '' s) p.range_eq
    dsimp at q
    rw [← image_univ, image_image] at q
    simpa using q
#align algebraic_independent.is_transcendence_basis_iff AlgebraicIndependent.isTranscendenceBasis_iff
-/

/- warning: is_transcendence_basis.is_algebraic -> IsTranscendenceBasis.isAlgebraic is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} A] [_inst_5 : Algebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2))] [_inst_8 : Nontrivial.{u2} R], (IsTranscendenceBasis.{u1, u2, u3} ι R A _inst_1 _inst_2 _inst_5 x) -> (Algebra.IsAlgebraic.{u3, u3} (coeSort.{succ u3, succ (succ u3)} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Subalgebra.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5) A (Subalgebra.setLike.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5)) (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) A (Subalgebra.toCommRing.{u2, u3} R A _inst_1 _inst_2 _inst_5 (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))) (CommRing.toRing.{u3} A _inst_2) (Subalgebra.toAlgebra.{u3, u2, u3} A R A (CommRing.toCommSemiring.{u2} R _inst_1) (CommRing.toCommSemiring.{u3} A _inst_2) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Algebra.id.{u3} A (CommRing.toCommSemiring.{u3} A _inst_2)) (Algebra.adjoin.{u2, u3} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2)) _inst_5 (Set.range.{u3, succ u1} A ι x))))
but is expected to have type
  forall {ι : Type.{u2}} {R : Type.{u3}} {A : Type.{u1}} {x : ι -> A} [_inst_1 : CommRing.{u3} R] [_inst_2 : CommRing.{u1} A] [_inst_5 : Algebra.{u3, u1} R A (CommRing.toCommSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] [_inst_8 : Nontrivial.{u3} R], (IsTranscendenceBasis.{u2, u3, u1} ι R A _inst_1 _inst_2 _inst_5 x) -> (Algebra.IsAlgebraic.{u1, u1} (Subtype.{succ u1} A (fun (x_1 : A) => Membership.mem.{u1, u1} A (Subalgebra.{u3, u1} R A (CommRing.toCommSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5) (SetLike.instMembership.{u1, u1} (Subalgebra.{u3, u1} R A (CommRing.toCommSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5) A (Subalgebra.instSetLikeSubalgebra.{u3, u1} R A (CommRing.toCommSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5)) x_1 (Algebra.adjoin.{u3, u1} R A (CommRing.toCommSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5 (Set.range.{u1, succ u2} A ι x)))) A (Subalgebra.toCommRing.{u3, u1} R A _inst_1 _inst_2 _inst_5 (Algebra.adjoin.{u3, u1} R A (CommRing.toCommSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5 (Set.range.{u1, succ u2} A ι x))) (CommRing.toRing.{u1} A _inst_2) (Subalgebra.toAlgebra.{u1, u3, u1} A R A (CommRing.toCommSemiring.{u3} R _inst_1) (CommRing.toCommSemiring.{u1} A _inst_2) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) _inst_5 (Algebra.id.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Algebra.adjoin.{u3, u1} R A (CommRing.toCommSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_5 (Set.range.{u1, succ u2} A ι x))))
Case conversion may be inaccurate. Consider using '#align is_transcendence_basis.is_algebraic IsTranscendenceBasis.isAlgebraicₓ'. -/
theorem IsTranscendenceBasis.isAlgebraic [Nontrivial R] (hx : IsTranscendenceBasis R x) :
    IsAlgebraic (adjoin R (range x)) A := by
  intro a
  rw [← not_iff_comm.1 (hx.1.option_iff _).symm]
  intro ai
  have h₁ : range x ⊆ range fun o : Option ι => o.elim a x :=
    by
    rintro x ⟨y, rfl⟩
    exact ⟨some y, rfl⟩
  have h₂ : range x ≠ range fun o : Option ι => o.elim a x :=
    by
    intro h
    have : a ∈ range x := by
      rw [h]
      exact ⟨none, rfl⟩
    rcases this with ⟨b, rfl⟩
    have : some b = none := ai.injective rfl
    simpa
  exact
    h₂
      (hx.2 (Set.range fun o : Option ι => o.elim a x)
        ((algebraicIndependent_subtype_range ai.injective).2 ai) h₁)
#align is_transcendence_basis.is_algebraic IsTranscendenceBasis.isAlgebraic

section Field

variable [Field K] [Algebra K A]

/- warning: algebraic_independent_empty_type -> algebraicIndependent_empty_type is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {K : Type.{u2}} {A : Type.{u3}} {x : ι -> A} [_inst_2 : CommRing.{u3} A] [_inst_8 : Field.{u2} K] [_inst_9 : Algebra.{u2, u3} K A (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_8)) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_2))] [_inst_10 : IsEmpty.{succ u1} ι] [_inst_11 : Nontrivial.{u3} A], AlgebraicIndependent.{u1, u2, u3} ι K A x (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_8)) _inst_2 _inst_9
but is expected to have type
  forall {ι : Type.{u3}} {K : Type.{u1}} {A : Type.{u2}} {x : ι -> A} [_inst_2 : CommRing.{u2} A] [_inst_8 : Field.{u1} K] [_inst_9 : Algebra.{u1, u2} K A (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_8)) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] [_inst_10 : IsEmpty.{succ u3} ι] [_inst_11 : Nontrivial.{u2} A], AlgebraicIndependent.{u3, u1, u2} ι K A x (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_8)) _inst_2 _inst_9
Case conversion may be inaccurate. Consider using '#align algebraic_independent_empty_type algebraicIndependent_empty_typeₓ'. -/
@[simp]
theorem algebraicIndependent_empty_type [IsEmpty ι] [Nontrivial A] : AlgebraicIndependent K x :=
  by
  rw [algebraicIndependent_empty_type_iff]
  exact RingHom.injective _
#align algebraic_independent_empty_type algebraicIndependent_empty_type

#print algebraicIndependent_empty /-
theorem algebraicIndependent_empty [Nontrivial A] :
    AlgebraicIndependent K (coe : (∅ : Set A) → A) :=
  algebraicIndependent_empty_type
#align algebraic_independent_empty algebraicIndependent_empty
-/

end Field

