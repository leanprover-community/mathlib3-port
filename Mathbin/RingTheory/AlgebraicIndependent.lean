import Mathbin.RingTheory.Adjoin.Basic 
import Mathbin.LinearAlgebra.LinearIndependent 
import Mathbin.RingTheory.MvPolynomial.Basic 
import Mathbin.Data.MvPolynomial.Supported 
import Mathbin.RingTheory.Algebraic 
import Mathbin.Data.MvPolynomial.Equiv

/-!
# Algebraic Independence

This file defines algebraic independence of a family of element of an `R` algebra

## Main definitions

* `algebraic_independent` - `algebraic_independent R x` states the family of elements `x`
  is algebraically independent over `R`, meaning that the canonical map out of the multivariable
  polynomial ring is injective.

* `algebraic_independent.repr` - The canonical map from the subalgebra generated by an
  algebraic independent family into the polynomial ring.

## References

* [Stacks: Transcendence](https://stacks.math.columbia.edu/tag/030D)

## TODO
Prove that a ring is an algebraic extension of the subalgebra generated by a transcendence basis.

## Tags
transcendence basis, transcendence degree, transcendence

-/


noncomputable theory

open Function Set Subalgebra MvPolynomial Algebra

open_locale Classical BigOperators

universe x u v w

variable{ι : Type _}{ι' : Type _}(R : Type _){K : Type _}

variable{A : Type _}{A' A'' : Type _}{V : Type u}{V' : Type _}

variable(x : ι → A)

variable[CommRingₓ R][CommRingₓ A][CommRingₓ A'][CommRingₓ A'']

variable[Algebra R A][Algebra R A'][Algebra R A'']

variable{a b : R}

/-- `algebraic_independent R x` states the family of elements `x`
  is algebraically independent over `R`, meaning that the canonical
  map out of the multivariable polynomial ring is injective. -/
def AlgebraicIndependent : Prop :=
  injective (MvPolynomial.aeval x : MvPolynomial ι R →ₐ[R] A)

variable{R}{x}

theorem algebraic_independent_iff_ker_eq_bot :
  AlgebraicIndependent R x ↔ (MvPolynomial.aeval x : MvPolynomial ι R →ₐ[R] A).toRingHom.ker = ⊥ :=
  RingHom.injective_iff_ker_eq_bot _

theorem algebraic_independent_iff :
  AlgebraicIndependent R x ↔ ∀ (p : MvPolynomial ι R), MvPolynomial.aeval (x : ι → A) p = 0 → p = 0 :=
  RingHom.injective_iff _

theorem AlgebraicIndependent.eq_zero_of_aeval_eq_zero (h : AlgebraicIndependent R x) :
  ∀ (p : MvPolynomial ι R), MvPolynomial.aeval (x : ι → A) p = 0 → p = 0 :=
  algebraic_independent_iff.1 h

theorem algebraic_independent_iff_injective_aeval :
  AlgebraicIndependent R x ↔ injective (MvPolynomial.aeval x : MvPolynomial ι R →ₐ[R] A) :=
  Iff.rfl

@[simp]
theorem algebraic_independent_empty_type_iff [IsEmpty ι] : AlgebraicIndependent R x ↔ injective (algebraMap R A) :=
  have  : aeval x = (Algebra.ofId R A).comp (@is_empty_alg_equiv R ι _ _).toAlgHom :=
    by 
      ext i 
      exact IsEmpty.elim' ‹IsEmpty ι› i 
  by 
    rw [AlgebraicIndependent, this, ←injective.of_comp_iff' _ (@is_empty_alg_equiv R ι _ _).Bijective]
    rfl

namespace AlgebraicIndependent

variable(hx : AlgebraicIndependent R x)

include hx

theorem algebra_map_injective : injective (algebraMap R A) :=
  by 
    simpa [←MvPolynomial.algebra_map_eq, Function.comp] using
      (injective.of_comp_iff (algebraic_independent_iff_injective_aeval.1 hx) MvPolynomial.c).2
        (MvPolynomial.C_injective _ _)

-- error in RingTheory.AlgebraicIndependent: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem linear_independent : linear_independent R x :=
begin
  rw ["[", expr linear_independent_iff_injective_total, "]"] [],
  have [] [":", expr «expr = »(finsupp.total ι A R x, (mv_polynomial.aeval x).to_linear_map.comp (finsupp.total ι _ R X))] [],
  { ext [] [] [],
    simp [] [] [] [] [] [] },
  rw [expr this] [],
  refine [expr hx.comp _],
  rw ["[", "<-", expr linear_independent_iff_injective_total, "]"] [],
  exact [expr linear_independent_X _ _]
end

protected theorem injective [Nontrivial R] : injective x :=
  hx.linear_independent.injective

theorem ne_zero [Nontrivial R] (i : ι) : x i ≠ 0 :=
  hx.linear_independent.ne_zero i

theorem comp (f : ι' → ι) (hf : Function.Injective f) : AlgebraicIndependent R (x ∘ f) :=
  fun p q =>
    by 
      simpa [aeval_rename, (rename_injective f hf).eq_iff] using @hx (rename f p) (rename f q)

theorem coe_range : AlgebraicIndependent R (coeₓ : range x → A) :=
  by 
    simpa using hx.comp _ (range_splitting_injective x)

theorem map {f : A →ₐ[R] A'} (hf_inj : Set.InjOn f (adjoin R (range x))) : AlgebraicIndependent R (f ∘ x) :=
  have  : aeval (f ∘ x) = f.comp (aeval x) :=
    by 
      ext <;> simp 
  have h : ∀ (p : MvPolynomial ι R), aeval x p ∈ (@aeval R _ _ _ _ _ (coeₓ : range x → A)).range :=
    by 
      intro p 
      rw [AlgHom.mem_range]
      refine' ⟨MvPolynomial.rename (cod_restrict x (range x) mem_range_self) p, _⟩
      simp [Function.comp, aeval_rename]
  by 
    intro x y hxy 
    rw [this] at hxy 
    rw [adjoin_eq_range] at hf_inj 
    exact hx (hf_inj (h x) (h y) hxy)

theorem map' {f : A →ₐ[R] A'} (hf_inj : injective f) : AlgebraicIndependent R (f ∘ x) :=
  hx.map (inj_on_of_injective hf_inj _)

omit hx

theorem of_comp (f : A →ₐ[R] A') (hfv : AlgebraicIndependent R (f ∘ x)) : AlgebraicIndependent R x :=
  have  : aeval (f ∘ x) = f.comp (aeval x) :=
    by 
      ext <;> simp 
  by 
    rw [AlgebraicIndependent, this] at hfv <;> exact hfv.of_comp

end AlgebraicIndependent

open AlgebraicIndependent

theorem AlgHom.algebraic_independent_iff (f : A →ₐ[R] A') (hf : injective f) :
  AlgebraicIndependent R (f ∘ x) ↔ AlgebraicIndependent R x :=
  ⟨fun h => h.of_comp f, fun h => h.map (inj_on_of_injective hf _)⟩

-- error in RingTheory.AlgebraicIndependent: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[nontriviality #[]] theorem algebraic_independent_of_subsingleton [subsingleton R] : algebraic_independent R x :=
by haveI [] [] [":=", expr @mv_polynomial.unique R ι]; exact [expr algebraic_independent_iff.2 (λ
  l hl, subsingleton.elim _ _)]

theorem algebraic_independent_equiv (e : ι ≃ ι') {f : ι' → A} :
  AlgebraicIndependent R (f ∘ e) ↔ AlgebraicIndependent R f :=
  ⟨fun h => Function.comp.right_id f ▸ e.self_comp_symm ▸ h.comp _ e.symm.injective, fun h => h.comp _ e.injective⟩

theorem algebraic_independent_equiv' (e : ι ≃ ι') {f : ι' → A} {g : ι → A} (h : f ∘ e = g) :
  AlgebraicIndependent R g ↔ AlgebraicIndependent R f :=
  h ▸ algebraic_independent_equiv e

theorem algebraic_independent_subtype_range {ι} {f : ι → A} (hf : injective f) :
  AlgebraicIndependent R (coeₓ : range f → A) ↔ AlgebraicIndependent R f :=
  Iff.symm$ algebraic_independent_equiv' (Equiv.ofInjective f hf) rfl

alias algebraic_independent_subtype_range ↔ AlgebraicIndependent.of_subtype_range _

-- error in RingTheory.AlgebraicIndependent: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem algebraic_independent_image
{ι}
{s : set ι}
{f : ι → A}
(hf : set.inj_on f s) : «expr ↔ »(algebraic_independent R (λ
  x : s, f x), algebraic_independent R (λ x : «expr '' »(f, s), (x : A))) :=
algebraic_independent_equiv' (equiv.set.image_of_inj_on _ _ hf) rfl

-- error in RingTheory.AlgebraicIndependent: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem algebraic_independent_adjoin
(hs : algebraic_independent R x) : @algebraic_independent ι R (adjoin R (range x)) (λ
 i : ι, ⟨x i, subset_adjoin (mem_range_self i)⟩) _ _ _ :=
algebraic_independent.of_comp (adjoin R (range x)).val hs

/-- A set of algebraically independent elements in an algebra `A` over a ring `K` is also
algebraically independent over a subring `R` of `K`. -/
theorem AlgebraicIndependent.restrict_scalars {K : Type _} [CommRingₓ K] [Algebra R K] [Algebra K A]
  [IsScalarTower R K A] (hinj : Function.Injective (algebraMap R K)) (ai : AlgebraicIndependent K x) :
  AlgebraicIndependent R x :=
  have  :
    (aeval x : MvPolynomial ι K →ₐ[K] A).toRingHom.comp (MvPolynomial.map (algebraMap R K)) =
      (aeval x : MvPolynomial ι R →ₐ[R] A).toRingHom :=
    by 
      ext <;> simp [algebra_map_eq_smul_one]
  by 
    show injective (aeval x).toRingHom 
    rw [←this]
    exact injective.comp ai (MvPolynomial.map_injective _ hinj)

/-- Every finite subset of an algebraically independent set is algebraically independent. -/
theorem algebraic_independent_finset_map_embedding_subtype (s : Set A) (li : AlgebraicIndependent R (coeₓ : s → A))
  (t : Finset s) : AlgebraicIndependent R (coeₓ : Finset.map (embedding.subtype s) t → A) :=
  by 
    let f : t.map (embedding.subtype s) → s :=
      fun x =>
        ⟨x.1,
          by 
            obtain ⟨x, h⟩ := x 
            rw [Finset.mem_map] at h 
            obtain ⟨a, ha, rfl⟩ := h 
            simp only [Subtype.coe_prop, embedding.coe_subtype]⟩
    convert AlgebraicIndependent.comp li f _ 
    rintro ⟨x, hx⟩ ⟨y, hy⟩
    rw [Finset.mem_map] at hx hy 
    obtain ⟨a, ha, rfl⟩ := hx 
    obtain ⟨b, hb, rfl⟩ := hy 
    simp only [imp_self, Subtype.mk_eq_mk]

-- error in RingTheory.AlgebraicIndependent: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/--
If every finite set of algebraically independent element has cardinality at most `n`,
then the same is true for arbitrary sets of algebraically independent elements.
-/
theorem algebraic_independent_bounded_of_finset_algebraic_independent_bounded
{n : exprℕ()}
(H : ∀
 s : finset A, algebraic_independent R (λ
  i : s, (i : A)) → «expr ≤ »(s.card, n)) : ∀
s : set A, algebraic_independent R (coe : s → A) → «expr ≤ »(cardinal.mk s, n) :=
begin
  intros [ident s, ident li],
  apply [expr cardinal.card_le_of],
  intro [ident t],
  rw ["<-", expr finset.card_map (embedding.subtype s)] [],
  apply [expr H],
  apply [expr algebraic_independent_finset_map_embedding_subtype _ li]
end

section Subtype

theorem AlgebraicIndependent.restrict_of_comp_subtype {s : Set ι} (hs : AlgebraicIndependent R (x ∘ coeₓ : s → A)) :
  AlgebraicIndependent R (s.restrict x) :=
  hs

variable(R A)

theorem algebraic_independent_empty_iff :
  AlgebraicIndependent R (fun x => x : (∅ : Set A) → A) ↔ injective (algebraMap R A) :=
  by 
    simp 

variable{R A}

theorem AlgebraicIndependent.mono {t s : Set A} (h : t ⊆ s) (hx : AlgebraicIndependent R (fun x => x : s → A)) :
  AlgebraicIndependent R (fun x => x : t → A) :=
  by 
    simpa [Function.comp] using hx.comp (inclusion h) (inclusion_injective h)

end Subtype

theorem AlgebraicIndependent.to_subtype_range {ι} {f : ι → A} (hf : AlgebraicIndependent R f) :
  AlgebraicIndependent R (coeₓ : range f → A) :=
  by 
    nontriviality R
    ·
      rwa [algebraic_independent_subtype_range hf.injective]

theorem AlgebraicIndependent.to_subtype_range' {ι} {f : ι → A} (hf : AlgebraicIndependent R f) {t} (ht : range f = t) :
  AlgebraicIndependent R (coeₓ : t → A) :=
  ht ▸ hf.to_subtype_range

theorem algebraic_independent_comp_subtype {s : Set ι} :
  AlgebraicIndependent R (x ∘ coeₓ : s → A) ↔ ∀ p (_ : p ∈ MvPolynomial.supported R s), aeval x p = 0 → p = 0 :=
  have  : (aeval (x ∘ coeₓ : s → A) : _ →ₐ[R] _) = (aeval x).comp (rename coeₓ) :=
    by 
      ext <;> simp 
  have  : ∀ (p : MvPolynomial s R), rename (coeₓ : s → ι) p = 0 ↔ p = 0 :=
    (RingHom.injective_iff' (rename (coeₓ : s → ι) : MvPolynomial s R →ₐ[R] _).toRingHom).1
      (rename_injective _ Subtype.val_injective)
  by 
    simp [algebraic_independent_iff, supported_eq_range_rename]

theorem algebraic_independent_subtype {s : Set A} :
  AlgebraicIndependent R (fun x => x : s → A) ↔
    ∀ (p : MvPolynomial A R), p ∈ MvPolynomial.supported R s → aeval id p = 0 → p = 0 :=
  by 
    apply @algebraic_independent_comp_subtype _ _ _ id

theorem algebraic_independent_of_finite (s : Set A)
  (H : ∀ t (_ : t ⊆ s), finite t → AlgebraicIndependent R (fun x => x : t → A)) :
  AlgebraicIndependent R (fun x => x : s → A) :=
  algebraic_independent_subtype.2$
    fun p hp =>
      algebraic_independent_subtype.1 (H _ (mem_supported.1 hp) (Finset.finite_to_set _)) _
        (by 
          simp )

-- error in RingTheory.AlgebraicIndependent: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem algebraic_independent.image_of_comp
{ι ι'}
(s : set ι)
(f : ι → ι')
(g : ι' → A)
(hs : algebraic_independent R (λ x : s, g (f x))) : algebraic_independent R (λ x : «expr '' »(f, s), g x) :=
begin
  nontriviality [expr R] [],
  have [] [":", expr inj_on f s] [],
  from [expr inj_on_iff_injective.2 hs.injective.of_comp],
  exact [expr (algebraic_independent_equiv' (equiv.set.image_of_inj_on f s this) rfl).1 hs]
end

-- error in RingTheory.AlgebraicIndependent: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem algebraic_independent.image
{ι}
{s : set ι}
{f : ι → A}
(hs : algebraic_independent R (λ x : s, f x)) : algebraic_independent R (λ x : «expr '' »(f, s), (x : A)) :=
by convert [] [expr algebraic_independent.image_of_comp s f id hs] []

theorem algebraic_independent_Union_of_directed {η : Type _} [Nonempty η] {s : η → Set A} (hs : Directed (· ⊆ ·) s)
  (h : ∀ i, AlgebraicIndependent R (fun x => x : s i → A)) : AlgebraicIndependent R (fun x => x : (⋃i, s i) → A) :=
  by 
    refine' algebraic_independent_of_finite (⋃i, s i) fun t ht ft => _ 
    rcases finite_subset_Union ft ht with ⟨I, fi, hI⟩
    rcases hs.finset_le fi.to_finset with ⟨i, hi⟩
    exact (h i).mono (subset.trans hI$ bUnion_subset$ fun j hj => hi j (fi.mem_to_finset.2 hj))

-- error in RingTheory.AlgebraicIndependent: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem algebraic_independent_sUnion_of_directed
{s : set (set A)}
(hsn : s.nonempty)
(hs : directed_on ((«expr ⊆ »)) s)
(h : ∀
 a «expr ∈ » s, algebraic_independent R (λ
 x, x : (a : set A) → A)) : algebraic_independent R (λ x, x : «expr⋃₀ »(s) → A) :=
by letI [] [":", expr nonempty s] [":=", expr nonempty.to_subtype hsn]; rw [expr sUnion_eq_Union] []; exact [expr algebraic_independent_Union_of_directed hs.directed_coe (by simpa [] [] [] [] [] ["using", expr h])]

theorem exists_maximal_algebraic_independent (s t : Set A) (hst : s ⊆ t) (hs : AlgebraicIndependent R (coeₓ : s → A)) :
  ∃ u : Set A,
    AlgebraicIndependent R (coeₓ : u → A) ∧
      s ⊆ u ∧ u ⊆ t ∧ ∀ (x : Set A), AlgebraicIndependent R (coeₓ : x → A) → u ⊆ x → x ⊆ t → x = u :=
  by 
    rcases
      Zorn.zorn_subset_nonempty { u:Set A | AlgebraicIndependent R (coeₓ : u → A) ∧ s ⊆ u ∧ u ⊆ t }
        (fun c hc chainc hcn =>
          ⟨⋃₀c,
            by 
              refine' ⟨⟨algebraic_independent_sUnion_of_directed hcn chainc.directed_on fun a ha => (hc ha).1, _, _⟩, _⟩
              ·
                cases' hcn with x hx 
                exact subset_sUnion_of_subset _ x (hc hx).2.1 hx
              ·
                exact sUnion_subset fun x hx => (hc hx).2.2
              ·
                intro s 
                exact subset_sUnion_of_mem⟩)
        s ⟨hs, Set.Subset.refl s, hst⟩ with
      ⟨u, ⟨huai, hsu, hut⟩, hsu, hx⟩
    use u, huai, hsu, hut 
    intro x hxai huv hxt 
    exact hx _ ⟨hxai, trans hsu huv, hxt⟩ huv

section reprₓ

variable(hx : AlgebraicIndependent R x)

/-- Canonical isomorphism between polynomials and the subalgebra generated by
  algebraically independent elements. -/
@[simps]
def AlgebraicIndependent.aevalEquiv (hx : AlgebraicIndependent R x) :
  MvPolynomial ι R ≃ₐ[R] Algebra.adjoin R (range x) :=
  by 
    apply AlgEquiv.ofBijective (AlgHom.codRestrict (@aeval R A ι _ _ _ x) (Algebra.adjoin R (range x)) _)
    swap
    ·
      intro x 
      rw [adjoin_range_eq_range_aeval]
      exact AlgHom.mem_range_self _ _
    ·
      split 
      ·
        exact (AlgHom.injective_cod_restrict _ _ _).2 hx
      ·
        rintro ⟨x, hx⟩
        rw [adjoin_range_eq_range_aeval] at hx 
        rcases hx with ⟨y, rfl⟩
        use y 
        ext 
        simp 

@[simp]
theorem AlgebraicIndependent.algebra_map_aeval_equiv (hx : AlgebraicIndependent R x) (p : MvPolynomial ι R) :
  algebraMap (Algebra.adjoin R (range x)) A (hx.aeval_equiv p) = aeval x p :=
  rfl

/-- The canonical map from the subalgebra generated by an algebraic independent family
  into the polynomial ring.  -/
def AlgebraicIndependent.repr (hx : AlgebraicIndependent R x) : Algebra.adjoin R (range x) →ₐ[R] MvPolynomial ι R :=
  hx.aeval_equiv.symm

@[simp]
theorem AlgebraicIndependent.aeval_repr p : aeval x (hx.repr p) = p :=
  Subtype.ext_iff.1 (AlgEquiv.apply_symm_apply hx.aeval_equiv p)

theorem AlgebraicIndependent.aeval_comp_repr : (aeval x).comp hx.repr = Subalgebra.val _ :=
  AlgHom.ext$ hx.aeval_repr

theorem AlgebraicIndependent.repr_ker : (hx.repr : adjoin R (range x) →+* MvPolynomial ι R).ker = ⊥ :=
  (RingHom.injective_iff_ker_eq_bot _).1 (AlgEquiv.injective _)

end reprₓ

/-- The isomorphism between `mv_polynomial (option ι) R` and the polynomial ring over
the algebra generated by an algebraically independent family.  -/
def AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin (hx : AlgebraicIndependent R x) :
  MvPolynomial (Option ι) R ≃+* Polynomial (adjoin R (Set.Range x)) :=
  (MvPolynomial.optionEquivLeft _ _).toRingEquiv.trans (Polynomial.mapEquiv hx.aeval_equiv.to_ring_equiv)

-- error in RingTheory.AlgebraicIndependent: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[simp]
theorem algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_apply
(hx : algebraic_independent R x)
(y) : «expr = »(hx.mv_polynomial_option_equiv_polynomial_adjoin y, polynomial.map (hx.aeval_equiv : «expr →+* »(mv_polynomial ι R, adjoin R (range x))) (aeval (λ
   o : option ι, o.elim polynomial.X (λ s : ι, polynomial.C (X s))) y)) :=
rfl

-- error in RingTheory.AlgebraicIndependent: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[simp]
theorem algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_C
(hx : algebraic_independent R x)
(r) : «expr = »(hx.mv_polynomial_option_equiv_polynomial_adjoin (C r), polynomial.C (algebra_map _ _ r)) :=
begin
  have [ident h] [":", expr is_scalar_tower R (mv_polynomial ι R) (polynomial (mv_polynomial ι R))] [":=", expr @polynomial.is_scalar_tower (mv_polynomial ι R) _ R _ _ _ _ _ _ _],
  rw ["[", expr algebraic_independent.mv_polynomial_option_equiv_polynomial_adjoin_apply, ",", expr aeval_C, ",", expr @is_scalar_tower.algebra_map_apply _ _ _ _ _ _ _ _ _ h, ",", "<-", expr polynomial.C_eq_algebra_map, ",", expr polynomial.map_C, ",", expr coe_coe, ",", expr alg_hom.coe_to_ring_hom, ",", expr alg_equiv.coe_alg_hom, ",", expr alg_equiv.commutes, "]"] []
end

@[simp]
theorem AlgebraicIndependent.mv_polynomial_option_equiv_polynomial_adjoin_X_none (hx : AlgebraicIndependent R x) :
  hx.mv_polynomial_option_equiv_polynomial_adjoin (X none) = Polynomial.x :=
  by 
    rw [AlgebraicIndependent.mv_polynomial_option_equiv_polynomial_adjoin_apply, aeval_X, Option.elim, Polynomial.map_X]

@[simp]
theorem AlgebraicIndependent.mv_polynomial_option_equiv_polynomial_adjoin_X_some (hx : AlgebraicIndependent R x) i :
  hx.mv_polynomial_option_equiv_polynomial_adjoin (X (some i)) = Polynomial.c (hx.aeval_equiv (X i)) :=
  by 
    rw [AlgebraicIndependent.mv_polynomial_option_equiv_polynomial_adjoin_apply, aeval_X, Option.elim, Polynomial.map_C,
      coe_coe, AlgHom.coe_to_ring_hom, AlgEquiv.coe_alg_hom]

-- error in RingTheory.AlgebraicIndependent: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem algebraic_independent.aeval_comp_mv_polynomial_option_equiv_polynomial_adjoin
(hx : algebraic_independent R x)
(a : A) : «expr = »(ring_hom.comp («expr↑ »((polynomial.aeval a : «expr →ₐ[ ] »(polynomial (adjoin R (set.range x)), _, A))) : «expr →+* »(polynomial (adjoin R (set.range x)), A)) hx.mv_polynomial_option_equiv_polynomial_adjoin.to_ring_hom, «expr↑ »((mv_polynomial.aeval (λ
   o : option ι, o.elim a x) : «expr →ₐ[ ] »(mv_polynomial (option ι) R, R, A)))) :=
begin
  refine [expr mv_polynomial.ring_hom_ext _ _]; simp [] [] ["only"] ["[", expr ring_hom.comp_apply, ",", expr ring_equiv.to_ring_hom_eq_coe, ",", expr ring_equiv.coe_to_ring_hom, ",", expr alg_hom.coe_to_ring_hom, ",", expr alg_hom.coe_to_ring_hom, "]"] [] [],
  { intro [ident r],
    rw ["[", expr hx.mv_polynomial_option_equiv_polynomial_adjoin_C, ",", expr aeval_C, ",", expr polynomial.aeval_C, ",", expr is_scalar_tower.algebra_map_apply R (adjoin R (range x)) A, "]"] [] },
  { rintro ["(", "⟨", "⟩", "|", "⟨", ident i, "⟩", ")"],
    { rw ["[", expr hx.mv_polynomial_option_equiv_polynomial_adjoin_X_none, ",", expr aeval_X, ",", expr polynomial.aeval_X, ",", expr option.elim, "]"] [] },
    { rw ["[", expr hx.mv_polynomial_option_equiv_polynomial_adjoin_X_some, ",", expr polynomial.aeval_C, ",", expr hx.algebra_map_aeval_equiv, ",", expr aeval_X, ",", expr aeval_X, ",", expr option.elim, "]"] [] } }
end

-- error in RingTheory.AlgebraicIndependent: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem algebraic_independent.option_iff
(hx : algebraic_independent R x)
(a : A) : «expr ↔ »(algebraic_independent R (λ
  o : option ι, o.elim a x), «expr¬ »(is_algebraic (adjoin R (set.range x)) a)) :=
by erw ["[", expr algebraic_independent_iff_injective_aeval, ",", expr is_algebraic_iff_not_injective, ",", expr not_not, ",", "<-", expr alg_hom.coe_to_ring_hom, ",", "<-", expr hx.aeval_comp_mv_polynomial_option_equiv_polynomial_adjoin, ",", expr ring_hom.coe_comp, ",", expr injective.of_comp_iff' _ (ring_equiv.bijective _), ",", expr alg_hom.coe_to_ring_hom, "]"] []

variable(R)

/--
  A family is a transcendence basis if it is a maximal algebraically independent subset.
-/
def IsTranscendenceBasis (x : ι → A) : Prop :=
  AlgebraicIndependent R x ∧ ∀ (s : Set A) (i' : AlgebraicIndependent R (coeₓ : s → A)) (h : range x ≤ s), range x = s

theorem exists_is_transcendence_basis (h : injective (algebraMap R A)) :
  ∃ s : Set A, IsTranscendenceBasis R (coeₓ : s → A) :=
  by 
    cases'
      exists_maximal_algebraic_independent (∅ : Set A) Set.Univ (Set.subset_univ _)
        ((algebraic_independent_empty_iff R A).2 h) with
      s hs 
    use s, hs.1
    intro t ht hr 
    simp only [Subtype.range_coe_subtype, set_of_mem_eq] at *
    exact Eq.symm (hs.2.2.2 t ht hr (Set.subset_univ _))

variable{R}

-- error in RingTheory.AlgebraicIndependent: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem algebraic_independent.is_transcendence_basis_iff
{ι : Type w}
{R : Type u}
[comm_ring R]
[nontrivial R]
{A : Type v}
[comm_ring A]
[algebra R A]
{x : ι → A}
(i : algebraic_independent R x) : «expr ↔ »(is_transcendence_basis R x, ∀
 (κ : Type v)
 (w : κ → A)
 (i' : algebraic_independent R w)
 (j : ι → κ)
 (h : «expr = »(«expr ∘ »(w, j), x)), surjective j) :=
begin
  fsplit,
  { rintros [ident p, ident κ, ident w, ident i', ident j, ident rfl],
    have [ident p] [] [":=", expr p.2 (range w) i'.coe_range (range_comp_subset_range _ _)],
    rw ["[", expr range_comp, ",", "<-", expr @image_univ _ _ w, "]"] ["at", ident p],
    exact [expr range_iff_surjective.mp (image_injective.mpr i'.injective p)] },
  { intros [ident p],
    use [expr i],
    intros [ident w, ident i', ident h],
    specialize [expr p w (coe : w → A) i' (λ
      i, ⟨x i, range_subset_iff.mp h i⟩) (by { ext [] [] [], simp [] [] [] [] [] [] })],
    have [ident q] [] [":=", expr congr_arg (λ s, «expr '' »((coe : w → A), s)) p.range_eq],
    dsimp [] [] [] ["at", ident q],
    rw ["[", "<-", expr image_univ, ",", expr image_image, "]"] ["at", ident q],
    simpa [] [] [] [] [] ["using", expr q] }
end

-- error in RingTheory.AlgebraicIndependent: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem is_transcendence_basis.is_algebraic
[nontrivial R]
(hx : is_transcendence_basis R x) : is_algebraic (adjoin R (range x)) A :=
begin
  intro [ident a],
  rw ["[", "<-", expr not_iff_comm.1 (hx.1.option_iff _).symm, "]"] [],
  intro [ident ai],
  have [ident h₁] [":", expr «expr ⊆ »(range x, range (λ o : option ι, o.elim a x))] [],
  { rintros [ident x, "⟨", ident y, ",", ident rfl, "⟩"],
    exact [expr ⟨some y, rfl⟩] },
  have [ident h₂] [":", expr «expr ≠ »(range x, range (λ o : option ι, o.elim a x))] [],
  { intro [ident h],
    have [] [":", expr «expr ∈ »(a, range x)] [],
    { rw [expr h] [],
      exact [expr ⟨none, rfl⟩] },
    rcases [expr this, "with", "⟨", ident b, ",", ident rfl, "⟩"],
    have [] [":", expr «expr = »(some b, none)] [":=", expr ai.injective rfl],
    simpa [] [] [] [] [] [] },
  exact [expr h₂ (hx.2 (set.range (λ
      o : option ι, o.elim a x)) ((algebraic_independent_subtype_range ai.injective).2 ai) h₁)]
end

section Field

variable[Field K][Algebra K A]

@[simp]
theorem algebraic_independent_empty_type [IsEmpty ι] [Nontrivial A] : AlgebraicIndependent K x :=
  by 
    rw [algebraic_independent_empty_type_iff]
    exact RingHom.injective _

theorem algebraic_independent_empty [Nontrivial A] : AlgebraicIndependent K (coeₓ : (∅ : Set A) → A) :=
  algebraic_independent_empty_type

end Field

