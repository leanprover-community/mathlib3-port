/-
Copyright (c) 2020 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Buzzard, Johan Commelin, Patrick Massot

! This file was ported from Lean 3 source module ring_theory.valuation.basic
! leanprover-community/mathlib commit 932872382355f00112641d305ba0619305dc8642
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Order.WithZero
import Mathbin.RingTheory.Ideal.Operations

/-!

# The basics of valuation theory.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

The basic theory of valuations (non-archimedean norms) on a commutative ring,
following T. Wedhorn's unpublished notes “Adic Spaces” ([wedhorn_adic]).

The definition of a valuation we use here is Definition 1.22 of [wedhorn_adic].
A valuation on a ring `R` is a monoid homomorphism `v` to a linearly ordered
commutative monoid with zero, that in addition satisfies the following two axioms:
 * `v 0 = 0`
 * `∀ x y, v (x + y) ≤ max (v x) (v y)`

`valuation R Γ₀`is the type of valuations `R → Γ₀`, with a coercion to the underlying
function. If `v` is a valuation from `R` to `Γ₀` then the induced group
homomorphism `units(R) → Γ₀` is called `unit_map v`.

The equivalence "relation" `is_equiv v₁ v₂ : Prop` defined in 1.27 of [wedhorn_adic] is not strictly
speaking a relation, because `v₁ : valuation R Γ₁` and `v₂ : valuation R Γ₂` might
not have the same type. This corresponds in ZFC to the set-theoretic difficulty
that the class of all valuations (as `Γ₀` varies) on a ring `R` is not a set.
The "relation" is however reflexive, symmetric and transitive in the obvious
sense. Note that we use 1.27(iii) of [wedhorn_adic] as the definition of equivalence.

## Main definitions

* `valuation R Γ₀`, the type of valuations on `R` with values in `Γ₀`
* `valuation.is_equiv`, the heterogeneous equivalence relation on valuations
* `valuation.supp`, the support of a valuation

* `add_valuation R Γ₀`, the type of additive valuations on `R` with values in a
  linearly ordered additive commutative group with a top element, `Γ₀`.

## Implementation Details

`add_valuation R Γ₀` is implemented as `valuation R (multiplicative Γ₀)ᵒᵈ`.

## Notation

In the `discrete_valuation` locale:

 * `ℕₘ₀` is a shorthand for `with_zero (multiplicative ℕ)`
 * `ℤₘ₀` is a shorthand for `with_zero (multiplicative ℤ)`

## TODO

If ever someone extends `valuation`, we should fully comply to the `fun_like` by migrating the
boilerplate lemmas to `valuation_class`.
-/


open Classical BigOperators

noncomputable section

open Function Ideal

variable {K F R : Type _} [DivisionRing K]

section

variable (F R) (Γ₀ : Type _) [LinearOrderedCommMonoidWithZero Γ₀] [Ring R]

#print Valuation /-
/-- The type of `Γ₀`-valued valuations on `R`.

When you extend this structure, make sure to extend `valuation_class`. -/
@[nolint has_nonempty_instance]
structure Valuation extends R →*₀ Γ₀ where
  map_add_le_max' : ∀ x y, to_fun (x + y) ≤ max (to_fun x) (to_fun y)
#align valuation Valuation
-/

#print ValuationClass /-
/-- `valuation_class F α β` states that `F` is a type of valuations.

You should also extend this typeclass when you extend `valuation`. -/
class ValuationClass extends MonoidWithZeroHomClass F R Γ₀ where
  map_add_le_max (f : F) (x y : R) : f (x + y) ≤ max (f x) (f y)
#align valuation_class ValuationClass
-/

export ValuationClass (map_add_le_max)

instance [ValuationClass F R Γ₀] : CoeTC F (Valuation R Γ₀) :=
  ⟨fun f =>
    { toFun := f
      map_one' := map_one f
      map_zero' := map_zero f
      map_mul' := map_mul f
      map_add_le_max' := map_add_le_max f }⟩

end

namespace Valuation

variable {Γ₀ : Type _}

variable {Γ'₀ : Type _}

variable {Γ''₀ : Type _} [LinearOrderedCommMonoidWithZero Γ''₀]

section Basic

variable [Ring R]

section Monoid

variable [LinearOrderedCommMonoidWithZero Γ₀] [LinearOrderedCommMonoidWithZero Γ'₀]

instance : ValuationClass (Valuation R Γ₀) R Γ₀
    where
  coe f := f.toFun
  coe_injective' f g h := by
    obtain ⟨⟨_, _⟩, _⟩ := f
    obtain ⟨⟨_, _⟩, _⟩ := g
    congr
  map_mul f := f.map_mul'
  map_one f := f.map_one'
  map_zero f := f.map_zero'
  map_add_le_max f := f.map_add_le_max'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (Valuation R Γ₀) fun _ => R → Γ₀ :=
  FunLike.hasCoeToFun

/- warning: valuation.to_fun_eq_coe -> Valuation.toFun_eq_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3), Eq.{max (succ u1) (succ u2)} (R -> Γ₀) (MonoidWithZeroHom.toFun.{u1, u2} R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (Valuation.toMonoidWithZeroHom.{u1, u2} R Γ₀ _inst_4 _inst_3 v)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v)
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_3 : Ring.{u2} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u1} Γ₀] (v : Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3), Eq.{max (succ u2) (succ u1)} (R -> Γ₀) (ZeroHom.toFun.{u2, u1} R Γ₀ (MulZeroOneClass.toZero.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3)))) (MulZeroOneClass.toZero.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MonoidWithZeroHom.toZeroHom.{u2, u1} R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (Valuation.toMonoidWithZeroHom.{u2, u1} R Γ₀ _inst_4 _inst_3 v))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))))) (MulOneClass.toMul.{u1} Γ₀ (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u2, u1} R Γ₀ _inst_3 _inst_4))))) v)
Case conversion may be inaccurate. Consider using '#align valuation.to_fun_eq_coe Valuation.toFun_eq_coeₓ'. -/
@[simp]
theorem toFun_eq_coe (v : Valuation R Γ₀) : v.toFun = v :=
  rfl
#align valuation.to_fun_eq_coe Valuation.toFun_eq_coe

/- warning: valuation.ext -> Valuation.ext is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] {v₁ : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3} {v₂ : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3}, (forall (r : R), Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v₁ r) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v₂ r)) -> (Eq.{max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) v₁ v₂)
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_3 : Ring.{u2} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u1} Γ₀] {v₁ : Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3} {v₂ : Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3}, (forall (r : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) r) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))))) (MulOneClass.toMul.{u1} Γ₀ (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u2, u1} R Γ₀ _inst_3 _inst_4))))) v₁ r) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))))) (MulOneClass.toMul.{u1} Γ₀ (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u2, u1} R Γ₀ _inst_3 _inst_4))))) v₂ r)) -> (Eq.{max (succ u2) (succ u1)} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) v₁ v₂)
Case conversion may be inaccurate. Consider using '#align valuation.ext Valuation.extₓ'. -/
@[ext]
theorem ext {v₁ v₂ : Valuation R Γ₀} (h : ∀ r, v₁ r = v₂ r) : v₁ = v₂ :=
  FunLike.ext _ _ h
#align valuation.ext Valuation.ext

variable (v : Valuation R Γ₀) {x y z : R}

/- warning: valuation.coe_coe -> Valuation.coe_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3), Eq.{max (succ u1) (succ u2)} (R -> Γ₀) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidWithZeroHom.{u1, u2} R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (fun (_x : MonoidWithZeroHom.{u1, u2} R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) => R -> Γ₀) (MonoidWithZeroHom.hasCoeToFun.{u1, u2} R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (MonoidWithZeroHom.{u1, u2} R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (MonoidWithZeroHom.{u1, u2} R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (MonoidWithZeroHom.{u1, u2} R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHom.hasCoeT.{u1, u2, max u1 u2} R Γ₀ (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.valuationClass.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v)
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_3 : Ring.{u2} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u1} Γ₀] (v : Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : R), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidWithZeroHom.{u2, u1} R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidWithZeroHom.{u2, u1} R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) R Γ₀ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))))) (MulOneClass.toMul.{u1} Γ₀ (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidWithZeroHom.{u2, u1} R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) R Γ₀ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (MonoidWithZeroHom.{u2, u1} R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (MonoidWithZeroHom.monoidWithZeroHomClass.{u2, u1} R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))))) (MonoidWithZeroHomClass.toMonoidWithZeroHom.{u2, u1, max u2 u1} R Γ₀ (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u2, u1} R Γ₀ _inst_3 _inst_4)) v)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))))) (MulOneClass.toMul.{u1} Γ₀ (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u2, u1} R Γ₀ _inst_3 _inst_4))))) v)
Case conversion may be inaccurate. Consider using '#align valuation.coe_coe Valuation.coe_coeₓ'. -/
@[simp, norm_cast]
theorem coe_coe : ⇑(v : R →*₀ Γ₀) = v :=
  rfl
#align valuation.coe_coe Valuation.coe_coe

/- warning: valuation.map_zero -> Valuation.map_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3), Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))))))) (OfNat.ofNat.{u2} Γ₀ 0 (OfNat.mk.{u2} Γ₀ 0 (Zero.zero.{u2} Γ₀ (MulZeroClass.toHasZero.{u2} Γ₀ (MulZeroOneClass.toMulZeroClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))))))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_3)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_3)))))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_3)))))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_3)))))) (LinearOrderedCommMonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_3)))))) _inst_4)))
Case conversion may be inaccurate. Consider using '#align valuation.map_zero Valuation.map_zeroₓ'. -/
@[simp]
theorem map_zero : v 0 = 0 :=
  v.map_zero'
#align valuation.map_zero Valuation.map_zero

/- warning: valuation.map_one -> Valuation.map_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3), Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))))) (OfNat.ofNat.{u2} Γ₀ 1 (OfNat.mk.{u2} Γ₀ 1 (One.one.{u2} Γ₀ (MulOneClass.toHasOne.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))))))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (Monoid.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MonoidWithZero.toMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (CommMonoidWithZero.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) _inst_4))))))
Case conversion may be inaccurate. Consider using '#align valuation.map_one Valuation.map_oneₓ'. -/
@[simp]
theorem map_one : v 1 = 1 :=
  v.map_one'
#align valuation.map_one Valuation.map_one

/- warning: valuation.map_mul -> Valuation.map_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (x : R) (y : R), Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3))) x y)) (HMul.hMul.{u2, u2, u2} Γ₀ Γ₀ Γ₀ (instHMul.{u2} Γ₀ (MulZeroClass.toHasMul.{u2} Γ₀ (MulZeroOneClass.toMulZeroClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v y))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (x : R) (y : R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x y)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x y)) (HMul.hMul.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (instHMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (MulZeroClass.toMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (MulZeroOneClass.toMulZeroClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (MonoidWithZero.toMulZeroOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (CommMonoidWithZero.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v y))
Case conversion may be inaccurate. Consider using '#align valuation.map_mul Valuation.map_mulₓ'. -/
@[simp]
theorem map_mul : ∀ x y, v (x * y) = v x * v y :=
  v.map_mul'
#align valuation.map_mul Valuation.map_mul

/- warning: valuation.map_add -> Valuation.map_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (x : R) (y : R), LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_3))) x y)) (LinearOrder.max.{u2} Γ₀ (LinearOrderedCommMonoid.toLinearOrder.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v y))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (x : R) (y : R), LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) _inst_4))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (Max.max.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrder.toMax.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoid.toLinearOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) _inst_4))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v y))
Case conversion may be inaccurate. Consider using '#align valuation.map_add Valuation.map_addₓ'. -/
@[simp]
theorem map_add : ∀ x y, v (x + y) ≤ max (v x) (v y) :=
  v.map_add_le_max'
#align valuation.map_add Valuation.map_add

/- warning: valuation.map_add_le -> Valuation.map_add_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) {x : R} {y : R} {g : Γ₀}, (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v x) g) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v y) g) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_3))) x y)) g)
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) {x : R} {y : R} {g : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x}, (LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) _inst_4))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v x) g) -> (LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) _inst_4))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v y) g) -> (LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) _inst_4))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) g)
Case conversion may be inaccurate. Consider using '#align valuation.map_add_le Valuation.map_add_leₓ'. -/
theorem map_add_le {x y g} (hx : v x ≤ g) (hy : v y ≤ g) : v (x + y) ≤ g :=
  le_trans (v.map_add x y) <| max_le hx hy
#align valuation.map_add_le Valuation.map_add_le

/- warning: valuation.map_add_lt -> Valuation.map_add_lt is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) {x : R} {y : R} {g : Γ₀}, (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v x) g) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v y) g) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_3))) x y)) g)
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) {x : R} {y : R} {g : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x}, (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) _inst_4))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v x) g) -> (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) _inst_4))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v y) g) -> (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) _inst_4))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) g)
Case conversion may be inaccurate. Consider using '#align valuation.map_add_lt Valuation.map_add_ltₓ'. -/
theorem map_add_lt {x y g} (hx : v x < g) (hy : v y < g) : v (x + y) < g :=
  lt_of_le_of_lt (v.map_add x y) <| max_lt hx hy
#align valuation.map_add_lt Valuation.map_add_lt

/- warning: valuation.map_sum_le -> Valuation.map_sum_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) {ι : Type.{u3}} {s : Finset.{u3} ι} {f : ι -> R} {g : Γ₀}, (forall (i : ι), (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v (f i)) g)) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v (Finset.sum.{u1, u3} R ι (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) g)
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) {ι : Type.{u3}} {s : Finset.{u3} ι} {f : ι -> R} {g : Γ₀}, (forall (i : ι), (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) -> (LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) _inst_4))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v (f i)) g)) -> (LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) _inst_4))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) g)
Case conversion may be inaccurate. Consider using '#align valuation.map_sum_le Valuation.map_sum_leₓ'. -/
theorem map_sum_le {ι : Type _} {s : Finset ι} {f : ι → R} {g : Γ₀} (hf : ∀ i ∈ s, v (f i) ≤ g) :
    v (∑ i in s, f i) ≤ g :=
  by
  refine'
    Finset.induction_on s (fun _ => trans_rel_right (· ≤ ·) v.map_zero zero_le')
      (fun a s has ih hf => _) hf
  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]
  exact v.map_add_le hf.1 (ih hf.2)
#align valuation.map_sum_le Valuation.map_sum_le

/- warning: valuation.map_sum_lt -> Valuation.map_sum_lt is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) {ι : Type.{u3}} {s : Finset.{u3} ι} {f : ι -> R} {g : Γ₀}, (Ne.{succ u2} Γ₀ g (OfNat.ofNat.{u2} Γ₀ 0 (OfNat.mk.{u2} Γ₀ 0 (Zero.zero.{u2} Γ₀ (MulZeroClass.toHasZero.{u2} Γ₀ (MulZeroOneClass.toMulZeroClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))))))) -> (forall (i : ι), (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v (f i)) g)) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v (Finset.sum.{u1, u3} R ι (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) g)
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) {ι : Type.{u3}} {s : Finset.{u3} ι} {f : ι -> R} {g : Γ₀}, (Ne.{succ u2} Γ₀ g (OfNat.ofNat.{u2} Γ₀ 0 (Zero.toOfNat0.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toZero.{u2} Γ₀ _inst_4)))) -> (forall (i : ι), (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) -> (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) _inst_4))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v (f i)) g)) -> (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) _inst_4))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) g)
Case conversion may be inaccurate. Consider using '#align valuation.map_sum_lt Valuation.map_sum_ltₓ'. -/
theorem map_sum_lt {ι : Type _} {s : Finset ι} {f : ι → R} {g : Γ₀} (hg : g ≠ 0)
    (hf : ∀ i ∈ s, v (f i) < g) : v (∑ i in s, f i) < g :=
  by
  refine'
    Finset.induction_on s (fun _ => trans_rel_right (· < ·) v.map_zero (zero_lt_iff.2 hg))
      (fun a s has ih hf => _) hf
  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]
  exact v.map_add_lt hf.1 (ih hf.2)
#align valuation.map_sum_lt Valuation.map_sum_lt

/- warning: valuation.map_sum_lt' -> Valuation.map_sum_lt' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) {ι : Type.{u3}} {s : Finset.{u3} ι} {f : ι -> R} {g : Γ₀}, (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4))))) (OfNat.ofNat.{u2} Γ₀ 0 (OfNat.mk.{u2} Γ₀ 0 (Zero.zero.{u2} Γ₀ (MulZeroClass.toHasZero.{u2} Γ₀ (MulZeroOneClass.toMulZeroClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))))))) g) -> (forall (i : ι), (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v (f i)) g)) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v (Finset.sum.{u1, u3} R ι (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) g)
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) {ι : Type.{u3}} {s : Finset.{u3} ι} {f : ι -> R} {g : Γ₀}, (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4))))) (OfNat.ofNat.{u2} Γ₀ 0 (Zero.toOfNat0.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toZero.{u2} Γ₀ _inst_4))) g) -> (forall (i : ι), (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) -> (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (f i)) _inst_4))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v (f i)) g)) -> (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) _inst_4))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) s (fun (i : ι) => f i))) g)
Case conversion may be inaccurate. Consider using '#align valuation.map_sum_lt' Valuation.map_sum_lt'ₓ'. -/
theorem map_sum_lt' {ι : Type _} {s : Finset ι} {f : ι → R} {g : Γ₀} (hg : 0 < g)
    (hf : ∀ i ∈ s, v (f i) < g) : v (∑ i in s, f i) < g :=
  v.map_sum_lt (ne_of_gt hg) hf
#align valuation.map_sum_lt' Valuation.map_sum_lt'

/- warning: valuation.map_pow -> Valuation.map_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (x : R) (n : Nat), Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R _inst_3))) x n)) (HPow.hPow.{u2, 0, u2} Γ₀ Nat Γ₀ (instHPow.{u2, 0} Γ₀ Nat (Monoid.Pow.{u2} Γ₀ (MonoidWithZero.toMonoid.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v x) n)
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (x : R) (n : Nat), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_3))))) x n)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_3))))) x n)) (HPow.hPow.{u2, 0, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) Nat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (instHPow.{u2, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) Nat (Monoid.Pow.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (MonoidWithZero.toMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (CommMonoidWithZero.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) _inst_4))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 _inst_4))))) v x) n)
Case conversion may be inaccurate. Consider using '#align valuation.map_pow Valuation.map_powₓ'. -/
@[simp]
theorem map_pow : ∀ (x) (n : ℕ), v (x ^ n) = v x ^ n :=
  v.toMonoidWithZeroHom.toMonoidHom.map_pow
#align valuation.map_pow Valuation.map_pow

/- warning: valuation.ext_iff -> Valuation.ext_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] {v₁ : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3} {v₂ : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3}, Iff (Eq.{max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) v₁ v₂) (forall (r : R), Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v₁ r) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v₂ r))
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_3 : Ring.{u2} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u1} Γ₀] {v₁ : Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3} {v₂ : Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3}, Iff (Eq.{max (succ u2) (succ u1)} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) v₁ v₂) (forall (r : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) r) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))))) (MulOneClass.toMul.{u1} Γ₀ (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u2, u1} R Γ₀ _inst_3 _inst_4))))) v₁ r) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))))) (MulOneClass.toMul.{u1} Γ₀ (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u2, u1} R Γ₀ _inst_3 _inst_4))))) v₂ r))
Case conversion may be inaccurate. Consider using '#align valuation.ext_iff Valuation.ext_iffₓ'. -/
/-- Deprecated. Use `fun_like.ext_iff`. -/
theorem ext_iff {v₁ v₂ : Valuation R Γ₀} : v₁ = v₂ ↔ ∀ r, v₁ r = v₂ r :=
  FunLike.ext_iff
#align valuation.ext_iff Valuation.ext_iff

#print Valuation.toPreorder /-
-- The following definition is not an instance, because we have more than one `v` on a given `R`.
-- In addition, type class inference would not be able to infer `v`.
/-- A valuation gives a preorder on the underlying ring. -/
def toPreorder : Preorder R :=
  Preorder.lift v
#align valuation.to_preorder Valuation.toPreorder
-/

/- warning: valuation.zero_iff -> Valuation.zero_iff is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u2}} [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_6 : Nontrivial.{u2} Γ₀] (v : Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) {x : K}, Iff (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) _inst_4) v x) (OfNat.ofNat.{u2} Γ₀ 0 (OfNat.mk.{u2} Γ₀ 0 (Zero.zero.{u2} Γ₀ (MulZeroClass.toHasZero.{u2} Γ₀ (MulZeroOneClass.toMulZeroClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))))))) (Eq.{succ u1} K x (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u2}} [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_6 : Nontrivial.{u2} Γ₀] (v : Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) {x : K}, Iff (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u2} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) _inst_4))))) v x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) _inst_4)))) (Eq.{succ u1} K x (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align valuation.zero_iff Valuation.zero_iffₓ'. -/
/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/
@[simp]
theorem zero_iff [Nontrivial Γ₀] (v : Valuation K Γ₀) {x : K} : v x = 0 ↔ x = 0 :=
  map_eq_zero v
#align valuation.zero_iff Valuation.zero_iff

/- warning: valuation.ne_zero_iff -> Valuation.ne_zero_iff is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u2}} [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_6 : Nontrivial.{u2} Γ₀] (v : Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) {x : K}, Iff (Ne.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) _inst_4) v x) (OfNat.ofNat.{u2} Γ₀ 0 (OfNat.mk.{u2} Γ₀ 0 (Zero.zero.{u2} Γ₀ (MulZeroClass.toHasZero.{u2} Γ₀ (MulZeroOneClass.toMulZeroClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))))))) (Ne.{succ u1} K x (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u2}} [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_6 : Nontrivial.{u2} Γ₀] (v : Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) {x : K}, Iff (Ne.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ _inst_4 (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u2} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) _inst_4))))) v x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) _inst_4)))) (Ne.{succ u1} K x (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align valuation.ne_zero_iff Valuation.ne_zero_iffₓ'. -/
theorem ne_zero_iff [Nontrivial Γ₀] (v : Valuation K Γ₀) {x : K} : v x ≠ 0 ↔ x ≠ 0 :=
  map_ne_zero v
#align valuation.ne_zero_iff Valuation.ne_zero_iff

/- warning: valuation.unit_map_eq -> Valuation.unit_map_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (u : Units.{u1} R (Ring.toMonoid.{u1} R _inst_3)), Eq.{succ u2} Γ₀ ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Units.{u2} Γ₀ (MonoidWithZero.toMonoid.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) Γ₀ (HasLiftT.mk.{succ u2, succ u2} (Units.{u2} Γ₀ (MonoidWithZero.toMonoid.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) Γ₀ (CoeTCₓ.coe.{succ u2, succ u2} (Units.{u2} Γ₀ (MonoidWithZero.toMonoid.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) Γ₀ (coeBase.{succ u2, succ u2} (Units.{u2} Γ₀ (MonoidWithZero.toMonoid.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) Γ₀ (Units.hasCoe.{u2} Γ₀ (MonoidWithZero.toMonoid.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_3)) (Units.{u2} Γ₀ (MonoidWithZero.toMonoid.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_3)) (Units.mulOneClass.{u2} Γ₀ (MonoidWithZero.toMonoid.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (fun (_x : MonoidHom.{u1, u2} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_3)) (Units.{u2} Γ₀ (MonoidWithZero.toMonoid.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_3)) (Units.mulOneClass.{u2} Γ₀ (MonoidWithZero.toMonoid.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) => (Units.{u1} R (Ring.toMonoid.{u1} R _inst_3)) -> (Units.{u2} Γ₀ (MonoidWithZero.toMonoid.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHom.hasCoeToFun.{u1, u2} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_3)) (Units.{u2} Γ₀ (MonoidWithZero.toMonoid.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_3)) (Units.mulOneClass.{u2} Γ₀ (MonoidWithZero.toMonoid.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (Units.map.{u1, u2} R Γ₀ (Ring.toMonoid.{u1} R _inst_3) (MonoidWithZero.toMonoid.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (MonoidHom.{u1, u2} R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (MonoidHom.{u1, u2} R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (MonoidHom.{u1, u2} R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} R Γ₀ (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.valuationClass.{u1, u2} R Γ₀ _inst_3 _inst_4)))))) v)) u)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} R (Ring.toMonoid.{u1} R _inst_3)) R (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_3)) R (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_3)) R (coeBase.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_3)) R (Units.hasCoe.{u1} R (Ring.toMonoid.{u1} R _inst_3))))) u))
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_3 : Ring.{u2} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u1} Γ₀] (v : Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) (u : Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3)))), Eq.{succ u1} Γ₀ (Units.val.{u1} Γ₀ (MonoidWithZero.toMonoid.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3)))) (Units.{u1} Γ₀ (MonoidWithZero.toMonoid.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (Units.instMulOneClassUnits.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3)))) (Units.instMulOneClassUnits.{u1} Γ₀ (MonoidWithZero.toMonoid.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3)))) (fun (_x : Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3)))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3)))) => Units.{u1} Γ₀ (MonoidWithZero.toMonoid.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3)))) (Units.{u1} Γ₀ (MonoidWithZero.toMonoid.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (Units.instMulOneClassUnits.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3)))) (Units.instMulOneClassUnits.{u1} Γ₀ (MonoidWithZero.toMonoid.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3)))) (Units.{u1} Γ₀ (MonoidWithZero.toMonoid.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MulOneClass.toMul.{u2} (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3)))) (Units.instMulOneClassUnits.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3))))) (MulOneClass.toMul.{u1} (Units.{u1} Γ₀ (MonoidWithZero.toMonoid.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (Units.instMulOneClassUnits.{u1} Γ₀ (MonoidWithZero.toMonoid.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3)))) (Units.{u1} Γ₀ (MonoidWithZero.toMonoid.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (Units.instMulOneClassUnits.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3)))) (Units.instMulOneClassUnits.{u1} Γ₀ (MonoidWithZero.toMonoid.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3)))) (Units.{u1} Γ₀ (MonoidWithZero.toMonoid.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (Units.instMulOneClassUnits.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3)))) (Units.instMulOneClassUnits.{u1} Γ₀ (MonoidWithZero.toMonoid.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MonoidHom.monoidHomClass.{u2, u1} (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3)))) (Units.{u1} Γ₀ (MonoidWithZero.toMonoid.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (Units.instMulOneClassUnits.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3)))) (Units.instMulOneClassUnits.{u1} Γ₀ (MonoidWithZero.toMonoid.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))))) (Units.map.{u2, u1} R Γ₀ (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3))) (MonoidWithZero.toMonoid.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (MonoidHomClass.toMonoidHom.{u2, u1, max u2 u1} R Γ₀ (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u2, u1} R Γ₀ _inst_3 _inst_4))) v)) u)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))))) (MulOneClass.toMul.{u1} Γ₀ (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u2, u1} R Γ₀ _inst_3 _inst_4))))) v (Units.val.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_3))) u))
Case conversion may be inaccurate. Consider using '#align valuation.unit_map_eq Valuation.unit_map_eqₓ'. -/
theorem unit_map_eq (u : Rˣ) : (Units.map (v : R →* Γ₀) u : Γ₀) = v u :=
  rfl
#align valuation.unit_map_eq Valuation.unit_map_eq

#print Valuation.comap /-
/-- A ring homomorphism `S → R` induces a map `valuation R Γ₀ → valuation S Γ₀`. -/
def comap {S : Type _} [Ring S] (f : S →+* R) (v : Valuation R Γ₀) : Valuation S Γ₀ :=
  {
    v.toMonoidWithZeroHom.comp
      f.toMonoidWithZeroHom with
    toFun := v ∘ f
    map_add_le_max' := fun x y => by simp only [comp_app, map_add, f.map_add] }
#align valuation.comap Valuation.comap
-/

/- warning: valuation.comap_apply -> Valuation.comap_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] {S : Type.{u3}} [_inst_6 : Ring.{u3} S] (f : RingHom.{u3, u1} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_6)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (s : S), Eq.{succ u2} Γ₀ (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (Valuation.{u3, u2} S Γ₀ _inst_4 _inst_6) (fun (_x : Valuation.{u3, u2} S Γ₀ _inst_4 _inst_6) => S -> Γ₀) (Valuation.hasCoeToFun.{u3, u2} S Γ₀ _inst_6 _inst_4) (Valuation.comap.{u1, u2, u3} R Γ₀ _inst_3 _inst_4 S _inst_6 f v) s) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (RingHom.{u3, u1} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_6)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (fun (_x : RingHom.{u3, u1} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_6)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) => S -> R) (RingHom.hasCoeToFun.{u3, u1} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_6)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) f s))
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_3 : Ring.{u2} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u1} Γ₀] {S : Type.{u3}} [_inst_6 : Ring.{u3} S] (f : RingHom.{u3, u2} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_6)) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (v : Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) (s : S), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Γ₀) s) (FunLike.coe.{max (succ u1) (succ u3), succ u3, succ u1} (Valuation.{u3, u1} S Γ₀ _inst_4 _inst_6) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u3, u3, u1} (Valuation.{u3, u1} S Γ₀ _inst_4 _inst_6) S Γ₀ (MulOneClass.toMul.{u3} S (MulZeroOneClass.toMulOneClass.{u3} S (NonAssocSemiring.toMulZeroOneClass.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_6))))) (MulOneClass.toMul.{u1} Γ₀ (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u1 u3, u3, u1} (Valuation.{u3, u1} S Γ₀ _inst_4 _inst_6) S Γ₀ (MulZeroOneClass.toMulOneClass.{u3} S (NonAssocSemiring.toMulZeroOneClass.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_6)))) (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u3, u3, u1} (Valuation.{u3, u1} S Γ₀ _inst_4 _inst_6) S Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_6))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u3, u3, u1} (Valuation.{u3, u1} S Γ₀ _inst_4 _inst_6) S Γ₀ _inst_4 _inst_6 (Valuation.instValuationClassValuation.{u3, u1} S Γ₀ _inst_6 _inst_4))))) (Valuation.comap.{u2, u1, u3} R Γ₀ _inst_3 _inst_4 S _inst_6 f v) s) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))))) (MulOneClass.toMul.{u1} Γ₀ (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u2, u1} R Γ₀ _inst_3 _inst_4))))) v (FunLike.coe.{max (succ u2) (succ u3), succ u3, succ u2} (RingHom.{u3, u2} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_6)) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => R) _x) (MulHomClass.toFunLike.{max u2 u3, u3, u2} (RingHom.{u3, u2} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_6)) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) S R (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_6)))) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u3, u3, u2} (RingHom.{u3, u2} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_6)) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) S R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_6))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u3, u3, u2} (RingHom.{u3, u2} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_6)) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_6)) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3)) (RingHom.instRingHomClassRingHom.{u3, u2} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_6)) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3)))))) f s))
Case conversion may be inaccurate. Consider using '#align valuation.comap_apply Valuation.comap_applyₓ'. -/
@[simp]
theorem comap_apply {S : Type _} [Ring S] (f : S →+* R) (v : Valuation R Γ₀) (s : S) :
    v.comap f s = v (f s) :=
  rfl
#align valuation.comap_apply Valuation.comap_apply

/- warning: valuation.comap_id -> Valuation.comap_id is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3), Eq.{max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (Valuation.comap.{u1, u2, u1} R Γ₀ _inst_3 _inst_4 R _inst_3 (RingHom.id.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) v) v
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_3 : Ring.{u2} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u1} Γ₀] (v : Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3), Eq.{max (succ u2) (succ u1)} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) (Valuation.comap.{u2, u1, u2} R Γ₀ _inst_3 _inst_4 R _inst_3 (RingHom.id.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))) v) v
Case conversion may be inaccurate. Consider using '#align valuation.comap_id Valuation.comap_idₓ'. -/
@[simp]
theorem comap_id : v.comap (RingHom.id R) = v :=
  ext fun r => rfl
#align valuation.comap_id Valuation.comap_id

/- warning: valuation.comap_comp -> Valuation.comap_comp is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) {S₁ : Type.{u3}} {S₂ : Type.{u4}} [_inst_6 : Ring.{u3} S₁] [_inst_7 : Ring.{u4} S₂] (f : RingHom.{u3, u4} S₁ S₂ (NonAssocRing.toNonAssocSemiring.{u3} S₁ (Ring.toNonAssocRing.{u3} S₁ _inst_6)) (NonAssocRing.toNonAssocSemiring.{u4} S₂ (Ring.toNonAssocRing.{u4} S₂ _inst_7))) (g : RingHom.{u4, u1} S₂ R (NonAssocRing.toNonAssocSemiring.{u4} S₂ (Ring.toNonAssocRing.{u4} S₂ _inst_7)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))), Eq.{max (succ u3) (succ u2)} (Valuation.{u3, u2} S₁ Γ₀ _inst_4 _inst_6) (Valuation.comap.{u1, u2, u3} R Γ₀ _inst_3 _inst_4 S₁ _inst_6 (RingHom.comp.{u3, u4, u1} S₁ S₂ R (NonAssocRing.toNonAssocSemiring.{u3} S₁ (Ring.toNonAssocRing.{u3} S₁ _inst_6)) (NonAssocRing.toNonAssocSemiring.{u4} S₂ (Ring.toNonAssocRing.{u4} S₂ _inst_7)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)) g f) v) (Valuation.comap.{u4, u2, u3} S₂ Γ₀ _inst_7 _inst_4 S₁ _inst_6 f (Valuation.comap.{u1, u2, u4} R Γ₀ _inst_3 _inst_4 S₂ _inst_7 g v))
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_3 : Ring.{u2} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u1} Γ₀] (v : Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) {S₁ : Type.{u4}} {S₂ : Type.{u3}} [_inst_6 : Ring.{u4} S₁] [_inst_7 : Ring.{u3} S₂] (f : RingHom.{u4, u3} S₁ S₂ (NonAssocRing.toNonAssocSemiring.{u4} S₁ (Ring.toNonAssocRing.{u4} S₁ _inst_6)) (NonAssocRing.toNonAssocSemiring.{u3} S₂ (Ring.toNonAssocRing.{u3} S₂ _inst_7))) (g : RingHom.{u3, u2} S₂ R (NonAssocRing.toNonAssocSemiring.{u3} S₂ (Ring.toNonAssocRing.{u3} S₂ _inst_7)) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3))), Eq.{max (succ u1) (succ u4)} (Valuation.{u4, u1} S₁ Γ₀ _inst_4 _inst_6) (Valuation.comap.{u2, u1, u4} R Γ₀ _inst_3 _inst_4 S₁ _inst_6 (RingHom.comp.{u4, u3, u2} S₁ S₂ R (NonAssocRing.toNonAssocSemiring.{u4} S₁ (Ring.toNonAssocRing.{u4} S₁ _inst_6)) (NonAssocRing.toNonAssocSemiring.{u3} S₂ (Ring.toNonAssocRing.{u3} S₂ _inst_7)) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_3)) g f) v) (Valuation.comap.{u3, u1, u4} S₂ Γ₀ _inst_7 _inst_4 S₁ _inst_6 f (Valuation.comap.{u2, u1, u3} R Γ₀ _inst_3 _inst_4 S₂ _inst_7 g v))
Case conversion may be inaccurate. Consider using '#align valuation.comap_comp Valuation.comap_compₓ'. -/
theorem comap_comp {S₁ : Type _} {S₂ : Type _} [Ring S₁] [Ring S₂] (f : S₁ →+* S₂) (g : S₂ →+* R) :
    v.comap (g.comp f) = (v.comap g).comap f :=
  ext fun r => rfl
#align valuation.comap_comp Valuation.comap_comp

/- warning: valuation.map -> Valuation.map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_5 : LinearOrderedCommMonoidWithZero.{u3} Γ'₀] (f : MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))), (Monotone.{u2, u3} Γ₀ Γ'₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4)))) (PartialOrder.toPreorder.{u3} Γ'₀ (OrderedCommMonoid.toPartialOrder.{u3} Γ'₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} Γ'₀ _inst_5)))) (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))) (fun (_x : MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))) => Γ₀ -> Γ'₀) (MonoidWithZeroHom.hasCoeToFun.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))) f)) -> (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) -> (Valuation.{u1, u3} R Γ'₀ _inst_5 _inst_3)
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_5 : LinearOrderedCommMonoidWithZero.{u3} Γ'₀] (f : MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))), (Monotone.{u2, u3} Γ₀ Γ'₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4)))) (PartialOrder.toPreorder.{u3} Γ'₀ (OrderedCommMonoid.toPartialOrder.{u3} Γ'₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} Γ'₀ _inst_5)))) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))) Γ₀ (fun (_x : Γ₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Γ₀) => Γ'₀) _x) (MulHomClass.toFunLike.{max u2 u3, u2, u3} (MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))) Γ₀ Γ'₀ (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MulOneClass.toMul.{u3} Γ'₀ (MulZeroOneClass.toMulOneClass.{u3} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5))))) (MonoidHomClass.toMulHomClass.{max u2 u3, u2, u3} (MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))) Γ₀ Γ'₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MulZeroOneClass.toMulOneClass.{u3} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u3, u2, u3} (MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))) Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5))) (MonoidWithZeroHom.monoidWithZeroHomClass.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5))))))) f)) -> (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) -> (Valuation.{u1, u3} R Γ'₀ _inst_5 _inst_3)
Case conversion may be inaccurate. Consider using '#align valuation.map Valuation.mapₓ'. -/
/-- A `≤`-preserving group homomorphism `Γ₀ → Γ'₀` induces a map `valuation R Γ₀ → valuation R Γ'₀`.
-/
def map (f : Γ₀ →*₀ Γ'₀) (hf : Monotone f) (v : Valuation R Γ₀) : Valuation R Γ'₀ :=
  {
    MonoidWithZeroHom.comp f v.toMonoidWithZeroHom with
    toFun := f ∘ v
    map_add_le_max' := fun r s =>
      calc
        f (v (r + s)) ≤ f (max (v r) (v s)) := hf (v.map_add r s)
        _ = max (f (v r)) (f (v s)) := hf.map_max
         }
#align valuation.map Valuation.map

#print Valuation.IsEquiv /-
/-- Two valuations on `R` are defined to be equivalent if they induce the same preorder on `R`. -/
def IsEquiv (v₁ : Valuation R Γ₀) (v₂ : Valuation R Γ'₀) : Prop :=
  ∀ r s, v₁ r ≤ v₁ s ↔ v₂ r ≤ v₂ s
#align valuation.is_equiv Valuation.IsEquiv
-/

end Monoid

section Group

variable [LinearOrderedCommGroupWithZero Γ₀] {R} {Γ₀} (v : Valuation R Γ₀) {x y z : R}

/- warning: valuation.map_neg -> Valuation.map_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (x : R), Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3))))) x)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v x)
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (x : R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (Neg.neg.{u1} R (Ring.toNeg.{u1} R _inst_3) x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v (Neg.neg.{u1} R (Ring.toNeg.{u1} R _inst_3) x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v x)
Case conversion may be inaccurate. Consider using '#align valuation.map_neg Valuation.map_negₓ'. -/
@[simp]
theorem map_neg (x : R) : v (-x) = v x :=
  v.toMonoidWithZeroHom.toMonoidHom.map_neg x
#align valuation.map_neg Valuation.map_neg

/- warning: valuation.map_sub_swap -> Valuation.map_sub_swap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (x : R) (y : R), Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) x y)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) y x))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (x : R) (y : R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) y x))
Case conversion may be inaccurate. Consider using '#align valuation.map_sub_swap Valuation.map_sub_swapₓ'. -/
theorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=
  v.toMonoidWithZeroHom.toMonoidHom.map_sub_swap x y
#align valuation.map_sub_swap Valuation.map_sub_swap

/- warning: valuation.map_sub -> Valuation.map_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (x : R) (y : R), LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) x y)) (LinearOrder.max.{u2} Γ₀ (LinearOrderedCommMonoid.toLinearOrder.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v y))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (x : R) (y : R), LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) (Max.max.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrder.toMax.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoid.toLinearOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) _inst_4)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v y))
Case conversion may be inaccurate. Consider using '#align valuation.map_sub Valuation.map_subₓ'. -/
theorem map_sub (x y : R) : v (x - y) ≤ max (v x) (v y) :=
  calc
    v (x - y) = v (x + -y) := by rw [sub_eq_add_neg]
    _ ≤ max (v x) (v <| -y) := (v.map_add _ _)
    _ = max (v x) (v y) := by rw [map_neg]
    
#align valuation.map_sub Valuation.map_sub

/- warning: valuation.map_sub_le -> Valuation.map_sub_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) {x : R} {y : R} {g : Γ₀}, (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v x) g) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v y) g) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) x y)) g)
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) {x : R} {y : R} {g : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x}, (LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v x) g) -> (LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v y) g) -> (LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) g)
Case conversion may be inaccurate. Consider using '#align valuation.map_sub_le Valuation.map_sub_leₓ'. -/
theorem map_sub_le {x y g} (hx : v x ≤ g) (hy : v y ≤ g) : v (x - y) ≤ g :=
  by
  rw [sub_eq_add_neg]
  exact v.map_add_le hx (le_trans (le_of_eq (v.map_neg y)) hy)
#align valuation.map_sub_le Valuation.map_sub_le

/- warning: valuation.map_add_of_distinct_val -> Valuation.map_add_of_distinct_val is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) {x : R} {y : R}, (Ne.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v y)) -> (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_3))) x y)) (LinearOrder.max.{u2} Γ₀ (LinearOrderedCommMonoid.toLinearOrder.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v y)))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) {x : R} {y : R}, (Ne.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v y)) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (Max.max.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrder.toMax.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoid.toLinearOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) _inst_4)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v y)))
Case conversion may be inaccurate. Consider using '#align valuation.map_add_of_distinct_val Valuation.map_add_of_distinct_valₓ'. -/
theorem map_add_of_distinct_val (h : v x ≠ v y) : v (x + y) = max (v x) (v y) :=
  by
  suffices : ¬v (x + y) < max (v x) (v y)
  exact or_iff_not_imp_right.1 (le_iff_eq_or_lt.1 (v.map_add x y)) this
  intro h'
  wlog vyx : v y < v x
  · refine' this v h.symm _ (h.lt_or_lt.resolve_right vyx)
    rwa [add_comm, max_comm]
  rw [max_eq_left_of_lt vyx] at h'
  apply lt_irrefl (v x)
  calc
    v x = v (x + y - y) := by simp
    _ ≤ max (v <| x + y) (v y) := (map_sub _ _ _)
    _ < v x := max_lt h' vyx
    
#align valuation.map_add_of_distinct_val Valuation.map_add_of_distinct_val

/- warning: valuation.map_add_eq_of_lt_right -> Valuation.map_add_eq_of_lt_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) {x : R} {y : R}, (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v y)) -> (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_3))) x y)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v y))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) {x : R} {y : R}, (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v y)) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v y))
Case conversion may be inaccurate. Consider using '#align valuation.map_add_eq_of_lt_right Valuation.map_add_eq_of_lt_rightₓ'. -/
theorem map_add_eq_of_lt_right (h : v x < v y) : v (x + y) = v y :=
  by
  convert v.map_add_of_distinct_val _
  · symm
    rw [max_eq_right_iff]
    exact le_of_lt h
  · exact ne_of_lt h
#align valuation.map_add_eq_of_lt_right Valuation.map_add_eq_of_lt_right

/- warning: valuation.map_add_eq_of_lt_left -> Valuation.map_add_eq_of_lt_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) {x : R} {y : R}, (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v y) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v x)) -> (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_3))) x y)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v x))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) {x : R} {y : R}, (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v y) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v x)) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v x))
Case conversion may be inaccurate. Consider using '#align valuation.map_add_eq_of_lt_left Valuation.map_add_eq_of_lt_leftₓ'. -/
theorem map_add_eq_of_lt_left (h : v y < v x) : v (x + y) = v x := by rw [add_comm];
  exact map_add_eq_of_lt_right _ h
#align valuation.map_add_eq_of_lt_left Valuation.map_add_eq_of_lt_left

/- warning: valuation.map_eq_of_sub_lt -> Valuation.map_eq_of_sub_lt is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) {x : R} {y : R}, (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) y x)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v x)) -> (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v y) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v x))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) {x : R} {y : R}, (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) y x)) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) y x)) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) y x)) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) y x)) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) y x)) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) y x)) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) y x)) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) y x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v x)) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) y) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v y) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v x))
Case conversion may be inaccurate. Consider using '#align valuation.map_eq_of_sub_lt Valuation.map_eq_of_sub_ltₓ'. -/
theorem map_eq_of_sub_lt (h : v (y - x) < v x) : v y = v x :=
  by
  have := Valuation.map_add_of_distinct_val v (ne_of_gt h).symm
  rw [max_eq_right (le_of_lt h)] at this
  simpa using this
#align valuation.map_eq_of_sub_lt Valuation.map_eq_of_sub_lt

/- warning: valuation.map_one_add_of_lt -> Valuation.map_one_add_of_lt is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) {x : R}, (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v x) (OfNat.ofNat.{u2} Γ₀ 1 (OfNat.mk.{u2} Γ₀ 1 (One.one.{u2} Γ₀ (MulOneClass.toHasOne.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_4)))))))))) -> (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_3))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3))))))) x)) (OfNat.ofNat.{u2} Γ₀ 1 (OfNat.mk.{u2} Γ₀ 1 (One.one.{u2} Γ₀ (MulOneClass.toHasOne.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_4))))))))))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) {x : R}, (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (InvOneClass.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (DivInvOneMonoid.toInvOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (DivisionMonoid.toDivInvOneMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (DivisionCommMonoid.toDivisionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) _inst_4))))))))) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) (InvOneClass.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) (DivInvOneMonoid.toInvOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) (DivisionMonoid.toDivInvOneMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) (DivisionCommMonoid.toDivisionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) (CommGroupWithZero.toDivisionCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) _inst_4)))))))))
Case conversion may be inaccurate. Consider using '#align valuation.map_one_add_of_lt Valuation.map_one_add_of_ltₓ'. -/
theorem map_one_add_of_lt (h : v x < 1) : v (1 + x) = 1 :=
  by
  rw [← v.map_one] at h
  simpa only [v.map_one] using v.map_add_eq_of_lt_left h
#align valuation.map_one_add_of_lt Valuation.map_one_add_of_lt

/- warning: valuation.map_one_sub_of_lt -> Valuation.map_one_sub_of_lt is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) {x : R}, (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v x) (OfNat.ofNat.{u2} Γ₀ 1 (OfNat.mk.{u2} Γ₀ 1 (One.one.{u2} Γ₀ (MulOneClass.toHasOne.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_4)))))))))) -> (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3))))))) x)) (OfNat.ofNat.{u2} Γ₀ 1 (OfNat.mk.{u2} Γ₀ 1 (One.one.{u2} Γ₀ (MulOneClass.toHasOne.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_4))))))))))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) {x : R}, (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (InvOneClass.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (DivInvOneMonoid.toInvOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (DivisionMonoid.toDivInvOneMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (DivisionCommMonoid.toDivisionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) _inst_4))))))))) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3 (Valuation.instValuationClassValuation.{u1, u2} R Γ₀ _inst_3 (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) (InvOneClass.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) (DivInvOneMonoid.toInvOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) (DivisionMonoid.toDivInvOneMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) (DivisionCommMonoid.toDivisionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) (CommGroupWithZero.toDivisionCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) x)) _inst_4)))))))))
Case conversion may be inaccurate. Consider using '#align valuation.map_one_sub_of_lt Valuation.map_one_sub_of_ltₓ'. -/
theorem map_one_sub_of_lt (h : v x < 1) : v (1 - x) = 1 :=
  by
  rw [← v.map_one, ← v.map_neg] at h
  rw [sub_eq_add_neg 1 x]
  simpa only [v.map_one, v.map_neg] using v.map_add_eq_of_lt_left h
#align valuation.map_one_sub_of_lt Valuation.map_one_sub_of_lt

/- warning: valuation.one_lt_val_iff -> Valuation.one_lt_val_iff is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u2}} [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) {x : K}, (Ne.{succ u1} K x (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) -> (Iff (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (OfNat.ofNat.{u2} Γ₀ 1 (OfNat.mk.{u2} Γ₀ 1 (One.one.{u2} Γ₀ (MulOneClass.toHasOne.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_4))))))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v x)) (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4)) v (Inv.inv.{u1} K (DivInvMonoid.toHasInv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1)) x)) (OfNat.ofNat.{u2} Γ₀ 1 (OfNat.mk.{u2} Γ₀ 1 (One.one.{u2} Γ₀ (MulOneClass.toHasOne.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_4)))))))))))
but is expected to have type
  forall {K : Type.{u2}} [_inst_1 : DivisionRing.{u2} K] {Γ₀ : Type.{u1}} [_inst_4 : LinearOrderedCommGroupWithZero.{u1} Γ₀] (v : Valuation.{u2, u1} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4) (DivisionRing.toRing.{u2} K _inst_1)) {x : K}, (Ne.{succ u2} K x (OfNat.ofNat.{u2} K 0 (Zero.toOfNat0.{u2} K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))))) -> (Iff (LT.lt.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (Preorder.toLT.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (OrderedCommMonoid.toPartialOrder.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) _inst_4)))))) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (InvOneClass.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivInvOneMonoid.toInvOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivisionMonoid.toDivInvOneMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivisionCommMonoid.toDivisionMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) _inst_4)))))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4) (DivisionRing.toRing.{u2} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4) (DivisionRing.toRing.{u2} K _inst_1)) K Γ₀ (MulOneClass.toMul.{u2} K (MulZeroOneClass.toMulOneClass.{u2} K (NonAssocSemiring.toMulZeroOneClass.{u2} K (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K _inst_1)))))) (MulOneClass.toMul.{u1} Γ₀ (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4) (DivisionRing.toRing.{u2} K _inst_1)) K Γ₀ (MulZeroOneClass.toMulOneClass.{u2} K (NonAssocSemiring.toMulZeroOneClass.{u2} K (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4) (DivisionRing.toRing.{u2} K _inst_1)) K Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} K (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4) (DivisionRing.toRing.{u2} K _inst_1)) K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4) (DivisionRing.toRing.{u2} K _inst_1) (Valuation.instValuationClassValuation.{u2, u1} K Γ₀ (DivisionRing.toRing.{u2} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4)))))) v x)) (LT.lt.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) (Preorder.toLT.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) (OrderedCommMonoid.toPartialOrder.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) _inst_4)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4) (DivisionRing.toRing.{u2} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4) (DivisionRing.toRing.{u2} K _inst_1)) K Γ₀ (MulOneClass.toMul.{u2} K (MulZeroOneClass.toMulOneClass.{u2} K (NonAssocSemiring.toMulZeroOneClass.{u2} K (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K _inst_1)))))) (MulOneClass.toMul.{u1} Γ₀ (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4) (DivisionRing.toRing.{u2} K _inst_1)) K Γ₀ (MulZeroOneClass.toMulOneClass.{u2} K (NonAssocSemiring.toMulZeroOneClass.{u2} K (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4) (DivisionRing.toRing.{u2} K _inst_1)) K Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} K (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4) (DivisionRing.toRing.{u2} K _inst_1)) K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4) (DivisionRing.toRing.{u2} K _inst_1) (Valuation.instValuationClassValuation.{u2, u1} K Γ₀ (DivisionRing.toRing.{u2} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} Γ₀ _inst_4)))))) v (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) (InvOneClass.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) (DivInvOneMonoid.toInvOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) (DivisionMonoid.toDivInvOneMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) (DivisionCommMonoid.toDivisionMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) (CommGroupWithZero.toDivisionCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) _inst_4))))))))))
Case conversion may be inaccurate. Consider using '#align valuation.one_lt_val_iff Valuation.one_lt_val_iffₓ'. -/
theorem one_lt_val_iff (v : Valuation K Γ₀) {x : K} (h : x ≠ 0) : 1 < v x ↔ v x⁻¹ < 1 := by
  simpa using (inv_lt_inv₀ (v.ne_zero_iff.2 h) one_ne_zero).symm
#align valuation.one_lt_val_iff Valuation.one_lt_val_iff

/- warning: valuation.lt_add_subgroup -> Valuation.ltAddSubgroup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀], (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) -> (Units.{u2} Γ₀ (MonoidWithZero.toMonoid.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_4))))) -> (AddSubgroup.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3))))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ₀], (Valuation.{u1, u2} R Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_4) _inst_3) -> (Units.{u2} Γ₀ (MonoidWithZero.toMonoid.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_4))))) -> (AddSubgroup.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (Ring.toAddGroupWithOne.{u1} R _inst_3)))
Case conversion may be inaccurate. Consider using '#align valuation.lt_add_subgroup Valuation.ltAddSubgroupₓ'. -/
/-- The subgroup of elements whose valuation is less than a certain unit.-/
def ltAddSubgroup (v : Valuation R Γ₀) (γ : Γ₀ˣ) : AddSubgroup R
    where
  carrier := { x | v x < γ }
  zero_mem' := by
    have h := Units.ne_zero γ
    contrapose! h
    simpa using h
  add_mem' x y x_in y_in := lt_of_le_of_lt (v.map_add x y) (max_lt x_in y_in)
  neg_mem' x x_in := by rwa [Set.mem_setOf_eq, map_neg]
#align valuation.lt_add_subgroup Valuation.ltAddSubgroup

end Group

end Basic

-- end of section
namespace IsEquiv

variable [Ring R]

variable [LinearOrderedCommMonoidWithZero Γ₀] [LinearOrderedCommMonoidWithZero Γ'₀]

variable {v : Valuation R Γ₀}

variable {v₁ : Valuation R Γ₀} {v₂ : Valuation R Γ'₀} {v₃ : Valuation R Γ''₀}

/- warning: valuation.is_equiv.refl -> Valuation.IsEquiv.refl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] {v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3}, Valuation.IsEquiv.{u1, u2, u2} R Γ₀ Γ₀ _inst_3 _inst_4 _inst_4 v v
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_3 : Ring.{u2} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u1} Γ₀] {v : Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3}, Valuation.IsEquiv.{u2, u1, u1} R Γ₀ Γ₀ _inst_3 _inst_4 _inst_4 v v
Case conversion may be inaccurate. Consider using '#align valuation.is_equiv.refl Valuation.IsEquiv.reflₓ'. -/
@[refl]
theorem refl : v.IsEquiv v := fun _ _ => Iff.refl _
#align valuation.is_equiv.refl Valuation.IsEquiv.refl

/- warning: valuation.is_equiv.symm -> Valuation.IsEquiv.symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_5 : LinearOrderedCommMonoidWithZero.{u3} Γ'₀] {v₁ : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3} {v₂ : Valuation.{u1, u3} R Γ'₀ _inst_5 _inst_3}, (Valuation.IsEquiv.{u1, u2, u3} R Γ₀ Γ'₀ _inst_3 _inst_4 _inst_5 v₁ v₂) -> (Valuation.IsEquiv.{u1, u3, u2} R Γ'₀ Γ₀ _inst_3 _inst_5 _inst_4 v₂ v₁)
but is expected to have type
  forall {R : Type.{u3}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u1}} [_inst_3 : Ring.{u3} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_5 : LinearOrderedCommMonoidWithZero.{u1} Γ'₀] {v₁ : Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3} {v₂ : Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3}, (Valuation.IsEquiv.{u3, u2, u1} R Γ₀ Γ'₀ _inst_3 _inst_4 _inst_5 v₁ v₂) -> (Valuation.IsEquiv.{u3, u1, u2} R Γ'₀ Γ₀ _inst_3 _inst_5 _inst_4 v₂ v₁)
Case conversion may be inaccurate. Consider using '#align valuation.is_equiv.symm Valuation.IsEquiv.symmₓ'. -/
@[symm]
theorem symm (h : v₁.IsEquiv v₂) : v₂.IsEquiv v₁ := fun _ _ => Iff.symm (h _ _)
#align valuation.is_equiv.symm Valuation.IsEquiv.symm

/- warning: valuation.is_equiv.trans -> Valuation.IsEquiv.trans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} {Γ''₀ : Type.{u4}} [_inst_2 : LinearOrderedCommMonoidWithZero.{u4} Γ''₀] [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_5 : LinearOrderedCommMonoidWithZero.{u3} Γ'₀] {v₁ : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3} {v₂ : Valuation.{u1, u3} R Γ'₀ _inst_5 _inst_3} {v₃ : Valuation.{u1, u4} R Γ''₀ _inst_2 _inst_3}, (Valuation.IsEquiv.{u1, u2, u3} R Γ₀ Γ'₀ _inst_3 _inst_4 _inst_5 v₁ v₂) -> (Valuation.IsEquiv.{u1, u3, u4} R Γ'₀ Γ''₀ _inst_3 _inst_5 _inst_2 v₂ v₃) -> (Valuation.IsEquiv.{u1, u2, u4} R Γ₀ Γ''₀ _inst_3 _inst_4 _inst_2 v₁ v₃)
but is expected to have type
  forall {R : Type.{u4}} {Γ₀ : Type.{u3}} {Γ'₀ : Type.{u2}} {Γ''₀ : Type.{u1}} [_inst_2 : LinearOrderedCommMonoidWithZero.{u1} Γ''₀] [_inst_3 : Ring.{u4} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u3} Γ₀] [_inst_5 : LinearOrderedCommMonoidWithZero.{u2} Γ'₀] {v₁ : Valuation.{u4, u3} R Γ₀ _inst_4 _inst_3} {v₂ : Valuation.{u4, u2} R Γ'₀ _inst_5 _inst_3} {v₃ : Valuation.{u4, u1} R Γ''₀ _inst_2 _inst_3}, (Valuation.IsEquiv.{u4, u3, u2} R Γ₀ Γ'₀ _inst_3 _inst_4 _inst_5 v₁ v₂) -> (Valuation.IsEquiv.{u4, u2, u1} R Γ'₀ Γ''₀ _inst_3 _inst_5 _inst_2 v₂ v₃) -> (Valuation.IsEquiv.{u4, u3, u1} R Γ₀ Γ''₀ _inst_3 _inst_4 _inst_2 v₁ v₃)
Case conversion may be inaccurate. Consider using '#align valuation.is_equiv.trans Valuation.IsEquiv.transₓ'. -/
@[trans]
theorem trans (h₁₂ : v₁.IsEquiv v₂) (h₂₃ : v₂.IsEquiv v₃) : v₁.IsEquiv v₃ := fun _ _ =>
  Iff.trans (h₁₂ _ _) (h₂₃ _ _)
#align valuation.is_equiv.trans Valuation.IsEquiv.trans

/- warning: valuation.is_equiv.of_eq -> Valuation.IsEquiv.of_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] {v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3} {v' : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3}, (Eq.{max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) v v') -> (Valuation.IsEquiv.{u1, u2, u2} R Γ₀ Γ₀ _inst_3 _inst_4 _inst_4 v v')
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_3 : Ring.{u2} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u1} Γ₀] {v : Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3} {v' : Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3}, (Eq.{max (succ u2) (succ u1)} (Valuation.{u2, u1} R Γ₀ _inst_4 _inst_3) v v') -> (Valuation.IsEquiv.{u2, u1, u1} R Γ₀ Γ₀ _inst_3 _inst_4 _inst_4 v v')
Case conversion may be inaccurate. Consider using '#align valuation.is_equiv.of_eq Valuation.IsEquiv.of_eqₓ'. -/
theorem of_eq {v' : Valuation R Γ₀} (h : v = v') : v.IsEquiv v' := by subst h
#align valuation.is_equiv.of_eq Valuation.IsEquiv.of_eq

/- warning: valuation.is_equiv.map -> Valuation.IsEquiv.map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_5 : LinearOrderedCommMonoidWithZero.{u3} Γ'₀] {v : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3} {v' : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3} (f : MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))) (hf : Monotone.{u2, u3} Γ₀ Γ'₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4)))) (PartialOrder.toPreorder.{u3} Γ'₀ (OrderedCommMonoid.toPartialOrder.{u3} Γ'₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} Γ'₀ _inst_5)))) (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))) (fun (_x : MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))) => Γ₀ -> Γ'₀) (MonoidWithZeroHom.hasCoeToFun.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))) f)), (Function.Injective.{succ u2, succ u3} Γ₀ Γ'₀ (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))) (fun (_x : MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))) => Γ₀ -> Γ'₀) (MonoidWithZeroHom.hasCoeToFun.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5)))) f)) -> (Valuation.IsEquiv.{u1, u2, u2} R Γ₀ Γ₀ _inst_3 _inst_4 _inst_4 v v') -> (Valuation.IsEquiv.{u1, u3, u3} R Γ'₀ Γ'₀ _inst_3 _inst_5 _inst_5 (Valuation.map.{u1, u2, u3} R Γ₀ Γ'₀ _inst_3 _inst_4 _inst_5 f hf v) (Valuation.map.{u1, u2, u3} R Γ₀ Γ'₀ _inst_3 _inst_4 _inst_5 f hf v'))
but is expected to have type
  forall {R : Type.{u3}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u1}} [_inst_3 : Ring.{u3} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_5 : LinearOrderedCommMonoidWithZero.{u1} Γ'₀] {v : Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3} {v' : Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3} (f : MonoidWithZeroHom.{u2, u1} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5)))) (hf : Monotone.{u2, u1} Γ₀ Γ'₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_4)))) (PartialOrder.toPreorder.{u1} Γ'₀ (OrderedCommMonoid.toPartialOrder.{u1} Γ'₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} Γ'₀ _inst_5)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidWithZeroHom.{u2, u1} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5)))) Γ₀ (fun (_x : Γ₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Γ₀) => Γ'₀) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidWithZeroHom.{u2, u1} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5)))) Γ₀ Γ'₀ (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MulOneClass.toMul.{u1} Γ'₀ (MulZeroOneClass.toMulOneClass.{u1} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidWithZeroHom.{u2, u1} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5)))) Γ₀ Γ'₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MulZeroOneClass.toMulOneClass.{u1} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (MonoidWithZeroHom.{u2, u1} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5)))) Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5))) (MonoidWithZeroHom.monoidWithZeroHomClass.{u2, u1} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5))))))) f)), (Function.Injective.{succ u2, succ u1} Γ₀ Γ'₀ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidWithZeroHom.{u2, u1} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5)))) Γ₀ (fun (_x : Γ₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Γ₀) => Γ'₀) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidWithZeroHom.{u2, u1} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5)))) Γ₀ Γ'₀ (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MulOneClass.toMul.{u1} Γ'₀ (MulZeroOneClass.toMulOneClass.{u1} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidWithZeroHom.{u2, u1} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5)))) Γ₀ Γ'₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MulZeroOneClass.toMulOneClass.{u1} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (MonoidWithZeroHom.{u2, u1} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5)))) Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5))) (MonoidWithZeroHom.monoidWithZeroHomClass.{u2, u1} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5))))))) f)) -> (Valuation.IsEquiv.{u3, u2, u2} R Γ₀ Γ₀ _inst_3 _inst_4 _inst_4 v v') -> (Valuation.IsEquiv.{u3, u1, u1} R Γ'₀ Γ'₀ _inst_3 _inst_5 _inst_5 (Valuation.map.{u3, u2, u1} R Γ₀ Γ'₀ _inst_3 _inst_4 _inst_5 f hf v) (Valuation.map.{u3, u2, u1} R Γ₀ Γ'₀ _inst_3 _inst_4 _inst_5 f hf v'))
Case conversion may be inaccurate. Consider using '#align valuation.is_equiv.map Valuation.IsEquiv.mapₓ'. -/
theorem map {v' : Valuation R Γ₀} (f : Γ₀ →*₀ Γ'₀) (hf : Monotone f) (inf : Injective f)
    (h : v.IsEquiv v') : (v.map f hf).IsEquiv (v'.map f hf) :=
  let H : StrictMono f := hf.strictMono_of_injective inf
  fun r s =>
  calc
    f (v r) ≤ f (v s) ↔ v r ≤ v s := by rw [H.le_iff_le]
    _ ↔ v' r ≤ v' s := (h r s)
    _ ↔ f (v' r) ≤ f (v' s) := by rw [H.le_iff_le]
    
#align valuation.is_equiv.map Valuation.IsEquiv.map

/- warning: valuation.is_equiv.comap -> Valuation.IsEquiv.comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_5 : LinearOrderedCommMonoidWithZero.{u3} Γ'₀] {v₁ : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3} {v₂ : Valuation.{u1, u3} R Γ'₀ _inst_5 _inst_3} {S : Type.{u4}} [_inst_6 : Ring.{u4} S] (f : RingHom.{u4, u1} S R (NonAssocRing.toNonAssocSemiring.{u4} S (Ring.toNonAssocRing.{u4} S _inst_6)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))), (Valuation.IsEquiv.{u1, u2, u3} R Γ₀ Γ'₀ _inst_3 _inst_4 _inst_5 v₁ v₂) -> (Valuation.IsEquiv.{u4, u2, u3} S Γ₀ Γ'₀ _inst_6 _inst_4 _inst_5 (Valuation.comap.{u1, u2, u4} R Γ₀ _inst_3 _inst_4 S _inst_6 f v₁) (Valuation.comap.{u1, u3, u4} R Γ'₀ _inst_3 _inst_5 S _inst_6 f v₂))
but is expected to have type
  forall {R : Type.{u3}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u1}} [_inst_3 : Ring.{u3} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_5 : LinearOrderedCommMonoidWithZero.{u1} Γ'₀] {v₁ : Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3} {v₂ : Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3} {S : Type.{u4}} [_inst_6 : Ring.{u4} S] (f : RingHom.{u4, u3} S R (NonAssocRing.toNonAssocSemiring.{u4} S (Ring.toNonAssocRing.{u4} S _inst_6)) (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3))), (Valuation.IsEquiv.{u3, u2, u1} R Γ₀ Γ'₀ _inst_3 _inst_4 _inst_5 v₁ v₂) -> (Valuation.IsEquiv.{u4, u2, u1} S Γ₀ Γ'₀ _inst_6 _inst_4 _inst_5 (Valuation.comap.{u3, u2, u4} R Γ₀ _inst_3 _inst_4 S _inst_6 f v₁) (Valuation.comap.{u3, u1, u4} R Γ'₀ _inst_3 _inst_5 S _inst_6 f v₂))
Case conversion may be inaccurate. Consider using '#align valuation.is_equiv.comap Valuation.IsEquiv.comapₓ'. -/
/-- `comap` preserves equivalence. -/
theorem comap {S : Type _} [Ring S] (f : S →+* R) (h : v₁.IsEquiv v₂) :
    (v₁.comap f).IsEquiv (v₂.comap f) := fun r s => h (f r) (f s)
#align valuation.is_equiv.comap Valuation.IsEquiv.comap

/- warning: valuation.is_equiv.val_eq -> Valuation.IsEquiv.val_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_5 : LinearOrderedCommMonoidWithZero.{u3} Γ'₀] {v₁ : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3} {v₂ : Valuation.{u1, u3} R Γ'₀ _inst_5 _inst_3}, (Valuation.IsEquiv.{u1, u2, u3} R Γ₀ Γ'₀ _inst_3 _inst_4 _inst_5 v₁ v₂) -> (forall {r : R} {s : R}, Iff (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v₁ r) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v₁ s)) (Eq.{succ u3} Γ'₀ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Valuation.{u1, u3} R Γ'₀ _inst_5 _inst_3) (fun (_x : Valuation.{u1, u3} R Γ'₀ _inst_5 _inst_3) => R -> Γ'₀) (Valuation.hasCoeToFun.{u1, u3} R Γ'₀ _inst_3 _inst_5) v₂ r) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Valuation.{u1, u3} R Γ'₀ _inst_5 _inst_3) (fun (_x : Valuation.{u1, u3} R Γ'₀ _inst_5 _inst_3) => R -> Γ'₀) (Valuation.hasCoeToFun.{u1, u3} R Γ'₀ _inst_3 _inst_5) v₂ s)))
but is expected to have type
  forall {R : Type.{u3}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u1}} [_inst_3 : Ring.{u3} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_5 : LinearOrderedCommMonoidWithZero.{u1} Γ'₀] {v₁ : Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3} {v₂ : Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3}, (Valuation.IsEquiv.{u3, u2, u1} R Γ₀ Γ'₀ _inst_3 _inst_4 _inst_5 v₁ v₂) -> (forall {r : R} {s : R}, Iff (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) r) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u3} R (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u3 u2, u3, u2} (Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u3 u2, u3, u2} (Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u3, u2} R Γ₀ _inst_3 _inst_4))))) v₁ r) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u3} R (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u3 u2, u3, u2} (Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u3 u2, u3, u2} (Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u3, u2} R Γ₀ _inst_3 _inst_4))))) v₁ s)) (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ'₀) r) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ'₀) _x) (MulHomClass.toFunLike.{max u3 u1, u3, u1} (Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3) R Γ'₀ (MulOneClass.toMul.{u3} R (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3))))) (MulOneClass.toMul.{u1} Γ'₀ (MulZeroOneClass.toMulOneClass.{u1} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5))))) (MonoidHomClass.toMulHomClass.{max u3 u1, u3, u1} (Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3) R Γ'₀ (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u1} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u3 u1, u3, u1} (Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3) R Γ'₀ (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5))) (ValuationClass.toMonoidWithZeroHomClass.{max u3 u1, u3, u1} (Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3) R Γ'₀ _inst_5 _inst_3 (Valuation.instValuationClassValuation.{u3, u1} R Γ'₀ _inst_3 _inst_5))))) v₂ r) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ'₀) _x) (MulHomClass.toFunLike.{max u3 u1, u3, u1} (Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3) R Γ'₀ (MulOneClass.toMul.{u3} R (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3))))) (MulOneClass.toMul.{u1} Γ'₀ (MulZeroOneClass.toMulOneClass.{u1} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5))))) (MonoidHomClass.toMulHomClass.{max u3 u1, u3, u1} (Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3) R Γ'₀ (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u1} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u3 u1, u3, u1} (Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3) R Γ'₀ (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5))) (ValuationClass.toMonoidWithZeroHomClass.{max u3 u1, u3, u1} (Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3) R Γ'₀ _inst_5 _inst_3 (Valuation.instValuationClassValuation.{u3, u1} R Γ'₀ _inst_3 _inst_5))))) v₂ s)))
Case conversion may be inaccurate. Consider using '#align valuation.is_equiv.val_eq Valuation.IsEquiv.val_eqₓ'. -/
theorem val_eq (h : v₁.IsEquiv v₂) {r s : R} : v₁ r = v₁ s ↔ v₂ r = v₂ s := by
  simpa only [le_antisymm_iff] using and_congr (h r s) (h s r)
#align valuation.is_equiv.val_eq Valuation.IsEquiv.val_eq

/- warning: valuation.is_equiv.ne_zero -> Valuation.IsEquiv.ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_3 : Ring.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_5 : LinearOrderedCommMonoidWithZero.{u3} Γ'₀] {v₁ : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3} {v₂ : Valuation.{u1, u3} R Γ'₀ _inst_5 _inst_3}, (Valuation.IsEquiv.{u1, u2, u3} R Γ₀ Γ'₀ _inst_3 _inst_4 _inst_5 v₁ v₂) -> (forall {r : R}, Iff (Ne.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 _inst_3) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_3 _inst_4) v₁ r) (OfNat.ofNat.{u2} Γ₀ 0 (OfNat.mk.{u2} Γ₀ 0 (Zero.zero.{u2} Γ₀ (MulZeroClass.toHasZero.{u2} Γ₀ (MulZeroOneClass.toMulZeroClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))))))) (Ne.{succ u3} Γ'₀ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Valuation.{u1, u3} R Γ'₀ _inst_5 _inst_3) (fun (_x : Valuation.{u1, u3} R Γ'₀ _inst_5 _inst_3) => R -> Γ'₀) (Valuation.hasCoeToFun.{u1, u3} R Γ'₀ _inst_3 _inst_5) v₂ r) (OfNat.ofNat.{u3} Γ'₀ 0 (OfNat.mk.{u3} Γ'₀ 0 (Zero.zero.{u3} Γ'₀ (MulZeroClass.toHasZero.{u3} Γ'₀ (MulZeroOneClass.toMulZeroClass.{u3} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_5))))))))))
but is expected to have type
  forall {R : Type.{u3}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u1}} [_inst_3 : Ring.{u3} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_5 : LinearOrderedCommMonoidWithZero.{u1} Γ'₀] {v₁ : Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3} {v₂ : Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3}, (Valuation.IsEquiv.{u3, u2, u1} R Γ₀ Γ'₀ _inst_3 _inst_4 _inst_5 v₁ v₂) -> (forall {r : R}, Iff (Ne.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) r) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulOneClass.toMul.{u3} R (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3))))) (MulOneClass.toMul.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u3 u2, u3, u2} (Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u3 u2, u3, u2} (Valuation.{u3, u2} R Γ₀ _inst_4 _inst_3) R Γ₀ _inst_4 _inst_3 (Valuation.instValuationClassValuation.{u3, u2} R Γ₀ _inst_3 _inst_4))))) v₁ r) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) r) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) r) (LinearOrderedCommMonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) r) _inst_4)))) (Ne.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ'₀) r) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ'₀) _x) (MulHomClass.toFunLike.{max u3 u1, u3, u1} (Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3) R Γ'₀ (MulOneClass.toMul.{u3} R (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3))))) (MulOneClass.toMul.{u1} Γ'₀ (MulZeroOneClass.toMulOneClass.{u1} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5))))) (MonoidHomClass.toMulHomClass.{max u3 u1, u3, u1} (Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3) R Γ'₀ (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3)))) (MulZeroOneClass.toMulOneClass.{u1} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u3 u1, u3, u1} (Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3) R Γ'₀ (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ'₀ _inst_5))) (ValuationClass.toMonoidWithZeroHomClass.{max u3 u1, u3, u1} (Valuation.{u3, u1} R Γ'₀ _inst_5 _inst_3) R Γ'₀ _inst_5 _inst_3 (Valuation.instValuationClassValuation.{u3, u1} R Γ'₀ _inst_3 _inst_5))))) v₂ r) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ'₀) r) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ'₀) r) (LinearOrderedCommMonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ'₀) r) _inst_5)))))
Case conversion may be inaccurate. Consider using '#align valuation.is_equiv.ne_zero Valuation.IsEquiv.ne_zeroₓ'. -/
theorem ne_zero (h : v₁.IsEquiv v₂) {r : R} : v₁ r ≠ 0 ↔ v₂ r ≠ 0 :=
  by
  have : v₁ r ≠ v₁ 0 ↔ v₂ r ≠ v₂ 0 := not_congr h.val_eq
  rwa [v₁.map_zero, v₂.map_zero] at this
#align valuation.is_equiv.ne_zero Valuation.IsEquiv.ne_zero

end IsEquiv

-- end of namespace
section

/- warning: valuation.is_equiv_of_map_strict_mono -> Valuation.isEquiv_of_map_strictMono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_3 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] [_inst_4 : LinearOrderedCommMonoidWithZero.{u3} Γ'₀] [_inst_5 : Ring.{u1} R] {v : Valuation.{u1, u2} R Γ₀ _inst_3 _inst_5} (f : MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_4)))) (H : StrictMono.{u2, u3} Γ₀ Γ'₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_3)))) (PartialOrder.toPreorder.{u3} Γ'₀ (OrderedCommMonoid.toPartialOrder.{u3} Γ'₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} Γ'₀ _inst_4)))) (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_4)))) (fun (_x : MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_4)))) => Γ₀ -> Γ'₀) (MonoidWithZeroHom.hasCoeToFun.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_4)))) f)), Valuation.IsEquiv.{u1, u3, u2} R Γ'₀ Γ₀ _inst_5 _inst_4 _inst_3 (Valuation.map.{u1, u2, u3} R Γ₀ Γ'₀ _inst_5 _inst_3 _inst_4 f (StrictMono.monotone.{u2, u3} Γ₀ Γ'₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ _inst_3))) (PartialOrder.toPreorder.{u3} Γ'₀ (OrderedCommMonoid.toPartialOrder.{u3} Γ'₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} Γ'₀ _inst_4)))) (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_4)))) (fun (_x : MonoidWithZeroHom.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_4)))) => Γ₀ -> Γ'₀) (MonoidWithZeroHom.hasCoeToFun.{u2, u3} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ'₀ _inst_4)))) f) H) v) v
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u3}} {Γ'₀ : Type.{u2}} [_inst_3 : LinearOrderedCommMonoidWithZero.{u3} Γ₀] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ'₀] [_inst_5 : Ring.{u1} R] {v : Valuation.{u1, u3} R Γ₀ _inst_3 _inst_5} (f : MonoidWithZeroHom.{u3, u2} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) (H : StrictMono.{u3, u2} Γ₀ Γ'₀ (PartialOrder.toPreorder.{u3} Γ₀ (OrderedCommMonoid.toPartialOrder.{u3} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} Γ₀ _inst_3)))) (PartialOrder.toPreorder.{u2} Γ'₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ'₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ'₀ _inst_4)))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidWithZeroHom.{u3, u2} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) Γ₀ (fun (_x : Γ₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Γ₀) => Γ'₀) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidWithZeroHom.{u3, u2} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) Γ₀ Γ'₀ (MulOneClass.toMul.{u3} Γ₀ (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3))))) (MulOneClass.toMul.{u2} Γ'₀ (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidWithZeroHom.{u3, u2} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) Γ₀ Γ'₀ (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u3 u2, u3, u2} (MonoidWithZeroHom.{u3, u2} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4))) (MonoidWithZeroHom.monoidWithZeroHomClass.{u3, u2} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4))))))) f)), Valuation.IsEquiv.{u1, u2, u3} R Γ'₀ Γ₀ _inst_5 _inst_4 _inst_3 (Valuation.map.{u1, u3, u2} R Γ₀ Γ'₀ _inst_5 _inst_3 _inst_4 f (StrictMono.monotone.{u3, u2} Γ₀ Γ'₀ (OrderedCommMonoid.toPartialOrder.{u3} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} Γ₀ _inst_3))) (PartialOrder.toPreorder.{u2} Γ'₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ'₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ'₀ _inst_4)))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidWithZeroHom.{u3, u2} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) Γ₀ (fun (_x : Γ₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Γ₀) => Γ'₀) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidWithZeroHom.{u3, u2} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) Γ₀ Γ'₀ (MulOneClass.toMul.{u3} Γ₀ (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3))))) (MulOneClass.toMul.{u2} Γ'₀ (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidWithZeroHom.{u3, u2} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) Γ₀ Γ'₀ (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3)))) (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u3 u2, u3, u2} (MonoidWithZeroHom.{u3, u2} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4))) (MonoidWithZeroHom.monoidWithZeroHomClass.{u3, u2} Γ₀ Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ _inst_4))))))) f) H) v) v
Case conversion may be inaccurate. Consider using '#align valuation.is_equiv_of_map_strict_mono Valuation.isEquiv_of_map_strictMonoₓ'. -/
theorem isEquiv_of_map_strictMono [LinearOrderedCommMonoidWithZero Γ₀]
    [LinearOrderedCommMonoidWithZero Γ'₀] [Ring R] {v : Valuation R Γ₀} (f : Γ₀ →*₀ Γ'₀)
    (H : StrictMono f) : IsEquiv (v.map f H.Monotone) v := fun x y =>
  ⟨H.le_iff_le.mp, fun h => H.Monotone h⟩
#align valuation.is_equiv_of_map_strict_mono Valuation.isEquiv_of_map_strictMono

/- warning: valuation.is_equiv_of_val_le_one -> Valuation.isEquiv_of_val_le_one is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_3 : LinearOrderedCommGroupWithZero.{u2} Γ₀] [_inst_4 : LinearOrderedCommGroupWithZero.{u3} Γ'₀] (v : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (v' : Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)), (forall {x : K}, Iff (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3)) v x) (OfNat.ofNat.{u2} Γ₀ 1 (OfNat.mk.{u2} Γ₀ 1 (One.one.{u2} Γ₀ (MulOneClass.toHasOne.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_3)))))))))) (LE.le.{u3} Γ'₀ (Preorder.toLE.{u3} Γ'₀ (PartialOrder.toPreorder.{u3} Γ'₀ (OrderedCommMonoid.toPartialOrder.{u3} Γ'₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ'₀) (Valuation.hasCoeToFun.{u1, u3} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4)) v' x) (OfNat.ofNat.{u3} Γ'₀ 1 (OfNat.mk.{u3} Γ'₀ 1 (One.one.{u3} Γ'₀ (MulOneClass.toHasOne.{u3} Γ'₀ (MulZeroOneClass.toMulOneClass.{u3} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (GroupWithZero.toMonoidWithZero.{u3} Γ'₀ (CommGroupWithZero.toGroupWithZero.{u3} Γ'₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} Γ'₀ _inst_4))))))))))) -> (Valuation.IsEquiv.{u1, u2, u3} K Γ₀ Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) v v')
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u3}} {Γ'₀ : Type.{u2}} [_inst_3 : LinearOrderedCommGroupWithZero.{u3} Γ₀] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ'₀] (v : Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (v' : Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)), (forall {x : K}, Iff (LE.le.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (Preorder.toLE.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (PartialOrder.toPreorder.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (OrderedCommMonoid.toPartialOrder.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) _inst_3)))))) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u3} Γ₀ (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) (MonoidHomClass.toMulHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u3} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) v x) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) 1 (One.toOfNat1.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (InvOneClass.toOne.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivInvOneMonoid.toInvOneClass.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivisionMonoid.toDivInvOneMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivisionCommMonoid.toDivisionMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) _inst_3))))))))) (LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u2} Γ'₀ (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u2} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) v' x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (InvOneClass.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivInvOneMonoid.toInvOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivisionMonoid.toDivInvOneMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivisionCommMonoid.toDivisionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) _inst_4)))))))))) -> (Valuation.IsEquiv.{u1, u3, u2} K Γ₀ Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) v v')
Case conversion may be inaccurate. Consider using '#align valuation.is_equiv_of_val_le_one Valuation.isEquiv_of_val_le_oneₓ'. -/
theorem isEquiv_of_val_le_one [LinearOrderedCommGroupWithZero Γ₀]
    [LinearOrderedCommGroupWithZero Γ'₀] (v : Valuation K Γ₀) (v' : Valuation K Γ'₀)
    (h : ∀ {x : K}, v x ≤ 1 ↔ v' x ≤ 1) : v.IsEquiv v' :=
  by
  intro x y
  by_cases hy : y = 0; · simp [hy, zero_iff]
  rw [show y = 1 * y by rw [one_mul]]
  rw [← inv_mul_cancel_right₀ hy x]
  iterate 2 rw [v.map_mul _ y, v'.map_mul _ y]
  rw [v.map_one, v'.map_one]
  constructor <;> intro H
  · apply mul_le_mul_right'
    replace hy := v.ne_zero_iff.mpr hy
    replace H := le_of_le_mul_right hy H
    rwa [h] at H
  · apply mul_le_mul_right'
    replace hy := v'.ne_zero_iff.mpr hy
    replace H := le_of_le_mul_right hy H
    rwa [h]
#align valuation.is_equiv_of_val_le_one Valuation.isEquiv_of_val_le_one

/- warning: valuation.is_equiv_iff_val_le_one -> Valuation.isEquiv_iff_val_le_one is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_3 : LinearOrderedCommGroupWithZero.{u2} Γ₀] [_inst_4 : LinearOrderedCommGroupWithZero.{u3} Γ'₀] (v : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (v' : Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)), Iff (Valuation.IsEquiv.{u1, u2, u3} K Γ₀ Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) v v') (forall {x : K}, Iff (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3)) v x) (OfNat.ofNat.{u2} Γ₀ 1 (OfNat.mk.{u2} Γ₀ 1 (One.one.{u2} Γ₀ (MulOneClass.toHasOne.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_3)))))))))) (LE.le.{u3} Γ'₀ (Preorder.toLE.{u3} Γ'₀ (PartialOrder.toPreorder.{u3} Γ'₀ (OrderedCommMonoid.toPartialOrder.{u3} Γ'₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ'₀) (Valuation.hasCoeToFun.{u1, u3} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4)) v' x) (OfNat.ofNat.{u3} Γ'₀ 1 (OfNat.mk.{u3} Γ'₀ 1 (One.one.{u3} Γ'₀ (MulOneClass.toHasOne.{u3} Γ'₀ (MulZeroOneClass.toMulOneClass.{u3} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (GroupWithZero.toMonoidWithZero.{u3} Γ'₀ (CommGroupWithZero.toGroupWithZero.{u3} Γ'₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} Γ'₀ _inst_4)))))))))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u3}} {Γ'₀ : Type.{u2}} [_inst_3 : LinearOrderedCommGroupWithZero.{u3} Γ₀] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ'₀] (v : Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (v' : Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)), Iff (Valuation.IsEquiv.{u1, u3, u2} K Γ₀ Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) v v') (forall {x : K}, Iff (LE.le.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (Preorder.toLE.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (PartialOrder.toPreorder.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (OrderedCommMonoid.toPartialOrder.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) _inst_3)))))) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u3} Γ₀ (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) (MonoidHomClass.toMulHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u3} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) v x) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) 1 (One.toOfNat1.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (InvOneClass.toOne.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivInvOneMonoid.toInvOneClass.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivisionMonoid.toDivInvOneMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivisionCommMonoid.toDivisionMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) _inst_3))))))))) (LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u2} Γ'₀ (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u2} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) v' x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (InvOneClass.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivInvOneMonoid.toInvOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivisionMonoid.toDivInvOneMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivisionCommMonoid.toDivisionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) _inst_4))))))))))
Case conversion may be inaccurate. Consider using '#align valuation.is_equiv_iff_val_le_one Valuation.isEquiv_iff_val_le_oneₓ'. -/
theorem isEquiv_iff_val_le_one [LinearOrderedCommGroupWithZero Γ₀]
    [LinearOrderedCommGroupWithZero Γ'₀] (v : Valuation K Γ₀) (v' : Valuation K Γ'₀) :
    v.IsEquiv v' ↔ ∀ {x : K}, v x ≤ 1 ↔ v' x ≤ 1 :=
  ⟨fun h x => by simpa using h x 1, isEquiv_of_val_le_one _ _⟩
#align valuation.is_equiv_iff_val_le_one Valuation.isEquiv_iff_val_le_one

/- warning: valuation.is_equiv_iff_val_eq_one -> Valuation.isEquiv_iff_val_eq_one is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_3 : LinearOrderedCommGroupWithZero.{u2} Γ₀] [_inst_4 : LinearOrderedCommGroupWithZero.{u3} Γ'₀] (v : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (v' : Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)), Iff (Valuation.IsEquiv.{u1, u2, u3} K Γ₀ Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) v v') (forall {x : K}, Iff (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3)) v x) (OfNat.ofNat.{u2} Γ₀ 1 (OfNat.mk.{u2} Γ₀ 1 (One.one.{u2} Γ₀ (MulOneClass.toHasOne.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_3)))))))))) (Eq.{succ u3} Γ'₀ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ'₀) (Valuation.hasCoeToFun.{u1, u3} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4)) v' x) (OfNat.ofNat.{u3} Γ'₀ 1 (OfNat.mk.{u3} Γ'₀ 1 (One.one.{u3} Γ'₀ (MulOneClass.toHasOne.{u3} Γ'₀ (MulZeroOneClass.toMulOneClass.{u3} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (GroupWithZero.toMonoidWithZero.{u3} Γ'₀ (CommGroupWithZero.toGroupWithZero.{u3} Γ'₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} Γ'₀ _inst_4)))))))))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u3}} {Γ'₀ : Type.{u2}} [_inst_3 : LinearOrderedCommGroupWithZero.{u3} Γ₀] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ'₀] (v : Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (v' : Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)), Iff (Valuation.IsEquiv.{u1, u3, u2} K Γ₀ Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) v v') (forall {x : K}, Iff (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u3} Γ₀ (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) (MonoidHomClass.toMulHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u3} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) v x) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) 1 (One.toOfNat1.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (InvOneClass.toOne.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivInvOneMonoid.toInvOneClass.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivisionMonoid.toDivInvOneMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivisionCommMonoid.toDivisionMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) _inst_3))))))))) (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u2} Γ'₀ (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u2} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) v' x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (InvOneClass.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivInvOneMonoid.toInvOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivisionMonoid.toDivInvOneMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivisionCommMonoid.toDivisionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) _inst_4))))))))))
Case conversion may be inaccurate. Consider using '#align valuation.is_equiv_iff_val_eq_one Valuation.isEquiv_iff_val_eq_oneₓ'. -/
theorem isEquiv_iff_val_eq_one [LinearOrderedCommGroupWithZero Γ₀]
    [LinearOrderedCommGroupWithZero Γ'₀] (v : Valuation K Γ₀) (v' : Valuation K Γ'₀) :
    v.IsEquiv v' ↔ ∀ {x : K}, v x = 1 ↔ v' x = 1 :=
  by
  constructor
  · intro h x
    simpa using @is_equiv.val_eq _ _ _ _ _ _ v v' h x 1
  · intro h
    apply is_equiv_of_val_le_one
    intro x
    constructor
    · intro hx
      cases' lt_or_eq_of_le hx with hx' hx'
      · have : v (1 + x) = 1 := by
          rw [← v.map_one]
          apply map_add_eq_of_lt_left
          simpa
        rw [h] at this
        rw [show x = -1 + (1 + x) by simp]
        refine' le_trans (v'.map_add _ _) _
        simp [this]
      · rw [h] at hx'
        exact le_of_eq hx'
    · intro hx
      cases' lt_or_eq_of_le hx with hx' hx'
      · have : v' (1 + x) = 1 := by
          rw [← v'.map_one]
          apply map_add_eq_of_lt_left
          simpa
        rw [← h] at this
        rw [show x = -1 + (1 + x) by simp]
        refine' le_trans (v.map_add _ _) _
        simp [this]
      · rw [← h] at hx'
        exact le_of_eq hx'
#align valuation.is_equiv_iff_val_eq_one Valuation.isEquiv_iff_val_eq_one

/- warning: valuation.is_equiv_iff_val_lt_one -> Valuation.isEquiv_iff_val_lt_one is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_3 : LinearOrderedCommGroupWithZero.{u2} Γ₀] [_inst_4 : LinearOrderedCommGroupWithZero.{u3} Γ'₀] (v : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (v' : Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)), Iff (Valuation.IsEquiv.{u1, u2, u3} K Γ₀ Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) v v') (forall {x : K}, Iff (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3)) v x) (OfNat.ofNat.{u2} Γ₀ 1 (OfNat.mk.{u2} Γ₀ 1 (One.one.{u2} Γ₀ (MulOneClass.toHasOne.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_3)))))))))) (LT.lt.{u3} Γ'₀ (Preorder.toLT.{u3} Γ'₀ (PartialOrder.toPreorder.{u3} Γ'₀ (OrderedCommMonoid.toPartialOrder.{u3} Γ'₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ'₀) (Valuation.hasCoeToFun.{u1, u3} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4)) v' x) (OfNat.ofNat.{u3} Γ'₀ 1 (OfNat.mk.{u3} Γ'₀ 1 (One.one.{u3} Γ'₀ (MulOneClass.toHasOne.{u3} Γ'₀ (MulZeroOneClass.toMulOneClass.{u3} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (GroupWithZero.toMonoidWithZero.{u3} Γ'₀ (CommGroupWithZero.toGroupWithZero.{u3} Γ'₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} Γ'₀ _inst_4)))))))))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u3}} {Γ'₀ : Type.{u2}} [_inst_3 : LinearOrderedCommGroupWithZero.{u3} Γ₀] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ'₀] (v : Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (v' : Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)), Iff (Valuation.IsEquiv.{u1, u3, u2} K Γ₀ Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) v v') (forall {x : K}, Iff (LT.lt.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (Preorder.toLT.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (PartialOrder.toPreorder.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (OrderedCommMonoid.toPartialOrder.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) _inst_3)))))) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u3} Γ₀ (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) (MonoidHomClass.toMulHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u3} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) v x) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) 1 (One.toOfNat1.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (InvOneClass.toOne.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivInvOneMonoid.toInvOneClass.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivisionMonoid.toDivInvOneMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivisionCommMonoid.toDivisionMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) _inst_3))))))))) (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u2} Γ'₀ (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u2} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) v' x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (InvOneClass.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivInvOneMonoid.toInvOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivisionMonoid.toDivInvOneMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivisionCommMonoid.toDivisionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) _inst_4))))))))))
Case conversion may be inaccurate. Consider using '#align valuation.is_equiv_iff_val_lt_one Valuation.isEquiv_iff_val_lt_oneₓ'. -/
theorem isEquiv_iff_val_lt_one [LinearOrderedCommGroupWithZero Γ₀]
    [LinearOrderedCommGroupWithZero Γ'₀] (v : Valuation K Γ₀) (v' : Valuation K Γ'₀) :
    v.IsEquiv v' ↔ ∀ {x : K}, v x < 1 ↔ v' x < 1 :=
  by
  constructor
  · intro h x
    simp only [lt_iff_le_and_ne,
      and_congr ((is_equiv_iff_val_le_one _ _).1 h) ((is_equiv_iff_val_eq_one _ _).1 h).Not]
  · rw [is_equiv_iff_val_eq_one]
    intro h x
    by_cases hx : x = 0
    · simp only [(zero_iff _).2 hx, zero_ne_one]
    constructor
    · intro hh
      by_contra h_1
      cases ne_iff_lt_or_gt.1 h_1
      · simpa [hh, lt_self_iff_false] using h.2 h_2
      · rw [← inv_one, ← inv_eq_iff_eq_inv, ← map_inv₀] at hh
        exact hh.not_lt (h.2 ((one_lt_val_iff v' hx).1 h_2))
    · intro hh
      by_contra h_1
      cases ne_iff_lt_or_gt.1 h_1
      · simpa [hh, lt_self_iff_false] using h.1 h_2
      · rw [← inv_one, ← inv_eq_iff_eq_inv, ← map_inv₀] at hh
        exact hh.not_lt (h.1 ((one_lt_val_iff v hx).1 h_2))
#align valuation.is_equiv_iff_val_lt_one Valuation.isEquiv_iff_val_lt_one

/- warning: valuation.is_equiv_iff_val_sub_one_lt_one -> Valuation.isEquiv_iff_val_sub_one_lt_one is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_3 : LinearOrderedCommGroupWithZero.{u2} Γ₀] [_inst_4 : LinearOrderedCommGroupWithZero.{u3} Γ'₀] (v : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (v' : Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)), Iff (Valuation.IsEquiv.{u1, u2, u3} K Γ₀ Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) v v') (forall {x : K}, Iff (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3)) v (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) x (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) (OfNat.ofNat.{u2} Γ₀ 1 (OfNat.mk.{u2} Γ₀ 1 (One.one.{u2} Γ₀ (MulOneClass.toHasOne.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_3)))))))))) (LT.lt.{u3} Γ'₀ (Preorder.toLT.{u3} Γ'₀ (PartialOrder.toPreorder.{u3} Γ'₀ (OrderedCommMonoid.toPartialOrder.{u3} Γ'₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ'₀) (Valuation.hasCoeToFun.{u1, u3} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4)) v' (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) x (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) (OfNat.ofNat.{u3} Γ'₀ 1 (OfNat.mk.{u3} Γ'₀ 1 (One.one.{u3} Γ'₀ (MulOneClass.toHasOne.{u3} Γ'₀ (MulZeroOneClass.toMulOneClass.{u3} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (GroupWithZero.toMonoidWithZero.{u3} Γ'₀ (CommGroupWithZero.toGroupWithZero.{u3} Γ'₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} Γ'₀ _inst_4)))))))))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u3}} {Γ'₀ : Type.{u2}} [_inst_3 : LinearOrderedCommGroupWithZero.{u3} Γ₀] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ'₀] (v : Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (v' : Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)), Iff (Valuation.IsEquiv.{u1, u3, u2} K Γ₀ Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) v v') (forall {x : K}, Iff (LT.lt.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (Preorder.toLT.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (PartialOrder.toPreorder.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (OrderedCommMonoid.toPartialOrder.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) _inst_3)))))) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u3} Γ₀ (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) (MonoidHomClass.toMulHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u3} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) v (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) 1 (One.toOfNat1.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (InvOneClass.toOne.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (DivInvOneMonoid.toInvOneClass.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (DivisionMonoid.toDivInvOneMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (DivisionCommMonoid.toDivisionMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (CommGroupWithZero.toDivisionCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) _inst_3))))))))) (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u2} Γ'₀ (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u2} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) v' (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (InvOneClass.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (DivInvOneMonoid.toInvOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (DivisionMonoid.toDivInvOneMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (DivisionCommMonoid.toDivisionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (CommGroupWithZero.toDivisionCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) _inst_4))))))))))
Case conversion may be inaccurate. Consider using '#align valuation.is_equiv_iff_val_sub_one_lt_one Valuation.isEquiv_iff_val_sub_one_lt_oneₓ'. -/
theorem isEquiv_iff_val_sub_one_lt_one [LinearOrderedCommGroupWithZero Γ₀]
    [LinearOrderedCommGroupWithZero Γ'₀] (v : Valuation K Γ₀) (v' : Valuation K Γ'₀) :
    v.IsEquiv v' ↔ ∀ {x : K}, v (x - 1) < 1 ↔ v' (x - 1) < 1 :=
  by
  rw [is_equiv_iff_val_lt_one]
  exact (Equiv.subRight 1).Surjective.forall
#align valuation.is_equiv_iff_val_sub_one_lt_one Valuation.isEquiv_iff_val_sub_one_lt_one

/- warning: valuation.is_equiv_tfae -> Valuation.isEquiv_tfae is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_3 : LinearOrderedCommGroupWithZero.{u2} Γ₀] [_inst_4 : LinearOrderedCommGroupWithZero.{u3} Γ'₀] (v : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (v' : Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)), List.TFAE (List.cons.{0} Prop (Valuation.IsEquiv.{u1, u2, u3} K Γ₀ Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) v v') (List.cons.{0} Prop (forall {x : K}, Iff (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3)) v x) (OfNat.ofNat.{u2} Γ₀ 1 (OfNat.mk.{u2} Γ₀ 1 (One.one.{u2} Γ₀ (MulOneClass.toHasOne.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_3)))))))))) (LE.le.{u3} Γ'₀ (Preorder.toLE.{u3} Γ'₀ (PartialOrder.toPreorder.{u3} Γ'₀ (OrderedCommMonoid.toPartialOrder.{u3} Γ'₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ'₀) (Valuation.hasCoeToFun.{u1, u3} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4)) v' x) (OfNat.ofNat.{u3} Γ'₀ 1 (OfNat.mk.{u3} Γ'₀ 1 (One.one.{u3} Γ'₀ (MulOneClass.toHasOne.{u3} Γ'₀ (MulZeroOneClass.toMulOneClass.{u3} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (GroupWithZero.toMonoidWithZero.{u3} Γ'₀ (CommGroupWithZero.toGroupWithZero.{u3} Γ'₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} Γ'₀ _inst_4))))))))))) (List.cons.{0} Prop (forall {x : K}, Iff (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3)) v x) (OfNat.ofNat.{u2} Γ₀ 1 (OfNat.mk.{u2} Γ₀ 1 (One.one.{u2} Γ₀ (MulOneClass.toHasOne.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_3)))))))))) (Eq.{succ u3} Γ'₀ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ'₀) (Valuation.hasCoeToFun.{u1, u3} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4)) v' x) (OfNat.ofNat.{u3} Γ'₀ 1 (OfNat.mk.{u3} Γ'₀ 1 (One.one.{u3} Γ'₀ (MulOneClass.toHasOne.{u3} Γ'₀ (MulZeroOneClass.toMulOneClass.{u3} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (GroupWithZero.toMonoidWithZero.{u3} Γ'₀ (CommGroupWithZero.toGroupWithZero.{u3} Γ'₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} Γ'₀ _inst_4))))))))))) (List.cons.{0} Prop (forall {x : K}, Iff (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3)) v x) (OfNat.ofNat.{u2} Γ₀ 1 (OfNat.mk.{u2} Γ₀ 1 (One.one.{u2} Γ₀ (MulOneClass.toHasOne.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_3)))))))))) (LT.lt.{u3} Γ'₀ (Preorder.toLT.{u3} Γ'₀ (PartialOrder.toPreorder.{u3} Γ'₀ (OrderedCommMonoid.toPartialOrder.{u3} Γ'₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ'₀) (Valuation.hasCoeToFun.{u1, u3} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4)) v' x) (OfNat.ofNat.{u3} Γ'₀ 1 (OfNat.mk.{u3} Γ'₀ 1 (One.one.{u3} Γ'₀ (MulOneClass.toHasOne.{u3} Γ'₀ (MulZeroOneClass.toMulOneClass.{u3} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (GroupWithZero.toMonoidWithZero.{u3} Γ'₀ (CommGroupWithZero.toGroupWithZero.{u3} Γ'₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} Γ'₀ _inst_4))))))))))) (List.cons.{0} Prop (forall {x : K}, Iff (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u2} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ₀ _inst_3)) v (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) x (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) (OfNat.ofNat.{u2} Γ₀ 1 (OfNat.mk.{u2} Γ₀ 1 (One.one.{u2} Γ₀ (MulOneClass.toHasOne.{u2} Γ₀ (MulZeroOneClass.toMulOneClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (GroupWithZero.toMonoidWithZero.{u2} Γ₀ (CommGroupWithZero.toGroupWithZero.{u2} Γ₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} Γ₀ _inst_3)))))))))) (LT.lt.{u3} Γ'₀ (Preorder.toLT.{u3} Γ'₀ (PartialOrder.toPreorder.{u3} Γ'₀ (OrderedCommMonoid.toPartialOrder.{u3} Γ'₀ (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4)))))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) (fun (_x : Valuation.{u1, u3} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) => K -> Γ'₀) (Valuation.hasCoeToFun.{u1, u3} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ'₀ _inst_4)) v' (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) x (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) (OfNat.ofNat.{u3} Γ'₀ 1 (OfNat.mk.{u3} Γ'₀ 1 (One.one.{u3} Γ'₀ (MulOneClass.toHasOne.{u3} Γ'₀ (MulZeroOneClass.toMulOneClass.{u3} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ'₀ (GroupWithZero.toMonoidWithZero.{u3} Γ'₀ (CommGroupWithZero.toGroupWithZero.{u3} Γ'₀ (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} Γ'₀ _inst_4))))))))))) (List.nil.{0} Prop))))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u3}} {Γ'₀ : Type.{u2}} [_inst_3 : LinearOrderedCommGroupWithZero.{u3} Γ₀] [_inst_4 : LinearOrderedCommGroupWithZero.{u2} Γ'₀] (v : Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) (v' : Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)), List.TFAE (List.cons.{0} Prop (Valuation.IsEquiv.{u1, u3, u2} K Γ₀ Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) v v') (List.cons.{0} Prop (forall {x : K}, Iff (LE.le.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (Preorder.toLE.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (PartialOrder.toPreorder.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (OrderedCommMonoid.toPartialOrder.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) _inst_3)))))) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u3} Γ₀ (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) (MonoidHomClass.toMulHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u3} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) v x) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) 1 (One.toOfNat1.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (InvOneClass.toOne.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivInvOneMonoid.toInvOneClass.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivisionMonoid.toDivInvOneMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivisionCommMonoid.toDivisionMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) _inst_3))))))))) (LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u2} Γ'₀ (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u2} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) v' x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (InvOneClass.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivInvOneMonoid.toInvOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivisionMonoid.toDivInvOneMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivisionCommMonoid.toDivisionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) _inst_4)))))))))) (List.cons.{0} Prop (forall {x : K}, Iff (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u3} Γ₀ (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) (MonoidHomClass.toMulHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u3} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) v x) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) 1 (One.toOfNat1.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (InvOneClass.toOne.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivInvOneMonoid.toInvOneClass.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivisionMonoid.toDivInvOneMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivisionCommMonoid.toDivisionMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) _inst_3))))))))) (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u2} Γ'₀ (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u2} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) v' x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (InvOneClass.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivInvOneMonoid.toInvOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivisionMonoid.toDivInvOneMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivisionCommMonoid.toDivisionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) _inst_4)))))))))) (List.cons.{0} Prop (forall {x : K}, Iff (LT.lt.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (Preorder.toLT.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (PartialOrder.toPreorder.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (OrderedCommMonoid.toPartialOrder.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) _inst_3)))))) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u3} Γ₀ (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) (MonoidHomClass.toMulHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u3} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) v x) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) 1 (One.toOfNat1.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (InvOneClass.toOne.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivInvOneMonoid.toInvOneClass.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivisionMonoid.toDivInvOneMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (DivisionCommMonoid.toDivisionMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) x) _inst_3))))))))) (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u2} Γ'₀ (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u2} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) v' x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (InvOneClass.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivInvOneMonoid.toInvOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivisionMonoid.toDivInvOneMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (DivisionCommMonoid.toDivisionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (CommGroupWithZero.toDivisionCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) x) _inst_4)))))))))) (List.cons.{0} Prop (forall {x : K}, Iff (LT.lt.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (Preorder.toLT.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (PartialOrder.toPreorder.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (OrderedCommMonoid.toPartialOrder.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) _inst_3)))))) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u3} Γ₀ (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) (MonoidHomClass.toMulHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u3} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u3} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u3} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u3} Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u3, u1, u3} (Valuation.{u1, u3} K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1)) K Γ₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u3} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u3} Γ₀ _inst_3)))))) v (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) 1 (One.toOfNat1.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (InvOneClass.toOne.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (DivInvOneMonoid.toInvOneClass.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (DivisionMonoid.toDivInvOneMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (DivisionCommMonoid.toDivisionMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (CommGroupWithZero.toDivisionCommMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) _inst_3))))))))) (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (OrderedCommMonoid.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (LinearOrderedCommMonoid.toOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulOneClass.toMul.{u1} K (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (MulOneClass.toMul.{u2} Γ'₀ (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (MulZeroOneClass.toMulOneClass.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toMulOneClass.{u2} Γ'₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u2} Γ'₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1)) K Γ'₀ (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4) (DivisionRing.toRing.{u1} K _inst_1) (Valuation.instValuationClassValuation.{u1, u2} K Γ'₀ (DivisionRing.toRing.{u1} K _inst_1) (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u2} Γ'₀ _inst_4)))))) v' (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (InvOneClass.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (DivInvOneMonoid.toInvOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (DivisionMonoid.toDivInvOneMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (DivisionCommMonoid.toDivisionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (CommGroupWithZero.toDivisionCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Γ'₀) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) x (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) _inst_4)))))))))) (List.nil.{0} Prop))))))
Case conversion may be inaccurate. Consider using '#align valuation.is_equiv_tfae Valuation.isEquiv_tfaeₓ'. -/
theorem isEquiv_tfae [LinearOrderedCommGroupWithZero Γ₀] [LinearOrderedCommGroupWithZero Γ'₀]
    (v : Valuation K Γ₀) (v' : Valuation K Γ'₀) :
    [v.IsEquiv v', ∀ {x}, v x ≤ 1 ↔ v' x ≤ 1, ∀ {x}, v x = 1 ↔ v' x = 1, ∀ {x}, v x < 1 ↔ v' x < 1,
        ∀ {x}, v (x - 1) < 1 ↔ v' (x - 1) < 1].TFAE :=
  by
  tfae_have 1 ↔ 2; · apply is_equiv_iff_val_le_one
  tfae_have 1 ↔ 3; · apply is_equiv_iff_val_eq_one
  tfae_have 1 ↔ 4; · apply is_equiv_iff_val_lt_one
  tfae_have 1 ↔ 5; · apply is_equiv_iff_val_sub_one_lt_one
  tfae_finish
#align valuation.is_equiv_tfae Valuation.isEquiv_tfae

end

section Supp

variable [CommRing R]

variable [LinearOrderedCommMonoidWithZero Γ₀] [LinearOrderedCommMonoidWithZero Γ'₀]

variable (v : Valuation R Γ₀)

#print Valuation.supp /-
/-- The support of a valuation `v : R → Γ₀` is the ideal of `R` where `v` vanishes. -/
def supp : Ideal R where
  carrier := { x | v x = 0 }
  zero_mem' := map_zero v
  add_mem' x y hx hy :=
    le_zero_iff.mp <|
      calc
        v (x + y) ≤ max (v x) (v y) := v.map_add x y
        _ ≤ 0 := max_le (le_zero_iff.mpr hx) (le_zero_iff.mpr hy)
        
  smul_mem' c x hx :=
    calc
      v (c * x) = v c * v x := map_mul v c x
      _ = v c * 0 := (congr_arg _ hx)
      _ = 0 := MulZeroClass.mul_zero _
      
#align valuation.supp Valuation.supp
-/

/- warning: valuation.mem_supp_iff -> Valuation.mem_supp_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : CommRing.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 (CommRing.toRing.{u1} R _inst_3)) (x : R), Iff (Membership.Mem.{u1, u1} R (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) x (Valuation.supp.{u1, u2} R Γ₀ _inst_3 _inst_4 v)) (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 (CommRing.toRing.{u1} R _inst_3)) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 (CommRing.toRing.{u1} R _inst_3)) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ (CommRing.toRing.{u1} R _inst_3) _inst_4) v x) (OfNat.ofNat.{u2} Γ₀ 0 (OfNat.mk.{u2} Γ₀ 0 (Zero.zero.{u2} Γ₀ (MulZeroClass.toHasZero.{u2} Γ₀ (MulZeroOneClass.toMulZeroClass.{u2} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u2} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u2} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} Γ₀ _inst_4)))))))))
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_3 : CommRing.{u2} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u1} Γ₀] (v : Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) (x : R), Iff (Membership.mem.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_3))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_3))) R (Submodule.setLike.{u2, u2} R R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_3))))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_3))))) x (Valuation.supp.{u2, u1} R Γ₀ _inst_3 _inst_4 v)) (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) R Γ₀ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3)))))) (MulOneClass.toMul.{u1} Γ₀ (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) R Γ₀ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))))) (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3)))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3) (Valuation.instValuationClassValuation.{u2, u1} R Γ₀ (CommRing.toRing.{u2} R _inst_3) _inst_4))))) v x) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) (LinearOrderedCommMonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) x) _inst_4))))
Case conversion may be inaccurate. Consider using '#align valuation.mem_supp_iff Valuation.mem_supp_iffₓ'. -/
@[simp]
theorem mem_supp_iff (x : R) : x ∈ supp v ↔ v x = 0 :=
  Iff.rfl
#align valuation.mem_supp_iff Valuation.mem_supp_iff

-- @[simp] lemma mem_supp_iff' (x : R) : x ∈ (supp v : set R) ↔ v x = 0 := iff.rfl
/-- The support of a valuation is a prime ideal. -/
instance [Nontrivial Γ₀] [NoZeroDivisors Γ₀] : Ideal.IsPrime (supp v) :=
  ⟨fun h : v.supp = ⊤ =>
    one_ne_zero <|
      show (1 : Γ₀) = 0 from
        calc
          1 = v 1 := v.map_one.symm
          _ = 0 :=
            show (1 : R) ∈ supp v by
              rw [h]
              trivial
          ,
    fun x y hxy => by
    show v x = 0 ∨ v y = 0
    change v (x * y) = 0 at hxy
    rw [v.map_mul x y] at hxy
    exact eq_zero_or_eq_zero_of_mul_eq_zero hxy⟩

/- warning: valuation.map_add_supp -> Valuation.map_add_supp is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : CommRing.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 (CommRing.toRing.{u1} R _inst_3)) (a : R) {s : R}, (Membership.Mem.{u1, u1} R (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) s (Valuation.supp.{u1, u2} R Γ₀ _inst_3 _inst_4 v)) -> (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 (CommRing.toRing.{u1} R _inst_3)) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 (CommRing.toRing.{u1} R _inst_3)) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ (CommRing.toRing.{u1} R _inst_3) _inst_4) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_3)))) a s)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R Γ₀ _inst_4 (CommRing.toRing.{u1} R _inst_3)) (fun (_x : Valuation.{u1, u2} R Γ₀ _inst_4 (CommRing.toRing.{u1} R _inst_3)) => R -> Γ₀) (Valuation.hasCoeToFun.{u1, u2} R Γ₀ (CommRing.toRing.{u1} R _inst_3) _inst_4) v a))
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_3 : CommRing.{u2} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u1} Γ₀] (v : Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) (a : R) {s : R}, (Membership.mem.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_3))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_3))) R (Submodule.setLike.{u2, u2} R R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_3))))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_3))))) s (Valuation.supp.{u2, u1} R Γ₀ _inst_3 _inst_4 v)) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))))))) a s)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) R Γ₀ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3)))))) (MulOneClass.toMul.{u1} Γ₀ (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) R Γ₀ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))))) (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3)))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3) (Valuation.instValuationClassValuation.{u2, u1} R Γ₀ (CommRing.toRing.{u2} R _inst_3) _inst_4))))) v (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))))))) a s)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Γ₀) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) R Γ₀ (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3)))))) (MulOneClass.toMul.{u1} Γ₀ (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) R Γ₀ (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))))) (MulZeroOneClass.toMulOneClass.{u1} Γ₀ (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4)))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) R Γ₀ (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3)))) (MonoidWithZero.toMulZeroOneClass.{u1} Γ₀ (CommMonoidWithZero.toMonoidWithZero.{u1} Γ₀ (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} Γ₀ _inst_4))) (ValuationClass.toMonoidWithZeroHomClass.{max u2 u1, u2, u1} (Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3) (Valuation.instValuationClassValuation.{u2, u1} R Γ₀ (CommRing.toRing.{u2} R _inst_3) _inst_4))))) v a))
Case conversion may be inaccurate. Consider using '#align valuation.map_add_supp Valuation.map_add_suppₓ'. -/
theorem map_add_supp (a : R) {s : R} (h : s ∈ supp v) : v (a + s) = v a :=
  by
  have aux : ∀ a s, v s = 0 → v (a + s) ≤ v a :=
    by
    intro a' s' h'
    refine' le_trans (v.map_add a' s') (max_le le_rfl _)
    simp [h']
  apply le_antisymm (aux a s h)
  calc
    v a = v (a + s + -s) := by simp
    _ ≤ v (a + s) := aux (a + s) (-s) (by rwa [← Ideal.neg_mem_iff] at h)
    
#align valuation.map_add_supp Valuation.map_add_supp

/- warning: valuation.comap_supp -> Valuation.comap_supp is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_3 : CommRing.{u1} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u2} Γ₀] (v : Valuation.{u1, u2} R Γ₀ _inst_4 (CommRing.toRing.{u1} R _inst_3)) {S : Type.{u3}} [_inst_6 : CommRing.{u3} S] (f : RingHom.{u3, u1} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3)))), Eq.{succ u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6))) (Valuation.supp.{u3, u2} S Γ₀ _inst_6 _inst_4 (Valuation.comap.{u1, u2, u3} R Γ₀ (CommRing.toRing.{u1} R _inst_3) _inst_4 S (CommRing.toRing.{u3} S _inst_6) f v)) (Ideal.comap.{u3, u1, max u3 u1} S R (RingHom.{u3, u1} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)) (RingHom.ringHomClass.{u3, u1} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3)))) f (Valuation.supp.{u1, u2} R Γ₀ _inst_3 _inst_4 v))
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_3 : CommRing.{u2} R] [_inst_4 : LinearOrderedCommMonoidWithZero.{u1} Γ₀] (v : Valuation.{u2, u1} R Γ₀ _inst_4 (CommRing.toRing.{u2} R _inst_3)) {S : Type.{u3}} [_inst_6 : CommRing.{u3} S] (f : RingHom.{u3, u2} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3)))), Eq.{succ u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6))) (Valuation.supp.{u3, u1} S Γ₀ _inst_6 _inst_4 (Valuation.comap.{u2, u1, u3} R Γ₀ (CommRing.toRing.{u2} R _inst_3) _inst_4 S (CommRing.toRing.{u3} S _inst_6) f v)) (Ideal.comap.{u3, u2, max u2 u3} S R (RingHom.{u3, u2} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3)))) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_3)) (RingHom.instRingHomClassRingHom.{u3, u2} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3)))) f (Valuation.supp.{u2, u1} R Γ₀ _inst_3 _inst_4 v))
Case conversion may be inaccurate. Consider using '#align valuation.comap_supp Valuation.comap_suppₓ'. -/
theorem comap_supp {S : Type _} [CommRing S] (f : S →+* R) :
    supp (v.comap f) = Ideal.comap f v.supp :=
  Ideal.ext fun x => by
    rw [mem_supp_iff, Ideal.mem_comap, mem_supp_iff]
    rfl
#align valuation.comap_supp Valuation.comap_supp

end Supp

-- end of section
end Valuation

section AddMonoid

variable (R) [Ring R] (Γ₀ : Type _) [LinearOrderedAddCommMonoidWithTop Γ₀]

#print AddValuation /-
/-- The type of `Γ₀`-valued additive valuations on `R`. -/
@[nolint has_nonempty_instance]
def AddValuation :=
  Valuation R (Multiplicative Γ₀ᵒᵈ)
#align add_valuation AddValuation
-/

end AddMonoid

namespace AddValuation

variable {Γ₀ : Type _} {Γ'₀ : Type _}

section Basic

section Monoid

variable [LinearOrderedAddCommMonoidWithTop Γ₀] [LinearOrderedAddCommMonoidWithTop Γ'₀]

variable (R) (Γ₀) [Ring R]

/-- A valuation is coerced to the underlying function `R → Γ₀`. -/
instance : CoeFun (AddValuation R Γ₀) fun _ => R → Γ₀ where coe v := v.toMonoidWithZeroHom.toFun

variable {R} {Γ₀} (v : AddValuation R Γ₀) {x y z : R}

section

variable (f : R → Γ₀) (h0 : f 0 = ⊤) (h1 : f 1 = 0)

variable (hadd : ∀ x y, min (f x) (f y) ≤ f (x + y)) (hmul : ∀ x y, f (x * y) = f x + f y)

/- warning: add_valuation.of -> AddValuation.of is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] (f : R -> Γ₀), (Eq.{succ u2} Γ₀ (f (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_4))))))))) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toHasTop.{u2} Γ₀ _inst_2))) -> (Eq.{succ u2} Γ₀ (f (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_4)))))))) (OfNat.ofNat.{u2} Γ₀ 0 (OfNat.mk.{u2} Γ₀ 0 (Zero.zero.{u2} Γ₀ (AddZeroClass.toHasZero.{u2} Γ₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))))))))) -> (forall (x : R) (y : R), LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (LinearOrder.min.{u2} Γ₀ (LinearOrderedAddCommMonoid.toLinearOrder.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)) (f x) (f y)) (f (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_4))) x y))) -> (forall (x : R) (y : R), Eq.{succ u2} Γ₀ (f (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_4))) x y)) (HAdd.hAdd.{u2, u2, u2} Γ₀ Γ₀ Γ₀ (instHAdd.{u2} Γ₀ (AddZeroClass.toHasAdd.{u2} Γ₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))))) (f x) (f y))) -> (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2)
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] (f : R -> Γ₀), (Eq.{succ u2} Γ₀ (f (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_2)))))) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u2} Γ₀ _inst_4))) -> (Eq.{succ u2} Γ₀ (f (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (OfNat.ofNat.{u2} Γ₀ 0 (Zero.toOfNat0.{u2} Γ₀ (AddMonoid.toZero.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))))) -> (forall (x : R) (y : R), LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) (Min.min.{u2} Γ₀ (LinearOrder.toMin.{u2} Γ₀ (LinearOrderedAddCommMonoid.toLinearOrder.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))) (f x) (f y)) (f (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))))) x y))) -> (forall (x : R) (y : R), Eq.{succ u2} Γ₀ (f (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) x y)) (HAdd.hAdd.{u2, u2, u2} Γ₀ Γ₀ Γ₀ (instHAdd.{u2} Γ₀ (AddZeroClass.toAdd.{u2} Γ₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4)))))) (f x) (f y))) -> (AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_4)
Case conversion may be inaccurate. Consider using '#align add_valuation.of AddValuation.ofₓ'. -/
/-- An alternate constructor of `add_valuation`, that doesn't reference `multiplicative Γ₀ᵒᵈ` -/
def of : AddValuation R Γ₀ where
  toFun := f
  map_one' := h1
  map_zero' := h0
  map_add_le_max' := hadd
  map_mul' := hmul
#align add_valuation.of AddValuation.of

variable {h0} {h1} {hadd} {hmul} {r : R}

/- warning: add_valuation.of_apply -> AddValuation.of_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] (f : R -> Γ₀) {h0 : Eq.{succ u2} Γ₀ (f (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_4))))))))) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toHasTop.{u2} Γ₀ _inst_2))} {h1 : Eq.{succ u2} Γ₀ (f (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_4)))))))) (OfNat.ofNat.{u2} Γ₀ 0 (OfNat.mk.{u2} Γ₀ 0 (Zero.zero.{u2} Γ₀ (AddZeroClass.toHasZero.{u2} Γ₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))))))))} {hadd : forall (x : R) (y : R), LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (LinearOrder.min.{u2} Γ₀ (LinearOrderedAddCommMonoid.toLinearOrder.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)) (f x) (f y)) (f (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_4))) x y))} {hmul : forall (x : R) (y : R), Eq.{succ u2} Γ₀ (f (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_4))) x y)) (HAdd.hAdd.{u2, u2, u2} Γ₀ Γ₀ Γ₀ (instHAdd.{u2} Γ₀ (AddZeroClass.toHasAdd.{u2} Γ₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))))) (f x) (f y))} {r : R}, Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) (AddValuation.of.{u1, u2} R Γ₀ _inst_2 _inst_4 f h0 h1 hadd hmul) r) (f r)
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] (f : R -> Γ₀) {h0 : Eq.{succ u2} Γ₀ (f (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_2)))))) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u2} Γ₀ _inst_4))} {h1 : Eq.{succ u2} Γ₀ (f (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (OfNat.ofNat.{u2} Γ₀ 0 (Zero.toOfNat0.{u2} Γ₀ (AddMonoid.toZero.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))))} {hadd : forall (x : R) (y : R), LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) (Min.min.{u2} Γ₀ (LinearOrder.toMin.{u2} Γ₀ (LinearOrderedAddCommMonoid.toLinearOrder.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))) (f x) (f y)) (f (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))))) x y))} {hmul : forall (x : R) (y : R), Eq.{succ u2} Γ₀ (f (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) x y)) (HAdd.hAdd.{u2, u2, u2} Γ₀ Γ₀ Γ₀ (instHAdd.{u2} Γ₀ (AddZeroClass.toAdd.{u2} Γ₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4)))))) (f x) (f y))} {r : R}, Eq.{succ u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 (AddValuation.of.{u1, u2} R Γ₀ _inst_2 _inst_4 f h0 h1 hadd hmul))) r) (f r)
Case conversion may be inaccurate. Consider using '#align add_valuation.of_apply AddValuation.of_applyₓ'. -/
@[simp]
theorem of_apply : (of f h0 h1 hadd hmul) r = f r :=
  rfl
#align add_valuation.of_apply AddValuation.of_apply

/- warning: add_valuation.valuation -> AddValuation.valuation is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R], (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) -> (Valuation.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_2) _inst_4)
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀], (AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_4) -> (Valuation.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2)
Case conversion may be inaccurate. Consider using '#align add_valuation.valuation AddValuation.valuationₓ'. -/
/-- The `valuation` associated to an `add_valuation` (useful if the latter is constructed using
`add_valuation.of`). -/
def valuation : Valuation R (Multiplicative Γ₀ᵒᵈ) :=
  v
#align add_valuation.valuation AddValuation.valuation

/- warning: add_valuation.valuation_apply -> AddValuation.valuation_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (r : R), Eq.{succ u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Valuation.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_2) _inst_4) (fun (_x : Valuation.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_2) _inst_4) => R -> (Multiplicative.{u2} (OrderDual.{u2} Γ₀))) (Valuation.hasCoeToFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) _inst_4 (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_2)) (AddValuation.valuation.{u1, u2} R Γ₀ _inst_2 _inst_4 v) r) (coeFn.{succ u2, succ u2} (Equiv.{succ u2, succ u2} (OrderDual.{u2} Γ₀) (Multiplicative.{u2} (OrderDual.{u2} Γ₀))) (fun (_x : Equiv.{succ u2, succ u2} (OrderDual.{u2} Γ₀) (Multiplicative.{u2} (OrderDual.{u2} Γ₀))) => (OrderDual.{u2} Γ₀) -> (Multiplicative.{u2} (OrderDual.{u2} Γ₀))) (Equiv.hasCoeToFun.{succ u2, succ u2} (OrderDual.{u2} Γ₀) (Multiplicative.{u2} (OrderDual.{u2} Γ₀))) (Multiplicative.ofAdd.{u2} (OrderDual.{u2} Γ₀)) (coeFn.{succ u2, succ u2} (Equiv.{succ u2, succ u2} Γ₀ (OrderDual.{u2} Γ₀)) (fun (_x : Equiv.{succ u2, succ u2} Γ₀ (OrderDual.{u2} Γ₀)) => Γ₀ -> (OrderDual.{u2} Γ₀)) (Equiv.hasCoeToFun.{succ u2, succ u2} Γ₀ (OrderDual.{u2} Γ₀)) (OrderDual.toDual.{u2} Γ₀) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v r)))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] (v : AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_4) (r : R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Multiplicative.{u2} (OrderDual.{u2} Γ₀)) r) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Valuation.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Multiplicative.{u2} (OrderDual.{u2} Γ₀)) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (Valuation.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2) R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (MulOneClass.toMul.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toMulOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2) R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toMulOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2) R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (ValuationClass.toMonoidWithZeroHomClass.{max u1 u2, u1, u2} (Valuation.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2) R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 (Valuation.instValuationClassValuation.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) _inst_2 (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))))) (AddValuation.valuation.{u1, u2} R Γ₀ _inst_2 _inst_4 v) r) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{u2} (OrderDual.{u2} Γ₀)) => OrderDual.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀))) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) r)) (Multiplicative.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{u2} (OrderDual.{u2} Γ₀)) => OrderDual.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀))) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) r)))) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{u2} (OrderDual.{u2} Γ₀)) => OrderDual.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀))) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) r)) (fun (_x : (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{u2} (OrderDual.{u2} Γ₀)) => OrderDual.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀))) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) r)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{u2} (OrderDual.{u2} Γ₀)) => OrderDual.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀))) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) r)) => Multiplicative.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{u2} (OrderDual.{u2} Γ₀)) => OrderDual.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀))) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) r))) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{u2} (OrderDual.{u2} Γ₀)) => OrderDual.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀))) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) r)) (Multiplicative.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{u2} (OrderDual.{u2} Γ₀)) => OrderDual.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀))) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) r)))) (Multiplicative.ofAdd.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{u2} (OrderDual.{u2} Γ₀)) => OrderDual.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀))) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) r))) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (OrderDual.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)))) (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (fun (_x : Multiplicative.{u2} (OrderDual.{u2} Γ₀)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{u2} (OrderDual.{u2} Γ₀)) => OrderDual.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀))) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (OrderDual.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)))) (OrderDual.toDual.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀))) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) r)))
Case conversion may be inaccurate. Consider using '#align add_valuation.valuation_apply AddValuation.valuation_applyₓ'. -/
@[simp]
theorem valuation_apply (r : R) : v.Valuation r = Multiplicative.ofAdd (OrderDual.toDual (v r)) :=
  rfl
#align add_valuation.valuation_apply AddValuation.valuation_apply

end

/- warning: add_valuation.map_zero -> AddValuation.map_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2), Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_4))))))))) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toHasTop.{u2} Γ₀ _inst_2))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] (v : AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_4), Eq.{succ u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_2)))))) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u2} Γ₀ _inst_4))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_zero AddValuation.map_zeroₓ'. -/
@[simp]
theorem map_zero : v 0 = ⊤ :=
  v.map_zero
#align add_valuation.map_zero AddValuation.map_zero

/- warning: add_valuation.map_one -> AddValuation.map_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2), Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_4)))))))) (OfNat.ofNat.{u2} Γ₀ 0 (OfNat.mk.{u2} Γ₀ 0 (Zero.zero.{u2} Γ₀ (AddZeroClass.toHasZero.{u2} Γ₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))))))))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] (v : AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_4), Eq.{succ u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (OfNat.ofNat.{u2} Γ₀ 0 (Zero.toOfNat0.{u2} Γ₀ (AddMonoid.toZero.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_one AddValuation.map_oneₓ'. -/
@[simp]
theorem map_one : v 1 = 0 :=
  v.map_one
#align add_valuation.map_one AddValuation.map_one

/- warning: add_valuation.map_mul -> AddValuation.map_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (x : R) (y : R), Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_4))) x y)) (HAdd.hAdd.{u2, u2, u2} Γ₀ Γ₀ Γ₀ (instHAdd.{u2} Γ₀ (AddZeroClass.toHasAdd.{u2} Γ₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v y))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] (v : AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_4) (x : R) (y : R), Eq.{succ u2} Γ₀ (AddValuation.asFun.{u1, u2} R Γ₀ _inst_2 _inst_4 v (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) x y)) (HAdd.hAdd.{u2, u2, u2} Γ₀ Γ₀ Γ₀ (instHAdd.{u2} Γ₀ (AddZeroClass.toAdd.{u2} Γ₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4)))))) (AddValuation.asFun.{u1, u2} R Γ₀ _inst_2 _inst_4 v x) (AddValuation.asFun.{u1, u2} R Γ₀ _inst_2 _inst_4 v y))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_mul AddValuation.map_mulₓ'. -/
@[simp]
theorem map_mul : ∀ x y, v (x * y) = v x + v y :=
  v.map_mul
#align add_valuation.map_mul AddValuation.map_mul

/- warning: add_valuation.map_add -> AddValuation.map_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (x : R) (y : R), LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (LinearOrder.min.{u2} Γ₀ (LinearOrderedAddCommMonoid.toLinearOrder.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v y)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_4))) x y))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] (v : AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_4) (x : R) (y : R), LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) (Min.min.{u2} Γ₀ (LinearOrder.toMin.{u2} Γ₀ (LinearOrderedAddCommMonoid.toLinearOrder.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))) (AddValuation.asFun.{u1, u2} R Γ₀ _inst_2 _inst_4 v x) (AddValuation.asFun.{u1, u2} R Γ₀ _inst_2 _inst_4 v y)) (AddValuation.asFun.{u1, u2} R Γ₀ _inst_2 _inst_4 v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))))) x y))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_add AddValuation.map_addₓ'. -/
@[simp]
theorem map_add : ∀ x y, min (v x) (v y) ≤ v (x + y) :=
  v.map_add
#align add_valuation.map_add AddValuation.map_add

/- warning: add_valuation.map_le_add -> AddValuation.map_le_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) {x : R} {y : R} {g : Γ₀}, (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v x)) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v y)) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_4))) x y)))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] (v : AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_4) {x : R} {y : R} {g : Γ₀}, (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) g (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) x)) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) g (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) y)) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) g (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))))) x y)))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_le_add AddValuation.map_le_addₓ'. -/
theorem map_le_add {x y g} (hx : g ≤ v x) (hy : g ≤ v y) : g ≤ v (x + y) :=
  v.map_add_le hx hy
#align add_valuation.map_le_add AddValuation.map_le_add

/- warning: add_valuation.map_lt_add -> AddValuation.map_lt_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) {x : R} {y : R} {g : Γ₀}, (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v x)) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v y)) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_4))) x y)))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] (v : AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_4) {x : R} {y : R} {g : Γ₀}, (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) g (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) x)) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) g (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) y)) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) g (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))))) x y)))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_lt_add AddValuation.map_lt_addₓ'. -/
theorem map_lt_add {x y g} (hx : g < v x) (hy : g < v y) : g < v (x + y) :=
  v.map_add_lt hx hy
#align add_valuation.map_lt_add AddValuation.map_lt_add

/- warning: add_valuation.map_le_sum -> AddValuation.map_le_sum is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) {ι : Type.{u3}} {s : Finset.{u3} ι} {f : ι -> R} {g : Γ₀}, (forall (i : ι), (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v (f i)))) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v (Finset.sum.{u1, u3} R ι (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_4)))) s (fun (i : ι) => f i))))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] (v : AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_4) {ι : Type.{u3}} {s : Finset.{u3} ι} {f : ι -> R} {g : Γ₀}, (forall (i : ι), (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) g (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) (f i)))) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) g (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) s (fun (i : ι) => f i))))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_le_sum AddValuation.map_le_sumₓ'. -/
theorem map_le_sum {ι : Type _} {s : Finset ι} {f : ι → R} {g : Γ₀} (hf : ∀ i ∈ s, g ≤ v (f i)) :
    g ≤ v (∑ i in s, f i) :=
  v.map_sum_le hf
#align add_valuation.map_le_sum AddValuation.map_le_sum

/- warning: add_valuation.map_lt_sum -> AddValuation.map_lt_sum is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) {ι : Type.{u3}} {s : Finset.{u3} ι} {f : ι -> R} {g : Γ₀}, (Ne.{succ u2} Γ₀ g (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toHasTop.{u2} Γ₀ _inst_2))) -> (forall (i : ι), (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v (f i)))) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v (Finset.sum.{u1, u3} R ι (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_4)))) s (fun (i : ι) => f i))))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] (v : AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_4) {ι : Type.{u3}} {s : Finset.{u3} ι} {f : ι -> R} {g : Γ₀}, (Ne.{succ u2} Γ₀ g (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u2} Γ₀ _inst_4))) -> (forall (i : ι), (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) g (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) (f i)))) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) g (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) s (fun (i : ι) => f i))))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_lt_sum AddValuation.map_lt_sumₓ'. -/
theorem map_lt_sum {ι : Type _} {s : Finset ι} {f : ι → R} {g : Γ₀} (hg : g ≠ ⊤)
    (hf : ∀ i ∈ s, g < v (f i)) : g < v (∑ i in s, f i) :=
  v.map_sum_lt hg hf
#align add_valuation.map_lt_sum AddValuation.map_lt_sum

/- warning: add_valuation.map_lt_sum' -> AddValuation.map_lt_sum' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) {ι : Type.{u3}} {s : Finset.{u3} ι} {f : ι -> R} {g : Γ₀}, (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) g (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toHasTop.{u2} Γ₀ _inst_2))) -> (forall (i : ι), (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v (f i)))) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v (Finset.sum.{u1, u3} R ι (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_4)))) s (fun (i : ι) => f i))))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] (v : AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_4) {ι : Type.{u3}} {s : Finset.{u3} ι} {f : ι -> R} {g : Γ₀}, (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) g (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u2} Γ₀ _inst_4))) -> (forall (i : ι), (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) g (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) (f i)))) -> (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) g (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_4) _inst_2 v)) (Finset.sum.{u1, u3} R ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) s (fun (i : ι) => f i))))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_lt_sum' AddValuation.map_lt_sum'ₓ'. -/
theorem map_lt_sum' {ι : Type _} {s : Finset ι} {f : ι → R} {g : Γ₀} (hg : g < ⊤)
    (hf : ∀ i ∈ s, g < v (f i)) : g < v (∑ i in s, f i) :=
  v.map_sum_lt' hg hf
#align add_valuation.map_lt_sum' AddValuation.map_lt_sum'

/- warning: add_valuation.map_pow -> AddValuation.map_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (x : R) (n : Nat), Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R _inst_4))) x n)) (SMul.smul.{0, u2} Nat Γ₀ (AddMonoid.SMul.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) n (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v x))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] (v : AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_4) (x : R) (n : Nat), Eq.{succ u2} Γ₀ (AddValuation.asFun.{u1, u2} R Γ₀ _inst_2 _inst_4 v (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_2))))) x n)) (HSMul.hSMul.{0, u2, u2} Nat Γ₀ Γ₀ (instHSMul.{0, u2} Nat Γ₀ (AddMonoid.SMul.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_4))))) n (AddValuation.asFun.{u1, u2} R Γ₀ _inst_2 _inst_4 v x))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_pow AddValuation.map_powₓ'. -/
@[simp]
theorem map_pow : ∀ (x) (n : ℕ), v (x ^ n) = n • v x :=
  v.map_pow
#align add_valuation.map_pow AddValuation.map_pow

/- warning: add_valuation.ext -> AddValuation.ext is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] {v₁ : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2} {v₂ : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2}, (forall (r : R), Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v₁ r) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v₂ r)) -> (Eq.{max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) v₁ v₂)
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_2 : Ring.{u2} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u1} Γ₀] {v₁ : AddValuation.{u2, u1} R _inst_2 Γ₀ _inst_4} {v₂ : AddValuation.{u2, u1} R _inst_2 Γ₀ _inst_4}, (forall (r : R), Eq.{succ u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (ZeroHom.toFun.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (MulZeroOneClass.toZero.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))) (MulZeroOneClass.toZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_4) _inst_2 v₁)) r) (ZeroHom.toFun.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (MulZeroOneClass.toZero.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))) (MulZeroOneClass.toZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_4) _inst_2 v₂)) r)) -> (Eq.{max (succ u2) (succ u1)} (AddValuation.{u2, u1} R _inst_2 Γ₀ _inst_4) v₁ v₂)
Case conversion may be inaccurate. Consider using '#align add_valuation.ext AddValuation.extₓ'. -/
@[ext]
theorem ext {v₁ v₂ : AddValuation R Γ₀} (h : ∀ r, v₁ r = v₂ r) : v₁ = v₂ :=
  Valuation.ext h
#align add_valuation.ext AddValuation.ext

/- warning: add_valuation.ext_iff -> AddValuation.ext_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] {v₁ : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2} {v₂ : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2}, Iff (Eq.{max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) v₁ v₂) (forall (r : R), Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v₁ r) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v₂ r))
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_2 : Ring.{u2} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u1} Γ₀] {v₁ : AddValuation.{u2, u1} R _inst_2 Γ₀ _inst_4} {v₂ : AddValuation.{u2, u1} R _inst_2 Γ₀ _inst_4}, Iff (Eq.{max (succ u2) (succ u1)} (AddValuation.{u2, u1} R _inst_2 Γ₀ _inst_4) v₁ v₂) (forall (r : R), Eq.{succ u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (ZeroHom.toFun.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (MulZeroOneClass.toZero.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))) (MulZeroOneClass.toZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_4) _inst_2 v₁)) r) (ZeroHom.toFun.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (MulZeroOneClass.toZero.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))) (MulZeroOneClass.toZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_4))))) (MonoidWithZeroHom.toZeroHom.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_4)))) (Valuation.toMonoidWithZeroHom.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_4) _inst_2 v₂)) r))
Case conversion may be inaccurate. Consider using '#align add_valuation.ext_iff AddValuation.ext_iffₓ'. -/
theorem ext_iff {v₁ v₂ : AddValuation R Γ₀} : v₁ = v₂ ↔ ∀ r, v₁ r = v₂ r :=
  Valuation.ext_iff
#align add_valuation.ext_iff AddValuation.ext_iff

/- warning: add_valuation.to_preorder -> AddValuation.toPreorder is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R], (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) -> (Preorder.{u1} R)
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀], (AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_4) -> (Preorder.{u1} R)
Case conversion may be inaccurate. Consider using '#align add_valuation.to_preorder AddValuation.toPreorderₓ'. -/
-- The following definition is not an instance, because we have more than one `v` on a given `R`.
-- In addition, type class inference would not be able to infer `v`.
/-- A valuation gives a preorder on the underlying ring. -/
def toPreorder : Preorder R :=
  Preorder.lift v
#align add_valuation.to_preorder AddValuation.toPreorder

/- warning: add_valuation.top_iff -> AddValuation.top_iff is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_5 : Nontrivial.{u2} Γ₀] (v : AddValuation.{u1, u2} K (DivisionRing.toRing.{u1} K _inst_1) Γ₀ _inst_2) {x : K}, Iff (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} K (DivisionRing.toRing.{u1} K _inst_1) Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} K (DivisionRing.toRing.{u1} K _inst_1) Γ₀ _inst_2) => K -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} K Γ₀ _inst_2 (DivisionRing.toRing.{u1} K _inst_1)) v x) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toHasTop.{u2} Γ₀ _inst_2))) (Eq.{succ u1} K x (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_5 : Nontrivial.{u2} Γ₀] (v : AddValuation.{u1, u2} K (DivisionRing.toRing.{u1} K _inst_1) Γ₀ _inst_2) {x : K}, Iff (Eq.{succ u2} Γ₀ (AddValuation.asFun.{u1, u2} K Γ₀ (DivisionRing.toRing.{u1} K _inst_1) _inst_2 v x) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u2} Γ₀ _inst_2))) (Eq.{succ u1} K x (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align add_valuation.top_iff AddValuation.top_iffₓ'. -/
/-- If `v` is an additive valuation on a division ring then `v(x) = ⊤` iff `x = 0`. -/
@[simp]
theorem top_iff [Nontrivial Γ₀] (v : AddValuation K Γ₀) {x : K} : v x = ⊤ ↔ x = 0 :=
  v.zero_iff
#align add_valuation.top_iff AddValuation.top_iff

/- warning: add_valuation.ne_top_iff -> AddValuation.ne_top_iff is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_5 : Nontrivial.{u2} Γ₀] (v : AddValuation.{u1, u2} K (DivisionRing.toRing.{u1} K _inst_1) Γ₀ _inst_2) {x : K}, Iff (Ne.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} K (DivisionRing.toRing.{u1} K _inst_1) Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} K (DivisionRing.toRing.{u1} K _inst_1) Γ₀ _inst_2) => K -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} K Γ₀ _inst_2 (DivisionRing.toRing.{u1} K _inst_1)) v x) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toHasTop.{u2} Γ₀ _inst_2))) (Ne.{succ u1} K x (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_5 : Nontrivial.{u2} Γ₀] (v : AddValuation.{u1, u2} K (DivisionRing.toRing.{u1} K _inst_1) Γ₀ _inst_2) {x : K}, Iff (Ne.{succ u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (ZeroHom.toFun.{u1, u2} K (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} K (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_2))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} K (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_2)))) (Valuation.toMonoidWithZeroHom.{u1, u2} K (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_2) (DivisionRing.toRing.{u1} K _inst_1) v)) x) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u2} Γ₀ _inst_2))) (Ne.{succ u1} K x (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align add_valuation.ne_top_iff AddValuation.ne_top_iffₓ'. -/
theorem ne_top_iff [Nontrivial Γ₀] (v : AddValuation K Γ₀) {x : K} : v x ≠ ⊤ ↔ x ≠ 0 :=
  v.neZero_iff
#align add_valuation.ne_top_iff AddValuation.ne_top_iff

/- warning: add_valuation.comap -> AddValuation.comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] {S : Type.{u3}} [_inst_5 : Ring.{u3} S], (RingHom.{u3, u1} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_5)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_4))) -> (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) -> (AddValuation.{u3, u2} S _inst_5 Γ₀ _inst_2)
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : Ring.{u1} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] {S : Type.{u3}} [_inst_5 : Ring.{u3} S], (RingHom.{u3, u1} S R (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S _inst_5)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) -> (AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_4) -> (AddValuation.{u3, u2} S _inst_5 Γ₀ _inst_4)
Case conversion may be inaccurate. Consider using '#align add_valuation.comap AddValuation.comapₓ'. -/
/-- A ring homomorphism `S → R` induces a map `add_valuation R Γ₀ → add_valuation S Γ₀`. -/
def comap {S : Type _} [Ring S] (f : S →+* R) (v : AddValuation R Γ₀) : AddValuation S Γ₀ :=
  v.comap f
#align add_valuation.comap AddValuation.comap

/- warning: add_valuation.comap_id -> AddValuation.comap_id is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2), Eq.{max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (AddValuation.comap.{u1, u2, u1} R Γ₀ _inst_2 _inst_4 R _inst_4 (RingHom.id.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_4))) v) v
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_2 : Ring.{u2} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u1} Γ₀] (v : AddValuation.{u2, u1} R _inst_2 Γ₀ _inst_4), Eq.{max (succ u2) (succ u1)} (AddValuation.{u2, u1} R _inst_2 Γ₀ _inst_4) (AddValuation.comap.{u2, u1, u2} R Γ₀ _inst_2 _inst_4 R _inst_2 (RingHom.id.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) v) v
Case conversion may be inaccurate. Consider using '#align add_valuation.comap_id AddValuation.comap_idₓ'. -/
@[simp]
theorem comap_id : v.comap (RingHom.id R) = v :=
  v.comap_id
#align add_valuation.comap_id AddValuation.comap_id

/- warning: add_valuation.comap_comp -> AddValuation.comap_comp is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) {S₁ : Type.{u3}} {S₂ : Type.{u4}} [_inst_5 : Ring.{u3} S₁] [_inst_6 : Ring.{u4} S₂] (f : RingHom.{u3, u4} S₁ S₂ (NonAssocRing.toNonAssocSemiring.{u3} S₁ (Ring.toNonAssocRing.{u3} S₁ _inst_5)) (NonAssocRing.toNonAssocSemiring.{u4} S₂ (Ring.toNonAssocRing.{u4} S₂ _inst_6))) (g : RingHom.{u4, u1} S₂ R (NonAssocRing.toNonAssocSemiring.{u4} S₂ (Ring.toNonAssocRing.{u4} S₂ _inst_6)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_4))), Eq.{max (succ u3) (succ u2)} (AddValuation.{u3, u2} S₁ _inst_5 Γ₀ _inst_2) (AddValuation.comap.{u1, u2, u3} R Γ₀ _inst_2 _inst_4 S₁ _inst_5 (RingHom.comp.{u3, u4, u1} S₁ S₂ R (NonAssocRing.toNonAssocSemiring.{u3} S₁ (Ring.toNonAssocRing.{u3} S₁ _inst_5)) (NonAssocRing.toNonAssocSemiring.{u4} S₂ (Ring.toNonAssocRing.{u4} S₂ _inst_6)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_4)) g f) v) (AddValuation.comap.{u4, u2, u3} S₂ Γ₀ _inst_2 _inst_6 S₁ _inst_5 f (AddValuation.comap.{u1, u2, u4} R Γ₀ _inst_2 _inst_4 S₂ _inst_6 g v))
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_2 : Ring.{u2} R] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u1} Γ₀] (v : AddValuation.{u2, u1} R _inst_2 Γ₀ _inst_4) {S₁ : Type.{u4}} {S₂ : Type.{u3}} [_inst_5 : Ring.{u4} S₁] [_inst_6 : Ring.{u3} S₂] (f : RingHom.{u4, u3} S₁ S₂ (NonAssocRing.toNonAssocSemiring.{u4} S₁ (Ring.toNonAssocRing.{u4} S₁ _inst_5)) (NonAssocRing.toNonAssocSemiring.{u3} S₂ (Ring.toNonAssocRing.{u3} S₂ _inst_6))) (g : RingHom.{u3, u2} S₂ R (NonAssocRing.toNonAssocSemiring.{u3} S₂ (Ring.toNonAssocRing.{u3} S₂ _inst_6)) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))), Eq.{max (succ u1) (succ u4)} (AddValuation.{u4, u1} S₁ _inst_5 Γ₀ _inst_4) (AddValuation.comap.{u2, u1, u4} R Γ₀ _inst_2 _inst_4 S₁ _inst_5 (RingHom.comp.{u4, u3, u2} S₁ S₂ R (NonAssocRing.toNonAssocSemiring.{u4} S₁ (Ring.toNonAssocRing.{u4} S₁ _inst_5)) (NonAssocRing.toNonAssocSemiring.{u3} S₂ (Ring.toNonAssocRing.{u3} S₂ _inst_6)) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)) g f) v) (AddValuation.comap.{u3, u1, u4} S₂ Γ₀ _inst_6 _inst_4 S₁ _inst_5 f (AddValuation.comap.{u2, u1, u3} R Γ₀ _inst_2 _inst_4 S₂ _inst_6 g v))
Case conversion may be inaccurate. Consider using '#align add_valuation.comap_comp AddValuation.comap_compₓ'. -/
theorem comap_comp {S₁ : Type _} {S₂ : Type _} [Ring S₁] [Ring S₂] (f : S₁ →+* S₂) (g : S₂ →+* R) :
    v.comap (g.comp f) = (v.comap g).comap f :=
  v.comap_comp f g
#align add_valuation.comap_comp AddValuation.comap_comp

/- warning: add_valuation.map -> AddValuation.map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_3 : LinearOrderedAddCommMonoidWithTop.{u3} Γ'₀] [_inst_4 : Ring.{u1} R] (f : AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))), (Eq.{succ u3} Γ'₀ (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))) (fun (_x : AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))) => Γ₀ -> Γ'₀) (AddMonoidHom.hasCoeToFun.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))) f (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toHasTop.{u2} Γ₀ _inst_2))) (Top.top.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toHasTop.{u3} Γ'₀ _inst_3))) -> (Monotone.{u2, u3} Γ₀ Γ'₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (PartialOrder.toPreorder.{u3} Γ'₀ (OrderedAddCommMonoid.toPartialOrder.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))) (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))) (fun (_x : AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))) => Γ₀ -> Γ'₀) (AddMonoidHom.hasCoeToFun.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))) f)) -> (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) -> (AddValuation.{u1, u3} R _inst_4 Γ'₀ _inst_3)
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_2 : Ring.{u1} R] [_inst_3 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u3} Γ'₀] (f : AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_3)))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_4))))), (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Γ₀) => Γ'₀) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u2} Γ₀ _inst_3))) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_3)))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_4))))) Γ₀ (fun (_x : Γ₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Γ₀) => Γ'₀) _x) (AddHomClass.toFunLike.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_3)))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_4))))) Γ₀ Γ'₀ (AddZeroClass.toAdd.{u2} Γ₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_3))))) (AddZeroClass.toAdd.{u3} Γ'₀ (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_4))))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_3)))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_4))))) Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_3)))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_4)))) (AddMonoidHom.addMonoidHomClass.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_3)))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_4))))))) f (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u2} Γ₀ _inst_3))) (Top.top.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Γ₀) => Γ'₀) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u2} Γ₀ _inst_3))) (LinearOrderedAddCommMonoidWithTop.toTop.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Γ₀) => Γ'₀) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u2} Γ₀ _inst_3))) _inst_4))) -> (Monotone.{u2, u3} Γ₀ Γ'₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_3)))) (PartialOrder.toPreorder.{u3} Γ'₀ (OrderedAddCommMonoid.toPartialOrder.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_4)))) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_3)))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_4))))) Γ₀ (fun (_x : Γ₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Γ₀) => Γ'₀) _x) (AddHomClass.toFunLike.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_3)))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_4))))) Γ₀ Γ'₀ (AddZeroClass.toAdd.{u2} Γ₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_3))))) (AddZeroClass.toAdd.{u3} Γ'₀ (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_4))))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_3)))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_4))))) Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_3)))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_4)))) (AddMonoidHom.addMonoidHomClass.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_3)))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_4))))))) f)) -> (AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_3) -> (AddValuation.{u1, u3} R _inst_2 Γ'₀ _inst_4)
Case conversion may be inaccurate. Consider using '#align add_valuation.map AddValuation.mapₓ'. -/
/-- A `≤`-preserving, `⊤`-preserving group homomorphism `Γ₀ → Γ'₀` induces a map
  `add_valuation R Γ₀ → add_valuation R Γ'₀`.
-/
def map (f : Γ₀ →+ Γ'₀) (ht : f ⊤ = ⊤) (hf : Monotone f) (v : AddValuation R Γ₀) :
    AddValuation R Γ'₀ :=
  v.map
    { toFun := f
      map_mul' := f.map_add
      map_one' := f.map_zero
      map_zero' := ht } fun x y h => hf h
#align add_valuation.map AddValuation.map

/- warning: add_valuation.is_equiv -> AddValuation.IsEquiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_3 : LinearOrderedAddCommMonoidWithTop.{u3} Γ'₀] [_inst_4 : Ring.{u1} R], (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) -> (AddValuation.{u1, u3} R _inst_4 Γ'₀ _inst_3) -> Prop
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_2 : Ring.{u1} R] [_inst_3 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : LinearOrderedAddCommMonoidWithTop.{u3} Γ'₀], (AddValuation.{u1, u2} R _inst_2 Γ₀ _inst_3) -> (AddValuation.{u1, u3} R _inst_2 Γ'₀ _inst_4) -> Prop
Case conversion may be inaccurate. Consider using '#align add_valuation.is_equiv AddValuation.IsEquivₓ'. -/
/-- Two additive valuations on `R` are defined to be equivalent if they induce the same
  preorder on `R`. -/
def IsEquiv (v₁ : AddValuation R Γ₀) (v₂ : AddValuation R Γ'₀) : Prop :=
  v₁.IsEquiv v₂
#align add_valuation.is_equiv AddValuation.IsEquiv

end Monoid

section Group

variable [LinearOrderedAddCommGroupWithTop Γ₀] [Ring R] (v : AddValuation R Γ₀) {x y z : R}

/- warning: add_valuation.map_inv -> AddValuation.map_inv is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommGroupWithTop.{u2} Γ₀] (v : AddValuation.{u1, u2} K (DivisionRing.toRing.{u1} K _inst_1) Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) {x : K}, Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} K (DivisionRing.toRing.{u1} K _inst_1) Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} K (DivisionRing.toRing.{u1} K _inst_1) Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => K -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} K Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) (DivisionRing.toRing.{u1} K _inst_1)) v (Inv.inv.{u1} K (DivInvMonoid.toHasInv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1)) x)) (Neg.neg.{u2} Γ₀ (SubNegMonoid.toHasNeg.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toSubNegMonoid.{u2} Γ₀ _inst_2)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} K (DivisionRing.toRing.{u1} K _inst_1) Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} K (DivisionRing.toRing.{u1} K _inst_1) Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => K -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} K Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) (DivisionRing.toRing.{u1} K _inst_1)) v x))
but is expected to have type
  forall {K : Type.{u2}} [_inst_1 : DivisionRing.{u2} K] {Γ₀ : Type.{u1}} [_inst_2 : LinearOrderedAddCommGroupWithTop.{u1} Γ₀] (v : AddValuation.{u2, u1} K (DivisionRing.toRing.{u2} K _inst_1) Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u1} Γ₀ _inst_2)) {x : K}, Eq.{succ u1} Γ₀ (AddValuation.asFun.{u2, u1} K Γ₀ (DivisionRing.toRing.{u2} K _inst_1) (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u1} Γ₀ _inst_2) v (Inv.inv.{u2} K (DivisionRing.toInv.{u2} K _inst_1) x)) (Neg.neg.{u1} Γ₀ (LinearOrderedAddCommGroupWithTop.toNeg.{u1} Γ₀ _inst_2) (AddValuation.asFun.{u2, u1} K Γ₀ (DivisionRing.toRing.{u2} K _inst_1) (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u1} Γ₀ _inst_2) v x))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_inv AddValuation.map_invₓ'. -/
@[simp]
theorem map_inv (v : AddValuation K Γ₀) {x : K} : v x⁻¹ = -v x :=
  map_inv₀ v.Valuation x
#align add_valuation.map_inv AddValuation.map_inv

/- warning: add_valuation.map_neg -> AddValuation.map_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommGroupWithTop.{u2} Γ₀] [_inst_3 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (x : R), Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3))))) x)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v x)
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommGroupWithTop.{u2} Γ₀] [_inst_3 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (x : R), Eq.{succ u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) (Neg.neg.{u1} R (Ring.toNeg.{u1} R _inst_3) x)) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) x)
Case conversion may be inaccurate. Consider using '#align add_valuation.map_neg AddValuation.map_negₓ'. -/
@[simp]
theorem map_neg (x : R) : v (-x) = v x :=
  v.map_neg x
#align add_valuation.map_neg AddValuation.map_neg

/- warning: add_valuation.map_sub_swap -> AddValuation.map_sub_swap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommGroupWithTop.{u2} Γ₀] [_inst_3 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (x : R) (y : R), Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) x y)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) y x))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommGroupWithTop.{u2} Γ₀] [_inst_3 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (x : R) (y : R), Eq.{succ u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) y x))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_sub_swap AddValuation.map_sub_swapₓ'. -/
theorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=
  v.map_sub_swap x y
#align add_valuation.map_sub_swap AddValuation.map_sub_swap

/- warning: add_valuation.map_sub -> AddValuation.map_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommGroupWithTop.{u2} Γ₀] [_inst_3 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (x : R) (y : R), LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (LinearOrder.min.{u2} Γ₀ (LinearOrderedAddCommMonoid.toLinearOrder.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v y)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) x y))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommGroupWithTop.{u2} Γ₀] [_inst_3 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (x : R) (y : R), LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (Min.min.{u2} Γ₀ (LinearOrder.toMin.{u2} Γ₀ (LinearOrderedAddCommMonoid.toLinearOrder.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))) (AddValuation.asFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) v x) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) y)) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_sub AddValuation.map_subₓ'. -/
theorem map_sub (x y : R) : min (v x) (v y) ≤ v (x - y) :=
  v.map_sub x y
#align add_valuation.map_sub AddValuation.map_sub

/- warning: add_valuation.map_le_sub -> AddValuation.map_le_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommGroupWithTop.{u2} Γ₀] [_inst_3 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) {x : R} {y : R} {g : Γ₀}, (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v x)) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v y)) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) x y)))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommGroupWithTop.{u2} Γ₀] [_inst_3 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) {x : R} {y : R} {g : Γ₀}, (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) g (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) x)) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) g (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) y)) -> (LE.le.{u2} Γ₀ (Preorder.toLE.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) g (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) x y)))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_le_sub AddValuation.map_le_subₓ'. -/
theorem map_le_sub {x y g} (hx : g ≤ v x) (hy : g ≤ v y) : g ≤ v (x - y) :=
  v.map_sub_le hx hy
#align add_valuation.map_le_sub AddValuation.map_le_sub

/- warning: add_valuation.map_add_of_distinct_val -> AddValuation.map_add_of_distinct_val is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommGroupWithTop.{u2} Γ₀] [_inst_3 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) {x : R} {y : R}, (Ne.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v y)) -> (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_3))) x y)) (LinearOrder.min.{u2} Γ₀ (LinearOrderedAddCommMonoid.toLinearOrder.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v y)))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommGroupWithTop.{u2} Γ₀] [_inst_3 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) {x : R} {y : R}, (Ne.{succ u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) x) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) y)) -> (Eq.{succ u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))))) x y)) (Min.min.{u2} Γ₀ (LinearOrder.toMin.{u2} Γ₀ (LinearOrderedAddCommMonoid.toLinearOrder.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) x) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) y)))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_add_of_distinct_val AddValuation.map_add_of_distinct_valₓ'. -/
theorem map_add_of_distinct_val (h : v x ≠ v y) : v (x + y) = min (v x) (v y) :=
  v.map_add_of_distinct_val h
#align add_valuation.map_add_of_distinct_val AddValuation.map_add_of_distinct_val

/- warning: add_valuation.map_eq_of_lt_sub -> AddValuation.map_eq_of_lt_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommGroupWithTop.{u2} Γ₀] [_inst_3 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) {x : R} {y : R}, (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) y x))) -> (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v y) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) (fun (_x : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) _inst_3) v x))
but is expected to have type
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommGroupWithTop.{u2} Γ₀] [_inst_3 : Ring.{u1} R] (v : AddValuation.{u1, u2} R _inst_3 Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) {x : R} {y : R}, (LT.lt.{u2} Γ₀ (Preorder.toLT.{u2} Γ₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (AddValuation.asFun.{u1, u2} R Γ₀ _inst_3 (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2) v x) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_3)) y x))) -> (Eq.{succ u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) y) (ZeroHom.toFun.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)))))) (MonoidWithZeroHom.toZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2))))) (Valuation.toMonoidWithZeroHom.{u1, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ (LinearOrderedAddCommGroupWithTop.toLinearOrderedAddCommMonoidWithTop.{u2} Γ₀ _inst_2)) _inst_3 v)) x))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_eq_of_lt_sub AddValuation.map_eq_of_lt_subₓ'. -/
theorem map_eq_of_lt_sub (h : v x < v (y - x)) : v y = v x :=
  v.map_eq_of_sub_lt h
#align add_valuation.map_eq_of_lt_sub AddValuation.map_eq_of_lt_sub

end Group

end Basic

namespace IsEquiv

variable [LinearOrderedAddCommMonoidWithTop Γ₀] [LinearOrderedAddCommMonoidWithTop Γ'₀]

variable [Ring R]

variable {Γ''₀ : Type _} [LinearOrderedAddCommMonoidWithTop Γ''₀]

variable {v : AddValuation R Γ₀}

variable {v₁ : AddValuation R Γ₀} {v₂ : AddValuation R Γ'₀} {v₃ : AddValuation R Γ''₀}

/- warning: add_valuation.is_equiv.refl -> AddValuation.IsEquiv.refl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] {v : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2}, AddValuation.IsEquiv.{u1, u2, u2} R Γ₀ Γ₀ _inst_2 _inst_2 _inst_4 v v
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u1} Γ₀] [_inst_4 : Ring.{u2} R] {v : AddValuation.{u2, u1} R _inst_4 Γ₀ _inst_2}, AddValuation.IsEquiv.{u2, u1, u1} R Γ₀ Γ₀ _inst_4 _inst_2 _inst_2 v v
Case conversion may be inaccurate. Consider using '#align add_valuation.is_equiv.refl AddValuation.IsEquiv.reflₓ'. -/
@[refl]
theorem refl : v.IsEquiv v :=
  Valuation.IsEquiv.refl
#align add_valuation.is_equiv.refl AddValuation.IsEquiv.refl

/- warning: add_valuation.is_equiv.symm -> AddValuation.IsEquiv.symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_3 : LinearOrderedAddCommMonoidWithTop.{u3} Γ'₀] [_inst_4 : Ring.{u1} R] {v₁ : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2} {v₂ : AddValuation.{u1, u3} R _inst_4 Γ'₀ _inst_3}, (AddValuation.IsEquiv.{u1, u2, u3} R Γ₀ Γ'₀ _inst_2 _inst_3 _inst_4 v₁ v₂) -> (AddValuation.IsEquiv.{u1, u3, u2} R Γ'₀ Γ₀ _inst_3 _inst_2 _inst_4 v₂ v₁)
but is expected to have type
  forall {R : Type.{u3}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u1}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_3 : LinearOrderedAddCommMonoidWithTop.{u1} Γ'₀] [_inst_4 : Ring.{u3} R] {v₁ : AddValuation.{u3, u2} R _inst_4 Γ₀ _inst_2} {v₂ : AddValuation.{u3, u1} R _inst_4 Γ'₀ _inst_3}, (AddValuation.IsEquiv.{u3, u2, u1} R Γ₀ Γ'₀ _inst_4 _inst_2 _inst_3 v₁ v₂) -> (AddValuation.IsEquiv.{u3, u1, u2} R Γ'₀ Γ₀ _inst_4 _inst_3 _inst_2 v₂ v₁)
Case conversion may be inaccurate. Consider using '#align add_valuation.is_equiv.symm AddValuation.IsEquiv.symmₓ'. -/
@[symm]
theorem symm (h : v₁.IsEquiv v₂) : v₂.IsEquiv v₁ :=
  h.symm
#align add_valuation.is_equiv.symm AddValuation.IsEquiv.symm

/- warning: add_valuation.is_equiv.trans -> AddValuation.IsEquiv.trans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_3 : LinearOrderedAddCommMonoidWithTop.{u3} Γ'₀] [_inst_4 : Ring.{u1} R] {Γ''₀ : Type.{u4}} [_inst_5 : LinearOrderedAddCommMonoidWithTop.{u4} Γ''₀] {v₁ : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2} {v₂ : AddValuation.{u1, u3} R _inst_4 Γ'₀ _inst_3} {v₃ : AddValuation.{u1, u4} R _inst_4 Γ''₀ _inst_5}, (AddValuation.IsEquiv.{u1, u2, u3} R Γ₀ Γ'₀ _inst_2 _inst_3 _inst_4 v₁ v₂) -> (AddValuation.IsEquiv.{u1, u3, u4} R Γ'₀ Γ''₀ _inst_3 _inst_5 _inst_4 v₂ v₃) -> (AddValuation.IsEquiv.{u1, u2, u4} R Γ₀ Γ''₀ _inst_2 _inst_5 _inst_4 v₁ v₃)
but is expected to have type
  forall {R : Type.{u4}} {Γ₀ : Type.{u3}} {Γ'₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u3} Γ₀] [_inst_3 : LinearOrderedAddCommMonoidWithTop.{u2} Γ'₀] [_inst_4 : Ring.{u4} R] {Γ''₀ : Type.{u1}} [_inst_5 : LinearOrderedAddCommMonoidWithTop.{u1} Γ''₀] {v₁ : AddValuation.{u4, u3} R _inst_4 Γ₀ _inst_2} {v₂ : AddValuation.{u4, u2} R _inst_4 Γ'₀ _inst_3} {v₃ : AddValuation.{u4, u1} R _inst_4 Γ''₀ _inst_5}, (AddValuation.IsEquiv.{u4, u3, u2} R Γ₀ Γ'₀ _inst_4 _inst_2 _inst_3 v₁ v₂) -> (AddValuation.IsEquiv.{u4, u2, u1} R Γ'₀ Γ''₀ _inst_4 _inst_3 _inst_5 v₂ v₃) -> (AddValuation.IsEquiv.{u4, u3, u1} R Γ₀ Γ''₀ _inst_4 _inst_2 _inst_5 v₁ v₃)
Case conversion may be inaccurate. Consider using '#align add_valuation.is_equiv.trans AddValuation.IsEquiv.transₓ'. -/
@[trans]
theorem trans (h₁₂ : v₁.IsEquiv v₂) (h₂₃ : v₂.IsEquiv v₃) : v₁.IsEquiv v₃ :=
  h₁₂.trans h₂₃
#align add_valuation.is_equiv.trans AddValuation.IsEquiv.trans

/- warning: add_valuation.is_equiv.of_eq -> AddValuation.IsEquiv.of_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : Ring.{u1} R] {v : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2} {v' : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2}, (Eq.{max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) v v') -> (AddValuation.IsEquiv.{u1, u2, u2} R Γ₀ Γ₀ _inst_2 _inst_2 _inst_4 v v')
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u1} Γ₀] [_inst_4 : Ring.{u2} R] {v : AddValuation.{u2, u1} R _inst_4 Γ₀ _inst_2} {v' : AddValuation.{u2, u1} R _inst_4 Γ₀ _inst_2}, (Eq.{max (succ u2) (succ u1)} (AddValuation.{u2, u1} R _inst_4 Γ₀ _inst_2) v v') -> (AddValuation.IsEquiv.{u2, u1, u1} R Γ₀ Γ₀ _inst_4 _inst_2 _inst_2 v v')
Case conversion may be inaccurate. Consider using '#align add_valuation.is_equiv.of_eq AddValuation.IsEquiv.of_eqₓ'. -/
theorem of_eq {v' : AddValuation R Γ₀} (h : v = v') : v.IsEquiv v' :=
  Valuation.IsEquiv.of_eq h
#align add_valuation.is_equiv.of_eq AddValuation.IsEquiv.of_eq

/- warning: add_valuation.is_equiv.map -> AddValuation.IsEquiv.map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_3 : LinearOrderedAddCommMonoidWithTop.{u3} Γ'₀] [_inst_4 : Ring.{u1} R] {v : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2} {v' : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2} (f : AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))) (ht : Eq.{succ u3} Γ'₀ (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))) (fun (_x : AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))) => Γ₀ -> Γ'₀) (AddMonoidHom.hasCoeToFun.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))) f (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toHasTop.{u2} Γ₀ _inst_2))) (Top.top.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toHasTop.{u3} Γ'₀ _inst_3))) (hf : Monotone.{u2, u3} Γ₀ Γ'₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (PartialOrder.toPreorder.{u3} Γ'₀ (OrderedAddCommMonoid.toPartialOrder.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))) (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))) (fun (_x : AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))) => Γ₀ -> Γ'₀) (AddMonoidHom.hasCoeToFun.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))) f)), (Function.Injective.{succ u2, succ u3} Γ₀ Γ'₀ (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))) (fun (_x : AddMonoidHom.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))) => Γ₀ -> Γ'₀) (AddMonoidHom.hasCoeToFun.{u2, u3} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (OrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddMonoid.toAddZeroClass.{u3} Γ'₀ (AddCommMonoid.toAddMonoid.{u3} Γ'₀ (OrderedAddCommMonoid.toAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u3} Γ'₀ _inst_3)))))) f)) -> (AddValuation.IsEquiv.{u1, u2, u2} R Γ₀ Γ₀ _inst_2 _inst_2 _inst_4 v v') -> (AddValuation.IsEquiv.{u1, u3, u3} R Γ'₀ Γ'₀ _inst_3 _inst_3 _inst_4 (AddValuation.map.{u1, u2, u3} R Γ₀ Γ'₀ _inst_2 _inst_3 _inst_4 f ht hf v) (AddValuation.map.{u1, u2, u3} R Γ₀ Γ'₀ _inst_2 _inst_3 _inst_4 f ht hf v'))
but is expected to have type
  forall {R : Type.{u3}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u1}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_3 : LinearOrderedAddCommMonoidWithTop.{u1} Γ'₀] [_inst_4 : Ring.{u3} R] {v : AddValuation.{u3, u2} R _inst_4 Γ₀ _inst_2} {v' : AddValuation.{u3, u2} R _inst_4 Γ₀ _inst_2} (f : AddMonoidHom.{u2, u1} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3))))) (ht : Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Γ₀) => Γ'₀) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u2} Γ₀ _inst_2))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3))))) Γ₀ (fun (_x : Γ₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Γ₀) => Γ'₀) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3))))) Γ₀ Γ'₀ (AddZeroClass.toAdd.{u2} Γ₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddZeroClass.toAdd.{u1} Γ'₀ (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3))))) Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3)))) (AddMonoidHom.addMonoidHomClass.{u2, u1} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3))))))) f (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u2} Γ₀ _inst_2))) (Top.top.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Γ₀) => Γ'₀) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u2} Γ₀ _inst_2))) (LinearOrderedAddCommMonoidWithTop.toTop.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Γ₀) => Γ'₀) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u2} Γ₀ _inst_2))) _inst_3))) (hf : Monotone.{u2, u1} Γ₀ Γ'₀ (PartialOrder.toPreorder.{u2} Γ₀ (OrderedAddCommMonoid.toPartialOrder.{u2} Γ₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (PartialOrder.toPreorder.{u1} Γ'₀ (OrderedAddCommMonoid.toPartialOrder.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3))))) Γ₀ (fun (_x : Γ₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Γ₀) => Γ'₀) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3))))) Γ₀ Γ'₀ (AddZeroClass.toAdd.{u2} Γ₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddZeroClass.toAdd.{u1} Γ'₀ (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3))))) Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3)))) (AddMonoidHom.addMonoidHomClass.{u2, u1} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3))))))) f)), (Function.Injective.{succ u2, succ u1} Γ₀ Γ'₀ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3))))) Γ₀ (fun (_x : Γ₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Γ₀) => Γ'₀) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3))))) Γ₀ Γ'₀ (AddZeroClass.toAdd.{u2} Γ₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2))))) (AddZeroClass.toAdd.{u1} Γ'₀ (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3))))) Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3)))) (AddMonoidHom.addMonoidHomClass.{u2, u1} Γ₀ Γ'₀ (AddMonoid.toAddZeroClass.{u2} Γ₀ (AddCommMonoid.toAddMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u2} Γ₀ _inst_2)))) (AddMonoid.toAddZeroClass.{u1} Γ'₀ (AddCommMonoid.toAddMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{u1} Γ'₀ _inst_3))))))) f)) -> (AddValuation.IsEquiv.{u3, u2, u2} R Γ₀ Γ₀ _inst_4 _inst_2 _inst_2 v v') -> (AddValuation.IsEquiv.{u3, u1, u1} R Γ'₀ Γ'₀ _inst_4 _inst_3 _inst_3 (AddValuation.map.{u3, u2, u1} R Γ₀ Γ'₀ _inst_4 _inst_2 _inst_3 f ht hf v) (AddValuation.map.{u3, u2, u1} R Γ₀ Γ'₀ _inst_4 _inst_2 _inst_3 f ht hf v'))
Case conversion may be inaccurate. Consider using '#align add_valuation.is_equiv.map AddValuation.IsEquiv.mapₓ'. -/
theorem map {v' : AddValuation R Γ₀} (f : Γ₀ →+ Γ'₀) (ht : f ⊤ = ⊤) (hf : Monotone f)
    (inf : Injective f) (h : v.IsEquiv v') : (v.map f ht hf).IsEquiv (v'.map f ht hf) :=
  h.map
    { toFun := f
      map_mul' := f.map_add
      map_one' := f.map_zero
      map_zero' := ht } (fun x y h => hf h) inf
#align add_valuation.is_equiv.map AddValuation.IsEquiv.map

/- warning: add_valuation.is_equiv.comap -> AddValuation.IsEquiv.comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_3 : LinearOrderedAddCommMonoidWithTop.{u3} Γ'₀] [_inst_4 : Ring.{u1} R] {v₁ : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2} {v₂ : AddValuation.{u1, u3} R _inst_4 Γ'₀ _inst_3} {S : Type.{u4}} [_inst_6 : Ring.{u4} S] (f : RingHom.{u4, u1} S R (NonAssocRing.toNonAssocSemiring.{u4} S (Ring.toNonAssocRing.{u4} S _inst_6)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_4))), (AddValuation.IsEquiv.{u1, u2, u3} R Γ₀ Γ'₀ _inst_2 _inst_3 _inst_4 v₁ v₂) -> (AddValuation.IsEquiv.{u4, u2, u3} S Γ₀ Γ'₀ _inst_2 _inst_3 _inst_6 (AddValuation.comap.{u1, u2, u4} R Γ₀ _inst_2 _inst_4 S _inst_6 f v₁) (AddValuation.comap.{u1, u3, u4} R Γ'₀ _inst_3 _inst_4 S _inst_6 f v₂))
but is expected to have type
  forall {R : Type.{u3}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u1}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_3 : LinearOrderedAddCommMonoidWithTop.{u1} Γ'₀] [_inst_4 : Ring.{u3} R] {v₁ : AddValuation.{u3, u2} R _inst_4 Γ₀ _inst_2} {v₂ : AddValuation.{u3, u1} R _inst_4 Γ'₀ _inst_3} {S : Type.{u4}} [_inst_6 : Ring.{u4} S] (f : RingHom.{u4, u3} S R (NonAssocRing.toNonAssocSemiring.{u4} S (Ring.toNonAssocRing.{u4} S _inst_6)) (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_4))), (AddValuation.IsEquiv.{u3, u2, u1} R Γ₀ Γ'₀ _inst_4 _inst_2 _inst_3 v₁ v₂) -> (AddValuation.IsEquiv.{u4, u2, u1} S Γ₀ Γ'₀ _inst_6 _inst_2 _inst_3 (AddValuation.comap.{u3, u2, u4} R Γ₀ _inst_4 _inst_2 S _inst_6 f v₁) (AddValuation.comap.{u3, u1, u4} R Γ'₀ _inst_4 _inst_3 S _inst_6 f v₂))
Case conversion may be inaccurate. Consider using '#align add_valuation.is_equiv.comap AddValuation.IsEquiv.comapₓ'. -/
/-- `comap` preserves equivalence. -/
theorem comap {S : Type _} [Ring S] (f : S →+* R) (h : v₁.IsEquiv v₂) :
    (v₁.comap f).IsEquiv (v₂.comap f) :=
  h.comap f
#align add_valuation.is_equiv.comap AddValuation.IsEquiv.comap

/- warning: add_valuation.is_equiv.val_eq -> AddValuation.IsEquiv.val_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_3 : LinearOrderedAddCommMonoidWithTop.{u3} Γ'₀] [_inst_4 : Ring.{u1} R] {v₁ : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2} {v₂ : AddValuation.{u1, u3} R _inst_4 Γ'₀ _inst_3}, (AddValuation.IsEquiv.{u1, u2, u3} R Γ₀ Γ'₀ _inst_2 _inst_3 _inst_4 v₁ v₂) -> (forall {r : R} {s : R}, Iff (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v₁ r) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v₁ s)) (Eq.{succ u3} Γ'₀ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (AddValuation.{u1, u3} R _inst_4 Γ'₀ _inst_3) (fun (_x : AddValuation.{u1, u3} R _inst_4 Γ'₀ _inst_3) => R -> Γ'₀) (AddValuation.hasCoeToFun.{u1, u3} R Γ'₀ _inst_3 _inst_4) v₂ r) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (AddValuation.{u1, u3} R _inst_4 Γ'₀ _inst_3) (fun (_x : AddValuation.{u1, u3} R _inst_4 Γ'₀ _inst_3) => R -> Γ'₀) (AddValuation.hasCoeToFun.{u1, u3} R Γ'₀ _inst_3 _inst_4) v₂ s)))
but is expected to have type
  forall {R : Type.{u3}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u1}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_3 : LinearOrderedAddCommMonoidWithTop.{u1} Γ'₀] [_inst_4 : Ring.{u3} R] {v₁ : AddValuation.{u3, u2} R _inst_4 Γ₀ _inst_2} {v₂ : AddValuation.{u3, u1} R _inst_4 Γ'₀ _inst_3}, (AddValuation.IsEquiv.{u3, u2, u1} R Γ₀ Γ'₀ _inst_4 _inst_2 _inst_3 v₁ v₂) -> (forall {r : R} {s : R}, Iff (Eq.{succ u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (ZeroHom.toFun.{u3, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_4)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_2))))) (MonoidWithZeroHom.toZeroHom.{u3, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_2)))) (Valuation.toMonoidWithZeroHom.{u3, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_2) _inst_4 v₁)) r) (ZeroHom.toFun.{u3, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_4)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_2))))) (MonoidWithZeroHom.toZeroHom.{u3, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_2)))) (Valuation.toMonoidWithZeroHom.{u3, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_2) _inst_4 v₁)) s)) (Eq.{succ u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (ZeroHom.toFun.{u3, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (MulZeroOneClass.toZero.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_4)))) (MulZeroOneClass.toZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ'₀ _inst_3))))) (MonoidWithZeroHom.toZeroHom.{u3, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ'₀ _inst_3)))) (Valuation.toMonoidWithZeroHom.{u3, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ'₀ _inst_3) _inst_4 v₂)) r) (ZeroHom.toFun.{u3, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (MulZeroOneClass.toZero.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_4)))) (MulZeroOneClass.toZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ'₀ _inst_3))))) (MonoidWithZeroHom.toZeroHom.{u3, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ'₀ _inst_3)))) (Valuation.toMonoidWithZeroHom.{u3, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ'₀ _inst_3) _inst_4 v₂)) s)))
Case conversion may be inaccurate. Consider using '#align add_valuation.is_equiv.val_eq AddValuation.IsEquiv.val_eqₓ'. -/
theorem val_eq (h : v₁.IsEquiv v₂) {r s : R} : v₁ r = v₁ s ↔ v₂ r = v₂ s :=
  h.val_eq
#align add_valuation.is_equiv.val_eq AddValuation.IsEquiv.val_eq

/- warning: add_valuation.is_equiv.ne_top -> AddValuation.IsEquiv.ne_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u3}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_3 : LinearOrderedAddCommMonoidWithTop.{u3} Γ'₀] [_inst_4 : Ring.{u1} R] {v₁ : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2} {v₂ : AddValuation.{u1, u3} R _inst_4 Γ'₀ _inst_3}, (AddValuation.IsEquiv.{u1, u2, u3} R Γ₀ Γ'₀ _inst_2 _inst_3 _inst_4 v₁ v₂) -> (forall {r : R}, Iff (Ne.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R _inst_4 Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 _inst_4) v₁ r) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toHasTop.{u2} Γ₀ _inst_2))) (Ne.{succ u3} Γ'₀ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (AddValuation.{u1, u3} R _inst_4 Γ'₀ _inst_3) (fun (_x : AddValuation.{u1, u3} R _inst_4 Γ'₀ _inst_3) => R -> Γ'₀) (AddValuation.hasCoeToFun.{u1, u3} R Γ'₀ _inst_3 _inst_4) v₂ r) (Top.top.{u3} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toHasTop.{u3} Γ'₀ _inst_3))))
but is expected to have type
  forall {R : Type.{u3}} {Γ₀ : Type.{u2}} {Γ'₀ : Type.{u1}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_3 : LinearOrderedAddCommMonoidWithTop.{u1} Γ'₀] [_inst_4 : Ring.{u3} R] {v₁ : AddValuation.{u3, u2} R _inst_4 Γ₀ _inst_2} {v₂ : AddValuation.{u3, u1} R _inst_4 Γ'₀ _inst_3}, (AddValuation.IsEquiv.{u3, u2, u1} R Γ₀ Γ'₀ _inst_4 _inst_2 _inst_3 v₁ v₂) -> (forall {r : R}, Iff (Ne.{succ u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (ZeroHom.toFun.{u3, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MulZeroOneClass.toZero.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_4)))) (MulZeroOneClass.toZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_2))))) (MonoidWithZeroHom.toZeroHom.{u3, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u2} (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_2)))) (Valuation.toMonoidWithZeroHom.{u3, u2} R (Multiplicative.{u2} (OrderDual.{u2} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u2} Γ₀ _inst_2) _inst_4 v₁)) r) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u2} Γ₀ _inst_2))) (Ne.{succ u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (ZeroHom.toFun.{u3, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (MulZeroOneClass.toZero.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_4)))) (MulZeroOneClass.toZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ'₀ _inst_3))))) (MonoidWithZeroHom.toZeroHom.{u3, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (NonAssocSemiring.toMulZeroOneClass.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_4))) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ'₀ _inst_3)))) (Valuation.toMonoidWithZeroHom.{u3, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ'₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ'₀ _inst_3) _inst_4 v₂)) r) (Top.top.{u1} Γ'₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u1} Γ'₀ _inst_3))))
Case conversion may be inaccurate. Consider using '#align add_valuation.is_equiv.ne_top AddValuation.IsEquiv.ne_topₓ'. -/
theorem ne_top (h : v₁.IsEquiv v₂) {r : R} : v₁ r ≠ ⊤ ↔ v₂ r ≠ ⊤ :=
  h.NeZero
#align add_valuation.is_equiv.ne_top AddValuation.IsEquiv.ne_top

end IsEquiv

section Supp

variable [LinearOrderedAddCommMonoidWithTop Γ₀] [LinearOrderedAddCommMonoidWithTop Γ'₀]

variable [CommRing R]

variable (v : AddValuation R Γ₀)

#print AddValuation.supp /-
/-- The support of an additive valuation `v : R → Γ₀` is the ideal of `R` where `v x = ⊤` -/
def supp : Ideal R :=
  v.supp
#align add_valuation.supp AddValuation.supp
-/

/- warning: add_valuation.mem_supp_iff -> AddValuation.mem_supp_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : CommRing.{u1} R] (v : AddValuation.{u1, u2} R (CommRing.toRing.{u1} R _inst_4) Γ₀ _inst_2) (x : R), Iff (Membership.Mem.{u1, u1} R (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_4))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_4))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_4))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_4))))) x (AddValuation.supp.{u1, u2} R Γ₀ _inst_2 _inst_4 v)) (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R (CommRing.toRing.{u1} R _inst_4) Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R (CommRing.toRing.{u1} R _inst_4) Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 (CommRing.toRing.{u1} R _inst_4)) v x) (Top.top.{u2} Γ₀ (LinearOrderedAddCommMonoidWithTop.toHasTop.{u2} Γ₀ _inst_2)))
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u1} Γ₀] [_inst_4 : CommRing.{u2} R] (v : AddValuation.{u2, u1} R (CommRing.toRing.{u2} R _inst_4) Γ₀ _inst_2) (x : R), Iff (Membership.mem.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))) R (Submodule.setLike.{u2, u2} R R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))))) x (AddValuation.supp.{u2, u1} R Γ₀ _inst_2 _inst_4 v)) (Eq.{succ u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (ZeroHom.toFun.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (MulZeroOneClass.toZero.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) (MulZeroOneClass.toZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_2))))) (MonoidWithZeroHom.toZeroHom.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_2)))) (Valuation.toMonoidWithZeroHom.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_2) (CommRing.toRing.{u2} R _inst_4) v)) x) (Top.top.{u1} Γ₀ (LinearOrderedAddCommMonoidWithTop.toTop.{u1} Γ₀ _inst_2)))
Case conversion may be inaccurate. Consider using '#align add_valuation.mem_supp_iff AddValuation.mem_supp_iffₓ'. -/
@[simp]
theorem mem_supp_iff (x : R) : x ∈ supp v ↔ v x = ⊤ :=
  v.mem_supp_iff x
#align add_valuation.mem_supp_iff AddValuation.mem_supp_iff

/- warning: add_valuation.map_add_supp -> AddValuation.map_add_supp is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {Γ₀ : Type.{u2}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u2} Γ₀] [_inst_4 : CommRing.{u1} R] (v : AddValuation.{u1, u2} R (CommRing.toRing.{u1} R _inst_4) Γ₀ _inst_2) (a : R) {s : R}, (Membership.Mem.{u1, u1} R (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_4))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_4))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_4))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_4))))) s (AddValuation.supp.{u1, u2} R Γ₀ _inst_2 _inst_4 v)) -> (Eq.{succ u2} Γ₀ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R (CommRing.toRing.{u1} R _inst_4) Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R (CommRing.toRing.{u1} R _inst_4) Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 (CommRing.toRing.{u1} R _inst_4)) v (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_4)))) a s)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddValuation.{u1, u2} R (CommRing.toRing.{u1} R _inst_4) Γ₀ _inst_2) (fun (_x : AddValuation.{u1, u2} R (CommRing.toRing.{u1} R _inst_4) Γ₀ _inst_2) => R -> Γ₀) (AddValuation.hasCoeToFun.{u1, u2} R Γ₀ _inst_2 (CommRing.toRing.{u1} R _inst_4)) v a))
but is expected to have type
  forall {R : Type.{u2}} {Γ₀ : Type.{u1}} [_inst_2 : LinearOrderedAddCommMonoidWithTop.{u1} Γ₀] [_inst_4 : CommRing.{u2} R] (v : AddValuation.{u2, u1} R (CommRing.toRing.{u2} R _inst_4) Γ₀ _inst_2) (a : R) {s : R}, (Membership.mem.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))) R (Submodule.setLike.{u2, u2} R R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_4))))) s (AddValuation.supp.{u2, u1} R Γ₀ _inst_2 _inst_4 v)) -> (Eq.{succ u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (ZeroHom.toFun.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (MulZeroOneClass.toZero.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) (MulZeroOneClass.toZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_2))))) (MonoidWithZeroHom.toZeroHom.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_2)))) (Valuation.toMonoidWithZeroHom.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_2) (CommRing.toRing.{u2} R _inst_4) v)) (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))))) a s)) (ZeroHom.toFun.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (MulZeroOneClass.toZero.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4))))) (MulZeroOneClass.toZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_2))))) (MonoidWithZeroHom.toZeroHom.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_4)))) (MonoidWithZero.toMulZeroOneClass.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (CommMonoidWithZero.toMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_2)))) (Valuation.toMonoidWithZeroHom.{u2, u1} R (Multiplicative.{u1} (OrderDual.{u1} Γ₀)) (instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual.{u1} Γ₀ _inst_2) (CommRing.toRing.{u2} R _inst_4) v)) a))
Case conversion may be inaccurate. Consider using '#align add_valuation.map_add_supp AddValuation.map_add_suppₓ'. -/
theorem map_add_supp (a : R) {s : R} (h : s ∈ supp v) : v (a + s) = v a :=
  v.map_add_supp a h
#align add_valuation.map_add_supp AddValuation.map_add_supp

end Supp

-- end of section
end AddValuation

section ValuationNotation

-- mathport name: nat.multiplicative_zero
scoped[DiscreteValuation] notation "ℕₘ₀" => WithZero (Multiplicative ℕ)

-- mathport name: int.multiplicative_zero
scoped[DiscreteValuation] notation "ℤₘ₀" => WithZero (Multiplicative ℤ)

end ValuationNotation

