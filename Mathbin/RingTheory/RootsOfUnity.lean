import Mathbin.Data.Polynomial.RingDivision 
import Mathbin.Tactic.Zify 
import Mathbin.FieldTheory.Separable 
import Mathbin.Data.Zmod.Basic 
import Mathbin.RingTheory.IntegralDomain 
import Mathbin.NumberTheory.Divisors 
import Mathbin.FieldTheory.Finite.Basic 
import Mathbin.GroupTheory.SpecificGroups.Cyclic

/-!
# Roots of unity and primitive roots of unity

We define roots of unity in the context of an arbitrary commutative monoid,
as a subgroup of the group of units. We also define a predicate `is_primitive_root` on commutative
monoids, expressing that an element is a primitive root of unity.

## Main definitions

* `roots_of_unity n M`, for `n : ℕ+` is the subgroup of the units of a commutative monoid `M`
  consisting of elements `x` that satisfy `x ^ n = 1`.
* `is_primitive_root ζ k`: an element `ζ` is a primitive `k`-th root of unity if `ζ ^ k = 1`,
  and if `l` satisfies `ζ ^ l = 1` then `k ∣ l`.
* `primitive_roots k R`: the finset of primitive `k`-th roots of unity in an integral domain `R`.

## Main results

* `roots_of_unity.is_cyclic`: the roots of unity in an integral domain form a cyclic group.
* `is_primitive_root.zmod_equiv_zpowers`: `zmod k` is equivalent to
  the subgroup generated by a primitive `k`-th root of unity.
* `is_primitive_root.zpowers_eq`: in an integral domain, the subgroup generated by
  a primitive `k`-th root of unity is equal to the `k`-th roots of unity.
* `is_primitive_root.card_primitive_roots`: if an integral domain
   has a primitive `k`-th root of unity, then it has `φ k` of them.

## Implementation details

It is desirable that `roots_of_unity` is a subgroup,
and it will mainly be applied to rings (e.g. the ring of integers in a number field) and fields.
We therefore implement it as a subgroup of the units of a commutative monoid.

We have chosen to define `roots_of_unity n` for `n : ℕ+`, instead of `n : ℕ`,
because almost all lemmas need the positivity assumption,
and in particular the type class instances for `fintype` and `is_cyclic`.

On the other hand, for primitive roots of unity, it is desirable to have a predicate
not just on units, but directly on elements of the ring/field.
For example, we want to say that `exp (2 * pi * I / n)` is a primitive `n`-th root of unity
in the complex numbers, without having to turn that number into a unit first.

This creates a little bit of friction, but lemmas like `is_primitive_root.is_unit` and
`is_primitive_root.coe_units_iff` should provide the necessary glue.

-/


open_locale Classical BigOperators

noncomputable theory

open Polynomial

open Finset

variable{M N G G₀ R S : Type _}

variable[CommMonoidₓ M][CommMonoidₓ N][CommGroupₓ G][CommGroupWithZero G₀]

section rootsOfUnity

variable{k l : ℕ+}

/-- `roots_of_unity k M` is the subgroup of elements `m : units M` that satisfy `m ^ k = 1` -/
def rootsOfUnity (k : ℕ+) (M : Type _) [CommMonoidₓ M] : Subgroup (Units M) :=
  { Carrier := { ζ | (ζ^(k : ℕ)) = 1 }, one_mem' := one_pow _,
    mul_mem' :=
      fun ζ ξ hζ hξ =>
        by 
          simp_all only [Set.mem_set_of_eq, mul_powₓ, one_mulₓ],
    inv_mem' :=
      fun ζ hζ =>
        by 
          simp_all only [Set.mem_set_of_eq, inv_pow, one_inv] }

@[simp]
theorem mem_roots_of_unity (k : ℕ+) (ζ : Units M) : ζ ∈ rootsOfUnity k M ↔ (ζ^(k : ℕ)) = 1 :=
  Iff.rfl

theorem roots_of_unity_le_of_dvd (h : k ∣ l) : rootsOfUnity k M ≤ rootsOfUnity l M :=
  by 
    obtain ⟨d, rfl⟩ := h 
    intro ζ h 
    simp_all only [mem_roots_of_unity, Pnat.mul_coe, pow_mulₓ, one_pow]

theorem map_roots_of_unity (f : Units M →* Units N) (k : ℕ+) : (rootsOfUnity k M).map f ≤ rootsOfUnity k N :=
  by 
    rintro _ ⟨ζ, h, rfl⟩
    simp_all only [←MonoidHom.map_pow, mem_roots_of_unity, SetLike.mem_coe, MonoidHom.map_one]

variable[CommRingₓ R]

@[normCast]
theorem rootsOfUnity.coe_pow (ζ : rootsOfUnity k R) (m : ℕ) : «expr↑ » (ζ^m) = (ζ^m : R) :=
  by 
    change «expr↑ » («expr↑ » (ζ^m) : Units R) = («expr↑ » (ζ : Units R)^m)
    rw [Subgroup.coe_pow, Units.coe_pow]

variable[CommRingₓ S]

/-- Restrict a ring homomorphism between integral domains to the nth roots of unity -/
def RingHom.restrictRootsOfUnity (σ : R →+* S) (n : ℕ+) : rootsOfUnity n R →* rootsOfUnity n S :=
  let h : ∀ (ξ : rootsOfUnity n R), (σ ξ^(n : ℕ)) = 1 :=
    fun ξ =>
      by 
        change (σ (ξ : Units R)^(n : ℕ)) = 1
        rw [←σ.map_pow, ←Units.coe_pow, show ((ξ : Units R)^(n : ℕ)) = 1 from ξ.2, Units.coe_one, σ.map_one]
  { toFun :=
      fun ξ =>
        ⟨@unitOfInvertible _ _ _ (invertibleOfPowEqOne _ _ (h ξ) n.2),
          by 
            ext 
            rw [Units.coe_pow]
            exact h ξ⟩,
    map_one' :=
      by 
        ext 
        exact σ.map_one,
    map_mul' :=
      fun ξ₁ ξ₂ =>
        by 
          ext 
          rw [Subgroup.coe_mul, Units.coe_mul]
          exact σ.map_mul _ _ }

@[simp]
theorem RingHom.restrict_roots_of_unity_coe_apply (σ : R →+* S) (ζ : rootsOfUnity k R) :
  «expr↑ » (σ.restrict_roots_of_unity k ζ) = σ («expr↑ » ζ) :=
  rfl

/-- Restrict a ring isomorphism between integral domains to the nth roots of unity -/
def RingEquiv.restrictRootsOfUnity (σ : R ≃+* S) (n : ℕ+) : rootsOfUnity n R ≃* rootsOfUnity n S :=
  { toFun := σ.to_ring_hom.restrict_roots_of_unity n, invFun := σ.symm.to_ring_hom.restrict_roots_of_unity n,
    left_inv :=
      fun ξ =>
        by 
          ext 
          exact σ.symm_apply_apply ξ,
    right_inv :=
      fun ξ =>
        by 
          ext 
          exact σ.apply_symm_apply ξ,
    map_mul' := (σ.to_ring_hom.restrict_roots_of_unity n).map_mul }

@[simp]
theorem RingEquiv.restrict_roots_of_unity_coe_apply (σ : R ≃+* S) (ζ : rootsOfUnity k R) :
  «expr↑ » (σ.restrict_roots_of_unity k ζ) = σ («expr↑ » ζ) :=
  rfl

@[simp]
theorem RingEquiv.restrict_roots_of_unity_symm (σ : R ≃+* S) :
  (σ.restrict_roots_of_unity k).symm = σ.symm.restrict_roots_of_unity k :=
  rfl

variable[IsDomain R]

theorem mem_roots_of_unity_iff_mem_nth_roots {ζ : Units R} : ζ ∈ rootsOfUnity k R ↔ (ζ : R) ∈ nth_roots k (1 : R) :=
  by 
    simp only [mem_roots_of_unity, mem_nth_roots k.pos, Units.ext_iff, Units.coe_one, Units.coe_pow]

variable(k R)

/-- Equivalence between the `k`-th roots of unity in `R` and the `k`-th roots of `1`.

This is implemented as equivalence of subtypes,
because `roots_of_unity` is a subgroup of the group of units,
whereas `nth_roots` is a multiset. -/
def rootsOfUnityEquivNthRoots : rootsOfUnity k R ≃ { x // x ∈ nth_roots k (1 : R) } :=
  by 
    refine'
      { toFun := fun x => ⟨x, mem_roots_of_unity_iff_mem_nth_roots.mp x.2⟩,
        invFun := fun x => ⟨⟨x, x^(k - 1 : ℕ), _, _⟩, _⟩, left_inv := _, right_inv := _ }
    swap 4
    ·
      rintro ⟨x, hx⟩
      ext 
      rfl 
    swap 4
    ·
      rintro ⟨x, hx⟩
      ext 
      rfl 
    all_goals 
      rcases x with ⟨x, hx⟩
      rw [mem_nth_roots k.pos] at hx 
      simp only [Subtype.coe_mk, ←pow_succₓ, ←pow_succ'ₓ, hx, tsub_add_cancel_of_le (show 1 ≤ (k : ℕ) from k.one_le)]
    ·
      show ((_ : Units R)^(k : ℕ)) = 1
      simp only [Units.ext_iff, hx, Units.coe_mk, Units.coe_one, Subtype.coe_mk, Units.coe_pow]

variable{k R}

@[simp]
theorem roots_of_unity_equiv_nth_roots_apply (x : rootsOfUnity k R) : (rootsOfUnityEquivNthRoots R k x : R) = x :=
  rfl

@[simp]
theorem roots_of_unity_equiv_nth_roots_symm_apply (x : { x // x ∈ nth_roots k (1 : R) }) :
  ((rootsOfUnityEquivNthRoots R k).symm x : R) = x :=
  rfl

variable(k R)

instance rootsOfUnity.fintype : Fintype (rootsOfUnity k R) :=
  Fintype.ofEquiv { x // x ∈ nth_roots k (1 : R) }$ (rootsOfUnityEquivNthRoots R k).symm

instance rootsOfUnity.is_cyclic : IsCyclic (rootsOfUnity k R) :=
  is_cyclic_of_subgroup_is_domain ((Units.coeHom R).comp (rootsOfUnity k R).Subtype)
    (Units.ext.comp Subtype.val_injective)

theorem card_roots_of_unity : Fintype.card (rootsOfUnity k R) ≤ k :=
  calc Fintype.card (rootsOfUnity k R) = Fintype.card { x // x ∈ nth_roots k (1 : R) } :=
    Fintype.card_congr (rootsOfUnityEquivNthRoots R k)
    _ ≤ (nth_roots k (1 : R)).attach.card := Multiset.card_le_of_le (Multiset.erase_dup_le _)
    _ = (nth_roots k (1 : R)).card := Multiset.card_attach 
    _ ≤ k := card_nth_roots k 1
    

variable{k R}

theorem RingHom.map_root_of_unity_eq_pow_self (σ : R →+* R) (ζ : rootsOfUnity k R) : ∃ m : ℕ, σ ζ = (ζ^m) :=
  by 
    obtain ⟨m, hm⟩ := (σ.restrict_roots_of_unity k).map_cyclic 
    rw [←σ.restrict_roots_of_unity_coe_apply, hm, zpow_eq_mod_order_of,
      ←Int.to_nat_of_nonneg (m.mod_nonneg (int.coe_nat_ne_zero.mpr (pos_iff_ne_zero.mp (order_of_pos ζ)))),
      zpow_coe_nat, rootsOfUnity.coe_pow]
    exact ⟨(m % orderOf ζ).toNat, rfl⟩

end rootsOfUnity

/-- An element `ζ` is a primitive `k`-th root of unity if `ζ ^ k = 1`,
and if `l` satisfies `ζ ^ l = 1` then `k ∣ l`. -/
structure IsPrimitiveRoot(ζ : M)(k : ℕ) : Prop where 
  pow_eq_one : (ζ^(k : ℕ)) = 1
  dvd_of_pow_eq_one : ∀ (l : ℕ), (ζ^l) = 1 → k ∣ l

section primitiveRoots

variable{k : ℕ}

/-- `primitive_roots k R` is the finset of primitive `k`-th roots of unity
in the integral domain `R`. -/
def primitiveRoots (k : ℕ) (R : Type _) [CommRingₓ R] [IsDomain R] : Finset R :=
  (nth_roots k (1 : R)).toFinset.filter fun ζ => IsPrimitiveRoot ζ k

variable[CommRingₓ R][IsDomain R]

@[simp]
theorem mem_primitive_roots {ζ : R} (h0 : 0 < k) : ζ ∈ primitiveRoots k R ↔ IsPrimitiveRoot ζ k :=
  by 
    rw [primitiveRoots, mem_filter, Multiset.mem_to_finset, mem_nth_roots h0, and_iff_right_iff_imp]
    exact IsPrimitiveRoot.pow_eq_one

end primitiveRoots

namespace IsPrimitiveRoot

variable{k l : ℕ}

theorem iff_def (ζ : M) (k : ℕ) : IsPrimitiveRoot ζ k ↔ (ζ^k) = 1 ∧ ∀ (l : ℕ), (ζ^l) = 1 → k ∣ l :=
  ⟨fun ⟨h1, h2⟩ => ⟨h1, h2⟩, fun ⟨h1, h2⟩ => ⟨h1, h2⟩⟩

theorem mk_of_lt (ζ : M) (hk : 0 < k) (h1 : (ζ^k) = 1) (h : ∀ (l : ℕ), 0 < l → l < k → (ζ^l) ≠ 1) :
  IsPrimitiveRoot ζ k :=
  by 
    refine' ⟨h1, _⟩
    intro l hl 
    apply dvd_trans _ (k.gcd_dvd_right l)
    suffices  : k.gcd l = k
    ·
      rw [this]
    rw [eq_iff_le_not_lt]
    refine' ⟨Nat.le_of_dvdₓ hk (k.gcd_dvd_left l), _⟩
    intro h' 
    apply h _ (Nat.gcd_pos_of_pos_leftₓ _ hk) h' 
    exact pow_gcd_eq_one _ h1 hl

section CommMonoidₓ

variable{ζ : M}(h : IsPrimitiveRoot ζ k)

@[nontriviality]
theorem of_subsingleton [Subsingleton M] (x : M) : IsPrimitiveRoot x 1 :=
  ⟨Subsingleton.elimₓ _ _, fun _ _ => one_dvd _⟩

theorem pow_eq_one_iff_dvd (l : ℕ) : (ζ^l) = 1 ↔ k ∣ l :=
  ⟨h.dvd_of_pow_eq_one l,
    by 
      rintro ⟨i, rfl⟩
      simp only [pow_mulₓ, h.pow_eq_one, one_pow, Pnat.mul_coe]⟩

theorem IsUnit (h : IsPrimitiveRoot ζ k) (h0 : 0 < k) : IsUnit ζ :=
  by 
    apply is_unit_of_mul_eq_one ζ (ζ^k - 1)
    rw [←pow_succₓ, tsub_add_cancel_of_le h0.nat_succ_le, h.pow_eq_one]

theorem pow_ne_one_of_pos_of_lt (h0 : 0 < l) (hl : l < k) : (ζ^l) ≠ 1 :=
  mt (Nat.le_of_dvdₓ h0 ∘ h.dvd_of_pow_eq_one _)$ not_le_of_lt hl

theorem pow_inj (h : IsPrimitiveRoot ζ k) ⦃i j : ℕ⦄ (hi : i < k) (hj : j < k) (H : (ζ^i) = (ζ^j)) : i = j :=
  by 
    wlog hij : i ≤ j 
    apply le_antisymmₓ hij 
    rw [←tsub_eq_zero_iff_le]
    apply Nat.eq_zero_of_dvd_of_lt _ (lt_of_le_of_ltₓ tsub_le_self hj)
    apply h.dvd_of_pow_eq_one 
    rw [←((h.is_unit (lt_of_le_of_ltₓ (Nat.zero_leₓ _) hi)).pow i).mul_left_inj, ←pow_addₓ, tsub_add_cancel_of_le hij,
      H, one_mulₓ]

theorem one : IsPrimitiveRoot (1 : M) 1 :=
  { pow_eq_one := pow_oneₓ _, dvd_of_pow_eq_one := fun l hl => one_dvd _ }

@[simp]
theorem one_right_iff : IsPrimitiveRoot ζ 1 ↔ ζ = 1 :=
  by 
    split 
    ·
      intro h 
      rw [←pow_oneₓ ζ, h.pow_eq_one]
    ·
      rintro rfl 
      exact one

@[simp]
theorem coe_units_iff {ζ : Units M} : IsPrimitiveRoot (ζ : M) k ↔ IsPrimitiveRoot ζ k :=
  by 
    simp only [iff_def, Units.ext_iff, Units.coe_pow, Units.coe_one]

theorem pow_of_coprime (h : IsPrimitiveRoot ζ k) (i : ℕ) (hi : i.coprime k) : IsPrimitiveRoot (ζ^i) k :=
  by 
    byCases' h0 : k = 0
    ·
      subst k 
      simp_all only [pow_oneₓ, Nat.coprime_zero_rightₓ]
    rcases h.is_unit (Nat.pos_of_ne_zeroₓ h0) with ⟨ζ, rfl⟩
    rw [←Units.coe_pow]
    rw [coe_units_iff] at h⊢
    refine'
      { pow_eq_one :=
          by 
            rw [←pow_mul', pow_mulₓ, h.pow_eq_one, one_pow],
        dvd_of_pow_eq_one := _ }
    intro l hl 
    apply h.dvd_of_pow_eq_one 
    rw [←pow_oneₓ ζ, ←zpow_coe_nat ζ, ←hi.gcd_eq_one, Nat.gcd_eq_gcd_ab, zpow_add, mul_powₓ, ←zpow_coe_nat, ←zpow_mul,
      mul_right_commₓ]
    simp only [zpow_mul, hl, h.pow_eq_one, one_zpow, one_pow, one_mulₓ, zpow_coe_nat]

theorem pow_of_prime (h : IsPrimitiveRoot ζ k) {p : ℕ} (hprime : Nat.Prime p) (hdiv : ¬p ∣ k) :
  IsPrimitiveRoot (ζ^p) k :=
  h.pow_of_coprime p (hprime.coprime_iff_not_dvd.2 hdiv)

theorem pow_iff_coprime (h : IsPrimitiveRoot ζ k) (h0 : 0 < k) (i : ℕ) : IsPrimitiveRoot (ζ^i) k ↔ i.coprime k :=
  by 
    refine' ⟨_, h.pow_of_coprime i⟩
    intro hi 
    obtain ⟨a, ha⟩ := i.gcd_dvd_left k 
    obtain ⟨b, hb⟩ := i.gcd_dvd_right k 
    suffices  : b = k
    ·
      rwa [this, ←one_mulₓ k, Nat.mul_left_inj h0, eq_comm] at hb 
    rw [ha] at hi 
    rw [mul_commₓ] at hb 
    apply Nat.dvd_antisymm ⟨i.gcd k, hb⟩ (hi.dvd_of_pow_eq_one b _)
    rw [←pow_mul', ←mul_assocₓ, ←hb, pow_mulₓ, h.pow_eq_one, one_pow]

protected theorem orderOf (ζ : M) : IsPrimitiveRoot ζ (orderOf ζ) :=
  ⟨pow_order_of_eq_one ζ, fun l => order_of_dvd_of_pow_eq_one⟩

theorem Unique {ζ : M} (hk : IsPrimitiveRoot ζ k) (hl : IsPrimitiveRoot ζ l) : k = l :=
  by 
    wlog hkl : k ≤ l 
    rcases hkl.eq_or_lt with (rfl | hkl)
    ·
      rfl 
    rcases k.eq_zero_or_pos with (rfl | hk')
    ·
      exact (zero_dvd_iff.mp$ hk.dvd_of_pow_eq_one l hl.pow_eq_one).symm 
    exact absurd hk.pow_eq_one (hl.pow_ne_one_of_pos_of_lt hk' hkl)

theorem eq_order_of : k = orderOf ζ :=
  h.unique (IsPrimitiveRoot.order_of ζ)

protected theorem Iff (hk : 0 < k) : IsPrimitiveRoot ζ k ↔ (ζ^k) = 1 ∧ ∀ (l : ℕ), 0 < l → l < k → (ζ^l) ≠ 1 :=
  by 
    refine' ⟨fun h => ⟨h.pow_eq_one, fun l hl' hl => _⟩, fun ⟨hζ, hl⟩ => IsPrimitiveRoot.mk_of_lt ζ hk hζ hl⟩
    rw [h.eq_order_of] at hl 
    exact pow_ne_one_of_lt_order_of' hl'.ne' hl

protected theorem not_iff : ¬IsPrimitiveRoot ζ k ↔ orderOf ζ ≠ k :=
  ⟨fun h hk => h$ hk ▸ IsPrimitiveRoot.order_of ζ, fun h hk => h.symm$ hk.unique$ IsPrimitiveRoot.order_of ζ⟩

end CommMonoidₓ

section CommMonoidWithZero

variable{M₀ : Type _}[CommMonoidWithZero M₀]

theorem zero [Nontrivial M₀] : IsPrimitiveRoot (0 : M₀) 0 :=
  ⟨pow_zeroₓ 0,
    fun l hl =>
      by 
        simpa [zero_pow_eq, show ∀ p, ¬p → False ↔ p from @not_not] using hl⟩

end CommMonoidWithZero

section CommGroupₓ

variable{ζ : G}

theorem zpow_eq_one (h : IsPrimitiveRoot ζ k) : (ζ^(k : ℤ)) = 1 :=
  by 
    rw [zpow_coe_nat]
    exact h.pow_eq_one

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem zpow_eq_one_iff_dvd
(h : is_primitive_root ζ k)
(l : exprℤ()) : «expr ↔ »(«expr = »(«expr ^ »(ζ, l), 1), «expr ∣ »((k : exprℤ()), l)) :=
begin
  by_cases [expr h0, ":", expr «expr ≤ »(0, l)],
  { lift [expr l] ["to", expr exprℕ()] ["using", expr h0] [],
    rw ["[", expr zpow_coe_nat, "]"] [],
    norm_cast [],
    exact [expr h.pow_eq_one_iff_dvd l] },
  { have [] [":", expr «expr ≤ »(0, «expr- »(l))] [],
    { simp [] [] ["only"] ["[", expr not_le, ",", expr neg_nonneg, "]"] [] ["at", ident h0, "⊢"],
      exact [expr le_of_lt h0] },
    lift [expr «expr- »(l)] ["to", expr exprℕ()] ["using", expr this] ["with", ident l', ident hl'],
    rw ["[", "<-", expr dvd_neg, ",", "<-", expr hl', "]"] [],
    norm_cast [],
    rw ["[", "<-", expr h.pow_eq_one_iff_dvd, ",", "<-", expr inv_inj, ",", "<-", expr zpow_neg, ",", "<-", expr hl', ",", expr zpow_coe_nat, ",", expr one_inv, "]"] [] }
end

theorem inv (h : IsPrimitiveRoot ζ k) : IsPrimitiveRoot (ζ⁻¹) k :=
  { pow_eq_one :=
      by 
        simp only [h.pow_eq_one, one_inv, eq_self_iff_true, inv_pow],
    dvd_of_pow_eq_one :=
      by 
        intro l hl 
        apply h.dvd_of_pow_eq_one l 
        rw [←inv_inj, ←inv_pow, hl, one_inv] }

@[simp]
theorem inv_iff : IsPrimitiveRoot (ζ⁻¹) k ↔ IsPrimitiveRoot ζ k :=
  by 
    refine' ⟨_, fun h => inv h⟩
    intro h 
    rw [←inv_invₓ ζ]
    exact inv h

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem zpow_of_gcd_eq_one
(h : is_primitive_root ζ k)
(i : exprℤ())
(hi : «expr = »(i.gcd k, 1)) : is_primitive_root «expr ^ »(ζ, i) k :=
begin
  by_cases [expr h0, ":", expr «expr ≤ »(0, i)],
  { lift [expr i] ["to", expr exprℕ()] ["using", expr h0] [],
    rw [expr zpow_coe_nat] [],
    exact [expr h.pow_of_coprime i hi] },
  have [] [":", expr «expr ≤ »(0, «expr- »(i))] [],
  { simp [] [] ["only"] ["[", expr not_le, ",", expr neg_nonneg, "]"] [] ["at", ident h0, "⊢"],
    exact [expr le_of_lt h0] },
  lift [expr «expr- »(i)] ["to", expr exprℕ()] ["using", expr this] ["with", ident i', ident hi'],
  rw ["[", "<-", expr inv_iff, ",", "<-", expr zpow_neg, ",", "<-", expr hi', ",", expr zpow_coe_nat, "]"] [],
  apply [expr h.pow_of_coprime],
  rw ["[", expr int.gcd, ",", "<-", expr int.nat_abs_neg, ",", "<-", expr hi', "]"] ["at", ident hi],
  exact [expr hi]
end

@[simp]
theorem coe_subgroup_iff (H : Subgroup G) {ζ : H} : IsPrimitiveRoot (ζ : G) k ↔ IsPrimitiveRoot ζ k :=
  by 
    simp only [iff_def, ←Subgroup.coe_pow, ←H.coe_one, ←Subtype.ext_iff]

end CommGroupₓ

section CommGroupWithZero

variable{ζ : G₀}

theorem zpow_eq_one₀ (h : IsPrimitiveRoot ζ k) : (ζ^(k : ℤ)) = 1 :=
  by 
    rw [zpow_coe_nat]
    exact h.pow_eq_one

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem zpow_eq_one_iff_dvd₀
(h : is_primitive_root ζ k)
(l : exprℤ()) : «expr ↔ »(«expr = »(«expr ^ »(ζ, l), 1), «expr ∣ »((k : exprℤ()), l)) :=
begin
  by_cases [expr h0, ":", expr «expr ≤ »(0, l)],
  { lift [expr l] ["to", expr exprℕ()] ["using", expr h0] [],
    rw ["[", expr zpow_coe_nat, "]"] [],
    norm_cast [],
    exact [expr h.pow_eq_one_iff_dvd l] },
  { have [] [":", expr «expr ≤ »(0, «expr- »(l))] [],
    { simp [] [] ["only"] ["[", expr not_le, ",", expr neg_nonneg, "]"] [] ["at", ident h0, "⊢"],
      exact [expr le_of_lt h0] },
    lift [expr «expr- »(l)] ["to", expr exprℕ()] ["using", expr this] ["with", ident l', ident hl'],
    rw ["[", "<-", expr dvd_neg, ",", "<-", expr hl', "]"] [],
    norm_cast [],
    rw ["[", "<-", expr h.pow_eq_one_iff_dvd, ",", "<-", expr inv_inj₀, ",", "<-", expr zpow_neg₀, ",", "<-", expr hl', ",", expr zpow_coe_nat, ",", expr inv_one, "]"] [] }
end

theorem inv' (h : IsPrimitiveRoot ζ k) : IsPrimitiveRoot (ζ⁻¹) k :=
  { pow_eq_one :=
      by 
        simp only [h.pow_eq_one, inv_one, eq_self_iff_true, inv_pow₀],
    dvd_of_pow_eq_one :=
      by 
        intro l hl 
        apply h.dvd_of_pow_eq_one l 
        rw [←inv_inj₀, ←inv_pow₀, hl, inv_one] }

@[simp]
theorem inv_iff' : IsPrimitiveRoot (ζ⁻¹) k ↔ IsPrimitiveRoot ζ k :=
  by 
    refine' ⟨_, fun h => inv' h⟩
    intro h 
    rw [←inv_inv₀ ζ]
    exact inv' h

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem zpow_of_gcd_eq_one₀
(h : is_primitive_root ζ k)
(i : exprℤ())
(hi : «expr = »(i.gcd k, 1)) : is_primitive_root «expr ^ »(ζ, i) k :=
begin
  by_cases [expr h0, ":", expr «expr ≤ »(0, i)],
  { lift [expr i] ["to", expr exprℕ()] ["using", expr h0] [],
    rw [expr zpow_coe_nat] [],
    exact [expr h.pow_of_coprime i hi] },
  have [] [":", expr «expr ≤ »(0, «expr- »(i))] [],
  { simp [] [] ["only"] ["[", expr not_le, ",", expr neg_nonneg, "]"] [] ["at", ident h0, "⊢"],
    exact [expr le_of_lt h0] },
  lift [expr «expr- »(i)] ["to", expr exprℕ()] ["using", expr this] ["with", ident i', ident hi'],
  rw ["[", "<-", expr inv_iff', ",", "<-", expr zpow_neg₀, ",", "<-", expr hi', ",", expr zpow_coe_nat, "]"] [],
  apply [expr h.pow_of_coprime],
  rw ["[", expr int.gcd, ",", "<-", expr int.nat_abs_neg, ",", "<-", expr hi', "]"] ["at", ident hi],
  exact [expr hi]
end

end CommGroupWithZero

section CommSemiringₓ

variable[CommSemiringₓ R][CommSemiringₓ S]{f : R →+* S}{ζ : R}

open Function

theorem map_of_injective (hf : injective f) (h : IsPrimitiveRoot ζ k) : IsPrimitiveRoot (f ζ) k :=
  { pow_eq_one :=
      by 
        rw [←f.map_pow, h.pow_eq_one, f.map_one],
    dvd_of_pow_eq_one :=
      by 
        rw [h.eq_order_of]
        intro l hl 
        rw [←f.map_pow, ←f.map_one] at hl 
        exact order_of_dvd_of_pow_eq_one (hf hl) }

theorem of_map_of_injective (hf : injective f) (h : IsPrimitiveRoot (f ζ) k) : IsPrimitiveRoot ζ k :=
  { pow_eq_one :=
      by 
        applyFun f 
        rw [f.map_pow, f.map_one, h.pow_eq_one],
    dvd_of_pow_eq_one :=
      by 
        rw [h.eq_order_of]
        intro l hl 
        applyFun f  at hl 
        rw [f.map_pow, f.map_one] at hl 
        exact order_of_dvd_of_pow_eq_one hl }

theorem map_iff_of_injective (hf : injective f) : IsPrimitiveRoot (f ζ) k ↔ IsPrimitiveRoot ζ k :=
  ⟨fun h => h.of_map_of_injective hf, fun h => h.map_of_injective hf⟩

end CommSemiringₓ

section IsDomain

variable{ζ : R}

variable[CommRingₓ R][IsDomain R]

@[simp]
theorem primitive_roots_zero : primitiveRoots 0 R = ∅ :=
  by 
    rw [←Finset.val_eq_zero, ←Multiset.subset_zero, ←nth_roots_zero (1 : R), primitiveRoots]
    simp only [Finset.not_mem_empty, forall_const, forall_prop_of_false, Multiset.to_finset_zero,
      Finset.filter_true_of_mem, Finset.empty_val, not_false_iff, Multiset.zero_subset, nth_roots_zero]

@[simp]
theorem primitive_roots_one : primitiveRoots 1 R = {(1 : R)} :=
  by 
    apply Finset.eq_singleton_iff_unique_mem.2
    split 
    ·
      simp only [IsPrimitiveRoot.one_right_iff, mem_primitive_roots zero_lt_one]
    ·
      intro x hx 
      rw [mem_primitive_roots zero_lt_one, IsPrimitiveRoot.one_right_iff] at hx 
      exact hx

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem neg_one (p : exprℕ()) [char_p R p] (hp : «expr ≠ »(p, 2)) : is_primitive_root («expr- »(1) : R) 2 :=
«expr $ »(mk_of_lt («expr- »(1) : R) exprdec_trivial() (by simp [] [] ["only"] ["[", expr one_pow, ",", expr neg_sq, "]"] [] []), begin
   intros [ident l, ident hl0, ident hl2],
   obtain [ident rfl, ":", expr «expr = »(l, 1)],
   { unfreezingI { clear_dependent [ident R, ident p] },
     dec_trivial ["!"] },
   simp [] [] ["only"] ["[", expr pow_one, ",", expr ne.def, "]"] [] [],
   intro [ident h],
   suffices [ident h2] [":", expr «expr ∣ »(p, 2)],
   { have [] [] [":=", expr char_p.char_ne_one R p],
     unfreezingI { clear_dependent [ident R] },
     have [ident aux] [] [":=", expr nat.le_of_dvd exprdec_trivial() h2],
     revert [ident this, ident hp, ident h2],
     revert [ident p],
     dec_trivial [] },
   simp [] [] ["only"] ["[", "<-", expr char_p.cast_eq_zero_iff R p, ",", expr nat.cast_bit0, ",", expr nat.cast_one, "]"] [] [],
   rw ["[", expr bit0, ",", "<-", expr h, ",", expr neg_add_self, "]"] [] { occs := occurrences.pos «expr[ , ]»([1]) }
 end)

theorem eq_neg_one_of_two_right (h : IsPrimitiveRoot ζ 2) : ζ = -1 :=
  by 
    apply (eq_or_eq_neg_of_sq_eq_sq ζ 1 _).resolve_left
    ·
      rw [←pow_oneₓ ζ]
      apply h.pow_ne_one_of_pos_of_lt <;> decide
    ·
      simp only [h.pow_eq_one, one_pow]

end IsDomain

section IsDomain

variable[CommRingₓ R]

variable{ζ : Units R}(h : IsPrimitiveRoot ζ k)

protected theorem mem_roots_of_unity {n : ℕ+} (h : IsPrimitiveRoot ζ n) : ζ ∈ rootsOfUnity n R :=
  h.pow_eq_one

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The (additive) monoid equivalence between `zmod k`
and the powers of a primitive root of unity `ζ`. -/
def zmod_equiv_zpowers (h : is_primitive_root ζ k) : «expr ≃+ »(zmod k, additive (subgroup.zpowers ζ)) :=
add_equiv.of_bijective (add_monoid_hom.lift_of_right_inverse «expr $ »(int.cast_add_hom, zmod k) _ zmod.int_cast_right_inverse ⟨{ to_fun := λ
    i, additive.of_mul (⟨_, i, rfl⟩ : subgroup.zpowers ζ),
    map_zero' := by { simp [] [] ["only"] ["[", expr zpow_zero, "]"] [] [],
      refl },
    map_add' := by { intros [ident i, ident j],
      simp [] [] ["only"] ["[", expr zpow_add, "]"] [] [],
      refl } }, λ i hi, begin
    simp [] [] ["only"] ["[", expr add_monoid_hom.mem_ker, ",", expr char_p.int_cast_eq_zero_iff (zmod k) k, ",", expr add_monoid_hom.coe_mk, ",", expr int.coe_cast_add_hom, "]"] [] ["at", ident hi, "⊢"],
    obtain ["⟨", ident i, ",", ident rfl, "⟩", ":=", expr hi],
    simp [] [] ["only"] ["[", expr zpow_mul, ",", expr h.pow_eq_one, ",", expr one_zpow, ",", expr zpow_coe_nat, "]"] [] [],
    refl
  end⟩) (begin
   split,
   { rw [expr add_monoid_hom.injective_iff] [],
     intros [ident i, ident hi],
     rw [expr subtype.ext_iff] ["at", ident hi],
     have [] [] [":=", expr (h.zpow_eq_one_iff_dvd _).mp hi],
     rw ["[", "<-", expr (char_p.int_cast_eq_zero_iff (zmod k) k _).mpr this, ",", expr eq_comm, "]"] [],
     exact [expr zmod.int_cast_right_inverse i] },
   { rintro ["⟨", ident ξ, ",", ident i, ",", ident rfl, "⟩"],
     refine [expr ⟨int.cast_add_hom _ i, _⟩],
     rw ["[", expr add_monoid_hom.lift_of_right_inverse_comp_apply, "]"] [],
     refl }
 end)

@[simp]
theorem zmod_equiv_zpowers_apply_coe_int (i : ℤ) :
  h.zmod_equiv_zpowers i = Additive.ofMul (⟨ζ^i, i, rfl⟩ : Subgroup.zpowers ζ) :=
  AddMonoidHom.lift_of_right_inverse_comp_apply _ _ Zmod.int_cast_right_inverse _ _

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[simp]
theorem zmod_equiv_zpowers_apply_coe_nat
(i : exprℕ()) : «expr = »(h.zmod_equiv_zpowers i, additive.of_mul (⟨«expr ^ »(ζ, i), i, rfl⟩ : subgroup.zpowers ζ)) :=
begin
  have [] [":", expr «expr = »((i : zmod k), (i : exprℤ()))] [],
  by norm_cast [],
  simp [] [] ["only"] ["[", expr this, ",", expr zmod_equiv_zpowers_apply_coe_int, ",", expr zpow_coe_nat, "]"] [] [],
  refl
end

@[simp]
theorem zmod_equiv_zpowers_symm_apply_zpow (i : ℤ) :
  h.zmod_equiv_zpowers.symm (Additive.ofMul (⟨ζ^i, i, rfl⟩ : Subgroup.zpowers ζ)) = i :=
  by 
    rw [←h.zmod_equiv_zpowers.symm_apply_apply i, zmod_equiv_zpowers_apply_coe_int]

@[simp]
theorem zmod_equiv_zpowers_symm_apply_zpow' (i : ℤ) : h.zmod_equiv_zpowers.symm ⟨ζ^i, i, rfl⟩ = i :=
  h.zmod_equiv_zpowers_symm_apply_zpow i

@[simp]
theorem zmod_equiv_zpowers_symm_apply_pow (i : ℕ) :
  h.zmod_equiv_zpowers.symm (Additive.ofMul (⟨ζ^i, i, rfl⟩ : Subgroup.zpowers ζ)) = i :=
  by 
    rw [←h.zmod_equiv_zpowers.symm_apply_apply i, zmod_equiv_zpowers_apply_coe_nat]

@[simp]
theorem zmod_equiv_zpowers_symm_apply_pow' (i : ℕ) : h.zmod_equiv_zpowers.symm ⟨ζ^i, i, rfl⟩ = i :=
  h.zmod_equiv_zpowers_symm_apply_pow i

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- If there is a `n`-th primitive root of unity in `R` and `b` divides `n`,
then there is a `b`-th primitive root of unity in `R`. -/
theorem pow
{ζ : R}
{n : exprℕ()}
{a b : exprℕ()}
(hn : «expr < »(0, n))
(h : is_primitive_root ζ n)
(hprod : «expr = »(n, «expr * »(a, b))) : is_primitive_root «expr ^ »(ζ, a) b :=
begin
  subst [expr n],
  simp [] [] ["only"] ["[", expr iff_def, ",", "<-", expr pow_mul, ",", expr h.pow_eq_one, ",", expr eq_self_iff_true, ",", expr true_and, "]"] [] [],
  intros [ident l, ident hl],
  have [ident ha0] [":", expr «expr ≠ »(a, 0)] [],
  { rintro [ident rfl],
    simpa [] [] ["only"] ["[", expr nat.not_lt_zero, ",", expr zero_mul, "]"] [] ["using", expr hn] },
  rwa ["<-", expr mul_dvd_mul_iff_left ha0] [],
  exact [expr h.dvd_of_pow_eq_one _ hl]
end

variable[IsDomain R]

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem zpowers_eq
{k : «exprℕ+»()}
{ζ : units R}
(h : is_primitive_root ζ k) : «expr = »(subgroup.zpowers ζ, roots_of_unity k R) :=
begin
  apply [expr set_like.coe_injective],
  haveI [] [":", expr fact «expr < »(0, (k : exprℕ()))] [":=", expr ⟨k.pos⟩],
  haveI [ident F] [":", expr fintype (subgroup.zpowers ζ)] [":=", expr fintype.of_equiv _ h.zmod_equiv_zpowers.to_equiv],
  refine [expr @set.eq_of_subset_of_card_le (units R) (subgroup.zpowers ζ) (roots_of_unity k R) F (roots_of_unity.fintype R k) «expr $ »(subgroup.zpowers_subset, show «expr ∈ »(ζ, roots_of_unity k R), from h.pow_eq_one) _],
  calc
    «expr ≤ »(fintype.card (roots_of_unity k R), k) : card_roots_of_unity R k
    «expr = »(..., fintype.card (zmod k)) : (zmod.card k).symm
    «expr = »(..., fintype.card (subgroup.zpowers ζ)) : fintype.card_congr h.zmod_equiv_zpowers.to_equiv
end

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem eq_pow_of_mem_roots_of_unity
{k : «exprℕ+»()}
{ζ ξ : units R}
(h : is_primitive_root ζ k)
(hξ : «expr ∈ »(ξ, roots_of_unity k R)) : «expr∃ , »((i : exprℕ())
 (hi : «expr < »(i, k)), «expr = »(«expr ^ »(ζ, i), ξ)) :=
begin
  obtain ["⟨", ident n, ",", ident rfl, "⟩", ":", expr «expr∃ , »((n : exprℤ()), «expr = »(«expr ^ »(ζ, n), ξ))],
  by rwa ["[", "<-", expr h.zpowers_eq, "]"] ["at", ident hξ],
  have [ident hk0] [":", expr «expr < »((0 : exprℤ()), k)] [":=", expr by exact_mod_cast [expr k.pos]],
  let [ident i] [] [":=", expr «expr % »(n, k)],
  have [ident hi0] [":", expr «expr ≤ »(0, i)] [":=", expr int.mod_nonneg _ (ne_of_gt hk0)],
  lift [expr i] ["to", expr exprℕ()] ["using", expr hi0] ["with", ident i₀, ident hi₀],
  refine [expr ⟨i₀, _, _⟩],
  { zify [] [],
    rw ["[", expr hi₀, "]"] [],
    exact [expr int.mod_lt_of_pos _ hk0] },
  { have [ident aux] [] [":=", expr h.zpow_eq_one],
    rw ["[", "<-", expr coe_coe, "]"] ["at", ident aux],
    rw ["[", "<-", expr zpow_coe_nat, ",", expr hi₀, ",", "<-", expr int.mod_add_div n k, ",", expr zpow_add, ",", expr zpow_mul, ",", expr aux, ",", expr one_zpow, ",", expr mul_one, "]"] [] }
end

theorem eq_pow_of_pow_eq_one {k : ℕ} {ζ ξ : R} (h : IsPrimitiveRoot ζ k) (hξ : (ξ^k) = 1) (h0 : 0 < k) :
  ∃ (i : _)(_ : i < k), (ζ^i) = ξ :=
  by 
    obtain ⟨ζ, rfl⟩ := h.is_unit h0 
    obtain ⟨ξ, rfl⟩ := is_unit_of_pow_eq_one ξ k hξ h0 
    obtain ⟨k, rfl⟩ : ∃ k' : ℕ+, k = k' := ⟨⟨k, h0⟩, rfl⟩
    simp only [←Units.coe_pow, ←Units.ext_iff]
    rw [coe_units_iff] at h 
    apply h.eq_pow_of_mem_roots_of_unity 
    rw [mem_roots_of_unity, Units.ext_iff, Units.coe_pow, hξ, Units.coe_one]

theorem is_primitive_root_iff' {k : ℕ+} {ζ ξ : Units R} (h : IsPrimitiveRoot ζ k) :
  IsPrimitiveRoot ξ k ↔ ∃ (i : _)(_ : i < (k : ℕ))(hi : i.coprime k), (ζ^i) = ξ :=
  by 
    split 
    ·
      intro hξ 
      obtain ⟨i, hik, rfl⟩ := h.eq_pow_of_mem_roots_of_unity hξ.pow_eq_one 
      rw [h.pow_iff_coprime k.pos] at hξ 
      exact ⟨i, hik, hξ, rfl⟩
    ·
      rintro ⟨i, -, hi, rfl⟩
      exact h.pow_of_coprime i hi

theorem is_primitive_root_iff {k : ℕ} {ζ ξ : R} (h : IsPrimitiveRoot ζ k) (h0 : 0 < k) :
  IsPrimitiveRoot ξ k ↔ ∃ (i : _)(_ : i < k)(hi : i.coprime k), (ζ^i) = ξ :=
  by 
    split 
    ·
      intro hξ 
      obtain ⟨i, hik, rfl⟩ := h.eq_pow_of_pow_eq_one hξ.pow_eq_one h0 
      rw [h.pow_iff_coprime h0] at hξ 
      exact ⟨i, hik, hξ, rfl⟩
    ·
      rintro ⟨i, -, hi, rfl⟩
      exact h.pow_of_coprime i hi

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem card_roots_of_unity'
{n : «exprℕ+»()}
(h : is_primitive_root ζ n) : «expr = »(fintype.card (roots_of_unity n R), n) :=
begin
  haveI [] [":", expr fact «expr < »(0, «expr↑ »(n))] [":=", expr ⟨n.pos⟩],
  let [ident e] [] [":=", expr h.zmod_equiv_zpowers],
  haveI [ident F] [":", expr fintype (subgroup.zpowers ζ)] [":=", expr fintype.of_equiv _ e.to_equiv],
  calc
    «expr = »(fintype.card (roots_of_unity n R), fintype.card (subgroup.zpowers ζ)) : «expr $ »(fintype.card_congr, by rw [expr h.zpowers_eq] [])
    «expr = »(..., fintype.card (zmod n)) : fintype.card_congr e.to_equiv.symm
    «expr = »(..., n) : zmod.card n
end

theorem card_roots_of_unity {ζ : R} {n : ℕ+} (h : IsPrimitiveRoot ζ n) : Fintype.card (rootsOfUnity n R) = n :=
  by 
    obtain ⟨ζ, hζ⟩ := h.is_unit n.pos 
    rw [←hζ, IsPrimitiveRoot.coe_units_iff] at h 
    exact h.card_roots_of_unity'

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The cardinality of the multiset `nth_roots ↑n (1 : R)` is `n`
if there is a primitive root of unity in `R`. -/
theorem card_nth_roots {ζ : R} {n : exprℕ()} (h : is_primitive_root ζ n) : «expr = »((nth_roots n (1 : R)).card, n) :=
begin
  cases [expr nat.eq_zero_or_pos n] ["with", ident hzero, ident hpos],
  { simp [] [] ["only"] ["[", expr hzero, ",", expr multiset.card_zero, ",", expr nth_roots_zero, "]"] [] [] },
  rw [expr eq_iff_le_not_lt] [],
  use [expr card_nth_roots n 1],
  { rw ["[", expr not_lt, "]"] [],
    have [ident hcard] [":", expr «expr ≤ »(fintype.card {x // «expr ∈ »(x, nth_roots n (1 : R))}, (nth_roots n (1 : R)).attach.card)] [":=", expr multiset.card_le_of_le (multiset.erase_dup_le _)],
    rw [expr multiset.card_attach] ["at", ident hcard],
    rw ["<-", expr pnat.to_pnat'_coe hpos] ["at", ident hcard, ident h, "⊢"],
    set [] [ident m] [] [":="] [expr nat.to_pnat' n] [],
    rw ["[", "<-", expr fintype.card_congr (roots_of_unity_equiv_nth_roots R m), ",", expr card_roots_of_unity h, "]"] ["at", ident hcard],
    exact [expr hcard] }
end

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The multiset `nth_roots ↑n (1 : R)` has no repeated elements
if there is a primitive root of unity in `R`. -/
theorem nth_roots_nodup {ζ : R} {n : exprℕ()} (h : is_primitive_root ζ n) : (nth_roots n (1 : R)).nodup :=
begin
  cases [expr nat.eq_zero_or_pos n] ["with", ident hzero, ident hpos],
  { simp [] [] ["only"] ["[", expr hzero, ",", expr multiset.nodup_zero, ",", expr nth_roots_zero, "]"] [] [] },
  apply [expr (@multiset.erase_dup_eq_self R _ _).1],
  rw [expr eq_iff_le_not_lt] [],
  split,
  { exact [expr multiset.erase_dup_le (nth_roots n (1 : R))] },
  { by_contra [ident ha],
    replace [ident ha] [] [":=", expr multiset.card_lt_of_lt ha],
    rw [expr card_nth_roots h] ["at", ident ha],
    have [ident hrw] [":", expr «expr = »((nth_roots n (1 : R)).erase_dup.card, fintype.card {x // «expr ∈ »(x, nth_roots n (1 : R))})] [],
    { set [] [ident fs] [] [":="] [expr (⟨(nth_roots n (1 : R)).erase_dup, multiset.nodup_erase_dup _⟩ : finset R)] [],
      rw ["[", "<-", expr finset.card_mk, ",", "<-", expr fintype.card_of_subtype fs _, "]"] [],
      intro [ident x],
      simp [] [] ["only"] ["[", expr multiset.mem_erase_dup, ",", expr finset.mem_mk, "]"] [] [] },
    rw ["<-", expr pnat.to_pnat'_coe hpos] ["at", ident h, ident hrw, ident ha],
    set [] [ident m] [] [":="] [expr nat.to_pnat' n] [],
    rw ["[", expr hrw, ",", "<-", expr fintype.card_congr (roots_of_unity_equiv_nth_roots R m), ",", expr card_roots_of_unity h, "]"] ["at", ident ha],
    exact [expr nat.lt_asymm ha ha] }
end

@[simp]
theorem card_nth_roots_finset {ζ : R} {n : ℕ} (h : IsPrimitiveRoot ζ n) : (nth_roots_finset n R).card = n :=
  by 
    rw [nth_roots_finset, ←Multiset.to_finset_eq (nth_roots_nodup h), card_mk, h.card_nth_roots]

open_locale Nat

/-- If an integral domain has a primitive `k`-th root of unity, then it has `φ k` of them. -/
theorem card_primitive_roots {ζ : R} {k : ℕ} (h : IsPrimitiveRoot ζ k) (h0 : 0 < k) : (primitiveRoots k R).card = φ k :=
  by 
    symm 
    refine' Finset.card_congr (fun i _ => ζ^i) _ _ _
    ·
      simp only [true_andₓ, and_imp, mem_filter, mem_range, mem_univ]
      rintro i - hi 
      rw [mem_primitive_roots h0]
      exact h.pow_of_coprime i hi.symm
    ·
      simp only [true_andₓ, and_imp, mem_filter, mem_range, mem_univ]
      rintro i j hi - hj - H 
      exact h.pow_inj hi hj H
    ·
      simp only [exists_prop, true_andₓ, mem_filter, mem_range, mem_univ]
      intro ξ hξ 
      rw [mem_primitive_roots h0, h.is_primitive_root_iff h0] at hξ 
      rcases hξ with ⟨i, hin, hi, H⟩
      exact ⟨i, ⟨hin, hi.symm⟩, H⟩

/-- The sets `primitive_roots k R` are pairwise disjoint. -/
theorem Disjoint {k l : ℕ} (hk : 0 < k) (hl : 0 < l) (h : k ≠ l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=
  by 
    intro z 
    simp only [Finset.inf_eq_inter, Finset.mem_inter, mem_primitive_roots, hk, hl, iff_def]
    rintro ⟨⟨hzk, Hzk⟩, ⟨hzl, Hzl⟩⟩
    applyRules [h, Nat.dvd_antisymm, Hzk, Hzl, hzk, hzl]

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- `nth_roots n` as a `finset` is equal to the union of `primitive_roots i R` for `i ∣ n`
if there is a primitive root of unity in `R`. -/
theorem nth_roots_one_eq_bUnion_primitive_roots'
{ζ : R}
{n : «exprℕ+»()}
(h : is_primitive_root ζ n) : «expr = »(nth_roots_finset n R, (nat.divisors «expr↑ »(n)).bUnion (λ
  i, primitive_roots i R)) :=
begin
  symmetry,
  apply [expr finset.eq_of_subset_of_card_le],
  { intros [ident x],
    simp [] [] ["only"] ["[", expr nth_roots_finset, ",", "<-", expr multiset.to_finset_eq (nth_roots_nodup h), ",", expr exists_prop, ",", expr finset.mem_bUnion, ",", expr finset.mem_filter, ",", expr finset.mem_range, ",", expr mem_nth_roots, ",", expr finset.mem_mk, ",", expr nat.mem_divisors, ",", expr and_true, ",", expr ne.def, ",", expr pnat.ne_zero, ",", expr pnat.pos, ",", expr not_false_iff, "]"] [] [],
    rintro ["⟨", ident a, ",", "⟨", ident d, ",", ident hd, "⟩", ",", ident ha, "⟩"],
    have [ident hazero] [":", expr «expr < »(0, a)] [],
    { contrapose ["!"] [ident hd, "with", ident ha0],
      simp [] [] ["only"] ["[", expr nonpos_iff_eq_zero, ",", expr zero_mul, ",", "*", "]"] [] ["at", "*"],
      exact [expr n.ne_zero] },
    rw [expr mem_primitive_roots hazero] ["at", ident ha],
    rw ["[", expr hd, ",", expr pow_mul, ",", expr ha.pow_eq_one, ",", expr one_pow, "]"] [] },
  { apply [expr le_of_eq],
    rw ["[", expr h.card_nth_roots_finset, ",", expr finset.card_bUnion, "]"] [],
    { rw ["[", "<-", expr nat.sum_totient n, ",", expr nat.filter_dvd_eq_divisors (pnat.ne_zero n), ",", expr sum_congr rfl, "]"] [] { occs := occurrences.pos «expr[ , ]»([1]) },
      simp [] [] ["only"] ["[", expr finset.mem_filter, ",", expr finset.mem_range, ",", expr nat.mem_divisors, "]"] [] [],
      rintro [ident k, "⟨", ident H, ",", ident hk, "⟩"],
      have [ident hdvd] [] [":=", expr H],
      rcases [expr H, "with", "⟨", ident d, ",", ident hd, "⟩"],
      rw [expr mul_comm] ["at", ident hd],
      rw [expr (h.pow n.pos hd).card_primitive_roots (pnat.pos_of_div_pos hdvd)] [] },
    { intros [ident i, ident hi, ident j, ident hj, ident hdiff],
      simp [] [] ["only"] ["[", expr nat.mem_divisors, ",", expr and_true, ",", expr ne.def, ",", expr pnat.ne_zero, ",", expr not_false_iff, "]"] [] ["at", ident hi, ident hj],
      exact [expr disjoint (pnat.pos_of_div_pos hi) (pnat.pos_of_div_pos hj) hdiff] } }
end

/-- `nth_roots n` as a `finset` is equal to the union of `primitive_roots i R` for `i ∣ n`
if there is a primitive root of unity in `R`. -/
theorem nth_roots_one_eq_bUnion_primitive_roots {ζ : R} {n : ℕ} (hpos : 0 < n) (h : IsPrimitiveRoot ζ n) :
  nth_roots_finset n R = (Nat.divisors n).bUnion fun i => primitiveRoots i R :=
  @nth_roots_one_eq_bUnion_primitive_roots' _ _ _ _ ⟨n, hpos⟩ h

end IsDomain

section minpoly

open minpoly

variable{n : ℕ}{K : Type _}[Field K]{μ : K}(h : IsPrimitiveRoot μ n)(hpos : 0 < n)

include n μ h hpos

/--`μ` is integral over `ℤ`. -/
theorem IsIntegral : IsIntegral ℤ μ :=
  by 
    use (X^n) - 1
    split 
    ·
      exact monic_X_pow_sub_C 1 (ne_of_ltₓ hpos).symm
    ·
      simp only [((IsPrimitiveRoot.iff_def μ n).mp h).left, eval₂_one, eval₂_X_pow, eval₂_sub, sub_self]

variable[CharZero K]

/--The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. -/
theorem minpoly_dvd_X_pow_sub_one : minpoly ℤ μ ∣ (X^n) - 1 :=
  by 
    apply
      minpoly.gcd_domain_dvd ℚ (IsIntegral h hpos)
        (Polynomial.Monic.is_primitive (monic_X_pow_sub_C 1 (ne_of_ltₓ hpos).symm))
    simp only [((IsPrimitiveRoot.iff_def μ n).mp h).left, aeval_X_pow, RingHom.eq_int_cast, Int.cast_one, aeval_one,
      AlgHom.map_sub, sub_self]

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is separable. -/
theorem separable_minpoly_mod
{p : exprℕ()}
[fact p.prime]
(hdiv : «expr¬ »(«expr ∣ »(p, n))) : separable (map (int.cast_ring_hom (zmod p)) (minpoly exprℤ() μ)) :=
begin
  have [ident hdvd] [":", expr «expr ∣ »(map (int.cast_ring_hom (zmod p)) (minpoly exprℤ() μ), «expr - »(«expr ^ »(X, n), 1))] [],
  { simpa [] [] [] ["[", expr map_pow, ",", expr map_X, ",", expr map_one, ",", expr map_sub, "]"] [] ["using", expr ring_hom.map_dvd (map_ring_hom (int.cast_ring_hom (zmod p))) (minpoly_dvd_X_pow_sub_one h hpos)] },
  refine [expr separable.of_dvd (separable_X_pow_sub_C 1 _ one_ne_zero) hdvd],
  by_contra [ident hzero],
  exact [expr hdiv ((zmod.nat_coe_zmod_eq_zero_iff_dvd n p).1 hzero)]
end

/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/
theorem squarefree_minpoly_mod {p : ℕ} [Fact p.prime] (hdiv : ¬p ∣ n) :
  Squarefree (map (Int.castRingHom (Zmod p)) (minpoly ℤ μ)) :=
  (separable_minpoly_mod h hpos hdiv).Squarefree

theorem minpoly_dvd_expand {p : ℕ} (hprime : Nat.Prime p) (hdiv : ¬p ∣ n) :
  minpoly ℤ μ ∣ expand ℤ p (minpoly ℤ (μ^p)) :=
  by 
    apply minpoly.gcd_domain_dvd ℚ (h.is_integral hpos)
    ·
      apply monic.is_primitive 
      rw [Polynomial.Monic, leading_coeff, nat_degree_expand, mul_commₓ, coeff_expand_mul' (Nat.Prime.pos hprime),
        ←leading_coeff, ←Polynomial.Monic]
      exact minpoly.monic (IsIntegral (pow_of_prime h hprime hdiv) hpos)
    ·
      rw [aeval_def, coe_expand, ←comp, eval₂_eq_eval_map, map_comp, map_pow, map_X, eval_comp, eval_pow, eval_X,
        ←eval₂_eq_eval_map, ←aeval_def]
      exact minpoly.aeval _ _

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem minpoly_dvd_pow_mod
{p : exprℕ()}
[hprime : fact p.prime]
(hdiv : «expr¬ »(«expr ∣ »(p, n))) : «expr ∣ »(map (int.cast_ring_hom (zmod p)) (minpoly exprℤ() μ), «expr ^ »(map (int.cast_ring_hom (zmod p)) (minpoly exprℤ() «expr ^ »(μ, p)), p)) :=
begin
  set [] [ident Q] [] [":="] [expr minpoly exprℤ() «expr ^ »(μ, p)] [],
  have [ident hfrob] [":", expr «expr = »(«expr ^ »(map (int.cast_ring_hom (zmod p)) Q, p), map (int.cast_ring_hom (zmod p)) (expand exprℤ() p Q))] [],
  by rw ["[", "<-", expr zmod.expand_card, ",", expr map_expand hprime.1.pos, "]"] [],
  rw ["[", expr hfrob, "]"] [],
  apply [expr ring_hom.map_dvd (map_ring_hom (int.cast_ring_hom (zmod p)))],
  exact [expr minpoly_dvd_expand h hpos hprime.1 hdiv]
end

theorem minpoly_dvd_mod_p {p : ℕ} [hprime : Fact p.prime] (hdiv : ¬p ∣ n) :
  map (Int.castRingHom (Zmod p)) (minpoly ℤ μ) ∣ map (Int.castRingHom (Zmod p)) (minpoly ℤ (μ^p)) :=
  (UniqueFactorizationMonoid.dvd_pow_iff_dvd_of_squarefree (squarefree_minpoly_mod h hpos hdiv) hprime.1.ne_zero).1
    (minpoly_dvd_pow_mod h hpos hdiv)

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- If `p` is a prime that does not divide `n`,
then the minimal polynomials of a primitive `n`-th root of unity `μ`
and of `μ ^ p` are the same. -/
theorem minpoly_eq_pow
{p : exprℕ()}
[hprime : fact p.prime]
(hdiv : «expr¬ »(«expr ∣ »(p, n))) : «expr = »(minpoly exprℤ() μ, minpoly exprℤ() «expr ^ »(μ, p)) :=
begin
  by_contra [ident hdiff],
  set [] [ident P] [] [":="] [expr minpoly exprℤ() μ] [],
  set [] [ident Q] [] [":="] [expr minpoly exprℤ() «expr ^ »(μ, p)] [],
  have [ident Pmonic] [":", expr P.monic] [":=", expr minpoly.monic (h.is_integral hpos)],
  have [ident Qmonic] [":", expr Q.monic] [":=", expr minpoly.monic ((h.pow_of_prime hprime.1 hdiv).is_integral hpos)],
  have [ident Pirr] [":", expr irreducible P] [":=", expr minpoly.irreducible (h.is_integral hpos)],
  have [ident Qirr] [":", expr irreducible Q] [":=", expr minpoly.irreducible ((h.pow_of_prime hprime.1 hdiv).is_integral hpos)],
  have [ident PQprim] [":", expr is_primitive «expr * »(P, Q)] [":=", expr Pmonic.is_primitive.mul Qmonic.is_primitive],
  have [ident prod] [":", expr «expr ∣ »(«expr * »(P, Q), «expr - »(«expr ^ »(X, n), 1))] [],
  { rw ["[", expr is_primitive.int.dvd_iff_map_cast_dvd_map_cast «expr * »(P, Q) «expr - »(«expr ^ »(X, n), 1) PQprim (monic_X_pow_sub_C (1 : exprℤ()) (ne_of_gt hpos)).is_primitive, ",", expr map_mul, "]"] [],
    refine [expr is_coprime.mul_dvd _ _ _],
    { have [ident aux] [] [":=", expr is_primitive.int.irreducible_iff_irreducible_map_cast Pmonic.is_primitive],
      refine [expr (dvd_or_coprime _ _ (aux.1 Pirr)).resolve_left _],
      rw [expr map_dvd_map (int.cast_ring_hom exprℚ()) int.cast_injective Pmonic] [],
      intro [ident hdiv],
      refine [expr hdiff (eq_of_monic_of_associated Pmonic Qmonic _)],
      exact [expr associated_of_dvd_dvd hdiv (Pirr.dvd_symm Qirr hdiv)] },
    { apply [expr (map_dvd_map (int.cast_ring_hom exprℚ()) int.cast_injective Pmonic).2],
      exact [expr minpoly_dvd_X_pow_sub_one h hpos] },
    { apply [expr (map_dvd_map (int.cast_ring_hom exprℚ()) int.cast_injective Qmonic).2],
      exact [expr minpoly_dvd_X_pow_sub_one (pow_of_prime h hprime.1 hdiv) hpos] } },
  replace [ident prod] [] [":=", expr ring_hom.map_dvd (map_ring_hom (int.cast_ring_hom (zmod p))) prod],
  rw ["[", expr coe_map_ring_hom, ",", expr map_mul, ",", expr map_sub, ",", expr map_one, ",", expr map_pow, ",", expr map_X, "]"] ["at", ident prod],
  obtain ["⟨", ident R, ",", ident hR, "⟩", ":=", expr minpoly_dvd_mod_p h hpos hdiv],
  rw ["[", expr hR, ",", "<-", expr mul_assoc, ",", "<-", expr map_mul, ",", "<-", expr sq, ",", expr map_pow, "]"] ["at", ident prod],
  have [ident habs] [":", expr «expr ∣ »(«expr ^ »(map (int.cast_ring_hom (zmod p)) P, 2), «expr * »(«expr ^ »(map (int.cast_ring_hom (zmod p)) P, 2), R))] [],
  { use [expr R] },
  replace [ident habs] [] [":=", expr lt_of_lt_of_le (enat.coe_lt_coe.2 one_lt_two) (multiplicity.le_multiplicity_of_pow_dvd (dvd_trans habs prod))],
  have [ident hfree] [":", expr squarefree («expr - »(«expr ^ »(X, n), 1) : polynomial (zmod p))] [],
  { exact [expr (separable_X_pow_sub_C 1 (λ
       h, «expr $ »(hdiv, (zmod.nat_coe_zmod_eq_zero_iff_dvd n p).1 h)) one_ne_zero).squarefree] },
  cases [expr (multiplicity.squarefree_iff_multiplicity_le_one «expr - »(«expr ^ »(X, n), 1)).1 hfree (map (int.cast_ring_hom (zmod p)) P)] ["with", ident hle, ident hunit],
  { rw [expr nat.cast_one] ["at", ident habs],
    exact [expr hle.not_lt habs] },
  { replace [ident hunit] [] [":=", expr degree_eq_zero_of_is_unit hunit],
    rw [expr degree_map_eq_of_leading_coeff_ne_zero (int.cast_ring_hom (zmod p)) _] ["at", ident hunit],
    { exact [expr (minpoly.degree_pos (is_integral h hpos)).ne' hunit] },
    simp [] [] ["only"] ["[", expr Pmonic, ",", expr ring_hom.eq_int_cast, ",", expr monic.leading_coeff, ",", expr int.cast_one, ",", expr ne.def, ",", expr not_false_iff, ",", expr one_ne_zero, "]"] [] [] }
end

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- If `m : ℕ` is coprime with `n`,
then the minimal polynomials of a primitive `n`-th root of unity `μ`
and of `μ ^ m` are the same. -/
theorem minpoly_eq_pow_coprime
{m : exprℕ()}
(hcop : nat.coprime m n) : «expr = »(minpoly exprℤ() μ, minpoly exprℤ() «expr ^ »(μ, m)) :=
begin
  revert [ident n, ident hcop],
  refine [expr unique_factorization_monoid.induction_on_prime m _ _ _],
  { intros [ident n, ident hn, ident h, ident hpos],
    congr,
    simpa [] [] [] ["[", expr (nat.coprime_zero_left n).mp hn, "]"] [] ["using", expr h] },
  { intros [ident u, ident hunit, ident n, ident hcop, ident h, ident hpos],
    congr,
    simp [] [] [] ["[", expr nat.is_unit_iff.mp hunit, "]"] [] [] },
  { intros [ident a, ident p, ident ha, ident hprime, ident hind, ident n, ident hcop, ident h, ident hpos],
    rw [expr hind (nat.coprime.coprime_mul_left hcop) h hpos] [],
    clear [ident hind],
    replace [ident hprime] [] [":=", expr nat.prime_iff.2 hprime],
    have [ident hdiv] [] [":=", expr (nat.prime.coprime_iff_not_dvd hprime).1 (nat.coprime.coprime_mul_right hcop)],
    haveI [] [] [":=", expr fact.mk hprime],
    rw ["[", expr minpoly_eq_pow (h.pow_of_coprime a (nat.coprime.coprime_mul_left hcop)) hpos hdiv, "]"] [],
    congr' [1] [],
    ring_exp [] [] }
end

/-- If `m : ℕ` is coprime with `n`,
then the minimal polynomial of a primitive `n`-th root of unity `μ`
has `μ ^ m` as root. -/
theorem pow_is_root_minpoly {m : ℕ} (hcop : Nat.Coprime m n) : is_root (map (Int.castRingHom K) (minpoly ℤ μ)) (μ^m) :=
  by 
    simpa [minpoly_eq_pow_coprime h hpos hcop, eval_map, aeval_def (μ^m) _] using minpoly.aeval ℤ (μ^m)

/-- `primitive_roots n K` is a subset of the roots of the minimal polynomial of a primitive
`n`-th root of unity `μ`. -/
theorem is_roots_of_minpoly : primitiveRoots n K ⊆ (map (Int.castRingHom K) (minpoly ℤ μ)).roots.toFinset :=
  by 
    intro x hx 
    obtain ⟨m, hle, hcop, rfl⟩ := (is_primitive_root_iff h hpos).1 ((mem_primitive_roots hpos).1 hx)
    simpa [Multiset.mem_to_finset, mem_roots (map_monic_ne_zero$ minpoly.monic$ IsIntegral h hpos)] using
      pow_is_root_minpoly h hpos hcop

/-- The degree of the minimal polynomial of `μ` is at least `totient n`. -/
theorem totient_le_degree_minpoly : Nat.totient n ≤ (minpoly ℤ μ).natDegree :=
  let P : Polynomial ℤ := minpoly ℤ μ 
  let P_K : Polynomial K := map (Int.castRingHom K) P 
  calc n.totient = (primitiveRoots n K).card := (h.card_primitive_roots hpos).symm 
    _ ≤ P_K.roots.to_finset.card := Finset.card_le_of_subset (is_roots_of_minpoly h hpos)
    _ ≤ P_K.roots.card := Multiset.to_finset_card_le _ 
    _ ≤ P_K.nat_degree := card_roots'$ map_monic_ne_zero (minpoly.monic$ IsIntegral h hpos)
    _ ≤ P.nat_degree := nat_degree_map_le _ _
    

end minpoly

end IsPrimitiveRoot

