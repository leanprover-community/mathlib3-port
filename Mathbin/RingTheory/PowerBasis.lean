import Mathbin.FieldTheory.Minpoly

/-!
# Power basis

This file defines a structure `power_basis R S`, giving a basis of the
`R`-algebra `S` as a finite list of powers `1, x, ..., x^n`.
For example, if `x` is algebraic over a ring/field, adjoining `x`
gives a `power_basis` structure generated by `x`.

## Definitions

* `power_basis R A`: a structure containing an `x` and an `n` such that
`1, x, ..., x^n` is a basis for the `R`-algebra `A` (viewed as an `R`-module).

* `finrank (hf : f ≠ 0) : finite_dimensional.finrank K (adjoin_root f) = f.nat_degree`,
  the dimension of `adjoin_root f` equals the degree of `f`

* `power_basis.lift (pb : power_basis R S)`: if `y : S'` satisfies the same
  equations as `pb.gen`, this is the map `S →ₐ[R] S'` sending `pb.gen` to `y`

* `power_basis.equiv`: if two power bases satisfy the same equations, they are
  equivalent as algebras

## Implementation notes

Throughout this file, `R`, `S`, ... are `comm_ring`s, `A`, `B`, ... are
`comm_ring` with `is_domain`s and `K`, `L`, ... are `field`s.
`S` is an `R`-algebra, `B` is an `A`-algebra, `L` is a `K`-algebra.

## Tags

power basis, powerbasis

-/


open Polynomial

variable {R S T : Type _} [CommRingₓ R] [CommRingₓ S] [CommRingₓ T]

variable [Algebra R S] [Algebra S T] [Algebra R T] [IsScalarTower R S T]

variable {A B : Type _} [CommRingₓ A] [CommRingₓ B] [IsDomain B] [Algebra A B]

variable {K L : Type _} [Field K] [Field L] [Algebra K L]

/-- `pb : power_basis R S` states that `1, pb.gen, ..., pb.gen ^ (pb.dim - 1)`
is a basis for the `R`-algebra `S` (viewed as `R`-module).

This is a structure, not a class, since the same algebra can have many power bases.
For the common case where `S` is defined by adjoining an integral element to `R`,
the canonical power basis is given by `{algebra,intermediate_field}.adjoin.power_basis`.
-/
@[nolint has_inhabited_instance]
structure PowerBasis (R S : Type _) [CommRingₓ R] [Ringₓ S] [Algebra R S] where 
  gen : S 
  dim : ℕ 
  Basis : Basis (Finₓ dim) R S 
  basis_eq_pow : ∀ i, Basis i = (gen^(i : ℕ))

namespace PowerBasis

@[simp]
theorem coe_basis (pb : PowerBasis R S) : «expr⇑ » pb.basis = fun i : Finₓ pb.dim => pb.gen^(i : ℕ) :=
  funext pb.basis_eq_pow

/-- Cannot be an instance because `power_basis` cannot be a class. -/
theorem FiniteDimensional [Algebra K S] (pb : PowerBasis K S) : FiniteDimensional K S :=
  FiniteDimensional.of_fintype_basis pb.basis

theorem finrank [Algebra K S] (pb : PowerBasis K S) : FiniteDimensional.finrank K S = pb.dim :=
  by 
    rw [FiniteDimensional.finrank_eq_card_basis pb.basis, Fintype.card_fin]

-- error in RingTheory.PowerBasis: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem mem_span_pow'
{x y : S}
{d : exprℕ()} : «expr ↔ »(«expr ∈ »(y, submodule.span R (set.range (λ
    i : fin d, «expr ^ »(x, (i : exprℕ()))))), «expr∃ , »((f : polynomial R), «expr ∧ »(«expr < »(f.degree, d), «expr = »(y, aeval x f)))) :=
begin
  have [] [":", expr «expr = »(set.range (λ
     i : fin d, «expr ^ »(x, (i : exprℕ()))), «expr '' »(λ i : exprℕ(), «expr ^ »(x, i), «expr↑ »(finset.range d)))] [],
  { ext [] [ident n] [],
    simp_rw ["[", expr set.mem_range, ",", expr set.mem_image, ",", expr finset.mem_coe, ",", expr finset.mem_range, "]"] [],
    exact [expr ⟨λ ⟨⟨i, hi⟩, hy⟩, ⟨i, hi, hy⟩, λ ⟨i, hi, hy⟩, ⟨⟨i, hi⟩, hy⟩⟩] },
  simp [] [] ["only"] ["[", expr this, ",", expr finsupp.mem_span_image_iff_total, ",", expr degree_lt_iff_coeff_zero, ",", expr exists_iff_exists_finsupp, ",", expr coeff, ",", expr aeval, ",", expr eval₂_ring_hom', ",", expr eval₂_eq_sum, ",", expr polynomial.sum, ",", expr support, ",", expr finsupp.mem_supported', ",", expr finsupp.total, ",", expr finsupp.sum, ",", expr algebra.smul_def, ",", expr eval₂_zero, ",", expr exists_prop, ",", expr linear_map.id_coe, ",", expr eval₂_one, ",", expr id.def, ",", expr not_lt, ",", expr finsupp.coe_lsum, ",", expr linear_map.coe_smul_right, ",", expr finset.mem_range, ",", expr alg_hom.coe_mk, ",", expr finset.mem_coe, "]"] [] [],
  simp_rw ["[", expr @eq_comm _ y, "]"] [],
  exact [expr iff.rfl]
end

theorem mem_span_pow {x y : S} {d : ℕ} (hd : d ≠ 0) :
  y ∈ Submodule.span R (Set.Range fun i : Finₓ d => x^(i : ℕ)) ↔ ∃ f : Polynomial R, f.nat_degree < d ∧ y = aeval x f :=
  by 
    rw [mem_span_pow']
    split  <;>
      ·
        rintro ⟨f, h, hy⟩
        refine' ⟨f, _, hy⟩
        byCases' hf : f = 0
        ·
          simp only [hf, nat_degree_zero, degree_zero] at h⊢
          first |
            exact lt_of_le_of_neₓ (Nat.zero_leₓ d) hd.symm|
            exact WithBot.bot_lt_coe d 
        simpa only [degree_eq_nat_degree hf, WithBot.coe_lt_coe] using h

theorem dim_ne_zero [h : Nontrivial S] (pb : PowerBasis R S) : pb.dim ≠ 0 :=
  fun h => not_nonempty_iff.mpr (h.symm ▸ Finₓ.is_empty : IsEmpty (Finₓ pb.dim)) pb.basis.index_nonempty

theorem dim_pos [Nontrivial S] (pb : PowerBasis R S) : 0 < pb.dim :=
  Nat.pos_of_ne_zeroₓ pb.dim_ne_zero

theorem exists_eq_aeval [Nontrivial S] (pb : PowerBasis R S) (y : S) :
  ∃ f : Polynomial R, f.nat_degree < pb.dim ∧ y = aeval pb.gen f :=
  (mem_span_pow pb.dim_ne_zero).mp
    (by 
      simpa using pb.basis.mem_span y)

theorem exists_eq_aeval' (pb : PowerBasis R S) (y : S) : ∃ f : Polynomial R, y = aeval pb.gen f :=
  by 
    nontriviality S 
    obtain ⟨f, _, hf⟩ := exists_eq_aeval pb y 
    exact ⟨f, hf⟩

theorem alg_hom_ext {S' : Type _} [Semiringₓ S'] [Algebra R S'] (pb : PowerBasis R S) ⦃f g : S →ₐ[R] S'⦄
  (h : f pb.gen = g pb.gen) : f = g :=
  by 
    ext x 
    obtain ⟨f, rfl⟩ := pb.exists_eq_aeval' x 
    rw [←Polynomial.aeval_alg_hom_apply, ←Polynomial.aeval_alg_hom_apply, h]

section minpoly

open_locale BigOperators

variable [Algebra A S]

/-- `pb.minpoly_gen` is a minimal polynomial for `pb.gen`.

If `A` is not a field, it might not necessarily be *the* minimal polynomial,
however `nat_degree_minpoly` shows its degree is indeed minimal.
-/
noncomputable def minpoly_gen (pb : PowerBasis A S) : Polynomial A :=
  (X^pb.dim) - ∑i : Finₓ pb.dim, C (pb.basis.repr (pb.gen^pb.dim) i)*X^(i : ℕ)

@[simp]
theorem aeval_minpoly_gen (pb : PowerBasis A S) : aeval pb.gen (minpoly_gen pb) = 0 :=
  by 
    simpRw [minpoly_gen, AlgHom.map_sub, AlgHom.map_sum, AlgHom.map_mul, AlgHom.map_pow, aeval_C, ←Algebra.smul_def,
      aeval_X]
    refine' sub_eq_zero.mpr ((pb.basis.total_repr (pb.gen^pb.dim)).symm.trans _)
    rw [Finsupp.total_apply, Finsupp.sum_fintype] <;>
      simp only [pb.coe_basis, zero_smul, eq_self_iff_true, implies_true_iff]

theorem dim_le_nat_degree_of_root (h : PowerBasis A S) {p : Polynomial A} (ne_zero : p ≠ 0) (root : aeval h.gen p = 0) :
  h.dim ≤ p.nat_degree :=
  by 
    refine' le_of_not_ltₓ fun hlt => ne_zero _ 
    let p_coeff : Finₓ h.dim → A := fun i => p.coeff i 
    suffices  : ∀ i, p_coeff i = 0
    ·
      ext i 
      byCases' hi : i < h.dim
      ·
        exact this ⟨i, hi⟩
      exact coeff_eq_zero_of_nat_degree_lt (lt_of_lt_of_leₓ hlt (le_of_not_gtₓ hi))
    intro i 
    refine' linear_independent_iff'.mp h.basis.linear_independent _ _ _ i (Finset.mem_univ _)
    rw [aeval_eq_sum_range' hlt] at root 
    rw [Finset.sum_fin_eq_sum_range]
    convert root 
    ext i 
    splitIfs with hi
    ·
      simpRw [coe_basis, p_coeff, Finₓ.coe_mk]
    ·
      rw [coeff_eq_zero_of_nat_degree_lt (lt_of_lt_of_leₓ hlt (le_of_not_gtₓ hi)), zero_smul]

theorem dim_le_degree_of_root (h : PowerBasis A S) {p : Polynomial A} (ne_zero : p ≠ 0) (root : aeval h.gen p = 0) :
  «expr↑ » h.dim ≤ p.degree :=
  by 
    rw [degree_eq_nat_degree ne_zero, WithBot.coe_le_coe]
    exact h.dim_le_nat_degree_of_root ne_zero root

variable [IsDomain A]

@[simp]
theorem degree_minpoly_gen (pb : PowerBasis A S) : degree (minpoly_gen pb) = pb.dim :=
  by 
    unfold minpoly_gen 
    rw [degree_sub_eq_left_of_degree_lt] <;> rw [degree_X_pow]
    apply degree_sum_fin_lt

@[simp]
theorem nat_degree_minpoly_gen (pb : PowerBasis A S) : nat_degree (minpoly_gen pb) = pb.dim :=
  nat_degree_eq_of_degree_eq_some pb.degree_minpoly_gen

theorem minpoly_gen_monic (pb : PowerBasis A S) : monic (minpoly_gen pb) :=
  by 
    apply monic_sub_of_left (monic_pow monic_X _)
    rw [degree_X_pow]
    exact degree_sum_fin_lt _

theorem is_integral_gen (pb : PowerBasis A S) : IsIntegral A pb.gen :=
  ⟨minpoly_gen pb, minpoly_gen_monic pb, aeval_minpoly_gen pb⟩

@[simp]
theorem nat_degree_minpoly (pb : PowerBasis A S) : (minpoly A pb.gen).natDegree = pb.dim :=
  by 
    refine' le_antisymmₓ _ (dim_le_nat_degree_of_root pb (minpoly.ne_zero pb.is_integral_gen) (minpoly.aeval _ _))
    rw [←nat_degree_minpoly_gen]
    apply nat_degree_le_of_degree_le 
    rw [←degree_eq_nat_degree (minpoly_gen_monic pb).ne_zero]
    exact minpoly.min _ _ (minpoly_gen_monic pb) (aeval_minpoly_gen pb)

@[simp]
theorem minpoly_gen_eq [Algebra K S] (pb : PowerBasis K S) : pb.minpoly_gen = minpoly K pb.gen :=
  minpoly.unique K pb.gen pb.minpoly_gen_monic pb.aeval_minpoly_gen
    fun p p_monic p_root => pb.degree_minpoly_gen.symm ▸ pb.dim_le_degree_of_root p_monic.ne_zero p_root

end minpoly

section Equiv

variable [Algebra A S] {S' : Type _} [CommRingₓ S'] [Algebra A S']

-- error in RingTheory.PowerBasis: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem nat_degree_lt_nat_degree
{p q : polynomial R}
(hp : «expr ≠ »(p, 0))
(hpq : «expr < »(p.degree, q.degree)) : «expr < »(p.nat_degree, q.nat_degree) :=
begin
  by_cases [expr hq, ":", expr «expr = »(q, 0)],
  { rw ["[", expr hq, ",", expr degree_zero, "]"] ["at", ident hpq],
    have [] [] [":=", expr not_lt_bot hpq],
    contradiction },
  rwa ["[", expr degree_eq_nat_degree hp, ",", expr degree_eq_nat_degree hq, ",", expr with_bot.coe_lt_coe, "]"] ["at", ident hpq]
end

variable [IsDomain A]

-- error in RingTheory.PowerBasis: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem constr_pow_aeval
(pb : power_basis A S)
{y : S'}
(hy : «expr = »(aeval y (minpoly A pb.gen), 0))
(f : polynomial A) : «expr = »(pb.basis.constr A (λ i, «expr ^ »(y, (i : exprℕ()))) (aeval pb.gen f), aeval y f) :=
begin
  rw ["[", "<-", expr aeval_mod_by_monic_eq_self_of_root (minpoly.monic pb.is_integral_gen) (minpoly.aeval _ _), ",", "<-", expr @aeval_mod_by_monic_eq_self_of_root _ _ _ _ _ f _ (minpoly.monic pb.is_integral_gen) y hy, "]"] [],
  by_cases [expr hf, ":", expr «expr = »(«expr %ₘ »(f, minpoly A pb.gen), 0)],
  { simp [] [] ["only"] ["[", expr hf, ",", expr alg_hom.map_zero, ",", expr linear_map.map_zero, "]"] [] [] },
  have [] [":", expr «expr < »(«expr %ₘ »(f, minpoly A pb.gen).nat_degree, pb.dim)] [],
  { rw ["<-", expr pb.nat_degree_minpoly] [],
    apply [expr nat_degree_lt_nat_degree hf],
    exact [expr degree_mod_by_monic_lt _ (minpoly.monic pb.is_integral_gen)] },
  rw ["[", expr aeval_eq_sum_range' this, ",", expr aeval_eq_sum_range' this, ",", expr linear_map.map_sum, "]"] [],
  refine [expr finset.sum_congr rfl (λ (i) (hi : «expr ∈ »(i, finset.range pb.dim)), _)],
  rw [expr finset.mem_range] ["at", ident hi],
  rw [expr linear_map.map_smul] [],
  congr,
  rw ["[", "<-", expr fin.coe_mk hi, ",", "<-", expr pb.basis_eq_pow ⟨i, hi⟩, ",", expr basis.constr_basis, "]"] []
end

theorem constr_pow_gen (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0) :
  pb.basis.constr A (fun i => y^(i : ℕ)) pb.gen = y :=
  by 
    convert pb.constr_pow_aeval hy X <;> rw [aeval_X]

theorem constr_pow_algebra_map (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0) (x : A) :
  pb.basis.constr A (fun i => y^(i : ℕ)) (algebraMap A S x) = algebraMap A S' x :=
  by 
    convert pb.constr_pow_aeval hy (C x) <;> rw [aeval_C]

theorem constr_pow_mul (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0) (x x' : S) :
  pb.basis.constr A (fun i => y^(i : ℕ)) (x*x') =
    pb.basis.constr A (fun i => y^(i : ℕ)) x*pb.basis.constr A (fun i => y^(i : ℕ)) x' :=
  by 
    obtain ⟨f, rfl⟩ := pb.exists_eq_aeval' x 
    obtain ⟨g, rfl⟩ := pb.exists_eq_aeval' x' 
    simp only [←aeval_mul, pb.constr_pow_aeval hy]

/-- `pb.lift y hy` is the algebra map sending `pb.gen` to `y`,
where `hy` states the higher powers of `y` are the same as the higher powers of `pb.gen`.

See `power_basis.lift_equiv` for a bundled equiv sending `⟨y, hy⟩` to the algebra map.
-/
noncomputable def lift (pb : PowerBasis A S) (y : S') (hy : aeval y (minpoly A pb.gen) = 0) : S →ₐ[A] S' :=
  { pb.basis.constr A fun i => y^(i : ℕ) with
    map_one' :=
      by 
        convert pb.constr_pow_algebra_map hy 1 using 2 <;> rw [RingHom.map_one],
    map_zero' :=
      by 
        convert pb.constr_pow_algebra_map hy 0 using 2 <;> rw [RingHom.map_zero],
    map_mul' := pb.constr_pow_mul hy, commutes' := pb.constr_pow_algebra_map hy }

@[simp]
theorem lift_gen (pb : PowerBasis A S) (y : S') (hy : aeval y (minpoly A pb.gen) = 0) : pb.lift y hy pb.gen = y :=
  pb.constr_pow_gen hy

@[simp]
theorem lift_aeval (pb : PowerBasis A S) (y : S') (hy : aeval y (minpoly A pb.gen) = 0) (f : Polynomial A) :
  pb.lift y hy (aeval pb.gen f) = aeval y f :=
  pb.constr_pow_aeval hy f

/-- `pb.lift_equiv` states that roots of the minimal polynomial of `pb.gen` correspond to
maps sending `pb.gen` to that root.

This is the bundled equiv version of `power_basis.lift`.
If the codomain of the `alg_hom`s is an integral domain, then the roots form a multiset,
see `lift_equiv'` for the corresponding statement.
-/
@[simps]
noncomputable def lift_equiv (pb : PowerBasis A S) : (S →ₐ[A] S') ≃ { y : S' // aeval y (minpoly A pb.gen) = 0 } :=
  { toFun :=
      fun f =>
        ⟨f pb.gen,
          by 
            rw [aeval_alg_hom_apply, minpoly.aeval, f.map_zero]⟩,
    invFun := fun y => pb.lift y y.2, left_inv := fun f => pb.alg_hom_ext$ lift_gen _ _ _,
    right_inv := fun y => Subtype.ext$ lift_gen _ _ y.prop }

/-- `pb.lift_equiv'` states that elements of the root set of the minimal
polynomial of `pb.gen` correspond to maps sending `pb.gen` to that root. -/
@[simps (config := { fullyApplied := ff })]
noncomputable def lift_equiv' (pb : PowerBasis A S) :
  (S →ₐ[A] B) ≃ { y : B // y ∈ ((minpoly A pb.gen).map (algebraMap A B)).roots } :=
  pb.lift_equiv.trans
    ((Equiv.refl _).subtypeEquiv
      fun x =>
        by 
          rw [mem_roots, is_root.def, Equiv.refl_apply, ←eval₂_eq_eval_map, ←aeval_def]
          exact map_monic_ne_zero (minpoly.monic pb.is_integral_gen))

-- error in RingTheory.PowerBasis: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- There are finitely many algebra homomorphisms `S →ₐ[A] B` if `S` is of the form `A[x]`
and `B` is an integral domain. -/
noncomputable
def alg_hom.fintype (pb : power_basis A S) : fintype «expr →ₐ[ ] »(S, A, B) :=
by letI [] [] [":=", expr classical.dec_eq B]; exact [expr fintype.of_equiv _ pb.lift_equiv'.symm]

/-- `pb.equiv_of_root pb' h₁ h₂` is an equivalence of algebras with the same power basis,
where "the same" means that `pb` is a root of `pb'`s minimal polynomial and vice versa.

See also `power_basis.equiv_of_minpoly` which takes the hypothesis that the
minimal polynomials are identical.
-/
noncomputable def equiv_of_root (pb : PowerBasis A S) (pb' : PowerBasis A S')
  (h₁ : aeval pb.gen (minpoly A pb'.gen) = 0) (h₂ : aeval pb'.gen (minpoly A pb.gen) = 0) : S ≃ₐ[A] S' :=
  AlgEquiv.ofAlgHom (pb.lift pb'.gen h₂) (pb'.lift pb.gen h₁)
    (by 
      ext x 
      obtain ⟨f, hf, rfl⟩ := pb'.exists_eq_aeval' x 
      simp )
    (by 
      ext x 
      obtain ⟨f, hf, rfl⟩ := pb.exists_eq_aeval' x 
      simp )

@[simp]
theorem equiv_of_root_aeval (pb : PowerBasis A S) (pb' : PowerBasis A S') (h₁ : aeval pb.gen (minpoly A pb'.gen) = 0)
  (h₂ : aeval pb'.gen (minpoly A pb.gen) = 0) (f : Polynomial A) :
  pb.equiv_of_root pb' h₁ h₂ (aeval pb.gen f) = aeval pb'.gen f :=
  pb.lift_aeval _ h₂ _

@[simp]
theorem equiv_of_root_gen (pb : PowerBasis A S) (pb' : PowerBasis A S') (h₁ : aeval pb.gen (minpoly A pb'.gen) = 0)
  (h₂ : aeval pb'.gen (minpoly A pb.gen) = 0) : pb.equiv_of_root pb' h₁ h₂ pb.gen = pb'.gen :=
  pb.lift_gen _ h₂

@[simp]
theorem equiv_of_root_symm (pb : PowerBasis A S) (pb' : PowerBasis A S') (h₁ : aeval pb.gen (minpoly A pb'.gen) = 0)
  (h₂ : aeval pb'.gen (minpoly A pb.gen) = 0) : (pb.equiv_of_root pb' h₁ h₂).symm = pb'.equiv_of_root pb h₂ h₁ :=
  rfl

/-- `pb.equiv_of_minpoly pb' h` is an equivalence of algebras with the same power basis,
where "the same" means that they have identical minimal polynomials.

See also `power_basis.equiv_of_root` which takes the hypothesis that each generator is a root of the
other basis' minimal polynomial; `power_basis.equiv_root` is more general if `A` is not a field.
-/
noncomputable def equiv_of_minpoly (pb : PowerBasis A S) (pb' : PowerBasis A S')
  (h : minpoly A pb.gen = minpoly A pb'.gen) : S ≃ₐ[A] S' :=
  pb.equiv_of_root pb' (h ▸ minpoly.aeval _ _) (h.symm ▸ minpoly.aeval _ _)

@[simp]
theorem equiv_of_minpoly_aeval (pb : PowerBasis A S) (pb' : PowerBasis A S') (h : minpoly A pb.gen = minpoly A pb'.gen)
  (f : Polynomial A) : pb.equiv_of_minpoly pb' h (aeval pb.gen f) = aeval pb'.gen f :=
  pb.equiv_of_root_aeval pb' _ _ _

@[simp]
theorem equiv_of_minpoly_gen (pb : PowerBasis A S) (pb' : PowerBasis A S') (h : minpoly A pb.gen = minpoly A pb'.gen) :
  pb.equiv_of_minpoly pb' h pb.gen = pb'.gen :=
  pb.equiv_of_root_gen pb' _ _

@[simp]
theorem equiv_of_minpoly_symm (pb : PowerBasis A S) (pb' : PowerBasis A S') (h : minpoly A pb.gen = minpoly A pb'.gen) :
  (pb.equiv_of_minpoly pb' h).symm = pb'.equiv_of_minpoly pb h.symm :=
  rfl

end Equiv

end PowerBasis

open PowerBasis

-- error in RingTheory.PowerBasis: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Useful lemma to show `x` generates a power basis:
the powers of `x` less than the degree of `x`'s minimal polynomial are linearly independent. -/
theorem is_integral.linear_independent_pow
[algebra K S]
{x : S}
(hx : is_integral K x) : linear_independent K (λ i : fin (minpoly K x).nat_degree, «expr ^ »(x, (i : exprℕ()))) :=
begin
  rw [expr linear_independent_iff] [],
  intros [ident p, ident hp],
  set [] [ident f] [":", expr polynomial K] [":="] [expr p.sum (λ i, monomial i)] ["with", ident hf0],
  have [ident f_def] [":", expr ∀ i : fin _, «expr = »(f.coeff i, p i)] [],
  { intro [ident i],
    simp [] [] ["only"] ["[", expr f, ",", expr finsupp.sum, ",", expr coeff_monomial, ",", expr finset_sum_coeff, "]"] [] [],
    rw ["[", expr finset.sum_eq_single, ",", expr if_pos rfl, "]"] [],
    { intros [ident b, "_", ident hb],
      rw [expr if_neg (mt (λ h, _) hb)] [],
      exact [expr fin.coe_injective h] },
    { intro [ident hi],
      split_ifs [] []; { exact [expr finsupp.not_mem_support_iff.mp hi] } } },
  have [ident f_def'] [":", expr ∀ i, «expr = »(f.coeff i, if hi : «expr < »(i, _) then p ⟨i, hi⟩ else 0)] [],
  { intro [ident i],
    split_ifs [] ["with", ident hi],
    { exact [expr f_def ⟨i, hi⟩] },
    simp [] [] ["only"] ["[", expr f, ",", expr finsupp.sum, ",", expr coeff_monomial, ",", expr finset_sum_coeff, "]"] [] [],
    apply [expr finset.sum_eq_zero],
    rintro ["⟨", ident j, ",", ident hj, "⟩", "-"],
    apply [expr if_neg (mt _ hi)],
    rintro [ident rfl],
    exact [expr hj] },
  suffices [] [":", expr «expr = »(f, 0)],
  { ext [] [ident i] [],
    rw ["[", "<-", expr f_def, ",", expr this, ",", expr coeff_zero, ",", expr finsupp.zero_apply, "]"] [] },
  contrapose [] [ident hp, "with", ident hf],
  intro [ident h],
  have [] [":", expr «expr ≤ »((minpoly K x).degree, f.degree)] [],
  { apply [expr minpoly.degree_le_of_ne_zero K x hf],
    convert [] [expr h] [],
    simp_rw ["[", expr finsupp.total_apply, ",", expr aeval_def, ",", expr hf0, ",", expr finsupp.sum, ",", expr eval₂_finset_sum, "]"] [],
    apply [expr finset.sum_congr rfl],
    rintro [ident i, "-"],
    simp [] [] ["only"] ["[", expr algebra.smul_def, ",", expr eval₂_monomial, "]"] [] [] },
  have [] [":", expr «expr¬ »(«expr ≤ »((minpoly K x).degree, f.degree))] [],
  { apply [expr not_le_of_lt],
    rw ["[", expr degree_eq_nat_degree (minpoly.ne_zero hx), ",", expr degree_lt_iff_coeff_zero, "]"] [],
    intros [ident i, ident hi],
    rw ["[", expr f_def' i, ",", expr dif_neg, "]"] [],
    exact [expr hi.not_lt] },
  contradiction
end

-- error in RingTheory.PowerBasis: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_integral.mem_span_pow
[nontrivial R]
{x y : S}
(hx : is_integral R x)
(hy : «expr∃ , »((f : polynomial R), «expr = »(y, aeval x f))) : «expr ∈ »(y, submodule.span R (set.range (λ
   i : fin (minpoly R x).nat_degree, «expr ^ »(x, (i : exprℕ()))))) :=
begin
  obtain ["⟨", ident f, ",", ident rfl, "⟩", ":=", expr hy],
  apply [expr mem_span_pow'.mpr _],
  have [] [] [":=", expr minpoly.monic hx],
  refine [expr ⟨f.mod_by_monic (minpoly R x), lt_of_lt_of_le (degree_mod_by_monic_lt _ this) degree_le_nat_degree, _⟩],
  conv_lhs [] [] { rw ["<-", expr mod_by_monic_add_div f this] },
  simp [] [] ["only"] ["[", expr add_zero, ",", expr zero_mul, ",", expr minpoly.aeval, ",", expr aeval_add, ",", expr alg_hom.map_mul, "]"] [] []
end

namespace PowerBasis

section Map

variable {S' : Type _} [CommRingₓ S'] [Algebra R S']

/-- `power_basis.map pb (e : S ≃ₐ[R] S')` is the power basis for `S'` generated by `e pb.gen`. -/
@[simps]
noncomputable def map (pb : PowerBasis R S) (e : S ≃ₐ[R] S') : PowerBasis R S' :=
  { dim := pb.dim, Basis := pb.basis.map e.to_linear_equiv, gen := e pb.gen,
    basis_eq_pow :=
      fun i =>
        by 
          rw [Basis.map_apply, pb.basis_eq_pow, e.to_linear_equiv_apply, e.map_pow] }

variable [Algebra A S] [Algebra A S']

@[simp]
theorem minpoly_gen_map (pb : PowerBasis A S) (e : S ≃ₐ[A] S') : (pb.map e).minpolyGen = pb.minpoly_gen :=
  by 
    dsimp only [minpoly_gen, map_dim]
    simp only [LinearEquiv.trans_apply, map_basis, Basis.map_repr, map_gen, AlgEquiv.to_linear_equiv_apply,
      e.to_linear_equiv_symm, AlgEquiv.map_pow, AlgEquiv.symm_apply_apply, sub_right_inj]

variable [IsDomain A]

@[simp]
theorem equiv_of_root_map (pb : PowerBasis A S) (e : S ≃ₐ[A] S') h₁ h₂ : pb.equiv_of_root (pb.map e) h₁ h₂ = e :=
  by 
    ext x 
    obtain ⟨f, rfl⟩ := pb.exists_eq_aeval' x 
    simp [aeval_alg_equiv]

@[simp]
theorem equiv_of_minpoly_map (pb : PowerBasis A S) (e : S ≃ₐ[A] S') (h : minpoly A pb.gen = minpoly A (pb.map e).gen) :
  pb.equiv_of_minpoly (pb.map e) h = e :=
  pb.equiv_of_root_map _ _ _

end Map

end PowerBasis

