/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen

! This file was ported from Lean 3 source module ring_theory.localization.submodule
! leanprover-community/mathlib commit 1ebb20602a8caef435ce47f6373e1aa40851a177
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.RingTheory.Localization.FractionRing
import Mathbin.RingTheory.Localization.Ideal
import Mathbin.RingTheory.PrincipalIdealDomain

/-!
# Submodules in localizations of commutative rings

## Implementation notes

See `src/ring_theory/localization/basic.lean` for a design overview.

## Tags
localization, ring localization, commutative ring localization, characteristic predicate,
commutative ring, field of fractions
-/


variable {R : Type _} [CommRing R] (M : Submonoid R) (S : Type _) [CommRing S]

variable [Algebra R S] {P : Type _} [CommRing P]

namespace IsLocalization

#print IsLocalization.coeSubmodule /-
-- This was previously a `has_coe` instance, but if `S = R` then this will loop.
-- It could be a `has_coe_t` instance, but we keep it explicit here to avoid slowing down
-- the rest of the library.
/-- Map from ideals of `R` to submodules of `S` induced by `f`. -/
def coeSubmodule (I : Ideal R) : Submodule R S :=
  Submodule.map (Algebra.linearMap R S) I
#align is_localization.coe_submodule IsLocalization.coeSubmodule
-/

/- warning: is_localization.mem_coe_submodule -> IsLocalization.mem_coeSubmodule is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (S : Type.{u2}) [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) {x : S}, Iff (Membership.Mem.{u2, u2} S (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) S (Submodule.setLike.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3))) x (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 I)) (Exists.{succ u1} R (fun (y : R) => And (Membership.Mem.{u1, u1} R (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) y I) (Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3) y) x)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] (S : Type.{u1}) [_inst_2 : CommRing.{u1} S] [_inst_3 : Algebra.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))] (I : Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) {x : S}, Iff (Membership.mem.{u1, u1} S (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) S (Submodule.setLike.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3))) x (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 S _inst_2 _inst_3 I)) (Exists.{succ u2} R (fun (y : R) => And (Membership.mem.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) R (Submodule.setLike.{u2, u2} R R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))))) y I) (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) y) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))))) (algebraMap.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) _inst_3) y) x)))
Case conversion may be inaccurate. Consider using '#align is_localization.mem_coe_submodule IsLocalization.mem_coeSubmoduleₓ'. -/
theorem mem_coeSubmodule (I : Ideal R) {x : S} :
    x ∈ coeSubmodule S I ↔ ∃ y : R, y ∈ I ∧ algebraMap R S y = x :=
  Iff.rfl
#align is_localization.mem_coe_submodule IsLocalization.mem_coeSubmodule

/- warning: is_localization.coe_submodule_mono -> IsLocalization.coeSubmodule_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (S : Type.{u2}) [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {J : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) I J) -> (LE.le.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (Preorder.toLE.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (Submodule.completeLattice.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)))))) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 I) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 J))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] (S : Type.{u1}) [_inst_2 : CommRing.{u1} S] [_inst_3 : Algebra.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))] {I : Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))} {J : Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))}, (LE.le.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Preorder.toLE.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Submodule.completeLattice.{u2, u2} R R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)))))))) I J) -> (LE.le.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (Submodule.completeLattice.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)))))) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 S _inst_2 _inst_3 I) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 S _inst_2 _inst_3 J))
Case conversion may be inaccurate. Consider using '#align is_localization.coe_submodule_mono IsLocalization.coeSubmodule_monoₓ'. -/
theorem coeSubmodule_mono {I J : Ideal R} (h : I ≤ J) : coeSubmodule S I ≤ coeSubmodule S J :=
  Submodule.map_mono h
#align is_localization.coe_submodule_mono IsLocalization.coeSubmodule_mono

/- warning: is_localization.coe_submodule_bot -> IsLocalization.coeSubmodule_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (S : Type.{u2}) [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))], Eq.{succ u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 (Bot.bot.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.hasBot.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Bot.bot.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (Submodule.hasBot.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (S : Type.{u2}) [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))], Eq.{succ u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 (Bot.bot.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.instBotSubmodule.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Bot.bot.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.instBotSubmodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align is_localization.coe_submodule_bot IsLocalization.coeSubmodule_botₓ'. -/
@[simp]
theorem coeSubmodule_bot : coeSubmodule S (⊥ : Ideal R) = ⊥ := by
  rw [coe_submodule, Submodule.map_bot]
#align is_localization.coe_submodule_bot IsLocalization.coeSubmodule_bot

/- warning: is_localization.coe_submodule_top -> IsLocalization.coeSubmodule_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (S : Type.{u2}) [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))], Eq.{succ u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.hasTop.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (OfNat.ofNat.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) 1 (OfNat.mk.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) 1 (One.one.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (Submodule.one.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (S : Type.{u2}) [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))], Eq.{succ u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.instTopSubmodule.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (OfNat.ofNat.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2 _inst_3)) 1 (One.toOfNat1.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Submodule.one.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)))
Case conversion may be inaccurate. Consider using '#align is_localization.coe_submodule_top IsLocalization.coeSubmodule_topₓ'. -/
@[simp]
theorem coeSubmodule_top : coeSubmodule S (⊤ : Ideal R) = 1 := by
  rw [coe_submodule, Submodule.map_top, Submodule.one_eq_range]
#align is_localization.coe_submodule_top IsLocalization.coeSubmodule_top

/- warning: is_localization.coe_submodule_sup -> IsLocalization.coeSubmodule_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (S : Type.{u2}) [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (J : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), Eq.{succ u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 (Sup.sup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.idemSemiring.{u1, u1} R (CommRing.toCommSemiring.{u1} R _inst_1) R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) I J)) (Sup.sup.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (IdemSemiring.toSemilatticeSup.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (Submodule.idemSemiring.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3))) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 I) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 J))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] (S : Type.{u1}) [_inst_2 : CommRing.{u1} S] [_inst_3 : Algebra.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))] (I : Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (J : Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))), Eq.{succ u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 S _inst_2 _inst_3 (Sup.sup.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (SemilatticeSup.toSup.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (IdemCommSemiring.toSemilatticeSup.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.instIdemCommSemiringIdealToSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) I J)) (Sup.sup.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (SemilatticeSup.toSup.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (IdemCommSemiring.toSemilatticeSup.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u2, u1} R (CommRing.toCommSemiring.{u2} R _inst_1) S (CommRing.toCommSemiring.{u1} S _inst_2) _inst_3))) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 S _inst_2 _inst_3 I) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 S _inst_2 _inst_3 J))
Case conversion may be inaccurate. Consider using '#align is_localization.coe_submodule_sup IsLocalization.coeSubmodule_supₓ'. -/
@[simp]
theorem coeSubmodule_sup (I J : Ideal R) :
    coeSubmodule S (I ⊔ J) = coeSubmodule S I ⊔ coeSubmodule S J :=
  Submodule.map_sup _ _ _
#align is_localization.coe_submodule_sup IsLocalization.coeSubmodule_sup

/- warning: is_localization.coe_submodule_mul -> IsLocalization.coeSubmodule_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (S : Type.{u2}) [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (J : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), Eq.{succ u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHMul.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ideal.hasMul.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) I J)) (HMul.hMul.{u2, u2, u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (instHMul.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (Submodule.mul.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 I) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 J))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] (S : Type.{u1}) [_inst_2 : CommRing.{u1} S] [_inst_3 : Algebra.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))] (I : Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (J : Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))), Eq.{succ u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 S _inst_2 _inst_3 (HMul.hMul.{u2, u2, u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (instHMul.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.instMulIdealToSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) I J)) (HMul.hMul.{u1, u1, u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (instHMul.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (Submodule.mul.{u2, u1} R (CommRing.toCommSemiring.{u2} R _inst_1) S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) _inst_3)) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 S _inst_2 _inst_3 I) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 S _inst_2 _inst_3 J))
Case conversion may be inaccurate. Consider using '#align is_localization.coe_submodule_mul IsLocalization.coeSubmodule_mulₓ'. -/
@[simp]
theorem coeSubmodule_mul (I J : Ideal R) :
    coeSubmodule S (I * J) = coeSubmodule S I * coeSubmodule S J :=
  Submodule.map_mul _ _ (Algebra.ofId R S)
#align is_localization.coe_submodule_mul IsLocalization.coeSubmodule_mul

/- warning: is_localization.coe_submodule_fg -> IsLocalization.coeSubmodule_fg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (S : Type.{u2}) [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))], (Function.Injective.{succ u1, succ u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3))) -> (forall (I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), Iff (Submodule.Fg.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 I)) (Submodule.Fg.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) I))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] (S : Type.{u1}) [_inst_2 : CommRing.{u1} S] [_inst_3 : Algebra.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))], (Function.Injective.{succ u2, succ u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))))) (algebraMap.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) _inst_3))) -> (forall (I : Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))), Iff (Submodule.Fg.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 S _inst_2 _inst_3 I)) (Submodule.Fg.{u2, u2} R R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) I))
Case conversion may be inaccurate. Consider using '#align is_localization.coe_submodule_fg IsLocalization.coeSubmodule_fgₓ'. -/
theorem coeSubmodule_fg (hS : Function.Injective (algebraMap R S)) (I : Ideal R) :
    Submodule.Fg (coeSubmodule S I) ↔ Submodule.Fg I :=
  ⟨Submodule.fg_of_fg_map _ (LinearMap.ker_eq_bot.mpr hS), Submodule.Fg.map _⟩
#align is_localization.coe_submodule_fg IsLocalization.coeSubmodule_fg

/- warning: is_localization.coe_submodule_span -> IsLocalization.coeSubmodule_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (S : Type.{u2}) [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] (s : Set.{u1} R), Eq.{succ u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 (Ideal.span.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) s)) (Submodule.span.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3) (Set.image.{u1, u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) s))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] (S : Type.{u1}) [_inst_2 : CommRing.{u1} S] [_inst_3 : Algebra.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))] (s : Set.{u2} R), Eq.{succ u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 S _inst_2 _inst_3 (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) s)) (Submodule.span.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Set.image.{u2, u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))))) (algebraMap.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) _inst_3)) s))
Case conversion may be inaccurate. Consider using '#align is_localization.coe_submodule_span IsLocalization.coeSubmodule_spanₓ'. -/
@[simp]
theorem coeSubmodule_span (s : Set R) :
    coeSubmodule S (Ideal.span s) = Submodule.span R (algebraMap R S '' s) :=
  by
  rw [IsLocalization.coeSubmodule, Ideal.span, Submodule.map_span]
  rfl
#align is_localization.coe_submodule_span IsLocalization.coeSubmodule_span

/- warning: is_localization.coe_submodule_span_singleton -> IsLocalization.coeSubmodule_span_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (S : Type.{u2}) [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] (x : R), Eq.{succ u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 (Ideal.span.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x))) (Submodule.span.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3) (Singleton.singleton.{u2, u2} S (Set.{u2} S) (Set.hasSingleton.{u2} S) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3) x)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (S : Type.{u2}) [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] (x : R), Eq.{succ u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 (Ideal.span.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x))) (Submodule.span.{u1, u2} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) (NonAssocRing.toNonUnitalNonAssocRing.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) (Ring.toNonAssocRing.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) (CommRing.toRing.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u1, u2} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Singleton.singleton.{u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) (Set.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x)) (Set.instSingletonSet.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))))))) (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3) x)))
Case conversion may be inaccurate. Consider using '#align is_localization.coe_submodule_span_singleton IsLocalization.coeSubmodule_span_singletonₓ'. -/
@[simp]
theorem coeSubmodule_span_singleton (x : R) :
    coeSubmodule S (Ideal.span {x}) = Submodule.span R {(algebraMap R S) x} := by
  rw [coe_submodule_span, Set.image_singleton]
#align is_localization.coe_submodule_span_singleton IsLocalization.coeSubmodule_span_singleton

variable {g : R →+* P}

variable {T : Submonoid P} (hy : M ≤ T.comap g) {Q : Type _} [CommRing Q]

variable [Algebra P Q] [IsLocalization T Q]

variable [IsLocalization M S]

section

include M

/- warning: is_localization.is_noetherian_ring -> IsLocalization.isNoetherianRing is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (S : Type.{u2}) [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] [_inst_8 : IsLocalization.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_3], (IsNoetherianRing.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) -> (IsNoetherianRing.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] (M : Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (S : Type.{u1}) [_inst_2 : CommRing.{u1} S] [_inst_3 : Algebra.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))] [_inst_8 : IsLocalization.{u2, u1} R (CommRing.toCommSemiring.{u2} R _inst_1) M S (CommRing.toCommSemiring.{u1} S _inst_2) _inst_3], (IsNoetherianRing.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) -> (IsNoetherianRing.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))
Case conversion may be inaccurate. Consider using '#align is_localization.is_noetherian_ring IsLocalization.isNoetherianRingₓ'. -/
theorem isNoetherianRing (h : IsNoetherianRing R) : IsNoetherianRing S :=
  by
  rw [isNoetherianRing_iff, isNoetherian_iff_wellFounded] at h⊢
  exact OrderEmbedding.wellFounded (IsLocalization.orderEmbedding M S).dual h
#align is_localization.is_noetherian_ring IsLocalization.isNoetherianRing

end

variable {S Q M}

/- warning: is_localization.coe_submodule_le_coe_submodule -> IsLocalization.coeSubmodule_le_coeSubmodule is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))} {S : Type.{u2}} [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] [_inst_8 : IsLocalization.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_3], (LE.le.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Preorder.toLE.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Submonoid.completeLattice.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))) M (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) -> (forall {I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {J : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, Iff (LE.le.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (Preorder.toLE.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (Submodule.completeLattice.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)))))) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 I) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 J)) (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) I J))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] {M : Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))} {S : Type.{u1}} [_inst_2 : CommRing.{u1} S] [_inst_3 : Algebra.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))] [_inst_8 : IsLocalization.{u2, u1} R (CommRing.toCommSemiring.{u2} R _inst_1) M S (CommRing.toCommSemiring.{u1} S _inst_2) _inst_3], (LE.le.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (Preorder.toLE.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (Submonoid.instCompleteLatticeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))))))) M (nonZeroDivisors.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))))) -> (forall {I : Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))} {J : Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))}, Iff (LE.le.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (Submodule.completeLattice.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)))))) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 S _inst_2 _inst_3 I) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 S _inst_2 _inst_3 J)) (LE.le.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Preorder.toLE.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Submodule.completeLattice.{u2, u2} R R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)))))))) I J))
Case conversion may be inaccurate. Consider using '#align is_localization.coe_submodule_le_coe_submodule IsLocalization.coeSubmodule_le_coeSubmoduleₓ'. -/
@[mono]
theorem coeSubmodule_le_coeSubmodule (h : M ≤ nonZeroDivisors R) {I J : Ideal R} :
    coeSubmodule S I ≤ coeSubmodule S J ↔ I ≤ J :=
  Submodule.map_le_map_iff_of_injective (IsLocalization.injective _ h) _ _
#align is_localization.coe_submodule_le_coe_submodule IsLocalization.coeSubmodule_le_coeSubmodule

/- warning: is_localization.coe_submodule_strict_mono -> IsLocalization.coeSubmodule_strictMono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))} {S : Type.{u2}} [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] [_inst_8 : IsLocalization.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_3], (LE.le.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Preorder.toLE.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Submonoid.completeLattice.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))) M (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) -> (StrictMono.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (Submodule.completeLattice.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3))))) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] {M : Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))} {S : Type.{u1}} [_inst_2 : CommRing.{u1} S] [_inst_3 : Algebra.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))] [_inst_8 : IsLocalization.{u2, u1} R (CommRing.toCommSemiring.{u2} R _inst_1) M S (CommRing.toCommSemiring.{u1} S _inst_2) _inst_3], (LE.le.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (Preorder.toLE.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (Submonoid.instCompleteLatticeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))))))) M (nonZeroDivisors.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))))) -> (StrictMono.{u2, u1} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Submodule.completeLattice.{u2, u2} R R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))))))) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (Submodule.completeLattice.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3))))) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 S _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align is_localization.coe_submodule_strict_mono IsLocalization.coeSubmodule_strictMonoₓ'. -/
@[mono]
theorem coeSubmodule_strictMono (h : M ≤ nonZeroDivisors R) :
    StrictMono (coeSubmodule S : Ideal R → Submodule R S) :=
  strictMono_of_le_iff_le fun _ _ => (coeSubmodule_le_coeSubmodule h).symm
#align is_localization.coe_submodule_strict_mono IsLocalization.coeSubmodule_strictMono

variable (S) {Q M}

/- warning: is_localization.coe_submodule_injective -> IsLocalization.coeSubmodule_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))} (S : Type.{u2}) [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] [_inst_8 : IsLocalization.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_3], (LE.le.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Preorder.toLE.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Submonoid.completeLattice.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))) M (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) -> (Function.Injective.{succ u1, succ u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] {M : Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))} (S : Type.{u1}) [_inst_2 : CommRing.{u1} S] [_inst_3 : Algebra.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))] [_inst_8 : IsLocalization.{u2, u1} R (CommRing.toCommSemiring.{u2} R _inst_1) M S (CommRing.toCommSemiring.{u1} S _inst_2) _inst_3], (LE.le.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (Preorder.toLE.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (Submonoid.instCompleteLatticeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))))))) M (nonZeroDivisors.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))))) -> (Function.Injective.{succ u2, succ u1} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Submodule.{u2, u1} R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3)) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 S _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align is_localization.coe_submodule_injective IsLocalization.coeSubmodule_injectiveₓ'. -/
theorem coeSubmodule_injective (h : M ≤ nonZeroDivisors R) :
    Function.Injective (coeSubmodule S : Ideal R → Submodule R S) :=
  injective_of_le_imp_le _ fun _ _ => (coeSubmodule_le_coeSubmodule h).mp
#align is_localization.coe_submodule_injective IsLocalization.coeSubmodule_injective

/- warning: is_localization.coe_submodule_is_principal -> IsLocalization.coeSubmodule_isPrincipal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))} (S : Type.{u2}) [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] [_inst_8 : IsLocalization.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_3] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (LE.le.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Preorder.toLE.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (PartialOrder.toPreorder.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Submonoid.completeLattice.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))) M (nonZeroDivisors.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) -> (Iff (Submodule.IsPrincipal.{u1, u2} R S (CommRing.toRing.{u1} R _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 S _inst_2 _inst_3 I)) (Submodule.IsPrincipal.{u1, u1} R R (CommRing.toRing.{u1} R _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) I))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] {M : Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))} (S : Type.{u1}) [_inst_2 : CommRing.{u1} S] [_inst_3 : Algebra.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))] [_inst_8 : IsLocalization.{u2, u1} R (CommRing.toCommSemiring.{u2} R _inst_1) M S (CommRing.toCommSemiring.{u1} S _inst_2) _inst_3] {I : Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))}, (LE.le.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (Preorder.toLE.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (PartialOrder.toPreorder.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (Submonoid.instCompleteLatticeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))))))) M (nonZeroDivisors.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))))) -> (Iff (Submodule.IsPrincipal.{u2, u1} R S (CommRing.toRing.{u2} R _inst_1) (Ring.toAddCommGroup.{u1} S (CommRing.toRing.{u1} S _inst_2)) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) _inst_2 _inst_3) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 S _inst_2 _inst_3 I)) (Submodule.IsPrincipal.{u2, u2} R R (CommRing.toRing.{u2} R _inst_1) (Ring.toAddCommGroup.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) I))
Case conversion may be inaccurate. Consider using '#align is_localization.coe_submodule_is_principal IsLocalization.coeSubmodule_isPrincipalₓ'. -/
theorem coeSubmodule_isPrincipal {I : Ideal R} (h : M ≤ nonZeroDivisors R) :
    (coeSubmodule S I).IsPrincipal ↔ I.IsPrincipal :=
  by
  constructor <;> rintro ⟨⟨x, hx⟩⟩
  · have x_mem : x ∈ coe_submodule S I := hx.symm ▸ Submodule.mem_span_singleton_self x
    obtain ⟨x, x_mem, rfl⟩ := (mem_coe_submodule _ _).mp x_mem
    refine' ⟨⟨x, coe_submodule_injective S h _⟩⟩
    rw [Ideal.submodule_span_eq, hx, coe_submodule_span_singleton]
  · refine' ⟨⟨algebraMap R S x, _⟩⟩
    rw [hx, Ideal.submodule_span_eq, coe_submodule_span_singleton]
#align is_localization.coe_submodule_is_principal IsLocalization.coeSubmodule_isPrincipal

variable {S} (M)

/- warning: is_localization.mem_span_iff -> IsLocalization.mem_span_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) {S : Type.{u2}} [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] [_inst_8 : IsLocalization.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_3] {N : Type.{u3}} [_inst_9 : AddCommGroup.{u3} N] [_inst_10 : Module.{u1, u3} R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9)] [_inst_11 : Module.{u2, u3} S N (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9)] [_inst_12 : IsScalarTower.{u1, u2, u3} R S N (SMulZeroClass.toHasSmul.{u1, u2} R S (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R S (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R S (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))))))) (Module.toMulActionWithZero.{u1, u2} R S (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Algebra.toModule.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3))))) (SMulZeroClass.toHasSmul.{u2, u3} S N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N (AddCommGroup.toAddCommMonoid.{u3} N _inst_9)))) (SMulWithZero.toSmulZeroClass.{u2, u3} S N (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N (AddCommGroup.toAddCommMonoid.{u3} N _inst_9)))) (MulActionWithZero.toSMulWithZero.{u2, u3} S N (Semiring.toMonoidWithZero.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N (AddCommGroup.toAddCommMonoid.{u3} N _inst_9)))) (Module.toMulActionWithZero.{u2, u3} S N (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_11)))) (SMulZeroClass.toHasSmul.{u1, u3} R N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N (AddCommGroup.toAddCommMonoid.{u3} N _inst_9)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R N (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N (AddCommGroup.toAddCommMonoid.{u3} N _inst_9)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R N (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N (AddCommGroup.toAddCommMonoid.{u3} N _inst_9)))) (Module.toMulActionWithZero.{u1, u3} R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_10))))] {x : N} {a : Set.{u3} N}, Iff (Membership.Mem.{u3, u3} N (Submodule.{u2, u3} S N (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_11) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} S N (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_11) N (Submodule.setLike.{u2, u3} S N (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_11)) x (Submodule.span.{u2, u3} S N (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_11 a)) (Exists.{succ u3} N (fun (y : N) => Exists.{0} (Membership.Mem.{u3, u3} N (Submodule.{u1, u3} R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_10) (SetLike.hasMem.{u3, u3} (Submodule.{u1, u3} R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_10) N (Submodule.setLike.{u1, u3} R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_10)) y (Submodule.span.{u1, u3} R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_10 a)) (fun (H : Membership.Mem.{u3, u3} N (Submodule.{u1, u3} R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_10) (SetLike.hasMem.{u3, u3} (Submodule.{u1, u3} R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_10) N (Submodule.setLike.{u1, u3} R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_10)) y (Submodule.span.{u1, u3} R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_10 a)) => Exists.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) M) (fun (z : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) M) => Eq.{succ u3} N x (SMul.smul.{u2, u3} S N (SMulZeroClass.toHasSmul.{u2, u3} S N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N (AddCommGroup.toAddCommMonoid.{u3} N _inst_9)))) (SMulWithZero.toSmulZeroClass.{u2, u3} S N (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N (AddCommGroup.toAddCommMonoid.{u3} N _inst_9)))) (MulActionWithZero.toSMulWithZero.{u2, u3} S N (Semiring.toMonoidWithZero.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N (AddCommGroup.toAddCommMonoid.{u3} N _inst_9)))) (Module.toMulActionWithZero.{u2, u3} S N (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_11)))) (IsLocalization.mk'.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_3 _inst_8 (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) z) y)))))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] (M : Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) {S : Type.{u1}} [_inst_2 : CommRing.{u1} S] [_inst_3 : Algebra.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))] [_inst_8 : IsLocalization.{u2, u1} R (CommRing.toCommSemiring.{u2} R _inst_1) M S (CommRing.toCommSemiring.{u1} S _inst_2) _inst_3] {N : Type.{u3}} [_inst_9 : AddCommGroup.{u3} N] [_inst_10 : Module.{u2, u3} R N (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9)] [_inst_11 : Module.{u1, u3} S N (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9)] [_inst_12 : IsScalarTower.{u2, u1, u3} R S N (Algebra.toSMul.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) _inst_3) (SMulZeroClass.toSMul.{u1, u3} S N (NegZeroClass.toZero.{u3} N (SubNegZeroMonoid.toNegZeroClass.{u3} N (SubtractionMonoid.toSubNegZeroMonoid.{u3} N (SubtractionCommMonoid.toSubtractionMonoid.{u3} N (AddCommGroup.toDivisionAddCommMonoid.{u3} N _inst_9))))) (SMulWithZero.toSMulZeroClass.{u1, u3} S N (CommMonoidWithZero.toZero.{u1} S (CommSemiring.toCommMonoidWithZero.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NegZeroClass.toZero.{u3} N (SubNegZeroMonoid.toNegZeroClass.{u3} N (SubtractionMonoid.toSubNegZeroMonoid.{u3} N (SubtractionCommMonoid.toSubtractionMonoid.{u3} N (AddCommGroup.toDivisionAddCommMonoid.{u3} N _inst_9))))) (MulActionWithZero.toSMulWithZero.{u1, u3} S N (Semiring.toMonoidWithZero.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (NegZeroClass.toZero.{u3} N (SubNegZeroMonoid.toNegZeroClass.{u3} N (SubtractionMonoid.toSubNegZeroMonoid.{u3} N (SubtractionCommMonoid.toSubtractionMonoid.{u3} N (AddCommGroup.toDivisionAddCommMonoid.{u3} N _inst_9))))) (Module.toMulActionWithZero.{u1, u3} S N (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_11)))) (SMulZeroClass.toSMul.{u2, u3} R N (NegZeroClass.toZero.{u3} N (SubNegZeroMonoid.toNegZeroClass.{u3} N (SubtractionMonoid.toSubNegZeroMonoid.{u3} N (SubtractionCommMonoid.toSubtractionMonoid.{u3} N (AddCommGroup.toDivisionAddCommMonoid.{u3} N _inst_9))))) (SMulWithZero.toSMulZeroClass.{u2, u3} R N (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u3} N (SubNegZeroMonoid.toNegZeroClass.{u3} N (SubtractionMonoid.toSubNegZeroMonoid.{u3} N (SubtractionCommMonoid.toSubtractionMonoid.{u3} N (AddCommGroup.toDivisionAddCommMonoid.{u3} N _inst_9))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R N (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NegZeroClass.toZero.{u3} N (SubNegZeroMonoid.toNegZeroClass.{u3} N (SubtractionMonoid.toSubNegZeroMonoid.{u3} N (SubtractionCommMonoid.toSubtractionMonoid.{u3} N (AddCommGroup.toDivisionAddCommMonoid.{u3} N _inst_9))))) (Module.toMulActionWithZero.{u2, u3} R N (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_10))))] {x : N} {a : Set.{u3} N}, Iff (Membership.mem.{u3, u3} N (Submodule.{u1, u3} S N (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_11) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} S N (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_11) N (Submodule.setLike.{u1, u3} S N (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_11)) x (Submodule.span.{u1, u3} S N (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_11 a)) (Exists.{succ u3} N (fun (y : N) => And (Membership.mem.{u3, u3} N (Submodule.{u2, u3} R N (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_10) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R N (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_10) N (Submodule.setLike.{u2, u3} R N (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_10)) y (Submodule.span.{u2, u3} R N (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_10 a)) (Exists.{succ u2} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))))))) x M)) (fun (z : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))))))) x M)) => Eq.{succ u3} N x (HSMul.hSMul.{u1, u3, u3} S N N (instHSMul.{u1, u3} S N (SMulZeroClass.toSMul.{u1, u3} S N (NegZeroClass.toZero.{u3} N (SubNegZeroMonoid.toNegZeroClass.{u3} N (SubtractionMonoid.toSubNegZeroMonoid.{u3} N (SubtractionCommMonoid.toSubtractionMonoid.{u3} N (AddCommGroup.toDivisionAddCommMonoid.{u3} N _inst_9))))) (SMulWithZero.toSMulZeroClass.{u1, u3} S N (CommMonoidWithZero.toZero.{u1} S (CommSemiring.toCommMonoidWithZero.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (NegZeroClass.toZero.{u3} N (SubNegZeroMonoid.toNegZeroClass.{u3} N (SubtractionMonoid.toSubNegZeroMonoid.{u3} N (SubtractionCommMonoid.toSubtractionMonoid.{u3} N (AddCommGroup.toDivisionAddCommMonoid.{u3} N _inst_9))))) (MulActionWithZero.toSMulWithZero.{u1, u3} S N (Semiring.toMonoidWithZero.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (NegZeroClass.toZero.{u3} N (SubNegZeroMonoid.toNegZeroClass.{u3} N (SubtractionMonoid.toSubNegZeroMonoid.{u3} N (SubtractionCommMonoid.toSubtractionMonoid.{u3} N (AddCommGroup.toDivisionAddCommMonoid.{u3} N _inst_9))))) (Module.toMulActionWithZero.{u1, u3} S N (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_9) _inst_11))))) (IsLocalization.mk'.{u2, u1} R (CommRing.toCommSemiring.{u2} R _inst_1) M S (CommRing.toCommSemiring.{u1} S _inst_2) _inst_3 _inst_8 (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))))) z) y)))))
Case conversion may be inaccurate. Consider using '#align is_localization.mem_span_iff IsLocalization.mem_span_iffₓ'. -/
theorem mem_span_iff {N : Type _} [AddCommGroup N] [Module R N] [Module S N] [IsScalarTower R S N]
    {x : N} {a : Set N} :
    x ∈ Submodule.span S a ↔ ∃ y ∈ Submodule.span R a, ∃ z : M, x = mk' S 1 z • y :=
  by
  constructor; intro h
  · refine' Submodule.span_induction h _ _ _ _
    · rintro x hx
      exact ⟨x, Submodule.subset_span hx, 1, by rw [mk'_one, _root_.map_one, one_smul]⟩
    · exact ⟨0, Submodule.zero_mem _, 1, by rw [mk'_one, _root_.map_one, one_smul]⟩
    · rintro _ _ ⟨y, hy, z, rfl⟩ ⟨y', hy', z', rfl⟩
      refine'
        ⟨(z' : R) • y + (z : R) • y',
          Submodule.add_mem _ (Submodule.smul_mem _ _ hy) (Submodule.smul_mem _ _ hy'), z * z', _⟩
      rw [smul_add, ← IsScalarTower.algebraMap_smul S (z : R), ←
        IsScalarTower.algebraMap_smul S (z' : R), smul_smul, smul_smul]
      congr 1
      · rw [← mul_one (1 : R), mk'_mul, mul_assoc, mk'_spec, _root_.map_one, mul_one, mul_one]
      · rw [← mul_one (1 : R), mk'_mul, mul_right_comm, mk'_spec, _root_.map_one, mul_one, one_mul]
      all_goals infer_instance
    · rintro a _ ⟨y, hy, z, rfl⟩
      obtain ⟨y', z', rfl⟩ := mk'_surjective M a
      refine' ⟨y' • y, Submodule.smul_mem _ _ hy, z' * z, _⟩
      rw [← IsScalarTower.algebraMap_smul S y', smul_smul, ← mk'_mul, smul_smul,
        mul_comm (mk' S _ _), mul_mk'_eq_mk'_of_mul]
      all_goals infer_instance
  · rintro ⟨y, hy, z, rfl⟩
    exact Submodule.smul_mem _ _ (Submodule.span_subset_span R S _ hy)
#align is_localization.mem_span_iff IsLocalization.mem_span_iff

/- warning: is_localization.mem_span_map -> IsLocalization.mem_span_map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) {S : Type.{u2}} [_inst_2 : CommRing.{u2} S] [_inst_3 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] [_inst_8 : IsLocalization.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_3] {x : S} {a : Set.{u1} R}, Iff (Membership.Mem.{u2, u2} S (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (SetLike.hasMem.{u2, u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) S (Submodule.setLike.{u2, u2} S S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))))) x (Ideal.span.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Set.image.{u1, u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_3)) a))) (Exists.{succ u1} R (fun (y : R) => Exists.{0} (Membership.Mem.{u1, u1} R (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) y (Ideal.span.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) a)) (fun (H : Membership.Mem.{u1, u1} R (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) y (Ideal.span.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) a)) => Exists.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) M) (fun (z : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) M) => Eq.{succ u2} S x (IsLocalization.mk'.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_3 _inst_8 y z)))))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] (M : Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) {S : Type.{u1}} [_inst_2 : CommRing.{u1} S] [_inst_3 : Algebra.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))] [_inst_8 : IsLocalization.{u2, u1} R (CommRing.toCommSemiring.{u2} R _inst_1) M S (CommRing.toCommSemiring.{u1} S _inst_2) _inst_3] {x : S} {a : Set.{u2} R}, Iff (Membership.mem.{u1, u1} S (Ideal.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) S (Submodule.setLike.{u1, u1} S S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) x (Ideal.span.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) (Set.image.{u2, u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))) R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))))) (algebraMap.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) _inst_3)) a))) (Exists.{succ u2} R (fun (y : R) => And (Membership.mem.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) R (Submodule.setLike.{u2, u2} R R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))))) y (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) a)) (Exists.{succ u2} (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))))))) x M)) (fun (z : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))))))) x M)) => Eq.{succ u1} S x (IsLocalization.mk'.{u2, u1} R (CommRing.toCommSemiring.{u2} R _inst_1) M S (CommRing.toCommSemiring.{u1} S _inst_2) _inst_3 _inst_8 y z)))))
Case conversion may be inaccurate. Consider using '#align is_localization.mem_span_map IsLocalization.mem_span_mapₓ'. -/
theorem mem_span_map {x : S} {a : Set R} :
    x ∈ Ideal.span (algebraMap R S '' a) ↔ ∃ y ∈ Ideal.span a, ∃ z : M, x = mk' S y z :=
  by
  refine' (mem_span_iff M).trans _
  constructor
  · rw [← coe_submodule_span]
    rintro ⟨_, ⟨y, hy, rfl⟩, z, hz⟩
    refine' ⟨y, hy, z, _⟩
    rw [hz, Algebra.linearMap_apply, smul_eq_mul, mul_comm, mul_mk'_eq_mk'_of_mul, mul_one]
  · rintro ⟨y, hy, z, hz⟩
    refine' ⟨algebraMap R S y, Submodule.map_mem_span_algebraMap_image _ _ hy, z, _⟩
    rw [hz, smul_eq_mul, mul_comm, mul_mk'_eq_mk'_of_mul, mul_one]
#align is_localization.mem_span_map IsLocalization.mem_span_map

end IsLocalization

namespace IsFractionRing

open IsLocalization

variable {R} {A K : Type _} [CommRing A]

section CommRing

variable [CommRing K] [Algebra R K] [IsFractionRing R K] [Algebra A K] [IsFractionRing A K]

/- warning: is_fraction_ring.coe_submodule_le_coe_submodule -> IsFractionRing.coeSubmodule_le_coeSubmodule is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {K : Type.{u2}} [_inst_6 : CommRing.{u2} K] [_inst_7 : Algebra.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6))] [_inst_8 : IsFractionRing.{u1, u2} R _inst_1 K _inst_6 _inst_7] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {J : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, Iff (LE.le.{u2} (Submodule.{u1, u2} R K (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toAddCommGroup.{u2} K (NonAssocRing.toNonUnitalNonAssocRing.{u2} K (Ring.toNonAssocRing.{u2} K (CommRing.toRing.{u2} K _inst_6))))) (Algebra.toModule.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6)) _inst_7)) (Preorder.toLE.{u2} (Submodule.{u1, u2} R K (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toAddCommGroup.{u2} K (NonAssocRing.toNonUnitalNonAssocRing.{u2} K (Ring.toNonAssocRing.{u2} K (CommRing.toRing.{u2} K _inst_6))))) (Algebra.toModule.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6)) _inst_7)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R K (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toAddCommGroup.{u2} K (NonAssocRing.toNonUnitalNonAssocRing.{u2} K (Ring.toNonAssocRing.{u2} K (CommRing.toRing.{u2} K _inst_6))))) (Algebra.toModule.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6)) _inst_7)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} R K (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toAddCommGroup.{u2} K (NonAssocRing.toNonUnitalNonAssocRing.{u2} K (Ring.toNonAssocRing.{u2} K (CommRing.toRing.{u2} K _inst_6))))) (Algebra.toModule.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6)) _inst_7)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} R K (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toAddCommGroup.{u2} K (NonAssocRing.toNonUnitalNonAssocRing.{u2} K (Ring.toNonAssocRing.{u2} K (CommRing.toRing.{u2} K _inst_6))))) (Algebra.toModule.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6)) _inst_7)) (Submodule.completeLattice.{u1, u2} R K (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toAddCommGroup.{u2} K (NonAssocRing.toNonUnitalNonAssocRing.{u2} K (Ring.toNonAssocRing.{u2} K (CommRing.toRing.{u2} K _inst_6))))) (Algebra.toModule.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6)) _inst_7)))))) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 K _inst_6 _inst_7 I) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 K _inst_6 _inst_7 J)) (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) I J)
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] {K : Type.{u1}} [_inst_6 : CommRing.{u1} K] [_inst_7 : Algebra.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_6))] [_inst_8 : IsFractionRing.{u2, u1} R _inst_1 K _inst_6 _inst_7] {I : Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))} {J : Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))}, Iff (LE.le.{u1} (Submodule.{u2, u1} R K (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_6))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) _inst_6 _inst_7)) (Preorder.toLE.{u1} (Submodule.{u2, u1} R K (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_6))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) _inst_6 _inst_7)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R K (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_6))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) _inst_6 _inst_7)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R K (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_6))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) _inst_6 _inst_7)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R K (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_6))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) _inst_6 _inst_7)) (Submodule.completeLattice.{u2, u1} R K (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_6))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) _inst_6 _inst_7)))))) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 K _inst_6 _inst_7 I) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 K _inst_6 _inst_7 J)) (LE.le.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Preorder.toLE.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Submodule.completeLattice.{u2, u2} R R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)))))))) I J)
Case conversion may be inaccurate. Consider using '#align is_fraction_ring.coe_submodule_le_coe_submodule IsFractionRing.coeSubmodule_le_coeSubmoduleₓ'. -/
@[simp, mono]
theorem coeSubmodule_le_coeSubmodule {I J : Ideal R} :
    coeSubmodule K I ≤ coeSubmodule K J ↔ I ≤ J :=
  IsLocalization.coeSubmodule_le_coeSubmodule le_rfl
#align is_fraction_ring.coe_submodule_le_coe_submodule IsFractionRing.coeSubmodule_le_coeSubmodule

/- warning: is_fraction_ring.coe_submodule_strict_mono -> IsFractionRing.coeSubmodule_strictMono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {K : Type.{u2}} [_inst_6 : CommRing.{u2} K] [_inst_7 : Algebra.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6))] [_inst_8 : IsFractionRing.{u1, u2} R _inst_1 K _inst_6 _inst_7], StrictMono.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.{u1, u2} R K (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toAddCommGroup.{u2} K (NonAssocRing.toNonUnitalNonAssocRing.{u2} K (Ring.toNonAssocRing.{u2} K (CommRing.toRing.{u2} K _inst_6))))) (Algebra.toModule.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6)) _inst_7)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R K (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toAddCommGroup.{u2} K (NonAssocRing.toNonUnitalNonAssocRing.{u2} K (Ring.toNonAssocRing.{u2} K (CommRing.toRing.{u2} K _inst_6))))) (Algebra.toModule.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6)) _inst_7)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} R K (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toAddCommGroup.{u2} K (NonAssocRing.toNonUnitalNonAssocRing.{u2} K (Ring.toNonAssocRing.{u2} K (CommRing.toRing.{u2} K _inst_6))))) (Algebra.toModule.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6)) _inst_7)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} R K (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toAddCommGroup.{u2} K (NonAssocRing.toNonUnitalNonAssocRing.{u2} K (Ring.toNonAssocRing.{u2} K (CommRing.toRing.{u2} K _inst_6))))) (Algebra.toModule.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6)) _inst_7)) (Submodule.completeLattice.{u1, u2} R K (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toAddCommGroup.{u2} K (NonAssocRing.toNonUnitalNonAssocRing.{u2} K (Ring.toNonAssocRing.{u2} K (CommRing.toRing.{u2} K _inst_6))))) (Algebra.toModule.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6)) _inst_7))))) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 K _inst_6 _inst_7)
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] {K : Type.{u1}} [_inst_6 : CommRing.{u1} K] [_inst_7 : Algebra.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_6))] [_inst_8 : IsFractionRing.{u2, u1} R _inst_1 K _inst_6 _inst_7], StrictMono.{u2, u1} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Submodule.{u2, u1} R K (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_6))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) _inst_6 _inst_7)) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Submodule.completeLattice.{u2, u2} R R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))))))) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R K (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_6))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) _inst_6 _inst_7)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R K (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_6))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) _inst_6 _inst_7)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R K (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_6))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) _inst_6 _inst_7)) (Submodule.completeLattice.{u2, u1} R K (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_6))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) _inst_6 _inst_7))))) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 K _inst_6 _inst_7)
Case conversion may be inaccurate. Consider using '#align is_fraction_ring.coe_submodule_strict_mono IsFractionRing.coeSubmodule_strictMonoₓ'. -/
@[mono]
theorem coeSubmodule_strictMono : StrictMono (coeSubmodule K : Ideal R → Submodule R K) :=
  strictMono_of_le_iff_le fun _ _ => coeSubmodule_le_coeSubmodule.symm
#align is_fraction_ring.coe_submodule_strict_mono IsFractionRing.coeSubmodule_strictMono

variable (R K)

/- warning: is_fraction_ring.coe_submodule_injective -> IsFractionRing.coeSubmodule_injective is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : CommRing.{u1} R] (K : Type.{u2}) [_inst_6 : CommRing.{u2} K] [_inst_7 : Algebra.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6))] [_inst_8 : IsFractionRing.{u1, u2} R _inst_1 K _inst_6 _inst_7], Function.Injective.{succ u1, succ u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.{u1, u2} R K (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toAddCommGroup.{u2} K (NonAssocRing.toNonUnitalNonAssocRing.{u2} K (Ring.toNonAssocRing.{u2} K (CommRing.toRing.{u2} K _inst_6))))) (Algebra.toModule.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6)) _inst_7)) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 K _inst_6 _inst_7)
but is expected to have type
  forall (R : Type.{u2}) [_inst_1 : CommRing.{u2} R] (K : Type.{u1}) [_inst_6 : CommRing.{u1} K] [_inst_7 : Algebra.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_6))] [_inst_8 : IsFractionRing.{u2, u1} R _inst_1 K _inst_6 _inst_7], Function.Injective.{succ u2, succ u1} (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Submodule.{u2, u1} R K (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_6))))) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) _inst_6 _inst_7)) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 K _inst_6 _inst_7)
Case conversion may be inaccurate. Consider using '#align is_fraction_ring.coe_submodule_injective IsFractionRing.coeSubmodule_injectiveₓ'. -/
theorem coeSubmodule_injective : Function.Injective (coeSubmodule K : Ideal R → Submodule R K) :=
  injective_of_le_imp_le _ fun _ _ => coeSubmodule_le_coeSubmodule.mp
#align is_fraction_ring.coe_submodule_injective IsFractionRing.coeSubmodule_injective

/- warning: is_fraction_ring.coe_submodule_is_principal -> IsFractionRing.coeSubmodule_isPrincipal is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : CommRing.{u1} R] (K : Type.{u2}) [_inst_6 : CommRing.{u2} K] [_inst_7 : Algebra.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6))] [_inst_8 : IsFractionRing.{u1, u2} R _inst_1 K _inst_6 _inst_7] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, Iff (Submodule.IsPrincipal.{u1, u2} R K (CommRing.toRing.{u1} R _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u2} K (NonAssocRing.toNonUnitalNonAssocRing.{u2} K (Ring.toNonAssocRing.{u2} K (CommRing.toRing.{u2} K _inst_6)))) (Algebra.toModule.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (CommRing.toRing.{u2} K _inst_6)) _inst_7) (IsLocalization.coeSubmodule.{u1, u2} R _inst_1 K _inst_6 _inst_7 I)) (Submodule.IsPrincipal.{u1, u1} R R (CommRing.toRing.{u1} R _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) I)
but is expected to have type
  forall (R : Type.{u2}) [_inst_1 : CommRing.{u2} R] (K : Type.{u1}) [_inst_6 : CommRing.{u1} K] [_inst_7 : Algebra.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_6))] [_inst_8 : IsFractionRing.{u2, u1} R _inst_1 K _inst_6 _inst_7] {I : Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))}, Iff (Submodule.IsPrincipal.{u2, u1} R K (CommRing.toRing.{u2} R _inst_1) (Ring.toAddCommGroup.{u1} K (CommRing.toRing.{u1} K _inst_6)) (_private.Mathlib.RingTheory.Ideal.Operations.0.Ideal.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRing.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_1) _inst_6 _inst_7) (IsLocalization.coeSubmodule.{u2, u1} R _inst_1 K _inst_6 _inst_7 I)) (Submodule.IsPrincipal.{u2, u2} R R (CommRing.toRing.{u2} R _inst_1) (Ring.toAddCommGroup.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) I)
Case conversion may be inaccurate. Consider using '#align is_fraction_ring.coe_submodule_is_principal IsFractionRing.coeSubmodule_isPrincipalₓ'. -/
@[simp]
theorem coeSubmodule_isPrincipal {I : Ideal R} : (coeSubmodule K I).IsPrincipal ↔ I.IsPrincipal :=
  IsLocalization.coeSubmodule_isPrincipal _ le_rfl
#align is_fraction_ring.coe_submodule_is_principal IsFractionRing.coeSubmodule_isPrincipal

end CommRing

end IsFractionRing

