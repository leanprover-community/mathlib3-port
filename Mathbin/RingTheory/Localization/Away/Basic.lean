/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Mario Carneiro, Johan Commelin, Amelia Livingston, Anne Baanen

! This file was ported from Lean 3 source module ring_theory.localization.away.basic
! leanprover-community/mathlib commit 38df578a6450a8c5142b3727e3ae894c2300cae0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.RingTheory.UniqueFactorizationDomain
import Mathbin.RingTheory.Localization.Basic

/-!
# Localizations away from an element

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

## Main definitions

 * `is_localization.away (x : R) S` expresses that `S` is a localization away from `x`, as an
   abbreviation of `is_localization (submonoid.powers x) S`
 * `exists_reduced_fraction (hb : b ≠ 0)` produces a reduced fraction of the form `b = a * x^n` for
   some `n : ℤ` and some `a : R` that is not divisible by `x`.

## Implementation notes

See `src/ring_theory/localization/basic.lean` for a design overview.

## Tags
localization, ring localization, commutative ring localization, characteristic predicate,
commutative ring, field of fractions
-/


section CommSemiring

variable {R : Type _} [CommSemiring R] (M : Submonoid R) {S : Type _} [CommSemiring S]

variable [Algebra R S] {P : Type _} [CommSemiring P]

namespace IsLocalization

section Away

variable (x : R)

#print IsLocalization.Away /-
/-- Given `x : R`, the typeclass `is_localization.away x S` states that `S` is
isomorphic to the localization of `R` at the submonoid generated by `x`. -/
abbrev Away (S : Type _) [CommSemiring S] [Algebra R S] :=
  IsLocalization (Submonoid.powers x) S
#align is_localization.away IsLocalization.Away
-/

namespace Away

variable [IsLocalization.Away x S]

#print IsLocalization.Away.invSelf /-
/-- Given `x : R` and a localization map `F : R →+* S` away from `x`, `inv_self` is `(F x)⁻¹`. -/
noncomputable def invSelf : S :=
  mk' S (1 : R) ⟨x, Submonoid.mem_powers _⟩
#align is_localization.away.inv_self IsLocalization.Away.invSelf
-/

/- warning: is_localization.away.mul_inv_self -> IsLocalization.Away.mul_invSelf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_2 : CommSemiring.{u2} S] [_inst_3 : Algebra.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2)] (x : R) [_inst_5 : IsLocalization.Away.{u1, u2} R _inst_1 x S _inst_2 _inst_3], Eq.{succ u2} S (HMul.hMul.{u2, u2, u2} S S S (instHMul.{u2} S (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (algebraMap.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2) _inst_3) x) (IsLocalization.Away.invSelf.{u1, u2} R _inst_1 S _inst_2 _inst_3 x _inst_5)) (OfNat.ofNat.{u2} S 1 (OfNat.mk.{u2} S 1 (One.one.{u2} S (AddMonoidWithOne.toOne.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_2 : CommSemiring.{u2} S] [_inst_3 : Algebra.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2)] (x : R) [_inst_5 : IsLocalization.Away.{u1, u2} R _inst_1 x S _inst_2 _inst_3], Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) (HMul.hMul.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) (instHMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) (NonUnitalNonAssocSemiring.toMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) (CommSemiring.toSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) _inst_2))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))))) (algebraMap.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2) _inst_3) x) (IsLocalization.Away.invSelf.{u1, u2} R _inst_1 ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) _inst_2 _inst_3 x _inst_5)) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) (Semiring.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) (CommSemiring.toSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) _inst_2))))
Case conversion may be inaccurate. Consider using '#align is_localization.away.mul_inv_self IsLocalization.Away.mul_invSelfₓ'. -/
@[simp]
theorem mul_invSelf : algebraMap R S x * invSelf x = 1 :=
  by
  convert IsLocalization.mk'_mul_mk'_eq_one _ 1
  symm
  apply IsLocalization.mk'_one
#align is_localization.away.mul_inv_self IsLocalization.Away.mul_invSelf

variable {g : R →+* P}

/- warning: is_localization.away.lift -> IsLocalization.Away.lift is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_2 : CommSemiring.{u2} S] [_inst_3 : Algebra.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2)] {P : Type.{u3}} [_inst_4 : CommSemiring.{u3} P] (x : R) [_inst_5 : IsLocalization.Away.{u1, u2} R _inst_1 x S _inst_2 _inst_3] {g : RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))}, (IsUnit.{u3} P (MonoidWithZero.toMonoid.{u3} P (Semiring.toMonoidWithZero.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (fun (_x : RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) => R -> P) (RingHom.hasCoeToFun.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) g x)) -> (RingHom.{u2, u3} S P (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_2 : CommSemiring.{u2} S] [_inst_3 : Algebra.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2)] {P : Type.{u3}} [_inst_4 : CommSemiring.{u3} P] (x : R) [_inst_5 : IsLocalization.Away.{u1, u2} R _inst_1 x S _inst_2 _inst_3] {g : RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))}, (IsUnit.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) x) (MonoidWithZero.toMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) x) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) x) (CommSemiring.toSemiring.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) x) _inst_4))) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R P (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} P (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u1, u3} (RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} P (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u3, u1, u3} (RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)) (RingHom.instRingHomClassRingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)))))) g x)) -> (RingHom.{u2, u3} S P (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)))
Case conversion may be inaccurate. Consider using '#align is_localization.away.lift IsLocalization.Away.liftₓ'. -/
/-- Given `x : R`, a localization map `F : R →+* S` away from `x`, and a map of `comm_semiring`s
`g : R →+* P` such that `g x` is invertible, the homomorphism induced from `S` to `P` sending
`z : S` to `g y * (g x)⁻ⁿ`, where `y : R, n : ℕ` are such that `z = F y * (F x)⁻ⁿ`. -/
noncomputable def lift (hg : IsUnit (g x)) : S →+* P :=
  IsLocalization.lift fun y : Submonoid.powers x =>
    show IsUnit (g y.1) by
      obtain ⟨n, hn⟩ := y.2
      rw [← hn, g.map_pow]
      exact IsUnit.map (powMonoidHom n : P →* P) hg
#align is_localization.away.lift IsLocalization.Away.lift

/- warning: is_localization.away.away_map.lift_eq -> IsLocalization.Away.AwayMap.lift_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_2 : CommSemiring.{u2} S] [_inst_3 : Algebra.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2)] {P : Type.{u3}} [_inst_4 : CommSemiring.{u3} P] (x : R) [_inst_5 : IsLocalization.Away.{u1, u2} R _inst_1 x S _inst_2 _inst_3] {g : RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))} (hg : IsUnit.{u3} P (MonoidWithZero.toMonoid.{u3} P (Semiring.toMonoidWithZero.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (fun (_x : RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) => R -> P) (RingHom.hasCoeToFun.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) g x)) (a : R), Eq.{succ u3} P (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingHom.{u2, u3} S P (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (fun (_x : RingHom.{u2, u3} S P (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) => S -> P) (RingHom.hasCoeToFun.{u2, u3} S P (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (IsLocalization.Away.lift.{u1, u2, u3} R _inst_1 S _inst_2 _inst_3 P _inst_4 x _inst_5 g hg) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (algebraMap.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2) _inst_3) a)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (fun (_x : RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) => R -> P) (RingHom.hasCoeToFun.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) g a)
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {S : Type.{u1}} [_inst_2 : CommSemiring.{u1} S] [_inst_3 : Algebra.{u2, u1} R S _inst_1 (CommSemiring.toSemiring.{u1} S _inst_2)] {P : Type.{u3}} [_inst_4 : CommSemiring.{u3} P] (x : R) [_inst_5 : IsLocalization.Away.{u2, u1} R _inst_1 x S _inst_2 _inst_3] {g : RingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))} (hg : IsUnit.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) x) (MonoidWithZero.toMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) x) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) x) (CommSemiring.toSemiring.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) x) _inst_4))) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (RingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) _x) (MulHomClass.toFunLike.{max u2 u3, u2, u3} (RingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R P (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} P (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u3, u2, u3} (RingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} P (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u3, u2, u3} (RingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)) (RingHom.instRingHomClassRingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)))))) g x)) (a : R), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) => P) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2))) R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2)))))) (algebraMap.{u2, u1} R S _inst_1 (CommSemiring.toSemiring.{u1} S _inst_2) _inst_3) a)) (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (RingHom.{u1, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) P (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) (CommSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) _inst_2)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) (fun (_x : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) => P) _x) (MulHomClass.toFunLike.{max u3 u1, u1, u3} (RingHom.{u1, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) P (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) (CommSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) _inst_2)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) P (NonUnitalNonAssocSemiring.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) (CommSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u3} P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} P (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u1, u1, u3} (RingHom.{u1, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) P (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) (CommSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) _inst_2)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) (CommSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} P (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u1, u1, u3} (RingHom.{u1, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) P (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) (CommSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) _inst_2)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) P (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) (CommSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) _inst_2)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)) (RingHom.instRingHomClassRingHom.{u1, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) P (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) (CommSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) _inst_2)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)))))) (IsLocalization.Away.lift.{u2, u1, u3} R _inst_1 ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) _inst_2 _inst_3 P _inst_4 x _inst_5 g hg) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2))) R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2)))))) (algebraMap.{u2, u1} R S _inst_1 (CommSemiring.toSemiring.{u1} S _inst_2) _inst_3) a)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (RingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) _x) (MulHomClass.toFunLike.{max u2 u3, u2, u3} (RingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R P (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} P (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u3, u2, u3} (RingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} P (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u3, u2, u3} (RingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)) (RingHom.instRingHomClassRingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)))))) g a)
Case conversion may be inaccurate. Consider using '#align is_localization.away.away_map.lift_eq IsLocalization.Away.AwayMap.lift_eqₓ'. -/
@[simp]
theorem AwayMap.lift_eq (hg : IsUnit (g x)) (a : R) : lift x hg ((algebraMap R S) a) = g a :=
  lift_eq _ _
#align is_localization.away.away_map.lift_eq IsLocalization.Away.AwayMap.lift_eq

/- warning: is_localization.away.away_map.lift_comp -> IsLocalization.Away.AwayMap.lift_comp is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_2 : CommSemiring.{u2} S] [_inst_3 : Algebra.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2)] {P : Type.{u3}} [_inst_4 : CommSemiring.{u3} P] (x : R) [_inst_5 : IsLocalization.Away.{u1, u2} R _inst_1 x S _inst_2 _inst_3] {g : RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))} (hg : IsUnit.{u3} P (MonoidWithZero.toMonoid.{u3} P (Semiring.toMonoidWithZero.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (fun (_x : RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) => R -> P) (RingHom.hasCoeToFun.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) g x)), Eq.{max (succ u1) (succ u3)} (RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (RingHom.comp.{u1, u2, u3} R S P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)) (IsLocalization.Away.lift.{u1, u2, u3} R _inst_1 S _inst_2 _inst_3 P _inst_4 x _inst_5 g hg) (algebraMap.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2) _inst_3)) g
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {S : Type.{u1}} [_inst_2 : CommSemiring.{u1} S] [_inst_3 : Algebra.{u2, u1} R S _inst_1 (CommSemiring.toSemiring.{u1} S _inst_2)] {P : Type.{u3}} [_inst_4 : CommSemiring.{u3} P] (x : R) [_inst_5 : IsLocalization.Away.{u2, u1} R _inst_1 x S _inst_2 _inst_3] {g : RingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))} (hg : IsUnit.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) x) (MonoidWithZero.toMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) x) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) x) (CommSemiring.toSemiring.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) x) _inst_4))) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (RingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) _x) (MulHomClass.toFunLike.{max u2 u3, u2, u3} (RingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R P (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} P (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u3, u2, u3} (RingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} P (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u3, u2, u3} (RingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)) (RingHom.instRingHomClassRingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)))))) g x)), Eq.{max (succ u2) (succ u3)} (RingHom.{u2, u3} R P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (RingHom.comp.{u2, u1, u3} R S P (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)) (IsLocalization.Away.lift.{u2, u1, u3} R _inst_1 S _inst_2 _inst_3 P _inst_4 x _inst_5 g hg) (algebraMap.{u2, u1} R S _inst_1 (CommSemiring.toSemiring.{u1} S _inst_2) _inst_3)) g
Case conversion may be inaccurate. Consider using '#align is_localization.away.away_map.lift_comp IsLocalization.Away.AwayMap.lift_compₓ'. -/
@[simp]
theorem AwayMap.lift_comp (hg : IsUnit (g x)) : (lift x hg).comp (algebraMap R S) = g :=
  lift_comp _
#align is_localization.away.away_map.lift_comp IsLocalization.Away.AwayMap.lift_comp

/- warning: is_localization.away.away_to_away_right -> IsLocalization.Away.awayToAwayRight is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_2 : CommSemiring.{u2} S] [_inst_3 : Algebra.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2)] {P : Type.{u3}} [_inst_4 : CommSemiring.{u3} P] (x : R) [_inst_5 : IsLocalization.Away.{u1, u2} R _inst_1 x S _inst_2 _inst_3] (y : R) [_inst_6 : Algebra.{u1, u3} R P _inst_1 (CommSemiring.toSemiring.{u3} P _inst_4)] [_inst_7 : IsLocalization.Away.{u1, u3} R _inst_1 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) x y) P _inst_4 _inst_6], RingHom.{u2, u3} S P (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_2 : CommSemiring.{u2} S] [_inst_3 : Algebra.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2)] {P : Type.{u3}} [_inst_4 : CommSemiring.{u3} P] (x : R) [_inst_5 : IsLocalization.Away.{u1, u2} R _inst_1 x S _inst_2 _inst_3] (y : R) [_inst_6 : Algebra.{u1, u3} R P _inst_1 (CommSemiring.toSemiring.{u3} P _inst_4)] [_inst_7 : IsLocalization.Away.{u1, u3} R _inst_1 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) x y) P _inst_4 _inst_6], RingHom.{u2, u3} S P (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))
Case conversion may be inaccurate. Consider using '#align is_localization.away.away_to_away_right IsLocalization.Away.awayToAwayRightₓ'. -/
/-- Given `x y : R` and localizations `S`, `P` away from `x` and `x * y`
respectively, the homomorphism induced from `S` to `P`. -/
noncomputable def awayToAwayRight (y : R) [Algebra R P] [IsLocalization.Away (x * y) P] : S →+* P :=
  lift x <|
    show IsUnit ((algebraMap R P) x) from
      isUnit_of_mul_eq_one ((algebraMap R P) x) (mk' P y ⟨x * y, Submonoid.mem_powers _⟩) <| by
        rw [mul_mk'_eq_mk'_of_mul, mk'_self]
#align is_localization.away.away_to_away_right IsLocalization.Away.awayToAwayRight

variable (S) (Q : Type _) [CommSemiring Q] [Algebra P Q]

/- warning: is_localization.away.map -> IsLocalization.Away.map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (S : Type.{u2}) [_inst_2 : CommSemiring.{u2} S] [_inst_3 : Algebra.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2)] {P : Type.{u3}} [_inst_4 : CommSemiring.{u3} P] (Q : Type.{u4}) [_inst_6 : CommSemiring.{u4} Q] [_inst_7 : Algebra.{u3, u4} P Q _inst_4 (CommSemiring.toSemiring.{u4} Q _inst_6)] (f : RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (r : R) [_inst_8 : IsLocalization.Away.{u1, u2} R _inst_1 r S _inst_2 _inst_3] [_inst_9 : IsLocalization.Away.{u3, u4} P _inst_4 (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (fun (_x : RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) => R -> P) (RingHom.hasCoeToFun.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) f r) Q _inst_6 _inst_7], RingHom.{u2, u4} S Q (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u4} Q (CommSemiring.toSemiring.{u4} Q _inst_6))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (S : Type.{u2}) [_inst_2 : CommSemiring.{u2} S] [_inst_3 : Algebra.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2)] {P : Type.{u3}} [_inst_4 : CommSemiring.{u3} P] (Q : Type.{u4}) [_inst_6 : CommSemiring.{u4} Q] [_inst_7 : Algebra.{u3, u4} P Q _inst_4 (CommSemiring.toSemiring.{u4} Q _inst_6)] (f : RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (r : R) [_inst_8 : IsLocalization.Away.{u1, u2} R _inst_1 r S _inst_2 _inst_3] [_inst_9 : IsLocalization.Away.{u3, u4} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) r) _inst_4 (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R P (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} P (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u1, u3} (RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} P (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u3, u1, u3} (RingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4))) R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)) (RingHom.instRingHomClassRingHom.{u1, u3} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} P (CommSemiring.toSemiring.{u3} P _inst_4)))))) f r) Q _inst_6 _inst_7], RingHom.{u2, u4} S Q (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u4} Q (CommSemiring.toSemiring.{u4} Q _inst_6))
Case conversion may be inaccurate. Consider using '#align is_localization.away.map IsLocalization.Away.mapₓ'. -/
/-- Given a map `f : R →+* S` and an element `r : R`, we may construct a map `Rᵣ →+* Sᵣ`. -/
noncomputable def map (f : R →+* P) (r : R) [IsLocalization.Away r S]
    [IsLocalization.Away (f r) Q] : S →+* Q :=
  IsLocalization.map Q f
    (show Submonoid.powers r ≤ (Submonoid.powers (f r)).comap f
      by
      rintro x ⟨n, rfl⟩
      use n
      simp)
#align is_localization.away.map IsLocalization.Away.map

end Away

end Away

variable [IsLocalization M S]

section AtUnits

variable (R) (S) (M)

/- warning: is_localization.at_units -> IsLocalization.atUnits is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] (M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (S : Type.{u2}) [_inst_2 : CommSemiring.{u2} S] [_inst_3 : Algebra.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2)] [_inst_5 : IsLocalization.{u1, u2} R _inst_1 M S _inst_2 _inst_3], (forall (x : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) M), IsUnit.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) M) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) M) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) M) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) M) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) x M))))) x)) -> (AlgEquiv.{u1, u1, u2} R R S _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} S _inst_2) (Algebra.id.{u1} R _inst_1) _inst_3)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] (M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (S : Type.{u2}) [_inst_2 : CommSemiring.{u2} S] [_inst_3 : Algebra.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2)] [_inst_5 : IsLocalization.{u1, u2} R _inst_1 M S _inst_2 _inst_3], (forall (x : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) x M)), IsUnit.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) M)) x)) -> (AlgEquiv.{u1, u1, u2} R R S _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} S _inst_2) (Algebra.id.{u1} R _inst_1) _inst_3)
Case conversion may be inaccurate. Consider using '#align is_localization.at_units IsLocalization.atUnitsₓ'. -/
/-- The localization at a module of units is isomorphic to the ring -/
noncomputable def atUnits (H : ∀ x : M, IsUnit (x : R)) : R ≃ₐ[R] S :=
  by
  refine' AlgEquiv.ofBijective (Algebra.ofId R S) ⟨_, _⟩
  · intro x y hxy
    obtain ⟨c, eq⟩ := (IsLocalization.eq_iff_exists M S).mp hxy
    obtain ⟨u, hu⟩ := H c
    rwa [← hu, Units.mul_right_inj] at eq
  · intro y
    obtain ⟨⟨x, s⟩, eq⟩ := IsLocalization.surj M y
    obtain ⟨u, hu⟩ := H s
    use x * u.inv
    dsimp only [Algebra.ofId, RingHom.toFun_eq_coe, AlgHom.coe_mks]
    rw [RingHom.map_mul, ← Eq, ← hu, mul_assoc, ← RingHom.map_mul]
    simp
#align is_localization.at_units IsLocalization.atUnits

#print IsLocalization.atUnit /-
/-- The localization away from a unit is isomorphic to the ring -/
noncomputable def atUnit (x : R) (e : IsUnit x) [IsLocalization.Away x S] : R ≃ₐ[R] S :=
  by
  apply at_units R (Submonoid.powers x)
  rintro ⟨xn, n, hxn⟩
  obtain ⟨u, hu⟩ := e
  rw [isUnit_iff_exists_inv]
  use u.inv ^ n
  simp [← hxn, ← hu, ← mul_pow]
#align is_localization.at_unit IsLocalization.atUnit
-/

#print IsLocalization.atOne /-
/-- The localization at one is isomorphic to the ring. -/
noncomputable def atOne [IsLocalization.Away (1 : R) S] : R ≃ₐ[R] S :=
  @atUnit R _ S _ _ (1 : R) isUnit_one _
#align is_localization.at_one IsLocalization.atOne
-/

/- warning: is_localization.away_of_is_unit_of_bijective -> IsLocalization.away_of_isUnit_of_bijective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_6 : CommRing.{u1} R] [_inst_7 : CommRing.{u2} S] [_inst_8 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_6) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_7))] {r : R}, (IsUnit.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_6)) r) -> (Function.Bijective.{succ u1, succ u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_6))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_7)))) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_6))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_7)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_6))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_7)))) (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_6) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_7)) _inst_8))) -> (IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_6) r S (CommRing.toCommSemiring.{u2} S _inst_7) _inst_8)
but is expected to have type
  forall {R : Type.{u2}} (S : Type.{u1}) [_inst_6 : CommRing.{u2} R] [_inst_7 : CommRing.{u1} S] [_inst_8 : Algebra.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_6) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))] {r : R}, (IsUnit.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6)))) r) -> (Function.Bijective.{succ u2, succ u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7)))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7)))) R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))))))) (algebraMap.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_6) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7)) _inst_8))) -> (IsLocalization.Away.{u2, u1} R (CommRing.toCommSemiring.{u2} R _inst_6) r S (CommRing.toCommSemiring.{u1} S _inst_7) _inst_8)
Case conversion may be inaccurate. Consider using '#align is_localization.away_of_is_unit_of_bijective IsLocalization.away_of_isUnit_of_bijectiveₓ'. -/
theorem away_of_isUnit_of_bijective {R : Type _} (S : Type _) [CommRing R] [CommRing S]
    [Algebra R S] {r : R} (hr : IsUnit r) (H : Function.Bijective (algebraMap R S)) :
    IsLocalization.Away r S :=
  { map_units := by
      rintro ⟨_, n, rfl⟩
      exact (algebraMap R S).isUnit_map (hr.pow _)
    surj := fun z => by
      obtain ⟨z', rfl⟩ := H.2 z
      exact ⟨⟨z', 1⟩, by simp⟩
    eq_iff_exists := fun x y => by
      erw [H.1.eq_iff]
      constructor
      · rintro rfl
        exact ⟨1, rfl⟩
      · rintro ⟨⟨_, n, rfl⟩, e⟩
        exact (hr.pow _).mul_right_inj.mp e }
#align is_localization.away_of_is_unit_of_bijective IsLocalization.away_of_isUnit_of_bijective

end AtUnits

end IsLocalization

namespace Localization

open IsLocalization

variable {M}

/- warning: localization.away_lift -> Localization.awayLift is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {P : Type.{u2}} [_inst_4 : CommSemiring.{u2} P] (f : RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) (r : R), (IsUnit.{u2} P (MonoidWithZero.toMonoid.{u2} P (Semiring.toMonoidWithZero.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) (fun (_x : RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) => R -> P) (RingHom.hasCoeToFun.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) f r)) -> (RingHom.{u1, u2} (Localization.Away.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1) r) P (Semiring.toNonAssocSemiring.{u1} (Localization.Away.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1) r) (CommSemiring.toSemiring.{u1} (Localization.Away.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1) r) (Localization.commSemiring.{u1} R _inst_1 (Submonoid.powers.{u1} R (CommMonoid.toMonoid.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1)) r)))) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {P : Type.{u2}} [_inst_4 : CommSemiring.{u2} P] (f : RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) (r : R), (IsUnit.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) r) (MonoidWithZero.toMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) r) (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) r) (CommSemiring.toSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) r) _inst_4))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R P (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} P (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} P (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)) (RingHom.instRingHomClassRingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)))))) f r)) -> (RingHom.{u1, u2} (Localization.Away.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1) r) P (Semiring.toNonAssocSemiring.{u1} (Localization.Away.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1) r) (CommSemiring.toSemiring.{u1} (Localization.Away.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1) r) (Localization.instCommSemiringLocalizationToCommMonoid.{u1} R _inst_1 (Submonoid.powers.{u1} R (CommMonoid.toMonoid.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1)) r)))) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)))
Case conversion may be inaccurate. Consider using '#align localization.away_lift Localization.awayLiftₓ'. -/
/-- Given a map `f : R →+* S` and an element `r : R`, such that `f r` is invertible,
  we may construct a map `Rᵣ →+* S`. -/
noncomputable abbrev awayLift (f : R →+* P) (r : R) (hr : IsUnit (f r)) :
    Localization.Away r →+* P :=
  IsLocalization.Away.lift r hr
#align localization.away_lift Localization.awayLift

/- warning: localization.away_map -> Localization.awayMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {P : Type.{u2}} [_inst_4 : CommSemiring.{u2} P] (f : RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) (r : R), RingHom.{u1, u2} (Localization.Away.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1) r) (Localization.Away.{u2} P (CommSemiring.toCommMonoid.{u2} P _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) (fun (_x : RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) => R -> P) (RingHom.hasCoeToFun.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) f r)) (Semiring.toNonAssocSemiring.{u1} (Localization.Away.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1) r) (CommSemiring.toSemiring.{u1} (Localization.Away.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1) r) (Localization.commSemiring.{u1} R _inst_1 (Submonoid.powers.{u1} R (CommMonoid.toMonoid.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1)) r)))) (Semiring.toNonAssocSemiring.{u2} (Localization.Away.{u2} P (CommSemiring.toCommMonoid.{u2} P _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) (fun (_x : RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) => R -> P) (RingHom.hasCoeToFun.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) f r)) (CommSemiring.toSemiring.{u2} (Localization.Away.{u2} P (CommSemiring.toCommMonoid.{u2} P _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) (fun (_x : RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) => R -> P) (RingHom.hasCoeToFun.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) f r)) (Localization.commSemiring.{u2} P _inst_4 (Submonoid.powers.{u2} P (CommMonoid.toMonoid.{u2} P (CommSemiring.toCommMonoid.{u2} P _inst_4)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) (fun (_x : RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) => R -> P) (RingHom.hasCoeToFun.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) f r)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {P : Type.{u2}} [_inst_4 : CommSemiring.{u2} P] (f : RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) (r : R), RingHom.{u1, u2} (Localization.Away.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1) r) (Localization.Away.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) r) (CommSemiring.toCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) r) _inst_4) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R P (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} P (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} P (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)) (RingHom.instRingHomClassRingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)))))) f r)) (Semiring.toNonAssocSemiring.{u1} (Localization.Away.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1) r) (CommSemiring.toSemiring.{u1} (Localization.Away.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1) r) (Localization.instCommSemiringLocalizationToCommMonoid.{u1} R _inst_1 (Submonoid.powers.{u1} R (CommMonoid.toMonoid.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1)) r)))) (Semiring.toNonAssocSemiring.{u2} (Localization.Away.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) r) (CommSemiring.toCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) r) _inst_4) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R P (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} P (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} P (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)) (RingHom.instRingHomClassRingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)))))) f r)) (CommSemiring.toSemiring.{u2} (Localization.Away.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) r) (CommSemiring.toCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) r) _inst_4) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R P (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} P (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} P (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)) (RingHom.instRingHomClassRingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)))))) f r)) (Localization.instCommSemiringLocalizationToCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) r) _inst_4 (Submonoid.powers.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) r) (CommMonoid.toMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) r) (CommSemiring.toCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) r) _inst_4)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => P) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R P (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} P (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R P (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} P (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4))) R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)) (RingHom.instRingHomClassRingHom.{u1, u2} R P (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} P (CommSemiring.toSemiring.{u2} P _inst_4)))))) f r)))))
Case conversion may be inaccurate. Consider using '#align localization.away_map Localization.awayMapₓ'. -/
/-- Given a map `f : R →+* S` and an element `r : R`, we may construct a map `Rᵣ →+* Sᵣ`. -/
noncomputable abbrev awayMap (f : R →+* P) (r : R) :
    Localization.Away r →+* Localization.Away (f r) :=
  IsLocalization.Away.map _ _ f r
#align localization.away_map Localization.awayMap

end Localization

end CommSemiring

open Localization

variable {R : Type _} [CommRing R]

section NumDenom

open UniqueFactorizationMonoid IsLocalization

variable (x : R)

variable (B : Type _) [CommRing B] [Algebra R B] [IsLocalization.Away x B]

#print selfZpow /-
/-- `self_zpow x (m : ℤ)` is `x ^ m` as an element of the localization away from `x`. -/
noncomputable def selfZpow (m : ℤ) : B :=
  if hm : 0 ≤ m then algebraMap _ _ x ^ m.natAbs else mk' _ (1 : R) (Submonoid.pow x m.natAbs)
#align self_zpow selfZpow
-/

/- warning: self_zpow_of_nonneg -> selfZpow_of_nonneg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] {n : Int}, (LE.le.{0} Int Int.hasLe (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero))) n) -> (Eq.{succ u2} B (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 n) (HPow.hPow.{u2, 0, u2} B Nat B (instHPow.{u2, 0} B Nat (Monoid.Pow.{u2} B (Ring.toMonoid.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (fun (_x : RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)))) => R -> B) (RingHom.hasCoeToFun.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (algebraMap.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)) _inst_3) x) (Int.natAbs n)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] {n : Int}, (LE.le.{0} Int Int.instLEInt (OfNat.ofNat.{0} Int 0 (instOfNatInt 0)) n) -> (Eq.{succ u2} B (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 n) (HPow.hPow.{u2, 0, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) x) Nat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) x) (instHPow.{u2, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) x) Nat (Monoid.Pow.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) x) (MonoidWithZero.toMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) x) (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) x) (CommSemiring.toSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) x) (CommRing.toCommSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) x) _inst_2)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))) R B (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u2} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))) R B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))) R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))))))) (algebraMap.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)) _inst_3) x) (Int.natAbs n)))
Case conversion may be inaccurate. Consider using '#align self_zpow_of_nonneg selfZpow_of_nonnegₓ'. -/
theorem selfZpow_of_nonneg {n : ℤ} (hn : 0 ≤ n) : selfZpow x B n = algebraMap R B x ^ n.natAbs :=
  dif_pos hn
#align self_zpow_of_nonneg selfZpow_of_nonneg

/- warning: self_zpow_coe_nat -> selfZpow_coe_nat is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] (d : Nat), Eq.{succ u2} B (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) d)) (HPow.hPow.{u2, 0, u2} B Nat B (instHPow.{u2, 0} B Nat (Monoid.Pow.{u2} B (Ring.toMonoid.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (fun (_x : RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)))) => R -> B) (RingHom.hasCoeToFun.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (algebraMap.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)) _inst_3) x) d)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] (d : Nat), Eq.{succ u2} B (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 (Nat.cast.{0} Int instNatCastInt d)) (HPow.hPow.{u2, 0, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) x) Nat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) x) (instHPow.{u2, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) x) Nat (Monoid.Pow.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) x) (MonoidWithZero.toMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) x) (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) x) (CommSemiring.toSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) x) (CommRing.toCommSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) x) _inst_2)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))) R B (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u2} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))) R B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))) R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))))))) (algebraMap.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)) _inst_3) x) d)
Case conversion may be inaccurate. Consider using '#align self_zpow_coe_nat selfZpow_coe_natₓ'. -/
@[simp]
theorem selfZpow_coe_nat (d : ℕ) : selfZpow x B d = algebraMap R B x ^ d :=
  selfZpow_of_nonneg _ _ (Int.coe_nat_nonneg d)
#align self_zpow_coe_nat selfZpow_coe_nat

/- warning: self_zpow_zero -> selfZpow_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3], Eq.{succ u2} B (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero)))) (OfNat.ofNat.{u2} B 1 (OfNat.mk.{u2} B 1 (One.one.{u2} B (AddMonoidWithOne.toOne.{u2} B (AddGroupWithOne.toAddMonoidWithOne.{u2} B (AddCommGroupWithOne.toAddGroupWithOne.{u2} B (Ring.toAddCommGroupWithOne.{u2} B (CommRing.toRing.{u2} B _inst_2))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3], Eq.{succ u2} B (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Int 0 (instOfNatInt 0))) (OfNat.ofNat.{u2} B 1 (One.toOfNat1.{u2} B (Semiring.toOne.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))))
Case conversion may be inaccurate. Consider using '#align self_zpow_zero selfZpow_zeroₓ'. -/
@[simp]
theorem selfZpow_zero : selfZpow x B 0 = 1 := by simp [selfZpow_of_nonneg _ _ le_rfl]
#align self_zpow_zero selfZpow_zero

/- warning: self_zpow_of_neg -> selfZpow_of_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] {n : Int}, (LT.lt.{0} Int Int.hasLt n (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero)))) -> (Eq.{succ u2} B (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 n) (IsLocalization.mk'.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) (Submonoid.powers.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x) B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3 _inst_4 (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Submonoid.pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x (Int.natAbs n))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] {n : Int}, (LT.lt.{0} Int Int.instLTInt n (OfNat.ofNat.{0} Int 0 (instOfNatInt 0))) -> (Eq.{succ u2} B (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 n) (IsLocalization.mk'.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) (Submonoid.powers.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x) B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3 _inst_4 (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Submonoid.pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x (Int.natAbs n))))
Case conversion may be inaccurate. Consider using '#align self_zpow_of_neg selfZpow_of_negₓ'. -/
theorem selfZpow_of_neg {n : ℤ} (hn : n < 0) :
    selfZpow x B n = mk' _ (1 : R) (Submonoid.pow x n.natAbs) :=
  dif_neg hn.not_le
#align self_zpow_of_neg selfZpow_of_neg

/- warning: self_zpow_of_nonpos -> selfZpow_of_nonpos is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] {n : Int}, (LE.le.{0} Int Int.hasLe n (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero)))) -> (Eq.{succ u2} B (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 n) (IsLocalization.mk'.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) (Submonoid.powers.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x) B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3 _inst_4 (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Submonoid.pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x (Int.natAbs n))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] {n : Int}, (LE.le.{0} Int Int.instLEInt n (OfNat.ofNat.{0} Int 0 (instOfNatInt 0))) -> (Eq.{succ u2} B (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 n) (IsLocalization.mk'.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) (Submonoid.powers.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x) B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3 _inst_4 (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Submonoid.pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x (Int.natAbs n))))
Case conversion may be inaccurate. Consider using '#align self_zpow_of_nonpos selfZpow_of_nonposₓ'. -/
theorem selfZpow_of_nonpos {n : ℤ} (hn : n ≤ 0) :
    selfZpow x B n = mk' _ (1 : R) (Submonoid.pow x n.natAbs) :=
  by
  by_cases hn0 : n = 0
  · simp [hn0, selfZpow_zero, Submonoid.pow_apply]
  · simp [selfZpow_of_neg _ _ (lt_of_le_of_ne hn hn0)]
#align self_zpow_of_nonpos selfZpow_of_nonpos

/- warning: self_zpow_neg_coe_nat -> selfZpow_neg_coe_nat is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] (d : Nat), Eq.{succ u2} B (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 (Neg.neg.{0} Int Int.hasNeg ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) d))) (IsLocalization.mk'.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) (Submonoid.powers.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x) B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3 _inst_4 (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Submonoid.pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x d))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] (d : Nat), Eq.{succ u2} B (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 (Neg.neg.{0} Int Int.instNegInt (Nat.cast.{0} Int instNatCastInt d))) (IsLocalization.mk'.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) (Submonoid.powers.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x) B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3 _inst_4 (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Submonoid.pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x d))
Case conversion may be inaccurate. Consider using '#align self_zpow_neg_coe_nat selfZpow_neg_coe_natₓ'. -/
@[simp]
theorem selfZpow_neg_coe_nat (d : ℕ) : selfZpow x B (-d) = mk' _ (1 : R) (Submonoid.pow x d) := by
  simp [selfZpow_of_nonpos _ _ (neg_nonpos.mpr (Int.coe_nat_nonneg d))]
#align self_zpow_neg_coe_nat selfZpow_neg_coe_nat

/- warning: self_zpow_sub_cast_nat -> selfZpow_sub_cast_nat is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] {n : Nat} {m : Nat}, Eq.{succ u2} B (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.hasSub) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) n) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) m))) (IsLocalization.mk'.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) (Submonoid.powers.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x) B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3 _inst_4 (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) x n) (Submonoid.pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x m))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] {n : Nat} {m : Nat}, Eq.{succ u2} B (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.instSubInt) (Nat.cast.{0} Int instNatCastInt n) (Nat.cast.{0} Int instNatCastInt m))) (IsLocalization.mk'.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) (Submonoid.powers.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x) B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3 _inst_4 (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) x n) (Submonoid.pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x m))
Case conversion may be inaccurate. Consider using '#align self_zpow_sub_cast_nat selfZpow_sub_cast_natₓ'. -/
@[simp]
theorem selfZpow_sub_cast_nat {n m : ℕ} :
    selfZpow x B (n - m) = mk' _ (x ^ n) (Submonoid.pow x m) :=
  by
  by_cases h : m ≤ n
  ·
    rw [IsLocalization.eq_mk'_iff_mul_eq, Submonoid.pow_apply, Subtype.coe_mk, ← Int.ofNat_sub h,
      selfZpow_coe_nat, ← map_pow, ← map_mul, ← pow_add, Nat.sub_add_cancel h]
  · rw [← neg_sub, ← Int.ofNat_sub (le_of_not_le h), selfZpow_neg_coe_nat,
      IsLocalization.mk'_eq_iff_eq]
    simp [Submonoid.pow_apply, ← pow_add, Nat.sub_add_cancel (le_of_not_le h)]
#align self_zpow_sub_cast_nat selfZpow_sub_cast_nat

/- warning: self_zpow_add -> selfZpow_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] {n : Int} {m : Int}, Eq.{succ u2} B (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.hasAdd) n m)) (HMul.hMul.{u2, u2, u2} B B B (instHMul.{u2} B (Distrib.toHasMul.{u2} B (Ring.toDistrib.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 n) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 m))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] {n : Int} {m : Int}, Eq.{succ u2} B (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.instAddInt) n m)) (HMul.hMul.{u2, u2, u2} B B B (instHMul.{u2} B (NonUnitalNonAssocRing.toMul.{u2} B (NonAssocRing.toNonUnitalNonAssocRing.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2))))) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 n) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 m))
Case conversion may be inaccurate. Consider using '#align self_zpow_add selfZpow_addₓ'. -/
@[simp]
theorem selfZpow_add {n m : ℤ} : selfZpow x B (n + m) = selfZpow x B n * selfZpow x B m :=
  by
  cases' le_or_lt 0 n with hn hn <;> cases' le_or_lt 0 m with hm hm
  ·
    rw [selfZpow_of_nonneg _ _ hn, selfZpow_of_nonneg _ _ hm,
      selfZpow_of_nonneg _ _ (add_nonneg hn hm), Int.natAbs_add_nonneg hn hm, pow_add]
  · have : n + m = n.nat_abs - m.nat_abs := by
      rw [Int.natAbs_of_nonneg hn, Int.ofNat_natAbs_of_nonpos hm.le, sub_neg_eq_add]
    rw [selfZpow_of_nonneg _ _ hn, selfZpow_of_neg _ _ hm, this, selfZpow_sub_cast_nat,
      IsLocalization.mk'_eq_mul_mk'_one, map_pow]
  · have : n + m = m.nat_abs - n.nat_abs := by
      rw [Int.natAbs_of_nonneg hm, Int.ofNat_natAbs_of_nonpos hn.le, sub_neg_eq_add, add_comm]
    rw [selfZpow_of_nonneg _ _ hm, selfZpow_of_neg _ _ hn, this, selfZpow_sub_cast_nat,
      IsLocalization.mk'_eq_mul_mk'_one, map_pow, mul_comm]
  · rw [selfZpow_of_neg _ _ hn, selfZpow_of_neg _ _ hm, selfZpow_of_neg _ _ (add_neg hn hm),
      Int.natAbs_add_neg hn hm, ← mk'_mul, one_mul]
    congr
    ext
    simp [pow_add]
#align self_zpow_add selfZpow_add

/- warning: self_zpow_mul_neg -> selfZpow_mul_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] (d : Int), Eq.{succ u2} B (HMul.hMul.{u2, u2, u2} B B B (instHMul.{u2} B (Distrib.toHasMul.{u2} B (Ring.toDistrib.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 d) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 (Neg.neg.{0} Int Int.hasNeg d))) (OfNat.ofNat.{u2} B 1 (OfNat.mk.{u2} B 1 (One.one.{u2} B (AddMonoidWithOne.toOne.{u2} B (AddGroupWithOne.toAddMonoidWithOne.{u2} B (AddCommGroupWithOne.toAddGroupWithOne.{u2} B (Ring.toAddCommGroupWithOne.{u2} B (CommRing.toRing.{u2} B _inst_2))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] (d : Int), Eq.{succ u2} B (HMul.hMul.{u2, u2, u2} B B B (instHMul.{u2} B (NonUnitalNonAssocRing.toMul.{u2} B (NonAssocRing.toNonUnitalNonAssocRing.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2))))) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 d) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 (Neg.neg.{0} Int Int.instNegInt d))) (OfNat.ofNat.{u2} B 1 (One.toOfNat1.{u2} B (Semiring.toOne.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))))
Case conversion may be inaccurate. Consider using '#align self_zpow_mul_neg selfZpow_mul_negₓ'. -/
theorem selfZpow_mul_neg (d : ℤ) : selfZpow x B d * selfZpow x B (-d) = 1 :=
  by
  by_cases hd : d ≤ 0
  · erw [selfZpow_of_nonpos x B hd, selfZpow_of_nonneg, ← map_pow, Int.natAbs_neg,
      IsLocalization.mk'_spec, map_one]
    apply nonneg_of_neg_nonpos
    rwa [neg_neg]
  · erw [selfZpow_of_nonneg x B (le_of_not_le hd), selfZpow_of_nonpos, ← map_pow, Int.natAbs_neg,
      @IsLocalization.mk'_spec' R _ (Submonoid.powers x) B _ _ _ 1 (Submonoid.pow x d.nat_abs),
      map_one]
    refine' nonpos_of_neg_nonneg (le_of_lt _)
    rwa [neg_neg, ← not_le]
#align self_zpow_mul_neg selfZpow_mul_neg

/- warning: self_zpow_neg_mul -> selfZpow_neg_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] (d : Int), Eq.{succ u2} B (HMul.hMul.{u2, u2, u2} B B B (instHMul.{u2} B (Distrib.toHasMul.{u2} B (Ring.toDistrib.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 (Neg.neg.{0} Int Int.hasNeg d)) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 d)) (OfNat.ofNat.{u2} B 1 (OfNat.mk.{u2} B 1 (One.one.{u2} B (AddMonoidWithOne.toOne.{u2} B (AddGroupWithOne.toAddMonoidWithOne.{u2} B (AddCommGroupWithOne.toAddGroupWithOne.{u2} B (Ring.toAddCommGroupWithOne.{u2} B (CommRing.toRing.{u2} B _inst_2))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] (d : Int), Eq.{succ u2} B (HMul.hMul.{u2, u2, u2} B B B (instHMul.{u2} B (NonUnitalNonAssocRing.toMul.{u2} B (NonAssocRing.toNonUnitalNonAssocRing.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2))))) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 (Neg.neg.{0} Int Int.instNegInt d)) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 d)) (OfNat.ofNat.{u2} B 1 (One.toOfNat1.{u2} B (Semiring.toOne.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))))
Case conversion may be inaccurate. Consider using '#align self_zpow_neg_mul selfZpow_neg_mulₓ'. -/
theorem selfZpow_neg_mul (d : ℤ) : selfZpow x B (-d) * selfZpow x B d = 1 := by
  rw [mul_comm, selfZpow_mul_neg x B d]
#align self_zpow_neg_mul selfZpow_neg_mul

/- warning: self_zpow_pow_sub -> selfZpow_pow_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] (a : R) (b : B) (m : Int) (d : Int), Iff (Eq.{succ u2} B (HMul.hMul.{u2, u2, u2} B B B (instHMul.{u2} B (Distrib.toHasMul.{u2} B (Ring.toDistrib.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.hasSub) m d)) (IsLocalization.mk'.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) (Submonoid.powers.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x) B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3 _inst_4 a (OfNat.ofNat.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Submonoid.powers.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x)) 1 (OfNat.mk.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Submonoid.powers.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x)) 1 (One.one.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Submonoid.powers.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x)) (Submonoid.one.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submonoid.powers.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x))))))) b) (Eq.{succ u2} B (HMul.hMul.{u2, u2, u2} B B B (instHMul.{u2} B (Distrib.toHasMul.{u2} B (Ring.toDistrib.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 m) (IsLocalization.mk'.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) (Submonoid.powers.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x) B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3 _inst_4 a (OfNat.ofNat.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Submonoid.powers.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x)) 1 (OfNat.mk.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Submonoid.powers.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x)) 1 (One.one.{u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) R (Submonoid.setLike.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Submonoid.powers.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x)) (Submonoid.one.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submonoid.powers.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x))))))) (HMul.hMul.{u2, u2, u2} B B B (instHMul.{u2} B (Distrib.toHasMul.{u2} B (Ring.toDistrib.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 d) b))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] (a : R) (b : B) (m : Int) (d : Int), Iff (Eq.{succ u2} B (HMul.hMul.{u2, u2, u2} B B B (instHMul.{u2} B (NonUnitalNonAssocRing.toMul.{u2} B (NonAssocRing.toNonUnitalNonAssocRing.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2))))) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.instSubInt) m d)) (IsLocalization.mk'.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) (Submonoid.powers.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x) B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3 _inst_4 a (OfNat.ofNat.{u1} (Subtype.{succ u1} R (fun (x_1 : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))))) x_1 (Submonoid.powers.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x))) 1 (One.toOfNat1.{u1} (Subtype.{succ u1} R (fun (x_1 : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))))) x_1 (Submonoid.powers.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x))) (Submonoid.one.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Submonoid.powers.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x)))))) b) (Eq.{succ u2} B (HMul.hMul.{u2, u2, u2} B B B (instHMul.{u2} B (NonUnitalNonAssocRing.toMul.{u2} B (NonAssocRing.toNonUnitalNonAssocRing.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2))))) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 m) (IsLocalization.mk'.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) (Submonoid.powers.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x) B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3 _inst_4 a (OfNat.ofNat.{u1} (Subtype.{succ u1} R (fun (x_1 : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))))) x_1 (Submonoid.powers.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x))) 1 (One.toOfNat1.{u1} (Subtype.{succ u1} R (fun (x_1 : R) => Membership.mem.{u1, u1} R (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))))) x_1 (Submonoid.powers.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x))) (Submonoid.one.{u1} R (Monoid.toMulOneClass.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Submonoid.powers.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x)))))) (HMul.hMul.{u2, u2, u2} B B B (instHMul.{u2} B (NonUnitalNonAssocRing.toMul.{u2} B (NonAssocRing.toNonUnitalNonAssocRing.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2))))) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 d) b))
Case conversion may be inaccurate. Consider using '#align self_zpow_pow_sub selfZpow_pow_subₓ'. -/
theorem selfZpow_pow_sub (a : R) (b : B) (m d : ℤ) :
    selfZpow x B (m - d) * mk' B a (1 : Submonoid.powers x) = b ↔
      selfZpow x B m * mk' B a (1 : Submonoid.powers x) = selfZpow x B d * b :=
  by
  rw [sub_eq_add_neg, selfZpow_add, mul_assoc, mul_comm _ (mk' B a 1), ← mul_assoc]
  constructor
  · intro h
    have := congr_arg (fun s : B => s * selfZpow x B d) h
    simp only at this
    rwa [mul_assoc, mul_assoc, selfZpow_neg_mul, mul_one, mul_comm b _] at this
  · intro h
    have := congr_arg (fun s : B => s * selfZpow x B (-d)) h
    simp only at this
    rwa [mul_comm _ b, mul_assoc b _ _, selfZpow_mul_neg, mul_one] at this
#align self_zpow_pow_sub selfZpow_pow_sub

variable [IsDomain R] [NormalizationMonoid R] [UniqueFactorizationMonoid R]

/- warning: exists_reduced_fraction' -> exists_reduced_fraction' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] [_inst_5 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] [_inst_6 : NormalizationMonoid.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_5)] [_inst_7 : UniqueFactorizationMonoid.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_5)] {b : B}, (Ne.{succ u2} B b (OfNat.ofNat.{u2} B 0 (OfNat.mk.{u2} B 0 (Zero.zero.{u2} B (MulZeroClass.toHasZero.{u2} B (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} B (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} B (NonAssocRing.toNonUnitalNonAssocRing.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))))))))) -> (Irreducible.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)) x) -> (Exists.{succ u1} R (fun (a : R) => Exists.{1} Int (fun (n : Int) => And (Not (Dvd.Dvd.{u1} R (semigroupDvd.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (NonUnitalCommRing.toNonUnitalRing.{u1} R (CommRing.toNonUnitalCommRing.{u1} R _inst_1)))))) x a)) (Eq.{succ u2} B (HMul.hMul.{u2, u2, u2} B B B (instHMul.{u2} B (Distrib.toHasMul.{u2} B (Ring.toDistrib.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 n) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (fun (_x : RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)))) => R -> B) (RingHom.hasCoeToFun.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (algebraMap.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)) _inst_3) a)) b))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : R) (B : Type.{u2}) [_inst_2 : CommRing.{u2} B] [_inst_3 : Algebra.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))] [_inst_4 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) x B (CommRing.toCommSemiring.{u2} B _inst_2) _inst_3] [_inst_5 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))] [_inst_6 : NormalizationMonoid.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_5)] [_inst_7 : UniqueFactorizationMonoid.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_5)] {b : B}, (Ne.{succ u2} B b (OfNat.ofNat.{u2} B 0 (Zero.toOfNat0.{u2} B (CommMonoidWithZero.toZero.{u2} B (CommSemiring.toCommMonoidWithZero.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))))) -> (Irreducible.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) x) -> (Exists.{succ u1} R (fun (a : R) => Exists.{1} Int (fun (n : Int) => And (Not (Dvd.dvd.{u1} R (semigroupDvd.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R (NonUnitalCommRing.toNonUnitalCommSemiring.{u1} R (CommRing.toNonUnitalCommRing.{u1} R _inst_1)))))) x a)) (Eq.{succ u2} B (HMul.hMul.{u2, u2, u2} B ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) a) B (instHMul.{u2} B (NonUnitalNonAssocRing.toMul.{u2} B (NonAssocRing.toNonUnitalNonAssocRing.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2))))) (selfZpow.{u1, u2} R _inst_1 x B _inst_2 _inst_3 _inst_4 n) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => B) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))) R B (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u2} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))) R B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)))) R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} B (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2))))))) (algebraMap.{u1, u2} R B (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} B (CommRing.toCommSemiring.{u2} B _inst_2)) _inst_3) a)) b))))
Case conversion may be inaccurate. Consider using '#align exists_reduced_fraction' exists_reduced_fraction'ₓ'. -/
theorem exists_reduced_fraction' {b : B} (hb : b ≠ 0) (hx : Irreducible x) :
    ∃ (a : R)(n : ℤ), ¬x ∣ a ∧ selfZpow x B n * algebraMap R B a = b := by
  classical
    obtain ⟨⟨a₀, y⟩, H⟩ := surj (Submonoid.powers x) b
    obtain ⟨d, hy⟩ := (Submonoid.mem_powers_iff y.1 x).mp y.2
    have ha₀ : a₀ ≠ 0 :=
      by
      haveI :=
        @is_domain_of_le_non_zero_divisors B _ R _ _ _ (Submonoid.powers x) _
          (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
      simp only [map_zero, ← Subtype.val_eq_coe, ← hy, map_pow] at H
      apply ((injective_iff_map_eq_zero' (algebraMap R B)).mp _ a₀).mpr.mt
      rw [← H]
      apply mul_ne_zero hb (pow_ne_zero _ _)
      exact
        IsLocalization.to_map_ne_zero_of_mem_nonZeroDivisors B
          (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
          (mem_non_zero_divisors_iff_ne_zero.mpr hx.ne_zero)
      exact IsLocalization.injective B (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
    simp only [← Subtype.val_eq_coe, ← hy] at H
    obtain ⟨m, a, hyp1, hyp2⟩ := max_power_factor ha₀ hx
    refine' ⟨a, m - d, _⟩
    rw [← mk'_one B, selfZpow_pow_sub, selfZpow_coe_nat, selfZpow_coe_nat, ← map_pow _ _ d,
      mul_comm _ b, H, hyp2, map_mul, map_pow _ _ m]
    exact ⟨hyp1, congr_arg _ (IsLocalization.mk'_one _ _)⟩
#align exists_reduced_fraction' exists_reduced_fraction'

end NumDenom

