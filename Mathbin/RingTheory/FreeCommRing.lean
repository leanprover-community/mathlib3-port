/-
Copyright (c) 2019 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Johan Commelin

! This file was ported from Lean 3 source module ring_theory.free_comm_ring
! leanprover-community/mathlib commit 50251fd6309cca5ca2e747882ffecd2729f38c5d
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.MvPolynomial.Equiv
import Mathbin.Data.MvPolynomial.CommRing
import Mathbin.Logic.Equiv.Functor
import Mathbin.RingTheory.FreeRing

/-!
# Free commutative rings

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

The theory of the free commutative ring generated by a type `α`.
It is isomorphic to the polynomial ring over ℤ with variables
in `α`

## Main definitions

* `free_comm_ring α`     : the free commutative ring on a type α
* `lift (f : α → R)` : the ring hom `free_comm_ring α →+* R` induced by functoriality from `f`.
* `map (f : α → β)`      : the ring hom `free_comm_ring α →*+ free_comm_ring β` induced by
                           functoriality from f.

## Main results

`free_comm_ring` has functorial properties (it is an adjoint to the forgetful functor).
In this file we have:

* `of : α → free_comm_ring α`
* `lift (f : α → R) : free_comm_ring α →+* R`
* `map (f : α → β) : free_comm_ring α →+* free_comm_ring β`

* `free_comm_ring_equiv_mv_polynomial_int : free_comm_ring α ≃+* mv_polynomial α ℤ` :
    `free_comm_ring α` is isomorphic to a polynomial ring.



## Implementation notes

`free_comm_ring α` is implemented not using `mv_polynomial` but
directly as the free abelian group on `multiset α`, the type
of monomials in this free commutative ring.

## Tags

free commutative ring, free ring
-/


noncomputable section

open Classical Polynomial

universe u v

variable (α : Type u)

#print FreeCommRing /-
/-- `free_comm_ring α` is the free commutative ring on the type `α`. -/
def FreeCommRing (α : Type u) : Type u :=
  FreeAbelianGroup <| Multiplicative <| Multiset α deriving CommRing, Inhabited
#align free_comm_ring FreeCommRing
-/

namespace FreeCommRing

variable {α}

#print FreeCommRing.of /-
/-- The canonical map from `α` to the free commutative ring on `α`. -/
def of (x : α) : FreeCommRing α :=
  FreeAbelianGroup.of <| Multiplicative.ofAdd ({x} : Multiset α)
#align free_comm_ring.of FreeCommRing.of
-/

#print FreeCommRing.of_injective /-
theorem of_injective : Function.Injective (of : α → FreeCommRing α) :=
  FreeAbelianGroup.of_injective.comp fun x y =>
    (Multiset.coe_eq_coe.trans List.singleton_perm_singleton).mp
#align free_comm_ring.of_injective FreeCommRing.of_injective
-/

/- warning: free_comm_ring.induction_on -> FreeCommRing.induction_on is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {C : (FreeCommRing.{u1} α) -> Prop} (z : FreeCommRing.{u1} α), (C (Neg.neg.{u1} (FreeCommRing.{u1} α) (SubNegMonoid.toHasNeg.{u1} (FreeCommRing.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeCommRing.{u1} α) (AddGroupWithOne.toAddGroup.{u1} (FreeCommRing.{u1} α) (AddCommGroupWithOne.toAddGroupWithOne.{u1} (FreeCommRing.{u1} α) (Ring.toAddCommGroupWithOne.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))))) (OfNat.ofNat.{u1} (FreeCommRing.{u1} α) 1 (OfNat.mk.{u1} (FreeCommRing.{u1} α) 1 (One.one.{u1} (FreeCommRing.{u1} α) (AddMonoidWithOne.toOne.{u1} (FreeCommRing.{u1} α) (AddGroupWithOne.toAddMonoidWithOne.{u1} (FreeCommRing.{u1} α) (AddCommGroupWithOne.toAddGroupWithOne.{u1} (FreeCommRing.{u1} α) (Ring.toAddCommGroupWithOne.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))))))))) -> (forall (b : α), C (FreeCommRing.of.{u1} α b)) -> (forall (x : FreeCommRing.{u1} α) (y : FreeCommRing.{u1} α), (C x) -> (C y) -> (C (HAdd.hAdd.{u1, u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (instHAdd.{u1} (FreeCommRing.{u1} α) (Distrib.toHasAdd.{u1} (FreeCommRing.{u1} α) (Ring.toDistrib.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) x y))) -> (forall (x : FreeCommRing.{u1} α) (y : FreeCommRing.{u1} α), (C x) -> (C y) -> (C (HMul.hMul.{u1, u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (instHMul.{u1} (FreeCommRing.{u1} α) (Distrib.toHasMul.{u1} (FreeCommRing.{u1} α) (Ring.toDistrib.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) x y))) -> (C z)
but is expected to have type
  forall {α : Type.{u1}} {C : (FreeCommRing.{u1} α) -> Prop} (z : FreeCommRing.{u1} α), (C (Neg.neg.{u1} (FreeCommRing.{u1} α) (Ring.toNeg.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))) (OfNat.ofNat.{u1} (FreeCommRing.{u1} α) 1 (One.toOfNat1.{u1} (FreeCommRing.{u1} α) (Semiring.toOne.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))))) -> (forall (b : α), C (FreeCommRing.of.{u1} α b)) -> (forall (x : FreeCommRing.{u1} α) (y : FreeCommRing.{u1} α), (C x) -> (C y) -> (C (HAdd.hAdd.{u1, u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (instHAdd.{u1} (FreeCommRing.{u1} α) (Distrib.toAdd.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocSemiring.toDistrib.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))))) x y))) -> (forall (x : FreeCommRing.{u1} α) (y : FreeCommRing.{u1} α), (C x) -> (C y) -> (C (HMul.hMul.{u1, u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (instHMul.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocRing.toMul.{u1} (FreeCommRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))) x y))) -> (C z)
Case conversion may be inaccurate. Consider using '#align free_comm_ring.induction_on FreeCommRing.induction_onₓ'. -/
@[elab_as_elim]
protected theorem induction_on {C : FreeCommRing α → Prop} (z : FreeCommRing α) (hn1 : C (-1))
    (hb : ∀ b, C (of b)) (ha : ∀ x y, C x → C y → C (x + y)) (hm : ∀ x y, C x → C y → C (x * y)) :
    C z :=
  have hn : ∀ x, C x → C (-x) := fun x ih => neg_one_mul x ▸ hm _ _ hn1 ih
  have h1 : C 1 := neg_neg (1 : FreeCommRing α) ▸ hn _ hn1
  FreeAbelianGroup.induction_on z (add_left_neg (1 : FreeCommRing α) ▸ ha _ _ hn1 h1)
    (fun m => Multiset.induction_on m h1 fun a m ih => hm _ _ (hb a) ih) (fun m ih => hn _ ih) ha
#align free_comm_ring.induction_on FreeCommRing.induction_on

section lift

variable {R : Type v} [CommRing R] (f : α → R)

/-- A helper to implement `lift`. This is essentially `free_comm_monoid.lift`, but this does not
currently exist. -/
private def lift_to_multiset : (α → R) ≃ (Multiplicative (Multiset α) →* R)
    where
  toFun f :=
    { toFun := fun s => (s.toAdd.map f).Prod
      map_mul' := fun x y =>
        calc
          _ = Multiset.prod (Multiset.map f x + Multiset.map f y) :=
            by
            congr 1
            exact Multiset.map_add _ _ _
          _ = _ := Multiset.prod_add _ _
          
      map_one' := rfl }
  invFun F x := F (Multiplicative.ofAdd ({x} : Multiset α))
  left_inv f := funext fun x => show (Multiset.map f {x}).Prod = _ by simp
  right_inv F :=
    MonoidHom.ext fun x =>
      let F' := F.toAdditive''
      let x' := x.toAdd
      show (Multiset.map (fun a => F' {a}) x').Sum = F' x'
        by
        rw [← Multiset.map_map, ← AddMonoidHom.map_multiset_sum]
        exact F.congr_arg (Multiset.sum_map_singleton x')
#align free_comm_ring.lift_to_multiset free_comm_ring.lift_to_multiset

#print FreeCommRing.lift /-
/-- Lift a map `α → R` to a additive group homomorphism `free_comm_ring α → R`.
For a version producing a bundled homomorphism, see `lift_hom`. -/
def lift : (α → R) ≃ (FreeCommRing α →+* R) :=
  Equiv.trans liftToMultiset FreeAbelianGroup.liftMonoid
#align free_comm_ring.lift FreeCommRing.lift
-/

/- warning: free_comm_ring.lift_of -> FreeCommRing.lift_of is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] (f : α -> R) (x : α), Eq.{succ u2} R (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))) (fun (_x : RingHom.{u1, u2} (FreeCommRing.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))) => (FreeCommRing.{u1} α) -> R) (RingHom.hasCoeToFun.{u1, u2} (FreeCommRing.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> R) (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> R) (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))))) => (α -> R) -> (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> R) (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))))) (FreeCommRing.lift.{u1, u2} α R _inst_1) f) (FreeCommRing.of.{u1} α x)) (f x)
but is expected to have type
  forall {α : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] (f : α -> R) (x : α), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : FreeCommRing.{u1} α) => R) (FreeCommRing.of.{u1} α x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : α -> R) => RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) f) (FreeCommRing.{u1} α) (fun (_x : FreeCommRing.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : FreeCommRing.{u1} α) => R) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : α -> R) => RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) f) (FreeCommRing.{u1} α) R (NonUnitalNonAssocSemiring.toMul.{u1} (FreeCommRing.{u1} α) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : α -> R) => RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) f) (FreeCommRing.{u1} α) R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : α -> R) => RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) f) (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> R) (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (α -> R) (fun (_x : α -> R) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : α -> R) => RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (α -> R) (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (FreeCommRing.lift.{u1, u2} α R _inst_1) f) (FreeCommRing.of.{u1} α x)) (f x)
Case conversion may be inaccurate. Consider using '#align free_comm_ring.lift_of FreeCommRing.lift_ofₓ'. -/
@[simp]
theorem lift_of (x : α) : lift f (of x) = f x :=
  (FreeAbelianGroup.lift.of _ _).trans <| mul_one _
#align free_comm_ring.lift_of FreeCommRing.lift_of

#print FreeCommRing.lift_comp_of /-
@[simp]
theorem lift_comp_of (f : FreeCommRing α →+* R) : lift (f ∘ of) = f :=
  RingHom.ext fun x =>
    FreeCommRing.induction_on x (by rw [RingHom.map_neg, RingHom.map_one, f.map_neg, f.map_one])
      (lift_of _) (fun x y ihx ihy => by rw [RingHom.map_add, f.map_add, ihx, ihy])
      fun x y ihx ihy => by rw [RingHom.map_mul, f.map_mul, ihx, ihy]
#align free_comm_ring.lift_comp_of FreeCommRing.lift_comp_of
-/

/- warning: free_comm_ring.hom_ext -> FreeCommRing.hom_ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] {{f : RingHom.{u1, u2} (FreeCommRing.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))}} {{g : RingHom.{u1, u2} (FreeCommRing.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))}}, (forall (x : α), Eq.{succ u2} R (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))) (fun (_x : RingHom.{u1, u2} (FreeCommRing.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))) => (FreeCommRing.{u1} α) -> R) (RingHom.hasCoeToFun.{u1, u2} (FreeCommRing.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))) f (FreeCommRing.of.{u1} α x)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))) (fun (_x : RingHom.{u1, u2} (FreeCommRing.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))) => (FreeCommRing.{u1} α) -> R) (RingHom.hasCoeToFun.{u1, u2} (FreeCommRing.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))) g (FreeCommRing.of.{u1} α x))) -> (Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))) f g)
but is expected to have type
  forall {α : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] {{f : RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))}} {{g : RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))}}, (forall (x : α), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : FreeCommRing.{u1} α) => R) (FreeCommRing.of.{u1} α x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (FreeCommRing.{u1} α) (fun (_x : FreeCommRing.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : FreeCommRing.{u1} α) => R) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (FreeCommRing.{u1} α) R (NonUnitalNonAssocSemiring.toMul.{u1} (FreeCommRing.{u1} α) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (FreeCommRing.{u1} α) R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))))) f (FreeCommRing.of.{u1} α x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (FreeCommRing.{u1} α) (fun (_x : FreeCommRing.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : FreeCommRing.{u1} α) => R) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (FreeCommRing.{u1} α) R (NonUnitalNonAssocSemiring.toMul.{u1} (FreeCommRing.{u1} α) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (FreeCommRing.{u1} α) R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))))) g (FreeCommRing.of.{u1} α x))) -> (Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} (FreeCommRing.{u1} α) R (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) f g)
Case conversion may be inaccurate. Consider using '#align free_comm_ring.hom_ext FreeCommRing.hom_extₓ'. -/
@[ext]
theorem hom_ext ⦃f g : FreeCommRing α →+* R⦄ (h : ∀ x, f (of x) = g (of x)) : f = g :=
  lift.symm.Injective (funext h)
#align free_comm_ring.hom_ext FreeCommRing.hom_ext

end lift

variable {β : Type v} (f : α → β)

#print FreeCommRing.map /-
/-- A map `f : α → β` produces a ring homomorphism `free_comm_ring α →+* free_comm_ring β`. -/
def map : FreeCommRing α →+* FreeCommRing β :=
  lift <| of ∘ f
#align free_comm_ring.map FreeCommRing.map
-/

/- warning: free_comm_ring.map_of -> FreeCommRing.map_of is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} (f : α -> β) (x : α), Eq.{succ u2} (FreeCommRing.{u2} β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} (FreeCommRing.{u1} α) (FreeCommRing.{u2} β) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} (FreeCommRing.{u2} β) (Ring.toNonAssocRing.{u2} (FreeCommRing.{u2} β) (CommRing.toRing.{u2} (FreeCommRing.{u2} β) (FreeCommRing.instCommRing.{u2} β))))) (fun (_x : RingHom.{u1, u2} (FreeCommRing.{u1} α) (FreeCommRing.{u2} β) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} (FreeCommRing.{u2} β) (Ring.toNonAssocRing.{u2} (FreeCommRing.{u2} β) (CommRing.toRing.{u2} (FreeCommRing.{u2} β) (FreeCommRing.instCommRing.{u2} β))))) => (FreeCommRing.{u1} α) -> (FreeCommRing.{u2} β)) (RingHom.hasCoeToFun.{u1, u2} (FreeCommRing.{u1} α) (FreeCommRing.{u2} β) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u2} (FreeCommRing.{u2} β) (Ring.toNonAssocRing.{u2} (FreeCommRing.{u2} β) (CommRing.toRing.{u2} (FreeCommRing.{u2} β) (FreeCommRing.instCommRing.{u2} β))))) (FreeCommRing.map.{u1, u2} α β f) (FreeCommRing.of.{u1} α x)) (FreeCommRing.of.{u2} β (f x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} (f : α -> β) (x : α), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : FreeCommRing.{u1} α) => FreeCommRing.{u2} β) (FreeCommRing.of.{u1} α x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} (FreeCommRing.{u1} α) (FreeCommRing.{u2} β) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} (FreeCommRing.{u2} β) (CommSemiring.toSemiring.{u2} (FreeCommRing.{u2} β) (CommRing.toCommSemiring.{u2} (FreeCommRing.{u2} β) (FreeCommRing.instCommRing.{u2} β))))) (FreeCommRing.{u1} α) (fun (_x : FreeCommRing.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : FreeCommRing.{u1} α) => FreeCommRing.{u2} β) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} (FreeCommRing.{u1} α) (FreeCommRing.{u2} β) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} (FreeCommRing.{u2} β) (CommSemiring.toSemiring.{u2} (FreeCommRing.{u2} β) (CommRing.toCommSemiring.{u2} (FreeCommRing.{u2} β) (FreeCommRing.instCommRing.{u2} β))))) (FreeCommRing.{u1} α) (FreeCommRing.{u2} β) (NonUnitalNonAssocSemiring.toMul.{u1} (FreeCommRing.{u1} α) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))) (NonUnitalNonAssocSemiring.toMul.{u2} (FreeCommRing.{u2} β) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (FreeCommRing.{u2} β) (Semiring.toNonAssocSemiring.{u2} (FreeCommRing.{u2} β) (CommSemiring.toSemiring.{u2} (FreeCommRing.{u2} β) (CommRing.toCommSemiring.{u2} (FreeCommRing.{u2} β) (FreeCommRing.instCommRing.{u2} β)))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (FreeCommRing.{u1} α) (FreeCommRing.{u2} β) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} (FreeCommRing.{u2} β) (CommSemiring.toSemiring.{u2} (FreeCommRing.{u2} β) (CommRing.toCommSemiring.{u2} (FreeCommRing.{u2} β) (FreeCommRing.instCommRing.{u2} β))))) (FreeCommRing.{u1} α) (FreeCommRing.{u2} β) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (FreeCommRing.{u2} β) (Semiring.toNonAssocSemiring.{u2} (FreeCommRing.{u2} β) (CommSemiring.toSemiring.{u2} (FreeCommRing.{u2} β) (CommRing.toCommSemiring.{u2} (FreeCommRing.{u2} β) (FreeCommRing.instCommRing.{u2} β))))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (FreeCommRing.{u1} α) (FreeCommRing.{u2} β) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} (FreeCommRing.{u2} β) (CommSemiring.toSemiring.{u2} (FreeCommRing.{u2} β) (CommRing.toCommSemiring.{u2} (FreeCommRing.{u2} β) (FreeCommRing.instCommRing.{u2} β))))) (FreeCommRing.{u1} α) (FreeCommRing.{u2} β) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} (FreeCommRing.{u2} β) (CommSemiring.toSemiring.{u2} (FreeCommRing.{u2} β) (CommRing.toCommSemiring.{u2} (FreeCommRing.{u2} β) (FreeCommRing.instCommRing.{u2} β)))) (RingHom.instRingHomClassRingHom.{u1, u2} (FreeCommRing.{u1} α) (FreeCommRing.{u2} β) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u2} (FreeCommRing.{u2} β) (CommSemiring.toSemiring.{u2} (FreeCommRing.{u2} β) (CommRing.toCommSemiring.{u2} (FreeCommRing.{u2} β) (FreeCommRing.instCommRing.{u2} β)))))))) (FreeCommRing.map.{u1, u2} α β f) (FreeCommRing.of.{u1} α x)) (FreeCommRing.of.{u2} β (f x))
Case conversion may be inaccurate. Consider using '#align free_comm_ring.map_of FreeCommRing.map_ofₓ'. -/
@[simp]
theorem map_of (x : α) : map f (of x) = of (f x) :=
  lift_of _ _
#align free_comm_ring.map_of FreeCommRing.map_of

#print FreeCommRing.IsSupported /-
/-- `is_supported x s` means that all monomials showing up in `x` have variables in `s`. -/
def IsSupported (x : FreeCommRing α) (s : Set α) : Prop :=
  x ∈ Subring.closure (of '' s)
#align free_comm_ring.is_supported FreeCommRing.IsSupported
-/

section IsSupported

variable {x y : FreeCommRing α} {s t : Set α}

#print FreeCommRing.isSupported_upwards /-
theorem isSupported_upwards (hs : IsSupported x s) (hst : s ⊆ t) : IsSupported x t :=
  Subring.closure_mono (Set.monotone_image hst) hs
#align free_comm_ring.is_supported_upwards FreeCommRing.isSupported_upwards
-/

/- warning: free_comm_ring.is_supported_add -> FreeCommRing.isSupported_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {x : FreeCommRing.{u1} α} {y : FreeCommRing.{u1} α} {s : Set.{u1} α}, (FreeCommRing.IsSupported.{u1} α x s) -> (FreeCommRing.IsSupported.{u1} α y s) -> (FreeCommRing.IsSupported.{u1} α (HAdd.hAdd.{u1, u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (instHAdd.{u1} (FreeCommRing.{u1} α) (Distrib.toHasAdd.{u1} (FreeCommRing.{u1} α) (Ring.toDistrib.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) x y) s)
but is expected to have type
  forall {α : Type.{u1}} {x : FreeCommRing.{u1} α} {y : FreeCommRing.{u1} α} {s : Set.{u1} α}, (FreeCommRing.IsSupported.{u1} α x s) -> (FreeCommRing.IsSupported.{u1} α y s) -> (FreeCommRing.IsSupported.{u1} α (HAdd.hAdd.{u1, u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (instHAdd.{u1} (FreeCommRing.{u1} α) (Distrib.toAdd.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocSemiring.toDistrib.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))))) x y) s)
Case conversion may be inaccurate. Consider using '#align free_comm_ring.is_supported_add FreeCommRing.isSupported_addₓ'. -/
theorem isSupported_add (hxs : IsSupported x s) (hys : IsSupported y s) : IsSupported (x + y) s :=
  Subring.add_mem _ hxs hys
#align free_comm_ring.is_supported_add FreeCommRing.isSupported_add

/- warning: free_comm_ring.is_supported_neg -> FreeCommRing.isSupported_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {x : FreeCommRing.{u1} α} {s : Set.{u1} α}, (FreeCommRing.IsSupported.{u1} α x s) -> (FreeCommRing.IsSupported.{u1} α (Neg.neg.{u1} (FreeCommRing.{u1} α) (SubNegMonoid.toHasNeg.{u1} (FreeCommRing.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeCommRing.{u1} α) (AddGroupWithOne.toAddGroup.{u1} (FreeCommRing.{u1} α) (AddCommGroupWithOne.toAddGroupWithOne.{u1} (FreeCommRing.{u1} α) (Ring.toAddCommGroupWithOne.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))))) x) s)
but is expected to have type
  forall {α : Type.{u1}} {x : FreeCommRing.{u1} α} {s : Set.{u1} α}, (FreeCommRing.IsSupported.{u1} α x s) -> (FreeCommRing.IsSupported.{u1} α (Neg.neg.{u1} (FreeCommRing.{u1} α) (Ring.toNeg.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))) x) s)
Case conversion may be inaccurate. Consider using '#align free_comm_ring.is_supported_neg FreeCommRing.isSupported_negₓ'. -/
theorem isSupported_neg (hxs : IsSupported x s) : IsSupported (-x) s :=
  Subring.neg_mem _ hxs
#align free_comm_ring.is_supported_neg FreeCommRing.isSupported_neg

/- warning: free_comm_ring.is_supported_sub -> FreeCommRing.isSupported_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {x : FreeCommRing.{u1} α} {y : FreeCommRing.{u1} α} {s : Set.{u1} α}, (FreeCommRing.IsSupported.{u1} α x s) -> (FreeCommRing.IsSupported.{u1} α y s) -> (FreeCommRing.IsSupported.{u1} α (HSub.hSub.{u1, u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (instHSub.{u1} (FreeCommRing.{u1} α) (SubNegMonoid.toHasSub.{u1} (FreeCommRing.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeCommRing.{u1} α) (AddGroupWithOne.toAddGroup.{u1} (FreeCommRing.{u1} α) (AddCommGroupWithOne.toAddGroupWithOne.{u1} (FreeCommRing.{u1} α) (Ring.toAddCommGroupWithOne.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))))) x y) s)
but is expected to have type
  forall {α : Type.{u1}} {x : FreeCommRing.{u1} α} {y : FreeCommRing.{u1} α} {s : Set.{u1} α}, (FreeCommRing.IsSupported.{u1} α x s) -> (FreeCommRing.IsSupported.{u1} α y s) -> (FreeCommRing.IsSupported.{u1} α (HSub.hSub.{u1, u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (instHSub.{u1} (FreeCommRing.{u1} α) (Ring.toSub.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) x y) s)
Case conversion may be inaccurate. Consider using '#align free_comm_ring.is_supported_sub FreeCommRing.isSupported_subₓ'. -/
theorem isSupported_sub (hxs : IsSupported x s) (hys : IsSupported y s) : IsSupported (x - y) s :=
  Subring.sub_mem _ hxs hys
#align free_comm_ring.is_supported_sub FreeCommRing.isSupported_sub

/- warning: free_comm_ring.is_supported_mul -> FreeCommRing.isSupported_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {x : FreeCommRing.{u1} α} {y : FreeCommRing.{u1} α} {s : Set.{u1} α}, (FreeCommRing.IsSupported.{u1} α x s) -> (FreeCommRing.IsSupported.{u1} α y s) -> (FreeCommRing.IsSupported.{u1} α (HMul.hMul.{u1, u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (instHMul.{u1} (FreeCommRing.{u1} α) (Distrib.toHasMul.{u1} (FreeCommRing.{u1} α) (Ring.toDistrib.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) x y) s)
but is expected to have type
  forall {α : Type.{u1}} {x : FreeCommRing.{u1} α} {y : FreeCommRing.{u1} α} {s : Set.{u1} α}, (FreeCommRing.IsSupported.{u1} α x s) -> (FreeCommRing.IsSupported.{u1} α y s) -> (FreeCommRing.IsSupported.{u1} α (HMul.hMul.{u1, u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (instHMul.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocRing.toMul.{u1} (FreeCommRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))) x y) s)
Case conversion may be inaccurate. Consider using '#align free_comm_ring.is_supported_mul FreeCommRing.isSupported_mulₓ'. -/
theorem isSupported_mul (hxs : IsSupported x s) (hys : IsSupported y s) : IsSupported (x * y) s :=
  Subring.mul_mem _ hxs hys
#align free_comm_ring.is_supported_mul FreeCommRing.isSupported_mul

/- warning: free_comm_ring.is_supported_zero -> FreeCommRing.isSupported_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {s : Set.{u1} α}, FreeCommRing.IsSupported.{u1} α (OfNat.ofNat.{u1} (FreeCommRing.{u1} α) 0 (OfNat.mk.{u1} (FreeCommRing.{u1} α) 0 (Zero.zero.{u1} (FreeCommRing.{u1} α) (MulZeroClass.toHasZero.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))))))) s
but is expected to have type
  forall {α : Type.{u1}} {s : Set.{u1} α}, FreeCommRing.IsSupported.{u1} α (OfNat.ofNat.{u1} (FreeCommRing.{u1} α) 0 (Zero.toOfNat0.{u1} (FreeCommRing.{u1} α) (CommMonoidWithZero.toZero.{u1} (FreeCommRing.{u1} α) (CommSemiring.toCommMonoidWithZero.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))) s
Case conversion may be inaccurate. Consider using '#align free_comm_ring.is_supported_zero FreeCommRing.isSupported_zeroₓ'. -/
theorem isSupported_zero : IsSupported 0 s :=
  Subring.zero_mem _
#align free_comm_ring.is_supported_zero FreeCommRing.isSupported_zero

/- warning: free_comm_ring.is_supported_one -> FreeCommRing.isSupported_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {s : Set.{u1} α}, FreeCommRing.IsSupported.{u1} α (OfNat.ofNat.{u1} (FreeCommRing.{u1} α) 1 (OfNat.mk.{u1} (FreeCommRing.{u1} α) 1 (One.one.{u1} (FreeCommRing.{u1} α) (AddMonoidWithOne.toOne.{u1} (FreeCommRing.{u1} α) (AddGroupWithOne.toAddMonoidWithOne.{u1} (FreeCommRing.{u1} α) (AddCommGroupWithOne.toAddGroupWithOne.{u1} (FreeCommRing.{u1} α) (Ring.toAddCommGroupWithOne.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))))))) s
but is expected to have type
  forall {α : Type.{u1}} {s : Set.{u1} α}, FreeCommRing.IsSupported.{u1} α (OfNat.ofNat.{u1} (FreeCommRing.{u1} α) 1 (One.toOfNat1.{u1} (FreeCommRing.{u1} α) (Semiring.toOne.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))) s
Case conversion may be inaccurate. Consider using '#align free_comm_ring.is_supported_one FreeCommRing.isSupported_oneₓ'. -/
theorem isSupported_one : IsSupported 1 s :=
  Subring.one_mem _
#align free_comm_ring.is_supported_one FreeCommRing.isSupported_one

/- warning: free_comm_ring.is_supported_int -> FreeCommRing.isSupported_int is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {i : Int} {s : Set.{u1} α}, FreeCommRing.IsSupported.{u1} α ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int (FreeCommRing.{u1} α) (HasLiftT.mk.{1, succ u1} Int (FreeCommRing.{u1} α) (CoeTCₓ.coe.{1, succ u1} Int (FreeCommRing.{u1} α) (Int.castCoe.{u1} (FreeCommRing.{u1} α) (AddGroupWithOne.toHasIntCast.{u1} (FreeCommRing.{u1} α) (AddCommGroupWithOne.toAddGroupWithOne.{u1} (FreeCommRing.{u1} α) (Ring.toAddCommGroupWithOne.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))))) i) s
but is expected to have type
  forall {α : Type.{u1}} {i : Int} {s : Set.{u1} α}, FreeCommRing.IsSupported.{u1} α (Int.cast.{u1} (FreeCommRing.{u1} α) (Ring.toIntCast.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))) i) s
Case conversion may be inaccurate. Consider using '#align free_comm_ring.is_supported_int FreeCommRing.isSupported_intₓ'. -/
theorem isSupported_int {i : ℤ} {s : Set α} : IsSupported (↑i) s :=
  Int.induction_on i isSupported_zero
    (fun i hi => by rw [Int.cast_add, Int.cast_one] <;> exact is_supported_add hi is_supported_one)
    fun i hi => by rw [Int.cast_sub, Int.cast_one] <;> exact is_supported_sub hi is_supported_one
#align free_comm_ring.is_supported_int FreeCommRing.isSupported_int

end IsSupported

#print FreeCommRing.restriction /-
/-- The restriction map from `free_comm_ring α` to `free_comm_ring s` where `s : set α`, defined
  by sending all variables not in `s` to zero. -/
def restriction (s : Set α) [DecidablePred (· ∈ s)] : FreeCommRing α →+* FreeCommRing s :=
  lift fun p => if H : p ∈ s then of (⟨p, H⟩ : s) else 0
#align free_comm_ring.restriction FreeCommRing.restriction
-/

section Restriction

variable (s : Set α) [DecidablePred (· ∈ s)] (x y : FreeCommRing α)

/- warning: free_comm_ring.restriction_of -> FreeCommRing.restriction_of is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (s : Set.{u1} α) [_inst_1 : DecidablePred.{succ u1} α (fun (_x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) _x s)] (p : α), Eq.{succ u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (CommRing.toRing.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (FreeCommRing.instCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)))))) (fun (_x : RingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (CommRing.toRing.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (FreeCommRing.instCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)))))) => (FreeCommRing.{u1} α) -> (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s))) (RingHom.hasCoeToFun.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (CommRing.toRing.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (FreeCommRing.instCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)))))) (FreeCommRing.restriction.{u1} α s (fun (a : α) => _inst_1 a)) (FreeCommRing.of.{u1} α p)) (dite.{succ u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) p s) (_inst_1 p) (fun (H : Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) p s) => FreeCommRing.of.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) (Subtype.mk.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s) p H)) (fun (H : Not (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) p s)) => OfNat.ofNat.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) 0 (OfNat.mk.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) 0 (Zero.zero.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (MulZeroClass.toHasZero.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (CommRing.toRing.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (FreeCommRing.instCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s))))))))))))
but is expected to have type
  forall {α : Type.{u1}} (s : Set.{u1} α) [_inst_1 : DecidablePred.{succ u1} α (fun (_x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) _x s)] (p : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : FreeCommRing.{u1} α) => FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.of.{u1} α p)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s)))))) (FreeCommRing.{u1} α) (fun (_x : FreeCommRing.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : FreeCommRing.{u1} α) => FreeCommRing.{u1} (Set.Elem.{u1} α s)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s)))))) (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (NonUnitalNonAssocSemiring.toMul.{u1} (FreeCommRing.{u1} α) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))) (NonUnitalNonAssocSemiring.toMul.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s)))))) (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s)))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s)))))) (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))) (RingHom.instRingHomClassRingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))))))) (FreeCommRing.restriction.{u1} α s (fun (a : α) => _inst_1 a)) (FreeCommRing.of.{u1} α p)) (dite.{succ u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) p s) (_inst_1 p) (fun (H : Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) p s) => FreeCommRing.of.{u1} (Set.Elem.{u1} α s) (Subtype.mk.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s) p H)) (fun (H : Not (Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) p s)) => OfNat.ofNat.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) 0 (Zero.toOfNat0.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommMonoidWithZero.toZero.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toCommMonoidWithZero.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))))))
Case conversion may be inaccurate. Consider using '#align free_comm_ring.restriction_of FreeCommRing.restriction_ofₓ'. -/
@[simp]
theorem restriction_of (p) : restriction s (of p) = if H : p ∈ s then of ⟨p, H⟩ else 0 :=
  lift_of _ _
#align free_comm_ring.restriction_of FreeCommRing.restriction_of

end Restriction

#print FreeCommRing.isSupported_of /-
theorem isSupported_of {p} {s : Set α} : IsSupported (of p) s ↔ p ∈ s :=
  suffices IsSupported (of p) s → p ∈ s from ⟨this, fun hps => Subring.subset_closure ⟨p, hps, rfl⟩⟩
  fun hps : IsSupported (of p) s =>
  by
  haveI := Classical.decPred s
  have :
    ∀ x,
      is_supported x s →
        ∃ n : ℤ, lift (fun a => if a ∈ s then (0 : ℤ[X]) else Polynomial.X) x = n :=
    by
    intro x hx
    refine' Subring.InClosure.recOn hx _ _ _ _
    · use 1
      rw [RingHom.map_one]
      norm_cast
    · use -1
      rw [RingHom.map_neg, RingHom.map_one, Int.cast_neg, Int.cast_one]
    · rintro _ ⟨z, hzs, rfl⟩ _ _
      use 0
      rw [RingHom.map_mul, lift_of, if_pos hzs, MulZeroClass.zero_mul]
      norm_cast
    · rintro x y ⟨q, hq⟩ ⟨r, hr⟩
      refine' ⟨q + r, _⟩
      rw [RingHom.map_add, hq, hr]
      norm_cast
  specialize this (of p) hps
  rw [lift_of] at this
  split_ifs  at this
  · exact h
  exfalso
  apply Ne.symm Int.zero_ne_one
  rcases this with ⟨w, H⟩
  rw [← Polynomial.C_eq_int_cast] at H
  have : polynomial.X.coeff 1 = (Polynomial.C ↑w).coeff 1 := by rw [H]
  rwa [Polynomial.coeff_C, if_neg (one_ne_zero : 1 ≠ 0), Polynomial.coeff_X, if_pos rfl] at this
#align free_comm_ring.is_supported_of FreeCommRing.isSupported_of
-/

/- warning: free_comm_ring.map_subtype_val_restriction -> FreeCommRing.map_subtype_val_restriction is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {x : FreeCommRing.{u1} α} (s : Set.{u1} α) [_inst_1 : DecidablePred.{succ u1} α (fun (_x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) _x s)], (FreeCommRing.IsSupported.{u1} α x s) -> (Eq.{succ u1} (FreeCommRing.{u1} α) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} (FreeCommRing.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s))) (FreeCommRing.{u1} α) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s))) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s))) (CommRing.toRing.{u1} (FreeCommRing.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s))) (FreeCommRing.instCommRing.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s)))))) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) (fun (_x : RingHom.{u1, u1} (FreeCommRing.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s))) (FreeCommRing.{u1} α) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s))) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s))) (CommRing.toRing.{u1} (FreeCommRing.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s))) (FreeCommRing.instCommRing.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s)))))) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) => (FreeCommRing.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s))) -> (FreeCommRing.{u1} α)) (RingHom.hasCoeToFun.{u1, u1} (FreeCommRing.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s))) (FreeCommRing.{u1} α) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s))) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s))) (CommRing.toRing.{u1} (FreeCommRing.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s))) (FreeCommRing.instCommRing.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s)))))) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) (FreeCommRing.map.{u1, u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s)) α (Subtype.val.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (CommRing.toRing.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (FreeCommRing.instCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)))))) (fun (_x : RingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (CommRing.toRing.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (FreeCommRing.instCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)))))) => (FreeCommRing.{u1} α) -> (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s))) (RingHom.hasCoeToFun.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (NonAssocRing.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (CommRing.toRing.{u1} (FreeCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)) (FreeCommRing.instCommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s)))))) (FreeCommRing.restriction.{u1} α s (fun (a : α) => _inst_1 a)) x)) x)
but is expected to have type
  forall {α : Type.{u1}} {x : FreeCommRing.{u1} α} (s : Set.{u1} α) [_inst_1 : DecidablePred.{succ u1} α (fun (_x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) _x s)], (FreeCommRing.IsSupported.{u1} α x s) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : FreeCommRing.{u1} (Set.Elem.{u1} α s)) => FreeCommRing.{u1} α) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s)))))) (FreeCommRing.{u1} α) (fun (a : FreeCommRing.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : FreeCommRing.{u1} α) => FreeCommRing.{u1} (Set.Elem.{u1} α s)) a) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s)))))) (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (NonUnitalNonAssocSemiring.toMul.{u1} (FreeCommRing.{u1} α) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))) (NonUnitalNonAssocSemiring.toMul.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s)))))) (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s)))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s)))))) (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))) (RingHom.instRingHomClassRingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))))))) (FreeCommRing.restriction.{u1} α s (fun (a : α) => _inst_1 a)) x)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (fun (_x : FreeCommRing.{u1} (Set.Elem.{u1} α s)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : FreeCommRing.{u1} (Set.Elem.{u1} α s)) => FreeCommRing.{u1} α) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.{u1} α) (NonUnitalNonAssocSemiring.toMul.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))))) (NonUnitalNonAssocSemiring.toMul.{u1} (FreeCommRing.{u1} α) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.{u1} α) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s)))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (RingHom.instRingHomClassRingHom.{u1, u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))))) (FreeCommRing.map.{u1, u1} (Set.Elem.{u1} α s) α (Subtype.val.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) x s))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s)))))) (FreeCommRing.{u1} α) (fun (_x : FreeCommRing.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : FreeCommRing.{u1} α) => FreeCommRing.{u1} (Set.Elem.{u1} α s)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s)))))) (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (NonUnitalNonAssocSemiring.toMul.{u1} (FreeCommRing.{u1} α) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))) (NonUnitalNonAssocSemiring.toMul.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s)))))) (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s)))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s)))))) (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))) (RingHom.instRingHomClassRingHom.{u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Semiring.toNonAssocSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} (Set.Elem.{u1} α s)) (FreeCommRing.instCommRing.{u1} (Set.Elem.{u1} α s))))))))) (FreeCommRing.restriction.{u1} α s (fun (a : α) => _inst_1 a)) x)) x)
Case conversion may be inaccurate. Consider using '#align free_comm_ring.map_subtype_val_restriction FreeCommRing.map_subtype_val_restrictionₓ'. -/
theorem map_subtype_val_restriction {x} (s : Set α) [DecidablePred (· ∈ s)]
    (hxs : IsSupported x s) : map (Subtype.val : s → α) (restriction s x) = x :=
  by
  refine' Subring.InClosure.recOn hxs _ _ _ _
  · rw [RingHom.map_one]
    rfl
  · rw [RingHom.map_neg, RingHom.map_neg, RingHom.map_one]
    rfl
  · rintro _ ⟨p, hps, rfl⟩ n ih
    rw [RingHom.map_mul, restriction_of, dif_pos hps, RingHom.map_mul, map_of, ih]
  · intro x y ihx ihy
    rw [RingHom.map_add, RingHom.map_add, ihx, ihy]
#align free_comm_ring.map_subtype_val_restriction FreeCommRing.map_subtype_val_restriction

#print FreeCommRing.exists_finite_support /-
theorem exists_finite_support (x : FreeCommRing α) : ∃ s : Set α, Set.Finite s ∧ IsSupported x s :=
  FreeCommRing.induction_on x ⟨∅, Set.finite_empty, isSupported_neg isSupported_one⟩
    (fun p => ⟨{p}, Set.finite_singleton p, isSupported_of.2 <| Set.mem_singleton _⟩)
    (fun x y ⟨s, hfs, hxs⟩ ⟨t, hft, hxt⟩ =>
      ⟨s ∪ t, hfs.union hft,
        isSupported_add (isSupported_upwards hxs <| Set.subset_union_left s t)
          (isSupported_upwards hxt <| Set.subset_union_right s t)⟩)
    fun x y ⟨s, hfs, hxs⟩ ⟨t, hft, hxt⟩ =>
    ⟨s ∪ t, hfs.union hft,
      isSupported_mul (isSupported_upwards hxs <| Set.subset_union_left s t)
        (isSupported_upwards hxt <| Set.subset_union_right s t)⟩
#align free_comm_ring.exists_finite_support FreeCommRing.exists_finite_support
-/

#print FreeCommRing.exists_finset_support /-
theorem exists_finset_support (x : FreeCommRing α) : ∃ s : Finset α, IsSupported x ↑s :=
  let ⟨s, hfs, hxs⟩ := exists_finite_support x
  ⟨hfs.toFinset, by rwa [Set.Finite.coe_toFinset]⟩
#align free_comm_ring.exists_finset_support FreeCommRing.exists_finset_support
-/

end FreeCommRing

namespace FreeRing

open Function

variable (α)

#print FreeRing.toFreeCommRing /-
/-- The canonical ring homomorphism from the free ring generated by `α` to the free commutative ring
    generated by `α`. -/
def toFreeCommRing {α} : FreeRing α →+* FreeCommRing α :=
  FreeRing.lift FreeCommRing.of
#align free_ring.to_free_comm_ring FreeRing.toFreeCommRing
-/

instance : Coe (FreeRing α) (FreeCommRing α) :=
  ⟨toFreeCommRing⟩

#print FreeRing.coeRingHom /-
/-- The natural map `free_ring α → free_comm_ring α`, as a `ring_hom`. -/
def coeRingHom : FreeRing α →+* FreeCommRing α :=
  toFreeCommRing
#align free_ring.coe_ring_hom FreeRing.coeRingHom
-/

/- warning: free_ring.coe_zero -> FreeRing.coe_zero is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}), Eq.{succ u1} (FreeCommRing.{u1} α) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (FreeRing.{u1} α) (FreeCommRing.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (coeBase.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (FreeRing.FreeCommRing.instCoe.{u1} α)))) (OfNat.ofNat.{u1} (FreeRing.{u1} α) 0 (OfNat.mk.{u1} (FreeRing.{u1} α) 0 (Zero.zero.{u1} (FreeRing.{u1} α) (MulZeroClass.toHasZero.{u1} (FreeRing.{u1} α) (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} (FreeRing.{u1} α) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (FreeRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeRing.{u1} α) (FreeRing.ring.{u1} α)))))))))) (OfNat.ofNat.{u1} (FreeCommRing.{u1} α) 0 (OfNat.mk.{u1} (FreeCommRing.{u1} α) 0 (Zero.zero.{u1} (FreeCommRing.{u1} α) (MulZeroClass.toHasZero.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))))))))
but is expected to have type
  forall (α : Type.{u1}), Eq.{succ u1} (FreeCommRing.{u1} α) (FreeRing.castFreeCommRing.{u1} α (OfNat.ofNat.{u1} (FreeRing.{u1} α) 0 (Zero.toOfNat0.{u1} (FreeRing.{u1} α) (MonoidWithZero.toZero.{u1} (FreeRing.{u1} α) (Semiring.toMonoidWithZero.{u1} (FreeRing.{u1} α) (Ring.toSemiring.{u1} (FreeRing.{u1} α) (instRingFreeRing.{u1} α))))))) (OfNat.ofNat.{u1} (FreeCommRing.{u1} α) 0 (Zero.toOfNat0.{u1} (FreeCommRing.{u1} α) (CommMonoidWithZero.toZero.{u1} (FreeCommRing.{u1} α) (CommSemiring.toCommMonoidWithZero.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))))
Case conversion may be inaccurate. Consider using '#align free_ring.coe_zero FreeRing.coe_zeroₓ'. -/
@[simp, norm_cast]
protected theorem coe_zero : ↑(0 : FreeRing α) = (0 : FreeCommRing α) :=
  rfl
#align free_ring.coe_zero FreeRing.coe_zero

/- warning: free_ring.coe_one -> FreeRing.coe_one is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}), Eq.{succ u1} (FreeCommRing.{u1} α) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (FreeRing.{u1} α) (FreeCommRing.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (coeBase.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (FreeRing.FreeCommRing.instCoe.{u1} α)))) (OfNat.ofNat.{u1} (FreeRing.{u1} α) 1 (OfNat.mk.{u1} (FreeRing.{u1} α) 1 (One.one.{u1} (FreeRing.{u1} α) (AddMonoidWithOne.toOne.{u1} (FreeRing.{u1} α) (AddGroupWithOne.toAddMonoidWithOne.{u1} (FreeRing.{u1} α) (AddCommGroupWithOne.toAddGroupWithOne.{u1} (FreeRing.{u1} α) (Ring.toAddCommGroupWithOne.{u1} (FreeRing.{u1} α) (FreeRing.ring.{u1} α))))))))) (OfNat.ofNat.{u1} (FreeCommRing.{u1} α) 1 (OfNat.mk.{u1} (FreeCommRing.{u1} α) 1 (One.one.{u1} (FreeCommRing.{u1} α) (AddMonoidWithOne.toOne.{u1} (FreeCommRing.{u1} α) (AddGroupWithOne.toAddMonoidWithOne.{u1} (FreeCommRing.{u1} α) (AddCommGroupWithOne.toAddGroupWithOne.{u1} (FreeCommRing.{u1} α) (Ring.toAddCommGroupWithOne.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))))))
but is expected to have type
  forall (α : Type.{u1}), Eq.{succ u1} (FreeCommRing.{u1} α) (FreeRing.castFreeCommRing.{u1} α (OfNat.ofNat.{u1} (FreeRing.{u1} α) 1 (One.toOfNat1.{u1} (FreeRing.{u1} α) (Semiring.toOne.{u1} (FreeRing.{u1} α) (Ring.toSemiring.{u1} (FreeRing.{u1} α) (instRingFreeRing.{u1} α)))))) (OfNat.ofNat.{u1} (FreeCommRing.{u1} α) 1 (One.toOfNat1.{u1} (FreeCommRing.{u1} α) (Semiring.toOne.{u1} (FreeCommRing.{u1} α) (CommSemiring.toSemiring.{u1} (FreeCommRing.{u1} α) (CommRing.toCommSemiring.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))))
Case conversion may be inaccurate. Consider using '#align free_ring.coe_one FreeRing.coe_oneₓ'. -/
@[simp, norm_cast]
protected theorem coe_one : ↑(1 : FreeRing α) = (1 : FreeCommRing α) :=
  rfl
#align free_ring.coe_one FreeRing.coe_one

variable {α}

#print FreeRing.coe_of /-
@[simp]
protected theorem coe_of (a : α) : ↑(FreeRing.of a) = FreeCommRing.of a :=
  FreeRing.lift_of _ _
#align free_ring.coe_of FreeRing.coe_of
-/

/- warning: free_ring.coe_neg -> FreeRing.coe_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (x : FreeRing.{u1} α), Eq.{succ u1} (FreeCommRing.{u1} α) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (FreeRing.{u1} α) (FreeCommRing.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (coeBase.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (FreeRing.FreeCommRing.instCoe.{u1} α)))) (Neg.neg.{u1} (FreeRing.{u1} α) (SubNegMonoid.toHasNeg.{u1} (FreeRing.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeRing.{u1} α) (AddGroupWithOne.toAddGroup.{u1} (FreeRing.{u1} α) (AddCommGroupWithOne.toAddGroupWithOne.{u1} (FreeRing.{u1} α) (Ring.toAddCommGroupWithOne.{u1} (FreeRing.{u1} α) (FreeRing.ring.{u1} α)))))) x)) (Neg.neg.{u1} (FreeCommRing.{u1} α) (SubNegMonoid.toHasNeg.{u1} (FreeCommRing.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeCommRing.{u1} α) (AddGroupWithOne.toAddGroup.{u1} (FreeCommRing.{u1} α) (AddCommGroupWithOne.toAddGroupWithOne.{u1} (FreeCommRing.{u1} α) (Ring.toAddCommGroupWithOne.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (FreeRing.{u1} α) (FreeCommRing.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (coeBase.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (FreeRing.FreeCommRing.instCoe.{u1} α)))) x))
but is expected to have type
  forall {α : Type.{u1}} (x : FreeRing.{u1} α), Eq.{succ u1} (FreeCommRing.{u1} α) (FreeRing.castFreeCommRing.{u1} α (Neg.neg.{u1} (FreeRing.{u1} α) (Ring.toNeg.{u1} (FreeRing.{u1} α) (instRingFreeRing.{u1} α)) x)) (Neg.neg.{u1} (FreeCommRing.{u1} α) (Ring.toNeg.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))) (FreeRing.castFreeCommRing.{u1} α x))
Case conversion may be inaccurate. Consider using '#align free_ring.coe_neg FreeRing.coe_negₓ'. -/
@[simp, norm_cast]
protected theorem coe_neg (x : FreeRing α) : ↑(-x) = -(x : FreeCommRing α) :=
  (FreeRing.lift _).map_neg _
#align free_ring.coe_neg FreeRing.coe_neg

/- warning: free_ring.coe_add -> FreeRing.coe_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (x : FreeRing.{u1} α) (y : FreeRing.{u1} α), Eq.{succ u1} (FreeCommRing.{u1} α) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (FreeRing.{u1} α) (FreeCommRing.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (coeBase.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (FreeRing.FreeCommRing.instCoe.{u1} α)))) (HAdd.hAdd.{u1, u1, u1} (FreeRing.{u1} α) (FreeRing.{u1} α) (FreeRing.{u1} α) (instHAdd.{u1} (FreeRing.{u1} α) (Distrib.toHasAdd.{u1} (FreeRing.{u1} α) (Ring.toDistrib.{u1} (FreeRing.{u1} α) (FreeRing.ring.{u1} α)))) x y)) (HAdd.hAdd.{u1, u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (instHAdd.{u1} (FreeCommRing.{u1} α) (Distrib.toHasAdd.{u1} (FreeCommRing.{u1} α) (Ring.toDistrib.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (FreeRing.{u1} α) (FreeCommRing.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (coeBase.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (FreeRing.FreeCommRing.instCoe.{u1} α)))) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (FreeRing.{u1} α) (FreeCommRing.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (coeBase.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (FreeRing.FreeCommRing.instCoe.{u1} α)))) y))
but is expected to have type
  forall {α : Type.{u1}} (x : FreeRing.{u1} α) (y : FreeRing.{u1} α), Eq.{succ u1} (FreeCommRing.{u1} α) (FreeRing.castFreeCommRing.{u1} α (HAdd.hAdd.{u1, u1, u1} (FreeRing.{u1} α) (FreeRing.{u1} α) (FreeRing.{u1} α) (instHAdd.{u1} (FreeRing.{u1} α) (Distrib.toAdd.{u1} (FreeRing.{u1} α) (NonUnitalNonAssocSemiring.toDistrib.{u1} (FreeRing.{u1} α) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (FreeRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeRing.{u1} α) (instRingFreeRing.{u1} α))))))) x y)) (HAdd.hAdd.{u1, u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (instHAdd.{u1} (FreeCommRing.{u1} α) (Distrib.toAdd.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocSemiring.toDistrib.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))))) (FreeRing.castFreeCommRing.{u1} α x) (FreeRing.castFreeCommRing.{u1} α y))
Case conversion may be inaccurate. Consider using '#align free_ring.coe_add FreeRing.coe_addₓ'. -/
@[simp, norm_cast]
protected theorem coe_add (x y : FreeRing α) : ↑(x + y) = (x : FreeCommRing α) + y :=
  (FreeRing.lift _).map_add _ _
#align free_ring.coe_add FreeRing.coe_add

/- warning: free_ring.coe_sub -> FreeRing.coe_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (x : FreeRing.{u1} α) (y : FreeRing.{u1} α), Eq.{succ u1} (FreeCommRing.{u1} α) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (FreeRing.{u1} α) (FreeCommRing.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (coeBase.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (FreeRing.FreeCommRing.instCoe.{u1} α)))) (HSub.hSub.{u1, u1, u1} (FreeRing.{u1} α) (FreeRing.{u1} α) (FreeRing.{u1} α) (instHSub.{u1} (FreeRing.{u1} α) (SubNegMonoid.toHasSub.{u1} (FreeRing.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeRing.{u1} α) (AddGroupWithOne.toAddGroup.{u1} (FreeRing.{u1} α) (AddCommGroupWithOne.toAddGroupWithOne.{u1} (FreeRing.{u1} α) (Ring.toAddCommGroupWithOne.{u1} (FreeRing.{u1} α) (FreeRing.ring.{u1} α))))))) x y)) (HSub.hSub.{u1, u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (instHSub.{u1} (FreeCommRing.{u1} α) (SubNegMonoid.toHasSub.{u1} (FreeCommRing.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeCommRing.{u1} α) (AddGroupWithOne.toAddGroup.{u1} (FreeCommRing.{u1} α) (AddCommGroupWithOne.toAddGroupWithOne.{u1} (FreeCommRing.{u1} α) (Ring.toAddCommGroupWithOne.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (FreeRing.{u1} α) (FreeCommRing.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (coeBase.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (FreeRing.FreeCommRing.instCoe.{u1} α)))) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (FreeRing.{u1} α) (FreeCommRing.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (coeBase.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (FreeRing.FreeCommRing.instCoe.{u1} α)))) y))
but is expected to have type
  forall {α : Type.{u1}} (x : FreeRing.{u1} α) (y : FreeRing.{u1} α), Eq.{succ u1} (FreeCommRing.{u1} α) (FreeRing.castFreeCommRing.{u1} α (HSub.hSub.{u1, u1, u1} (FreeRing.{u1} α) (FreeRing.{u1} α) (FreeRing.{u1} α) (instHSub.{u1} (FreeRing.{u1} α) (Ring.toSub.{u1} (FreeRing.{u1} α) (instRingFreeRing.{u1} α))) x y)) (HSub.hSub.{u1, u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (instHSub.{u1} (FreeCommRing.{u1} α) (Ring.toSub.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (FreeRing.castFreeCommRing.{u1} α x) (FreeRing.castFreeCommRing.{u1} α y))
Case conversion may be inaccurate. Consider using '#align free_ring.coe_sub FreeRing.coe_subₓ'. -/
@[simp, norm_cast]
protected theorem coe_sub (x y : FreeRing α) : ↑(x - y) = (x : FreeCommRing α) - y :=
  (FreeRing.lift _).map_sub _ _
#align free_ring.coe_sub FreeRing.coe_sub

/- warning: free_ring.coe_mul -> FreeRing.coe_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (x : FreeRing.{u1} α) (y : FreeRing.{u1} α), Eq.{succ u1} (FreeCommRing.{u1} α) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (FreeRing.{u1} α) (FreeCommRing.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (coeBase.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (FreeRing.FreeCommRing.instCoe.{u1} α)))) (HMul.hMul.{u1, u1, u1} (FreeRing.{u1} α) (FreeRing.{u1} α) (FreeRing.{u1} α) (instHMul.{u1} (FreeRing.{u1} α) (Distrib.toHasMul.{u1} (FreeRing.{u1} α) (Ring.toDistrib.{u1} (FreeRing.{u1} α) (FreeRing.ring.{u1} α)))) x y)) (HMul.hMul.{u1, u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (instHMul.{u1} (FreeCommRing.{u1} α) (Distrib.toHasMul.{u1} (FreeCommRing.{u1} α) (Ring.toDistrib.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (FreeRing.{u1} α) (FreeCommRing.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (coeBase.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (FreeRing.FreeCommRing.instCoe.{u1} α)))) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (FreeRing.{u1} α) (FreeCommRing.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (coeBase.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (FreeRing.FreeCommRing.instCoe.{u1} α)))) y))
but is expected to have type
  forall {α : Type.{u1}} (x : FreeRing.{u1} α) (y : FreeRing.{u1} α), Eq.{succ u1} (FreeCommRing.{u1} α) (FreeRing.castFreeCommRing.{u1} α (HMul.hMul.{u1, u1, u1} (FreeRing.{u1} α) (FreeRing.{u1} α) (FreeRing.{u1} α) (instHMul.{u1} (FreeRing.{u1} α) (NonUnitalNonAssocRing.toMul.{u1} (FreeRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeRing.{u1} α) (instRingFreeRing.{u1} α))))) x y)) (HMul.hMul.{u1, u1, u1} (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (FreeCommRing.{u1} α) (instHMul.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocRing.toMul.{u1} (FreeCommRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))) (FreeRing.castFreeCommRing.{u1} α x) (FreeRing.castFreeCommRing.{u1} α y))
Case conversion may be inaccurate. Consider using '#align free_ring.coe_mul FreeRing.coe_mulₓ'. -/
@[simp, norm_cast]
protected theorem coe_mul (x y : FreeRing α) : ↑(x * y) = (x : FreeCommRing α) * y :=
  (FreeRing.lift _).map_mul _ _
#align free_ring.coe_mul FreeRing.coe_mul

variable (α)

#print FreeRing.coe_surjective /-
protected theorem coe_surjective : Surjective (coe : FreeRing α → FreeCommRing α) := fun x =>
  by
  apply FreeCommRing.induction_on x
  · use -1
    rfl
  · intro x
    use FreeRing.of x
    rfl
  · rintro _ _ ⟨x, rfl⟩ ⟨y, rfl⟩
    use x + y
    exact (FreeRing.lift _).map_add _ _
  · rintro _ _ ⟨x, rfl⟩ ⟨y, rfl⟩
    use x * y
    exact (FreeRing.lift _).map_mul _ _
#align free_ring.coe_surjective FreeRing.coe_surjective
-/

/- warning: free_ring.coe_eq -> FreeRing.coe_eq is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}), Eq.{succ u1} ((FreeRing.{u1} α) -> (FreeCommRing.{u1} α)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (FreeRing.{u1} α) (FreeCommRing.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (coeBase.{succ u1, succ u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (FreeRing.FreeCommRing.instCoe.{u1} α))))) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) (List.{u1} α) (Multiset.{u1} α) (fun (l : List.{u1} α) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (List.{u1} α) (Multiset.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (List.{u1} α) (Multiset.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (List.{u1} α) (Multiset.{u1} α) (coeBase.{succ u1, succ u1} (List.{u1} α) (Multiset.{u1} α) (Multiset.hasCoe.{u1} α)))) l))
but is expected to have type
  forall (α : Type.{u1}), Eq.{succ u1} ((FreeRing.{u1} α) -> (FreeCommRing.{u1} α)) (FreeRing.castFreeCommRing.{u1} α) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) (List.{u1} α) (Multiset.{u1} α) (fun (l : List.{u1} α) => Multiset.ofList.{u1} α l))
Case conversion may be inaccurate. Consider using '#align free_ring.coe_eq FreeRing.coe_eqₓ'. -/
theorem coe_eq :
    (coe : FreeRing α → FreeCommRing α) =
      @Functor.map FreeAbelianGroup _ _ _ fun l : List α => (l : Multiset α) :=
  funext fun x =>
    FreeAbelianGroup.lift.unique _ _ fun L =>
      by
      simp_rw [FreeAbelianGroup.lift.of, (· ∘ ·)]
      exact
        FreeMonoid.recOn L rfl fun hd tl ih =>
          by
          rw [(FreeMonoid.lift _).map_mul, FreeMonoid.lift_eval_of, ih]
          rfl
#align free_ring.coe_eq FreeRing.coe_eq

/- warning: free_ring.subsingleton_equiv_free_comm_ring -> FreeRing.subsingletonEquivFreeCommRing is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : Subsingleton.{succ u1} α], RingEquiv.{u1, u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (Distrib.toHasMul.{u1} (FreeRing.{u1} α) (Ring.toDistrib.{u1} (FreeRing.{u1} α) (FreeRing.ring.{u1} α))) (Distrib.toHasAdd.{u1} (FreeRing.{u1} α) (Ring.toDistrib.{u1} (FreeRing.{u1} α) (FreeRing.ring.{u1} α))) (Distrib.toHasMul.{u1} (FreeCommRing.{u1} α) (Ring.toDistrib.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Distrib.toHasAdd.{u1} (FreeCommRing.{u1} α) (Ring.toDistrib.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : Subsingleton.{succ u1} α], RingEquiv.{u1, u1} (FreeRing.{u1} α) (FreeCommRing.{u1} α) (NonUnitalNonAssocRing.toMul.{u1} (FreeRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeRing.{u1} α) (instRingFreeRing.{u1} α)))) (NonUnitalNonAssocRing.toMul.{u1} (FreeCommRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) (Distrib.toAdd.{u1} (FreeRing.{u1} α) (NonUnitalNonAssocSemiring.toDistrib.{u1} (FreeRing.{u1} α) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (FreeRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeRing.{u1} α) (instRingFreeRing.{u1} α)))))) (Distrib.toAdd.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocSemiring.toDistrib.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))))))
Case conversion may be inaccurate. Consider using '#align free_ring.subsingleton_equiv_free_comm_ring FreeRing.subsingletonEquivFreeCommRingₓ'. -/
/-- If α has size at most 1 then the natural map from the free ring on `α` to the
    free commutative ring on `α` is an isomorphism of rings. -/
def subsingletonEquivFreeCommRing [Subsingleton α] : FreeRing α ≃+* FreeCommRing α :=
  RingEquiv.ofBijective (coeRingHom _)
    (by
      have :
        (coe_ring_hom _ : FreeRing α → FreeCommRing α) =
          Functor.mapEquiv FreeAbelianGroup (Multiset.subsingletonEquiv α) :=
        coe_eq α
      rw [this]
      apply Equiv.bijective)
#align free_ring.subsingleton_equiv_free_comm_ring FreeRing.subsingletonEquivFreeCommRing

instance [Subsingleton α] : CommRing (FreeRing α) :=
  { FreeRing.ring α with
    mul_comm := fun x y => by
      rw [← (subsingleton_equiv_free_comm_ring α).symm_apply_apply (y * x),
        (subsingleton_equiv_free_comm_ring α).map_mul, mul_comm, ←
        (subsingleton_equiv_free_comm_ring α).map_mul,
        (subsingleton_equiv_free_comm_ring α).symm_apply_apply] }

end FreeRing

/- warning: free_comm_ring_equiv_mv_polynomial_int -> freeCommRingEquivMvPolynomialInt is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}), RingEquiv.{u1, u1} (FreeCommRing.{u1} α) (MvPolynomial.{u1, 0} α Int Int.commSemiring) (Distrib.toHasMul.{u1} (FreeCommRing.{u1} α) (Ring.toDistrib.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Distrib.toHasAdd.{u1} (FreeCommRing.{u1} α) (Ring.toDistrib.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α)))) (Distrib.toHasMul.{u1} (MvPolynomial.{u1, 0} α Int Int.commSemiring) (Ring.toDistrib.{u1} (MvPolynomial.{u1, 0} α Int Int.commSemiring) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} α Int Int.commSemiring) (MvPolynomial.commRing.{0, u1} Int α Int.commRing)))) (Distrib.toHasAdd.{u1} (MvPolynomial.{u1, 0} α Int Int.commSemiring) (Ring.toDistrib.{u1} (MvPolynomial.{u1, 0} α Int Int.commSemiring) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} α Int Int.commSemiring) (MvPolynomial.commRing.{0, u1} Int α Int.commRing))))
but is expected to have type
  forall (α : Type.{u1}), RingEquiv.{u1, u1} (FreeCommRing.{u1} α) (MvPolynomial.{u1, 0} α Int Int.instCommSemiringInt) (NonUnitalNonAssocRing.toMul.{u1} (FreeCommRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))) (NonUnitalNonAssocRing.toMul.{u1} (MvPolynomial.{u1, 0} α Int Int.instCommSemiringInt) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (MvPolynomial.{u1, 0} α Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} α Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} α Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int α Int.instCommRingInt))))) (Distrib.toAdd.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocSemiring.toDistrib.{u1} (FreeCommRing.{u1} α) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} α) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} α) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} α) (CommRing.toRing.{u1} (FreeCommRing.{u1} α) (FreeCommRing.instCommRing.{u1} α))))))) (Distrib.toAdd.{u1} (MvPolynomial.{u1, 0} α Int Int.instCommSemiringInt) (NonUnitalNonAssocSemiring.toDistrib.{u1} (MvPolynomial.{u1, 0} α Int Int.instCommSemiringInt) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} α Int Int.instCommSemiringInt) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (MvPolynomial.{u1, 0} α Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} α Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} α Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int α Int.instCommRingInt)))))))
Case conversion may be inaccurate. Consider using '#align free_comm_ring_equiv_mv_polynomial_int freeCommRingEquivMvPolynomialIntₓ'. -/
/-- The free commutative ring on `α` is isomorphic to the polynomial ring over ℤ with
    variables in `α` -/
def freeCommRingEquivMvPolynomialInt : FreeCommRing α ≃+* MvPolynomial α ℤ :=
  RingEquiv.ofHomInv (FreeCommRing.lift <| (fun a => MvPolynomial.X a : α → MvPolynomial α ℤ))
    (MvPolynomial.eval₂Hom (Int.castRingHom (FreeCommRing α)) FreeCommRing.of)
    (by
      ext
      simp)
    (by ext <;> simp)
#align free_comm_ring_equiv_mv_polynomial_int freeCommRingEquivMvPolynomialInt

/- warning: free_comm_ring_pempty_equiv_int -> freeCommRingPemptyEquivInt is a dubious translation:
lean 3 declaration is
  RingEquiv.{u1, 0} (FreeCommRing.{u1} PEmpty.{succ u1}) Int (Distrib.toHasMul.{u1} (FreeCommRing.{u1} PEmpty.{succ u1}) (Ring.toDistrib.{u1} (FreeCommRing.{u1} PEmpty.{succ u1}) (CommRing.toRing.{u1} (FreeCommRing.{u1} PEmpty.{succ u1}) (FreeCommRing.instCommRing.{u1} PEmpty.{succ u1})))) (Distrib.toHasAdd.{u1} (FreeCommRing.{u1} PEmpty.{succ u1}) (Ring.toDistrib.{u1} (FreeCommRing.{u1} PEmpty.{succ u1}) (CommRing.toRing.{u1} (FreeCommRing.{u1} PEmpty.{succ u1}) (FreeCommRing.instCommRing.{u1} PEmpty.{succ u1})))) Int.hasMul Int.hasAdd
but is expected to have type
  RingEquiv.{u1, 0} (FreeCommRing.{u1} PEmpty.{succ u1}) Int (NonUnitalNonAssocRing.toMul.{u1} (FreeCommRing.{u1} PEmpty.{succ u1}) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} PEmpty.{succ u1}) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} PEmpty.{succ u1}) (CommRing.toRing.{u1} (FreeCommRing.{u1} PEmpty.{succ u1}) (FreeCommRing.instCommRing.{u1} PEmpty.{succ u1}))))) Int.instMulInt (Distrib.toAdd.{u1} (FreeCommRing.{u1} PEmpty.{succ u1}) (NonUnitalNonAssocSemiring.toDistrib.{u1} (FreeCommRing.{u1} PEmpty.{succ u1}) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} PEmpty.{succ u1}) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} PEmpty.{succ u1}) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} PEmpty.{succ u1}) (CommRing.toRing.{u1} (FreeCommRing.{u1} PEmpty.{succ u1}) (FreeCommRing.instCommRing.{u1} PEmpty.{succ u1}))))))) Int.instAddInt
Case conversion may be inaccurate. Consider using '#align free_comm_ring_pempty_equiv_int freeCommRingPemptyEquivIntₓ'. -/
/-- The free commutative ring on the empty type is isomorphic to `ℤ`. -/
def freeCommRingPemptyEquivInt : FreeCommRing PEmpty.{u + 1} ≃+* ℤ :=
  RingEquiv.trans (freeCommRingEquivMvPolynomialInt _) (MvPolynomial.isEmptyRingEquiv _ PEmpty)
#align free_comm_ring_pempty_equiv_int freeCommRingPemptyEquivInt

/- warning: free_comm_ring_punit_equiv_polynomial_int -> freeCommRingPunitEquivPolynomialInt is a dubious translation:
lean 3 declaration is
  RingEquiv.{u1, 0} (FreeCommRing.{u1} PUnit.{succ u1}) (Polynomial.{0} Int Int.semiring) (Distrib.toHasMul.{u1} (FreeCommRing.{u1} PUnit.{succ u1}) (Ring.toDistrib.{u1} (FreeCommRing.{u1} PUnit.{succ u1}) (CommRing.toRing.{u1} (FreeCommRing.{u1} PUnit.{succ u1}) (FreeCommRing.instCommRing.{u1} PUnit.{succ u1})))) (Distrib.toHasAdd.{u1} (FreeCommRing.{u1} PUnit.{succ u1}) (Ring.toDistrib.{u1} (FreeCommRing.{u1} PUnit.{succ u1}) (CommRing.toRing.{u1} (FreeCommRing.{u1} PUnit.{succ u1}) (FreeCommRing.instCommRing.{u1} PUnit.{succ u1})))) (Polynomial.mul'.{0} Int Int.semiring) (Polynomial.add'.{0} Int Int.semiring)
but is expected to have type
  RingEquiv.{u1, 0} (FreeCommRing.{u1} PUnit.{succ u1}) (Polynomial.{0} Int Int.instSemiringInt) (NonUnitalNonAssocRing.toMul.{u1} (FreeCommRing.{u1} PUnit.{succ u1}) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} PUnit.{succ u1}) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} PUnit.{succ u1}) (CommRing.toRing.{u1} (FreeCommRing.{u1} PUnit.{succ u1}) (FreeCommRing.instCommRing.{u1} PUnit.{succ u1}))))) (Polynomial.mul'.{0} Int Int.instSemiringInt) (Distrib.toAdd.{u1} (FreeCommRing.{u1} PUnit.{succ u1}) (NonUnitalNonAssocSemiring.toDistrib.{u1} (FreeCommRing.{u1} PUnit.{succ u1}) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (FreeCommRing.{u1} PUnit.{succ u1}) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeCommRing.{u1} PUnit.{succ u1}) (Ring.toNonAssocRing.{u1} (FreeCommRing.{u1} PUnit.{succ u1}) (CommRing.toRing.{u1} (FreeCommRing.{u1} PUnit.{succ u1}) (FreeCommRing.instCommRing.{u1} PUnit.{succ u1}))))))) (Polynomial.add'.{0} Int Int.instSemiringInt)
Case conversion may be inaccurate. Consider using '#align free_comm_ring_punit_equiv_polynomial_int freeCommRingPunitEquivPolynomialIntₓ'. -/
/-- The free commutative ring on a type with one term is isomorphic to `ℤ[X]`. -/
def freeCommRingPunitEquivPolynomialInt : FreeCommRing PUnit.{u + 1} ≃+* ℤ[X] :=
  (freeCommRingEquivMvPolynomialInt _).trans (MvPolynomial.pUnitAlgEquiv ℤ).toRingEquiv
#align free_comm_ring_punit_equiv_polynomial_int freeCommRingPunitEquivPolynomialInt

open FreeRing

/- warning: free_ring_pempty_equiv_int -> freeRingPemptyEquivInt is a dubious translation:
lean 3 declaration is
  RingEquiv.{u1, 0} (FreeRing.{u1} PEmpty.{succ u1}) Int (Distrib.toHasMul.{u1} (FreeRing.{u1} PEmpty.{succ u1}) (Ring.toDistrib.{u1} (FreeRing.{u1} PEmpty.{succ u1}) (FreeRing.ring.{u1} PEmpty.{succ u1}))) (Distrib.toHasAdd.{u1} (FreeRing.{u1} PEmpty.{succ u1}) (Ring.toDistrib.{u1} (FreeRing.{u1} PEmpty.{succ u1}) (FreeRing.ring.{u1} PEmpty.{succ u1}))) Int.hasMul Int.hasAdd
but is expected to have type
  RingEquiv.{u1, 0} (FreeRing.{u1} PEmpty.{succ u1}) Int (NonUnitalNonAssocRing.toMul.{u1} (FreeRing.{u1} PEmpty.{succ u1}) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeRing.{u1} PEmpty.{succ u1}) (Ring.toNonAssocRing.{u1} (FreeRing.{u1} PEmpty.{succ u1}) (instRingFreeRing.{u1} PEmpty.{succ u1})))) Int.instMulInt (Distrib.toAdd.{u1} (FreeRing.{u1} PEmpty.{succ u1}) (NonUnitalNonAssocSemiring.toDistrib.{u1} (FreeRing.{u1} PEmpty.{succ u1}) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (FreeRing.{u1} PEmpty.{succ u1}) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeRing.{u1} PEmpty.{succ u1}) (Ring.toNonAssocRing.{u1} (FreeRing.{u1} PEmpty.{succ u1}) (instRingFreeRing.{u1} PEmpty.{succ u1})))))) Int.instAddInt
Case conversion may be inaccurate. Consider using '#align free_ring_pempty_equiv_int freeRingPemptyEquivIntₓ'. -/
/-- The free ring on the empty type is isomorphic to `ℤ`. -/
def freeRingPemptyEquivInt : FreeRing PEmpty.{u + 1} ≃+* ℤ :=
  RingEquiv.trans (subsingletonEquivFreeCommRing _) freeCommRingPemptyEquivInt
#align free_ring_pempty_equiv_int freeRingPemptyEquivInt

/- warning: free_ring_punit_equiv_polynomial_int -> freeRingPunitEquivPolynomialInt is a dubious translation:
lean 3 declaration is
  RingEquiv.{u1, 0} (FreeRing.{u1} PUnit.{succ u1}) (Polynomial.{0} Int Int.semiring) (Distrib.toHasMul.{u1} (FreeRing.{u1} PUnit.{succ u1}) (Ring.toDistrib.{u1} (FreeRing.{u1} PUnit.{succ u1}) (FreeRing.ring.{u1} PUnit.{succ u1}))) (Distrib.toHasAdd.{u1} (FreeRing.{u1} PUnit.{succ u1}) (Ring.toDistrib.{u1} (FreeRing.{u1} PUnit.{succ u1}) (FreeRing.ring.{u1} PUnit.{succ u1}))) (Polynomial.mul'.{0} Int Int.semiring) (Polynomial.add'.{0} Int Int.semiring)
but is expected to have type
  RingEquiv.{u1, 0} (FreeRing.{u1} PUnit.{succ u1}) (Polynomial.{0} Int Int.instSemiringInt) (NonUnitalNonAssocRing.toMul.{u1} (FreeRing.{u1} PUnit.{succ u1}) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeRing.{u1} PUnit.{succ u1}) (Ring.toNonAssocRing.{u1} (FreeRing.{u1} PUnit.{succ u1}) (instRingFreeRing.{u1} PUnit.{succ u1})))) (Polynomial.mul'.{0} Int Int.instSemiringInt) (Distrib.toAdd.{u1} (FreeRing.{u1} PUnit.{succ u1}) (NonUnitalNonAssocSemiring.toDistrib.{u1} (FreeRing.{u1} PUnit.{succ u1}) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (FreeRing.{u1} PUnit.{succ u1}) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (FreeRing.{u1} PUnit.{succ u1}) (Ring.toNonAssocRing.{u1} (FreeRing.{u1} PUnit.{succ u1}) (instRingFreeRing.{u1} PUnit.{succ u1})))))) (Polynomial.add'.{0} Int Int.instSemiringInt)
Case conversion may be inaccurate. Consider using '#align free_ring_punit_equiv_polynomial_int freeRingPunitEquivPolynomialIntₓ'. -/
/-- The free ring on a type with one term is isomorphic to `ℤ[X]`. -/
def freeRingPunitEquivPolynomialInt : FreeRing PUnit.{u + 1} ≃+* ℤ[X] :=
  RingEquiv.trans (subsingletonEquivFreeCommRing _) freeCommRingPunitEquivPolynomialInt
#align free_ring_punit_equiv_polynomial_int freeRingPunitEquivPolynomialInt

