/-
Copyright (c) 2022 Jireh Loreaux All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux

! This file was ported from Lean 3 source module ring_theory.non_unital_subsemiring.basic
! leanprover-community/mathlib commit ce38d86c0b2d427ce208c3cee3159cb421d2b3c4
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Ring.Equiv
import Mathbin.Algebra.Ring.Prod
import Mathbin.Data.Set.Finite
import Mathbin.GroupTheory.Submonoid.Membership
import Mathbin.GroupTheory.Subsemigroup.Membership
import Mathbin.GroupTheory.Subsemigroup.Centralizer

/-!
# Bundled non-unital subsemirings

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We define bundled non-unital subsemirings and some standard constructions:
`complete_lattice` structure, `subtype` and `inclusion` ring homomorphisms, non-unital subsemiring
`map`, `comap` and range (`srange`) of a `non_unital_ring_hom` etc.
-/


open BigOperators

universe u v w

variable {R : Type u} {S : Type v} {T : Type w} [NonUnitalNonAssocSemiring R] (M : Subsemigroup R)

#print NonUnitalSubsemiringClass /-
/-- `non_unital_subsemiring_class S R` states that `S` is a type of subsets `s ⊆ R` that
are both an additive submonoid and also a multiplicative subsemigroup. -/
class NonUnitalSubsemiringClass (S : Type _) (R : Type u) [NonUnitalNonAssocSemiring R]
  [SetLike S R] extends AddSubmonoidClass S R where
  mul_mem : ∀ {s : S} {a b : R}, a ∈ s → b ∈ s → a * b ∈ s
#align non_unital_subsemiring_class NonUnitalSubsemiringClass
-/

/- warning: non_unital_subsemiring_class.mul_mem_class -> NonUnitalSubsemiringClass.mulMemClass is a dubious translation:
lean 3 declaration is
  forall (S : Type.{u2}) (R : Type.{u1}) [_inst_2 : NonUnitalNonAssocSemiring.{u1} R] [_inst_3 : SetLike.{u2, u1} S R] [h : NonUnitalSubsemiringClass.{u1, u2} S R _inst_2 _inst_3], MulMemClass.{u2, u1} S R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_2)) _inst_3
but is expected to have type
  forall (S : Type.{u2}) (R : Type.{u1}) [_inst_2 : NonUnitalNonAssocSemiring.{u1} R] [_inst_3 : SetLike.{u2, u1} S R] [h : NonUnitalSubsemiringClass.{u1, u2} S R _inst_2 _inst_3], MulMemClass.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_2) _inst_3
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring_class.mul_mem_class NonUnitalSubsemiringClass.mulMemClassₓ'. -/
-- See note [lower instance priority]
instance (priority := 100) NonUnitalSubsemiringClass.mulMemClass (S : Type _) (R : Type u)
    [NonUnitalNonAssocSemiring R] [SetLike S R] [h : NonUnitalSubsemiringClass S R] :
    MulMemClass S R :=
  { h with }
#align non_unital_subsemiring_class.mul_mem_class NonUnitalSubsemiringClass.mulMemClass

namespace NonUnitalSubsemiringClass

variable [SetLike S R] [NonUnitalSubsemiringClass S R] (s : S)

include R S

open AddSubmonoidClass

#print NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring /-
/- Prefer subclasses of `non_unital_non_assoc_semiring` over subclasses of
`non_unital_subsemiring_class`. -/
/-- A non-unital subsemiring of a `non_unital_non_assoc_semiring` inherits a
`non_unital_non_assoc_semiring` structure -/
instance (priority := 75) toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring s :=
  Subtype.coe_injective.NonUnitalNonAssocSemiring coe rfl (by simp) (fun _ _ => rfl) fun _ _ => rfl
#align non_unital_subsemiring_class.to_non_unital_non_assoc_semiring NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring
-/

/- warning: non_unital_subsemiring_class.no_zero_divisors -> NonUnitalSubsemiringClass.noZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : SetLike.{u2, u1} S R] [_inst_3 : NonUnitalSubsemiringClass.{u1, u2} S R _inst_1 _inst_2] (s : S) [_inst_4 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1))], NoZeroDivisors.{u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S R _inst_2) s) (MulMemClass.mul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) _inst_2 (NonUnitalSubsemiringClass.mulMemClass.{u1, u2} S R _inst_1 _inst_2 _inst_3) s) (ZeroMemClass.zero.{u2, u1} S R _inst_2 (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (AddSubmonoidClass.to_zeroMemClass.{u2, u1} S R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) _inst_2 (NonUnitalSubsemiringClass.to_addSubmonoidClass.{u1, u2} S R _inst_1 _inst_2 _inst_3)) s)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : SetLike.{u2, u1} S R] [_inst_3 : NonUnitalSubsemiringClass.{u1, u2} S R _inst_1 _inst_2] (s : S) [_inst_4 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (MulZeroClass.toZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1))], NoZeroDivisors.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u2} R S (SetLike.instMembership.{u2, u1} S R _inst_2) x s)) (NonUnitalNonAssocSemiring.toMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u2} R S (SetLike.instMembership.{u2, u1} S R _inst_2) x s)) (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2 _inst_3 s)) (ZeroMemClass.zero.{u2, u1} S R _inst_2 (MulZeroClass.toZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1)) (AddSubmonoidClass.toZeroMemClass.{u2, u1} S R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) _inst_2 (NonUnitalSubsemiringClass.toAddSubmonoidClass.{u1, u2} S R _inst_1 _inst_2 _inst_3)) s)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring_class.no_zero_divisors NonUnitalSubsemiringClass.noZeroDivisorsₓ'. -/
instance noZeroDivisors [NoZeroDivisors R] : NoZeroDivisors s :=
  Subtype.coe_injective.NoZeroDivisors coe rfl fun x y => rfl
#align non_unital_subsemiring_class.no_zero_divisors NonUnitalSubsemiringClass.noZeroDivisors

#print NonUnitalSubsemiringClass.subtype /-
/-- The natural non-unital ring hom from a non-unital subsemiring of a non-unital semiring `R` to
`R`. -/
def subtype : s →ₙ+* R :=
  { AddSubmonoidClass.Subtype s, MulMemClass.subtype s with toFun := coe }
#align non_unital_subsemiring_class.subtype NonUnitalSubsemiringClass.subtype
-/

/- warning: non_unital_subsemiring_class.coe_subtype -> NonUnitalSubsemiringClass.coeSubtype is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : SetLike.{u2, u1} S R] [_inst_3 : NonUnitalSubsemiringClass.{u1, u2} S R _inst_1 _inst_2] (s : S), Eq.{succ u1} ((fun (_x : NonUnitalRingHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S R _inst_2) s) R (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2 _inst_3 s) _inst_1) => (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S R _inst_2) s) -> R) (NonUnitalSubsemiringClass.subtype.{u1, u2} R S _inst_1 _inst_2 _inst_3 s)) (coeFn.{succ u1, succ u1} (NonUnitalRingHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S R _inst_2) s) R (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2 _inst_3 s) _inst_1) (fun (_x : NonUnitalRingHom.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S R _inst_2) s) R (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2 _inst_3 s) _inst_1) => (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S R _inst_2) s) -> R) (NonUnitalRingHom.hasCoeToFun.{u1, u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S R _inst_2) s) R (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2 _inst_3 s) _inst_1) (NonUnitalSubsemiringClass.subtype.{u1, u2} R S _inst_1 _inst_2 _inst_3 s)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S R _inst_2) s) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S R _inst_2) s) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S R _inst_2) s) R (coeBase.{succ u1, succ u1} (coeSort.{succ u2, succ (succ u1)} S Type.{u1} (SetLike.hasCoeToSort.{u2, u1} S R _inst_2) s) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u2} R S (SetLike.hasMem.{u2, u1} S R _inst_2) x s))))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : SetLike.{u2, u1} S R] [_inst_3 : NonUnitalSubsemiringClass.{u1, u2} S R _inst_1 _inst_2] (s : S), Eq.{succ u1} (forall (a : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u2} R S (SetLike.instMembership.{u2, u1} S R _inst_2) x s)), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u2} R S (SetLike.instMembership.{u2, u1} S R _inst_2) x s)) => R) a) (FunLike.coe.{succ u1, succ u1, succ u1} (NonUnitalRingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u2} R S (SetLike.instMembership.{u2, u1} S R _inst_2) x s)) R (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2 _inst_3 s) _inst_1) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u2} R S (SetLike.instMembership.{u2, u1} S R _inst_2) x s)) (fun (_x : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u2} R S (SetLike.instMembership.{u2, u1} S R _inst_2) x s)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u2} R S (SetLike.instMembership.{u2, u1} S R _inst_2) x s)) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u2} R S (SetLike.instMembership.{u2, u1} S R _inst_2) x s)) R (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2 _inst_3 s) _inst_1) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u2} R S (SetLike.instMembership.{u2, u1} S R _inst_2) x s)) R (NonUnitalNonAssocSemiring.toMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u2} R S (SetLike.instMembership.{u2, u1} S R _inst_2) x s)) (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2 _inst_3 s)) (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u2} R S (SetLike.instMembership.{u2, u1} S R _inst_2) x s)) R (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2 _inst_3 s) _inst_1) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u2} R S (SetLike.instMembership.{u2, u1} S R _inst_2) x s)) R (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2 _inst_3 s) _inst_1 (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u2} R S (SetLike.instMembership.{u2, u1} S R _inst_2) x s)) R (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2 _inst_3 s) _inst_1))) (NonUnitalSubsemiringClass.subtype.{u1, u2} R S _inst_1 _inst_2 _inst_3 s)) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u2, u1} S R _inst_2 s)))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring_class.coe_subtype NonUnitalSubsemiringClass.coeSubtypeₓ'. -/
@[simp]
theorem coeSubtype : (subtype s : s → R) = coe :=
  rfl
#align non_unital_subsemiring_class.coe_subtype NonUnitalSubsemiringClass.coeSubtype

omit R S

#print NonUnitalSubsemiringClass.toNonUnitalSemiring /-
/-- A non-unital subsemiring of a `non_unital_semiring` is a `non_unital_semiring`. -/
instance toNonUnitalSemiring {R} [NonUnitalSemiring R] [SetLike S R]
    [NonUnitalSubsemiringClass S R] : NonUnitalSemiring s :=
  Subtype.coe_injective.NonUnitalSemiring coe rfl (by simp) (fun _ _ => rfl) fun _ _ => rfl
#align non_unital_subsemiring_class.to_non_unital_semiring NonUnitalSubsemiringClass.toNonUnitalSemiring
-/

#print NonUnitalSubsemiringClass.toNonUnitalCommSemiring /-
/-- A non-unital subsemiring of a `non_unital_comm_semiring` is a `non_unital_comm_semiring`. -/
instance toNonUnitalCommSemiring {R} [NonUnitalCommSemiring R] [SetLike S R]
    [NonUnitalSubsemiringClass S R] : NonUnitalCommSemiring s :=
  Subtype.coe_injective.NonUnitalCommSemiring coe rfl (by simp) (fun _ _ => rfl) fun _ _ => rfl
#align non_unital_subsemiring_class.to_non_unital_comm_semiring NonUnitalSubsemiringClass.toNonUnitalCommSemiring
-/

/-! Note: currently, there are no ordered versions of non-unital rings. -/


end NonUnitalSubsemiringClass

variable [NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]

#print NonUnitalSubsemiring /-
/-- A non-unital subsemiring of a non-unital semiring `R` is a subset `s` that is both an additive
submonoid and a semigroup. -/
structure NonUnitalSubsemiring (R : Type u) [NonUnitalNonAssocSemiring R] extends AddSubmonoid R,
  Subsemigroup R
#align non_unital_subsemiring NonUnitalSubsemiring
-/

/-- Reinterpret a `non_unital_subsemiring` as a `subsemigroup`. -/
add_decl_doc NonUnitalSubsemiring.toSubsemigroup

/-- Reinterpret a `non_unital_subsemiring` as an `add_submonoid`. -/
add_decl_doc NonUnitalSubsemiring.toAddSubmonoid

namespace NonUnitalSubsemiring

instance : SetLike (NonUnitalSubsemiring R) R
    where
  coe := NonUnitalSubsemiring.carrier
  coe_injective' p q h := by cases p <;> cases q <;> congr

instance : NonUnitalSubsemiringClass (NonUnitalSubsemiring R) R
    where
  zero_mem := zero_mem'
  add_mem := add_mem'
  mul_mem := mul_mem'

/- warning: non_unital_subsemiring.mem_carrier -> NonUnitalSubsemiring.mem_carrier is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : NonUnitalSubsemiring.{u1} R _inst_1} {x : R}, Iff (Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) x (NonUnitalSubsemiring.carrier.{u1} R _inst_1 s)) (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x s)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : NonUnitalSubsemiring.{u1} R _inst_1} {x : R}, Iff (Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (AddSubsemigroup.carrier.{u1} R (AddZeroClass.toAdd.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (AddSubmonoid.toAddSubsemigroup.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1 s)))) (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_carrier NonUnitalSubsemiring.mem_carrierₓ'. -/
@[simp]
theorem mem_carrier {s : NonUnitalSubsemiring R} {x : R} : x ∈ s.carrier ↔ x ∈ s :=
  Iff.rfl
#align non_unital_subsemiring.mem_carrier NonUnitalSubsemiring.mem_carrier

/- warning: non_unital_subsemiring.ext -> NonUnitalSubsemiring.ext is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {S : NonUnitalSubsemiring.{u1} R _inst_1} {T : NonUnitalSubsemiring.{u1} R _inst_1}, (forall (x : R), Iff (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x S) (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x T)) -> (Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) S T)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {S : NonUnitalSubsemiring.{u1} R _inst_1} {T : NonUnitalSubsemiring.{u1} R _inst_1}, (forall (x : R), Iff (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x S) (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x T)) -> (Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) S T)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.ext NonUnitalSubsemiring.extₓ'. -/
/-- Two non-unital subsemirings are equal if they have the same elements. -/
@[ext]
theorem ext {S T : NonUnitalSubsemiring R} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=
  SetLike.ext h
#align non_unital_subsemiring.ext NonUnitalSubsemiring.ext

/- warning: non_unital_subsemiring.copy -> NonUnitalSubsemiring.copy is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (S : NonUnitalSubsemiring.{u1} R _inst_1) (s : Set.{u1} R), (Eq.{succ u1} (Set.{u1} R) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) S)) -> (NonUnitalSubsemiring.{u1} R _inst_1)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (S : NonUnitalSubsemiring.{u1} R _inst_1) (s : Set.{u1} R), (Eq.{succ u1} (Set.{u1} R) s (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) S)) -> (NonUnitalSubsemiring.{u1} R _inst_1)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.copy NonUnitalSubsemiring.copyₓ'. -/
/-- Copy of a non-unital subsemiring with a new `carrier` equal to the old one. Useful to fix
definitional equalities.-/
protected def copy (S : NonUnitalSubsemiring R) (s : Set R) (hs : s = ↑S) :
    NonUnitalSubsemiring R :=
  { S.toAddSubmonoid.copy s hs, S.toSubsemigroup.copy s hs with carrier := s }
#align non_unital_subsemiring.copy NonUnitalSubsemiring.copy

/- warning: non_unital_subsemiring.coe_copy -> NonUnitalSubsemiring.coe_copy is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (S : NonUnitalSubsemiring.{u1} R _inst_1) (s : Set.{u1} R) (hs : Eq.{succ u1} (Set.{u1} R) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) S)), Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (NonUnitalSubsemiring.copy.{u1} R _inst_1 S s hs)) s
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (S : NonUnitalSubsemiring.{u1} R _inst_1) (s : Set.{u1} R) (hs : Eq.{succ u1} (Set.{u1} R) s (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) S)), Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.copy.{u1} R _inst_1 S s hs)) s
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_copy NonUnitalSubsemiring.coe_copyₓ'. -/
@[simp]
theorem coe_copy (S : NonUnitalSubsemiring R) (s : Set R) (hs : s = ↑S) :
    (S.copy s hs : Set R) = s :=
  rfl
#align non_unital_subsemiring.coe_copy NonUnitalSubsemiring.coe_copy

/- warning: non_unital_subsemiring.copy_eq -> NonUnitalSubsemiring.copy_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (S : NonUnitalSubsemiring.{u1} R _inst_1) (s : Set.{u1} R) (hs : Eq.{succ u1} (Set.{u1} R) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) S)), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.copy.{u1} R _inst_1 S s hs) S
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (S : NonUnitalSubsemiring.{u1} R _inst_1) (s : Set.{u1} R) (hs : Eq.{succ u1} (Set.{u1} R) s (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) S)), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.copy.{u1} R _inst_1 S s hs) S
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.copy_eq NonUnitalSubsemiring.copy_eqₓ'. -/
theorem copy_eq (S : NonUnitalSubsemiring R) (s : Set R) (hs : s = ↑S) : S.copy s hs = S :=
  SetLike.coe_injective hs
#align non_unital_subsemiring.copy_eq NonUnitalSubsemiring.copy_eq

/- warning: non_unital_subsemiring.to_subsemigroup_injective -> NonUnitalSubsemiring.toSubsemigroup_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], Function.Injective.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (NonUnitalSubsemiring.toSubsemigroup.{u1} R _inst_1)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], Function.Injective.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (NonUnitalSubsemiring.toSubsemigroup.{u1} R _inst_1)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.to_subsemigroup_injective NonUnitalSubsemiring.toSubsemigroup_injectiveₓ'. -/
theorem toSubsemigroup_injective :
    Function.Injective (toSubsemigroup : NonUnitalSubsemiring R → Subsemigroup R)
  | r, s, h => ext (SetLike.ext_iff.mp h : _)
#align non_unital_subsemiring.to_subsemigroup_injective NonUnitalSubsemiring.toSubsemigroup_injective

/- warning: non_unital_subsemiring.to_subsemigroup_strict_mono -> NonUnitalSubsemiring.toSubsemigroup_strictMono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], StrictMono.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (SetLike.partialOrder.{u1, u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) R (Subsemigroup.setLike.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))))) (NonUnitalSubsemiring.toSubsemigroup.{u1} R _inst_1)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], StrictMono.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instPartialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (Subsemigroup.instCompleteLatticeSubsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1))))) (NonUnitalSubsemiring.toSubsemigroup.{u1} R _inst_1)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.to_subsemigroup_strict_mono NonUnitalSubsemiring.toSubsemigroup_strictMonoₓ'. -/
@[mono]
theorem toSubsemigroup_strictMono :
    StrictMono (toSubsemigroup : NonUnitalSubsemiring R → Subsemigroup R) := fun _ _ => id
#align non_unital_subsemiring.to_subsemigroup_strict_mono NonUnitalSubsemiring.toSubsemigroup_strictMono

/- warning: non_unital_subsemiring.to_subsemigroup_mono -> NonUnitalSubsemiring.toSubsemigroup_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], Monotone.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (SetLike.partialOrder.{u1, u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) R (Subsemigroup.setLike.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))))) (NonUnitalSubsemiring.toSubsemigroup.{u1} R _inst_1)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], Monotone.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instPartialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (Subsemigroup.instCompleteLatticeSubsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1))))) (NonUnitalSubsemiring.toSubsemigroup.{u1} R _inst_1)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.to_subsemigroup_mono NonUnitalSubsemiring.toSubsemigroup_monoₓ'. -/
@[mono]
theorem toSubsemigroup_mono : Monotone (toSubsemigroup : NonUnitalSubsemiring R → Subsemigroup R) :=
  toSubsemigroup_strictMono.Monotone
#align non_unital_subsemiring.to_subsemigroup_mono NonUnitalSubsemiring.toSubsemigroup_mono

#print NonUnitalSubsemiring.toAddSubmonoid_injective /-
theorem toAddSubmonoid_injective :
    Function.Injective (toAddSubmonoid : NonUnitalSubsemiring R → AddSubmonoid R)
  | r, s, h => ext (SetLike.ext_iff.mp h : _)
#align non_unital_subsemiring.to_add_submonoid_injective NonUnitalSubsemiring.toAddSubmonoid_injective
-/

/- warning: non_unital_subsemiring.to_add_submonoid_strict_mono -> NonUnitalSubsemiring.toAddSubmonoid_strictMono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], StrictMono.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (SetLike.partialOrder.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], StrictMono.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instPartialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))))))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.to_add_submonoid_strict_mono NonUnitalSubsemiring.toAddSubmonoid_strictMonoₓ'. -/
@[mono]
theorem toAddSubmonoid_strictMono :
    StrictMono (toAddSubmonoid : NonUnitalSubsemiring R → AddSubmonoid R) := fun _ _ => id
#align non_unital_subsemiring.to_add_submonoid_strict_mono NonUnitalSubsemiring.toAddSubmonoid_strictMono

/- warning: non_unital_subsemiring.to_add_submonoid_mono -> NonUnitalSubsemiring.toAddSubmonoid_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], Monotone.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (SetLike.partialOrder.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], Monotone.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instPartialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))))))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.to_add_submonoid_mono NonUnitalSubsemiring.toAddSubmonoid_monoₓ'. -/
@[mono]
theorem toAddSubmonoid_mono : Monotone (toAddSubmonoid : NonUnitalSubsemiring R → AddSubmonoid R) :=
  toAddSubmonoid_strictMono.Monotone
#align non_unital_subsemiring.to_add_submonoid_mono NonUnitalSubsemiring.toAddSubmonoid_mono

/- warning: non_unital_subsemiring.mk' -> NonUnitalSubsemiring.mk' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : Set.{u1} R) (sg : Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))), (Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) R (Subsemigroup.setLike.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))))) sg) s) -> (forall (sa : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))), (Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))))))) sa) s) -> (NonUnitalSubsemiring.{u1} R _inst_1))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : Set.{u1} R) (sg : Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)), (Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) R (Subsemigroup.instSetLikeSubsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) sg) s) -> (forall (sa : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))), (Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) sa) s) -> (NonUnitalSubsemiring.{u1} R _inst_1))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mk' NonUnitalSubsemiring.mk'ₓ'. -/
/-- Construct a `non_unital_subsemiring R` from a set `s`, a subsemigroup `sg`, and an additive
submonoid `sa` such that `x ∈ s ↔ x ∈ sg ↔ x ∈ sa`. -/
protected def mk' (s : Set R) (sg : Subsemigroup R) (hg : ↑sg = s) (sa : AddSubmonoid R)
    (ha : ↑sa = s) : NonUnitalSubsemiring R
    where
  carrier := s
  zero_mem' := ha ▸ sa.zero_mem
  add_mem' x y := by simpa only [← ha] using sa.add_mem
  mul_mem' x y := by simpa only [← hg] using sg.mul_mem
#align non_unital_subsemiring.mk' NonUnitalSubsemiring.mk'

/- warning: non_unital_subsemiring.coe_mk' -> NonUnitalSubsemiring.coe_mk' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {sg : Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))} (hg : Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) R (Subsemigroup.setLike.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))))) sg) s) {sa : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))} (ha : Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))))))) sa) s), Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (NonUnitalSubsemiring.mk'.{u1} R _inst_1 s sg hg sa ha)) s
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {sg : Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)} (hg : Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) R (Subsemigroup.instSetLikeSubsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) sg) s) {sa : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))} (ha : Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) sa) s), Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.mk'.{u1} R _inst_1 s sg hg sa ha)) s
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_mk' NonUnitalSubsemiring.coe_mk'ₓ'. -/
@[simp]
theorem coe_mk' {s : Set R} {sg : Subsemigroup R} (hg : ↑sg = s) {sa : AddSubmonoid R}
    (ha : ↑sa = s) : (NonUnitalSubsemiring.mk' s sg hg sa ha : Set R) = s :=
  rfl
#align non_unital_subsemiring.coe_mk' NonUnitalSubsemiring.coe_mk'

/- warning: non_unital_subsemiring.mem_mk' -> NonUnitalSubsemiring.mem_mk' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {sg : Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))} (hg : Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) R (Subsemigroup.setLike.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))))) sg) s) {sa : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))} (ha : Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))))))) sa) s) {x : R}, Iff (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x (NonUnitalSubsemiring.mk'.{u1} R _inst_1 s sg hg sa ha)) (Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) x s)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {sg : Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)} (hg : Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) R (Subsemigroup.instSetLikeSubsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) sg) s) {sa : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))} (ha : Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) sa) s) {x : R}, Iff (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x (NonUnitalSubsemiring.mk'.{u1} R _inst_1 s sg hg sa ha)) (Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x s)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_mk' NonUnitalSubsemiring.mem_mk'ₓ'. -/
@[simp]
theorem mem_mk' {s : Set R} {sg : Subsemigroup R} (hg : ↑sg = s) {sa : AddSubmonoid R}
    (ha : ↑sa = s) {x : R} : x ∈ NonUnitalSubsemiring.mk' s sg hg sa ha ↔ x ∈ s :=
  Iff.rfl
#align non_unital_subsemiring.mem_mk' NonUnitalSubsemiring.mem_mk'

/- warning: non_unital_subsemiring.mk'_to_subsemigroup -> NonUnitalSubsemiring.mk'_toSubsemigroup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {sg : Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))} (hg : Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) R (Subsemigroup.setLike.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))))) sg) s) {sa : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))} (ha : Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))))))) sa) s), Eq.{succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (NonUnitalSubsemiring.toSubsemigroup.{u1} R _inst_1 (NonUnitalSubsemiring.mk'.{u1} R _inst_1 s sg hg sa ha)) sg
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {sg : Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)} (hg : Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) R (Subsemigroup.instSetLikeSubsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) sg) s) {sa : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))} (ha : Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) sa) s), Eq.{succ u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (NonUnitalSubsemiring.toSubsemigroup.{u1} R _inst_1 (NonUnitalSubsemiring.mk'.{u1} R _inst_1 s sg hg sa ha)) sg
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mk'_to_subsemigroup NonUnitalSubsemiring.mk'_toSubsemigroupₓ'. -/
@[simp]
theorem mk'_toSubsemigroup {s : Set R} {sg : Subsemigroup R} (hg : ↑sg = s) {sa : AddSubmonoid R}
    (ha : ↑sa = s) : (NonUnitalSubsemiring.mk' s sg hg sa ha).toSubsemigroup = sg :=
  SetLike.coe_injective hg.symm
#align non_unital_subsemiring.mk'_to_subsemigroup NonUnitalSubsemiring.mk'_toSubsemigroup

/- warning: non_unital_subsemiring.mk'_to_add_submonoid -> NonUnitalSubsemiring.mk'_toAddSubmonoid is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {sg : Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))} (hg : Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) R (Subsemigroup.setLike.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))))) sg) s) {sa : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))} (ha : Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))))))) sa) s), Eq.{succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1 (NonUnitalSubsemiring.mk'.{u1} R _inst_1 s sg hg sa ha)) sa
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {sg : Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)} (hg : Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) R (Subsemigroup.instSetLikeSubsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) sg) s) {sa : AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))} (ha : Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) sa) s), Eq.{succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1 (NonUnitalSubsemiring.mk'.{u1} R _inst_1 s sg hg sa ha)) sa
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mk'_to_add_submonoid NonUnitalSubsemiring.mk'_toAddSubmonoidₓ'. -/
@[simp]
theorem mk'_toAddSubmonoid {s : Set R} {sg : Subsemigroup R} (hg : ↑sg = s) {sa : AddSubmonoid R}
    (ha : ↑sa = s) : (NonUnitalSubsemiring.mk' s sg hg sa ha).toAddSubmonoid = sa :=
  SetLike.coe_injective ha.symm
#align non_unital_subsemiring.mk'_to_add_submonoid NonUnitalSubsemiring.mk'_toAddSubmonoid

end NonUnitalSubsemiring

namespace NonUnitalSubsemiring

variable {F G : Type _} [NonUnitalRingHomClass F R S] [NonUnitalRingHomClass G S T]
  (s : NonUnitalSubsemiring R)

/- warning: non_unital_subsemiring.coe_zero -> NonUnitalSubsemiring.coe_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{succ u1} R ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x s))))) (OfNat.ofNat.{u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) 0 (OfNat.mk.{u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) 0 (Zero.zero.{u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) (ZeroMemClass.zero.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (AddSubmonoidClass.to_zeroMemClass.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (NonUnitalSubsemiringClass.to_addSubmonoidClass.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R _inst_1 (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (NonUnitalSubsemiring.nonUnitalSubsemiringClass.{u1} R _inst_1))) s))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{succ u1} R (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s)) (OfNat.ofNat.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) 0 (Zero.toOfNat0.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (AddSubmonoid.zero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1 s))))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MulZeroClass.toZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_zero NonUnitalSubsemiring.coe_zeroₓ'. -/
@[simp, norm_cast]
theorem coe_zero : ((0 : s) : R) = (0 : R) :=
  rfl
#align non_unital_subsemiring.coe_zero NonUnitalSubsemiring.coe_zero

/- warning: non_unital_subsemiring.coe_add -> NonUnitalSubsemiring.coe_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : NonUnitalSubsemiring.{u1} R _inst_1) (x : coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) (y : coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s), Eq.{succ u1} R ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x s))))) (HAdd.hAdd.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) (instHAdd.{u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) (AddMemClass.add.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (AddZeroClass.toHasAdd.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (AddSubmonoidClass.to_addMemClass.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (NonUnitalSubsemiringClass.to_addSubmonoidClass.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R _inst_1 (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (NonUnitalSubsemiring.nonUnitalSubsemiringClass.{u1} R _inst_1))) s)) x y)) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x s))))) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x s))))) y))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : NonUnitalSubsemiring.{u1} R _inst_1) (x : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (y : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)), Eq.{succ u1} R (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s)) (HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (instHAdd.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (AddSubmonoid.add.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1 s))) x y)) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s)) x) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s)) y))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_add NonUnitalSubsemiring.coe_addₓ'. -/
@[simp, norm_cast]
theorem coe_add (x y : s) : ((x + y : s) : R) = (x + y : R) :=
  rfl
#align non_unital_subsemiring.coe_add NonUnitalSubsemiring.coe_add

/- warning: non_unital_subsemiring.coe_mul -> NonUnitalSubsemiring.coe_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : NonUnitalSubsemiring.{u1} R _inst_1) (x : coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) (y : coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s), Eq.{succ u1} R ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x s))))) (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) (MulMemClass.mul.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (NonUnitalSubsemiringClass.mulMemClass.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R _inst_1 (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (NonUnitalSubsemiring.nonUnitalSubsemiringClass.{u1} R _inst_1)) s)) x y)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x s))))) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x s))))) y))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : NonUnitalSubsemiring.{u1} R _inst_1) (x : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (y : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)), Eq.{succ u1} R (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s)) (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (instHMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (NonUnitalNonAssocSemiring.toMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s))) x y)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s)) x) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s)) y))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_mul NonUnitalSubsemiring.coe_mulₓ'. -/
@[simp, norm_cast]
theorem coe_mul (x y : s) : ((x * y : s) : R) = (x * y : R) :=
  rfl
#align non_unital_subsemiring.coe_mul NonUnitalSubsemiring.coe_mul

/-! Note: currently, there are no ordered versions of non-unital rings. -/


/- warning: non_unital_subsemiring.mem_to_subsemigroup -> NonUnitalSubsemiring.mem_toSubsemigroup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : NonUnitalSubsemiring.{u1} R _inst_1} {x : R}, Iff (Membership.Mem.{u1, u1} R (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) R (Subsemigroup.setLike.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))) x (NonUnitalSubsemiring.toSubsemigroup.{u1} R _inst_1 s)) (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x s)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : NonUnitalSubsemiring.{u1} R _inst_1} {x : R}, Iff (Membership.mem.{u1, u1} R (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) R (Subsemigroup.instSetLikeSubsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1))) x (NonUnitalSubsemiring.toSubsemigroup.{u1} R _inst_1 s)) (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_to_subsemigroup NonUnitalSubsemiring.mem_toSubsemigroupₓ'. -/
@[simp]
theorem mem_toSubsemigroup {s : NonUnitalSubsemiring R} {x : R} : x ∈ s.toSubsemigroup ↔ x ∈ s :=
  Iff.rfl
#align non_unital_subsemiring.mem_to_subsemigroup NonUnitalSubsemiring.mem_toSubsemigroup

/- warning: non_unital_subsemiring.coe_to_subsemigroup -> NonUnitalSubsemiring.coe_toSubsemigroup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) R (Subsemigroup.setLike.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))))) (NonUnitalSubsemiring.toSubsemigroup.{u1} R _inst_1 s)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) s)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) R (Subsemigroup.instSetLikeSubsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (NonUnitalSubsemiring.toSubsemigroup.{u1} R _inst_1 s)) (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_to_subsemigroup NonUnitalSubsemiring.coe_toSubsemigroupₓ'. -/
@[simp]
theorem coe_toSubsemigroup (s : NonUnitalSubsemiring R) : (s.toSubsemigroup : Set R) = s :=
  rfl
#align non_unital_subsemiring.coe_to_subsemigroup NonUnitalSubsemiring.coe_toSubsemigroup

/- warning: non_unital_subsemiring.mem_to_add_submonoid -> NonUnitalSubsemiring.mem_toAddSubmonoid is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : NonUnitalSubsemiring.{u1} R _inst_1} {x : R}, Iff (Membership.Mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))))) x (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1 s)) (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x s)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : NonUnitalSubsemiring.{u1} R _inst_1} {x : R}, Iff (Membership.mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))))) x (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1 s)) (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_to_add_submonoid NonUnitalSubsemiring.mem_toAddSubmonoidₓ'. -/
@[simp]
theorem mem_toAddSubmonoid {s : NonUnitalSubsemiring R} {x : R} : x ∈ s.toAddSubmonoid ↔ x ∈ s :=
  Iff.rfl
#align non_unital_subsemiring.mem_to_add_submonoid NonUnitalSubsemiring.mem_toAddSubmonoid

/- warning: non_unital_subsemiring.coe_to_add_submonoid -> NonUnitalSubsemiring.coe_toAddSubmonoid is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))))))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1 s)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) s)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1 s)) (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_to_add_submonoid NonUnitalSubsemiring.coe_toAddSubmonoidₓ'. -/
@[simp]
theorem coe_toAddSubmonoid (s : NonUnitalSubsemiring R) : (s.toAddSubmonoid : Set R) = s :=
  rfl
#align non_unital_subsemiring.coe_to_add_submonoid NonUnitalSubsemiring.coe_toAddSubmonoid

/-- The non-unital subsemiring `R` of the non-unital semiring `R`. -/
instance : Top (NonUnitalSubsemiring R) :=
  ⟨{ (⊤ : Subsemigroup R), (⊤ : AddSubmonoid R) with }⟩

/- warning: non_unital_subsemiring.mem_top -> NonUnitalSubsemiring.mem_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (x : R), Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasTop.{u1} R _inst_1))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (x : R), Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u1} R _inst_1))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_top NonUnitalSubsemiring.mem_topₓ'. -/
@[simp]
theorem mem_top (x : R) : x ∈ (⊤ : NonUnitalSubsemiring R) :=
  Set.mem_univ x
#align non_unital_subsemiring.mem_top NonUnitalSubsemiring.mem_top

/- warning: non_unital_subsemiring.coe_top -> NonUnitalSubsemiring.coe_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasTop.{u1} R _inst_1))) (Set.univ.{u1} R)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u1} R _inst_1))) (Set.univ.{u1} R)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_top NonUnitalSubsemiring.coe_topₓ'. -/
@[simp]
theorem coe_top : ((⊤ : NonUnitalSubsemiring R) : Set R) = Set.univ :=
  rfl
#align non_unital_subsemiring.coe_top NonUnitalSubsemiring.coe_top

#print NonUnitalSubsemiring.comap /-
/-- The preimage of a non-unital subsemiring along a non-unital ring homomorphism is a
non-unital subsemiring. -/
def comap (f : F) (s : NonUnitalSubsemiring S) : NonUnitalSubsemiring R :=
  { s.toSubsemigroup.comap (f : MulHom R S), s.toAddSubmonoid.comap (f : R →+ S) with
    carrier := f ⁻¹' s }
#align non_unital_subsemiring.comap NonUnitalSubsemiring.comap
-/

/- warning: non_unital_subsemiring.coe_comap -> NonUnitalSubsemiring.coe_comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (s : NonUnitalSubsemiring.{u2} S _inst_2) (f : F), Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (NonUnitalSubsemiring.comap.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f s)) (Set.preimage.{u1, u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_4))) f) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (NonUnitalSubsemiring.{u2} S _inst_2) (Set.{u2} S) (HasLiftT.mk.{succ u2, succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (Set.{u2} S) (CoeTCₓ.coe.{succ u2, succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (Set.{u2} S) (SetLike.Set.hasCoeT.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)))) s))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (s : NonUnitalSubsemiring.{u3} S _inst_2) (f : F), Eq.{succ u2} (Set.{u2} R) (SetLike.coe.{u2, u2} (NonUnitalSubsemiring.{u2} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.comap.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f s)) (Set.preimage.{u2, u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_4)) f) (SetLike.coe.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2) s))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_comap NonUnitalSubsemiring.coe_comapₓ'. -/
@[simp]
theorem coe_comap (s : NonUnitalSubsemiring S) (f : F) : (s.comap f : Set R) = f ⁻¹' s :=
  rfl
#align non_unital_subsemiring.coe_comap NonUnitalSubsemiring.coe_comap

/- warning: non_unital_subsemiring.mem_comap -> NonUnitalSubsemiring.mem_comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] {s : NonUnitalSubsemiring.{u2} S _inst_2} {f : F} {x : R}, Iff (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x (NonUnitalSubsemiring.comap.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f s)) (Membership.Mem.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.hasMem.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_4))) f x) s)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] {s : NonUnitalSubsemiring.{u3} S _inst_2} {f : F} {x : R}, Iff (Membership.mem.{u2, u2} R (NonUnitalSubsemiring.{u2} R _inst_1) (SetLike.instMembership.{u2, u2} (NonUnitalSubsemiring.{u2} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} R _inst_1)) x (NonUnitalSubsemiring.comap.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f s)) (Membership.mem.{u3, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) (NonUnitalSubsemiring.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2)) (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_4)) f x) s)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_comap NonUnitalSubsemiring.mem_comapₓ'. -/
@[simp]
theorem mem_comap {s : NonUnitalSubsemiring S} {f : F} {x : R} : x ∈ s.comap f ↔ f x ∈ s :=
  Iff.rfl
#align non_unital_subsemiring.mem_comap NonUnitalSubsemiring.mem_comap

/- warning: non_unital_subsemiring.comap_comap -> NonUnitalSubsemiring.comap_comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] [_inst_3 : NonUnitalNonAssocSemiring.{u3} T] {F : Type.{u4}} {G : Type.{u5}} [_inst_4 : NonUnitalRingHomClass.{u4, u1, u2} F R S _inst_1 _inst_2] [_inst_5 : NonUnitalRingHomClass.{u5, u2, u3} G S T _inst_2 _inst_3] (s : NonUnitalSubsemiring.{u3} T _inst_3) (g : G) (f : F), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.comap.{u1, u2, u4} R S _inst_1 _inst_2 F _inst_4 f (NonUnitalSubsemiring.comap.{u2, u3, u5} S T _inst_2 _inst_3 G _inst_5 g s)) (NonUnitalSubsemiring.comap.{u1, u3, max u1 u3} R T _inst_1 _inst_3 (NonUnitalRingHom.{u1, u3} R T _inst_1 _inst_3) (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u3} R T _inst_1 _inst_3) (NonUnitalRingHom.comp.{u1, u2, u3} R S T _inst_1 _inst_2 _inst_3 ((fun (a : Type.{u5}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{succ u5, max (succ u2) (succ u3)} a b] => self.0) G (NonUnitalRingHom.{u2, u3} S T _inst_2 _inst_3) (HasLiftT.mk.{succ u5, max (succ u2) (succ u3)} G (NonUnitalRingHom.{u2, u3} S T _inst_2 _inst_3) (CoeTCₓ.coe.{succ u5, max (succ u2) (succ u3)} G (NonUnitalRingHom.{u2, u3} S T _inst_2 _inst_3) (NonUnitalRingHom.hasCoeT.{u5, u2, u3} G S T _inst_2 _inst_3 _inst_5))) g) ((fun (a : Type.{u4}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{succ u4, max (succ u1) (succ u2)} a b] => self.0) F (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (HasLiftT.mk.{succ u4, max (succ u1) (succ u2)} F (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (CoeTCₓ.coe.{succ u4, max (succ u1) (succ u2)} F (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.hasCoeT.{u4, u1, u2} F R S _inst_1 _inst_2 _inst_4))) f)) s)
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u4}} {T : Type.{u5}} [_inst_1 : NonUnitalNonAssocSemiring.{u3} R] [_inst_2 : NonUnitalNonAssocSemiring.{u4} S] [_inst_3 : NonUnitalNonAssocSemiring.{u5} T] {F : Type.{u2}} {G : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u2, u3, u4} F R S _inst_1 _inst_2] [_inst_5 : NonUnitalRingHomClass.{u1, u4, u5} G S T _inst_2 _inst_3] (s : NonUnitalSubsemiring.{u5} T _inst_3) (g : G) (f : F), Eq.{succ u3} (NonUnitalSubsemiring.{u3} R _inst_1) (NonUnitalSubsemiring.comap.{u3, u4, u2} R S _inst_1 _inst_2 F _inst_4 f (NonUnitalSubsemiring.comap.{u4, u5, u1} S T _inst_2 _inst_3 G _inst_5 g s)) (NonUnitalSubsemiring.comap.{u3, u5, max u5 u3} R T _inst_1 _inst_3 (NonUnitalRingHom.{u3, u5} R T _inst_1 _inst_3) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u3, u5} R T _inst_1 _inst_3) (NonUnitalRingHom.comp.{u3, u4, u5} R S T _inst_1 _inst_2 _inst_3 (NonUnitalRingHomClass.toNonUnitalRingHom.{u1, u4, u5} G S T _inst_2 _inst_3 _inst_5 g) (NonUnitalRingHomClass.toNonUnitalRingHom.{u2, u3, u4} F R S _inst_1 _inst_2 _inst_4 f)) s)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.comap_comap NonUnitalSubsemiring.comap_comapₓ'. -/
-- this has some nasty coercions, how to deal with it?
theorem comap_comap (s : NonUnitalSubsemiring T) (g : G) (f : F) :
    ((s.comap g : NonUnitalSubsemiring S).comap f : NonUnitalSubsemiring R) =
      s.comap ((g : S →ₙ+* T).comp (f : R →ₙ+* S)) :=
  rfl
#align non_unital_subsemiring.comap_comap NonUnitalSubsemiring.comap_comap

#print NonUnitalSubsemiring.map /-
/-- The image of a non-unital subsemiring along a ring homomorphism is a non-unital subsemiring. -/
def map (f : F) (s : NonUnitalSubsemiring R) : NonUnitalSubsemiring S :=
  { s.toSubsemigroup.map (f : R →ₙ* S), s.toAddSubmonoid.map (f : R →+ S) with carrier := f '' s }
#align non_unital_subsemiring.map NonUnitalSubsemiring.map
-/

/- warning: non_unital_subsemiring.coe_map -> NonUnitalSubsemiring.coe_map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F) (s : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{succ u2} (Set.{u2} S) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (NonUnitalSubsemiring.{u2} S _inst_2) (Set.{u2} S) (HasLiftT.mk.{succ u2, succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (Set.{u2} S) (CoeTCₓ.coe.{succ u2, succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (Set.{u2} S) (SetLike.Set.hasCoeT.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)))) (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f s)) (Set.image.{u1, u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_4))) f) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) s))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (f : F) (s : NonUnitalSubsemiring.{u2} R _inst_1), Eq.{succ u3} (Set.{u3} S) (SetLike.coe.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalSubsemiring.map.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f s)) (Set.image.{u2, u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_4)) f) (SetLike.coe.{u2, u2} (NonUnitalSubsemiring.{u2} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} R _inst_1) s))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_map NonUnitalSubsemiring.coe_mapₓ'. -/
@[simp]
theorem coe_map (f : F) (s : NonUnitalSubsemiring R) : (s.map f : Set S) = f '' s :=
  rfl
#align non_unital_subsemiring.coe_map NonUnitalSubsemiring.coe_map

/- warning: non_unital_subsemiring.mem_map -> NonUnitalSubsemiring.mem_map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] {f : F} {s : NonUnitalSubsemiring.{u1} R _inst_1} {y : S}, Iff (Membership.Mem.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.hasMem.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) y (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f s)) (Exists.{succ u1} R (fun (x : R) => Exists.{0} (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x s) (fun (H : Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x s) => Eq.{succ u2} S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_4))) f x) y)))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] {f : F} {s : NonUnitalSubsemiring.{u2} R _inst_1} {y : S}, Iff (Membership.mem.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2)) y (NonUnitalSubsemiring.map.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f s)) (Exists.{succ u2} R (fun (x : R) => And (Membership.mem.{u2, u2} R (NonUnitalSubsemiring.{u2} R _inst_1) (SetLike.instMembership.{u2, u2} (NonUnitalSubsemiring.{u2} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} R _inst_1)) x s) (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) a) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_4)) f x) y)))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_map NonUnitalSubsemiring.mem_mapₓ'. -/
@[simp]
theorem mem_map {f : F} {s : NonUnitalSubsemiring R} {y : S} : y ∈ s.map f ↔ ∃ x ∈ s, f x = y :=
  Set.mem_image_iff_bex
#align non_unital_subsemiring.mem_map NonUnitalSubsemiring.mem_map

/- warning: non_unital_subsemiring.map_id -> NonUnitalSubsemiring.map_id is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.map.{u1, u1, u1} R R _inst_1 _inst_1 (NonUnitalRingHom.{u1, u1} R R _inst_1 _inst_1) (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u1} R R _inst_1 _inst_1) (NonUnitalRingHom.id.{u1} R _inst_1) s) s
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.map.{u1, u1, u1} R R _inst_1 _inst_1 (NonUnitalRingHom.{u1, u1} R R _inst_1 _inst_1) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u1} R R _inst_1 _inst_1) (NonUnitalRingHom.id.{u1} R _inst_1) s) s
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.map_id NonUnitalSubsemiring.map_idₓ'. -/
@[simp]
theorem map_id : s.map (NonUnitalRingHom.id R) = s :=
  SetLike.coe_injective <| Set.image_id _
#align non_unital_subsemiring.map_id NonUnitalSubsemiring.map_id

/- warning: non_unital_subsemiring.map_map -> NonUnitalSubsemiring.map_map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] [_inst_3 : NonUnitalNonAssocSemiring.{u3} T] {F : Type.{u4}} {G : Type.{u5}} [_inst_4 : NonUnitalRingHomClass.{u4, u1, u2} F R S _inst_1 _inst_2] [_inst_5 : NonUnitalRingHomClass.{u5, u2, u3} G S T _inst_2 _inst_3] (s : NonUnitalSubsemiring.{u1} R _inst_1) (g : G) (f : F), Eq.{succ u3} (NonUnitalSubsemiring.{u3} T _inst_3) (NonUnitalSubsemiring.map.{u2, u3, max u2 u3} S T _inst_2 _inst_3 (NonUnitalRingHom.{u2, u3} S T _inst_2 _inst_3) (NonUnitalRingHom.nonUnitalRingHomClass.{u2, u3} S T _inst_2 _inst_3) ((fun (a : Type.{u5}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{succ u5, max (succ u2) (succ u3)} a b] => self.0) G (NonUnitalRingHom.{u2, u3} S T _inst_2 _inst_3) (HasLiftT.mk.{succ u5, max (succ u2) (succ u3)} G (NonUnitalRingHom.{u2, u3} S T _inst_2 _inst_3) (CoeTCₓ.coe.{succ u5, max (succ u2) (succ u3)} G (NonUnitalRingHom.{u2, u3} S T _inst_2 _inst_3) (NonUnitalRingHom.hasCoeT.{u5, u2, u3} G S T _inst_2 _inst_3 _inst_5))) g) (NonUnitalSubsemiring.map.{u1, u2, max u1 u2} R S _inst_1 _inst_2 (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u2} R S _inst_1 _inst_2) ((fun (a : Type.{u4}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{succ u4, max (succ u1) (succ u2)} a b] => self.0) F (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (HasLiftT.mk.{succ u4, max (succ u1) (succ u2)} F (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (CoeTCₓ.coe.{succ u4, max (succ u1) (succ u2)} F (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.hasCoeT.{u4, u1, u2} F R S _inst_1 _inst_2 _inst_4))) f) s)) (NonUnitalSubsemiring.map.{u1, u3, max u1 u3} R T _inst_1 _inst_3 (NonUnitalRingHom.{u1, u3} R T _inst_1 _inst_3) (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u3} R T _inst_1 _inst_3) (NonUnitalRingHom.comp.{u1, u2, u3} R S T _inst_1 _inst_2 _inst_3 ((fun (a : Type.{u5}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{succ u5, max (succ u2) (succ u3)} a b] => self.0) G (NonUnitalRingHom.{u2, u3} S T _inst_2 _inst_3) (HasLiftT.mk.{succ u5, max (succ u2) (succ u3)} G (NonUnitalRingHom.{u2, u3} S T _inst_2 _inst_3) (CoeTCₓ.coe.{succ u5, max (succ u2) (succ u3)} G (NonUnitalRingHom.{u2, u3} S T _inst_2 _inst_3) (NonUnitalRingHom.hasCoeT.{u5, u2, u3} G S T _inst_2 _inst_3 _inst_5))) g) ((fun (a : Type.{u4}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{succ u4, max (succ u1) (succ u2)} a b] => self.0) F (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (HasLiftT.mk.{succ u4, max (succ u1) (succ u2)} F (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (CoeTCₓ.coe.{succ u4, max (succ u1) (succ u2)} F (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.hasCoeT.{u4, u1, u2} F R S _inst_1 _inst_2 _inst_4))) f)) s)
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u4}} {T : Type.{u5}} [_inst_1 : NonUnitalNonAssocSemiring.{u3} R] [_inst_2 : NonUnitalNonAssocSemiring.{u4} S] [_inst_3 : NonUnitalNonAssocSemiring.{u5} T] {F : Type.{u1}} {G : Type.{u2}} [_inst_4 : NonUnitalRingHomClass.{u1, u3, u4} F R S _inst_1 _inst_2] [_inst_5 : NonUnitalRingHomClass.{u2, u4, u5} G S T _inst_2 _inst_3] (s : NonUnitalSubsemiring.{u3} R _inst_1) (g : G) (f : F), Eq.{succ u5} (NonUnitalSubsemiring.{u5} T _inst_3) (NonUnitalSubsemiring.map.{u4, u5, max u4 u5} S T _inst_2 _inst_3 (NonUnitalRingHom.{u4, u5} S T _inst_2 _inst_3) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u4, u5} S T _inst_2 _inst_3) (NonUnitalRingHomClass.toNonUnitalRingHom.{u2, u4, u5} G S T _inst_2 _inst_3 _inst_5 g) (NonUnitalSubsemiring.map.{u3, u4, max u3 u4} R S _inst_1 _inst_2 (NonUnitalRingHom.{u3, u4} R S _inst_1 _inst_2) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u3, u4} R S _inst_1 _inst_2) (NonUnitalRingHomClass.toNonUnitalRingHom.{u1, u3, u4} F R S _inst_1 _inst_2 _inst_4 f) s)) (NonUnitalSubsemiring.map.{u3, u5, max u5 u3} R T _inst_1 _inst_3 (NonUnitalRingHom.{u3, u5} R T _inst_1 _inst_3) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u3, u5} R T _inst_1 _inst_3) (NonUnitalRingHom.comp.{u3, u4, u5} R S T _inst_1 _inst_2 _inst_3 (NonUnitalRingHomClass.toNonUnitalRingHom.{u2, u4, u5} G S T _inst_2 _inst_3 _inst_5 g) (NonUnitalRingHomClass.toNonUnitalRingHom.{u1, u3, u4} F R S _inst_1 _inst_2 _inst_4 f)) s)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.map_map NonUnitalSubsemiring.map_mapₓ'. -/
-- unavoidable coercions?
theorem map_map (g : G) (f : F) :
    (s.map (f : R →ₙ+* S)).map (g : S →ₙ+* T) = s.map ((g : S →ₙ+* T).comp (f : R →ₙ+* S)) :=
  SetLike.coe_injective <| Set.image_image _ _ _
#align non_unital_subsemiring.map_map NonUnitalSubsemiring.map_map

/- warning: non_unital_subsemiring.map_le_iff_le_comap -> NonUnitalSubsemiring.map_le_iff_le_comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] {f : F} {s : NonUnitalSubsemiring.{u1} R _inst_1} {t : NonUnitalSubsemiring.{u2} S _inst_2}, Iff (LE.le.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (Preorder.toHasLe.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (PartialOrder.toPreorder.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.partialOrder.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)))) (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f s) t) (LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toHasLe.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) s (NonUnitalSubsemiring.comap.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f t))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] {f : F} {s : NonUnitalSubsemiring.{u2} R _inst_1} {t : NonUnitalSubsemiring.{u3} S _inst_2}, Iff (LE.le.{u3} (NonUnitalSubsemiring.{u3} S _inst_2) (Preorder.toLE.{u3} (NonUnitalSubsemiring.{u3} S _inst_2) (PartialOrder.toPreorder.{u3} (NonUnitalSubsemiring.{u3} S _inst_2) (SetLike.instPartialOrder.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2)))) (NonUnitalSubsemiring.map.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f s) t) (LE.le.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (Preorder.toLE.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (PartialOrder.toPreorder.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (SetLike.instPartialOrder.{u2, u2} (NonUnitalSubsemiring.{u2} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} R _inst_1)))) s (NonUnitalSubsemiring.comap.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f t))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.map_le_iff_le_comap NonUnitalSubsemiring.map_le_iff_le_comapₓ'. -/
theorem map_le_iff_le_comap {f : F} {s : NonUnitalSubsemiring R} {t : NonUnitalSubsemiring S} :
    s.map f ≤ t ↔ s ≤ t.comap f :=
  Set.image_subset_iff
#align non_unital_subsemiring.map_le_iff_le_comap NonUnitalSubsemiring.map_le_iff_le_comap

/- warning: non_unital_subsemiring.gc_map_comap -> NonUnitalSubsemiring.gc_map_comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F), GaloisConnection.{u1, u2} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.{u2} S _inst_2) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1))) (PartialOrder.toPreorder.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.partialOrder.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2))) (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f) (NonUnitalSubsemiring.comap.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (f : F), GaloisConnection.{u2, u3} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.{u3} S _inst_2) (PartialOrder.toPreorder.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (SetLike.instPartialOrder.{u2, u2} (NonUnitalSubsemiring.{u2} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} R _inst_1))) (PartialOrder.toPreorder.{u3} (NonUnitalSubsemiring.{u3} S _inst_2) (SetLike.instPartialOrder.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2))) (NonUnitalSubsemiring.map.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f) (NonUnitalSubsemiring.comap.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.gc_map_comap NonUnitalSubsemiring.gc_map_comapₓ'. -/
theorem gc_map_comap (f : F) :
    @GaloisConnection (NonUnitalSubsemiring R) (NonUnitalSubsemiring S) _ _ (map f) (comap f) :=
  fun S T => map_le_iff_le_comap
#align non_unital_subsemiring.gc_map_comap NonUnitalSubsemiring.gc_map_comap

/- warning: non_unital_subsemiring.equiv_map_of_injective -> NonUnitalSubsemiring.equivMapOfInjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (s : NonUnitalSubsemiring.{u1} R _inst_1) (f : F), (Function.Injective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_4))) f)) -> (RingEquiv.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) (coeSort.{succ u2, succ (succ u2)} (NonUnitalSubsemiring.{u2} S _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f s)) (MulMemClass.mul.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (NonUnitalSubsemiring.equivMapOfInjective._proof_1.{u1} R _inst_1) s) (AddMemClass.add.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (AddZeroClass.toHasAdd.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (NonUnitalSubsemiring.equivMapOfInjective._proof_2.{u1} R _inst_1) s) (MulMemClass.mul.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalSubsemiring.setLike.{u2} S _inst_2) (NonUnitalSubsemiring.equivMapOfInjective._proof_3.{u2} S _inst_2) (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f s)) (AddMemClass.add.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (AddZeroClass.toHasAdd.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S _inst_2)))) (NonUnitalSubsemiring.setLike.{u2} S _inst_2) (NonUnitalSubsemiring.equivMapOfInjective._proof_4.{u2} S _inst_2) (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f s)))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (s : NonUnitalSubsemiring.{u1} R _inst_1) (f : F), (Function.Injective.{succ u1, succ u2} R S (FunLike.coe.{succ u3, succ u1, succ u2} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u3, u1, u2} F R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_4)) f)) -> (RingEquiv.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (Subtype.{succ u2} S (fun (x : S) => Membership.mem.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.instMembership.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2)) x (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f s))) (NonUnitalNonAssocSemiring.toMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s)) (NonUnitalNonAssocSemiring.toMul.{u2} (Subtype.{succ u2} S (fun (x : S) => Membership.mem.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.instMembership.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2)) x (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f s))) (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) _inst_2 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f s))) (AddSubmonoid.add.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1 s)) (AddSubmonoid.add.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S _inst_2))) (NonUnitalSubsemiring.toAddSubmonoid.{u2} S _inst_2 (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f s))))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.equiv_map_of_injective NonUnitalSubsemiring.equivMapOfInjectiveₓ'. -/
/-- A non-unital subsemiring is isomorphic to its image under an injective function -/
noncomputable def equivMapOfInjective (f : F) (hf : Function.Injective (f : R → S)) :
    s ≃+* s.map f :=
  {
    Equiv.Set.image f s
      hf with
    map_mul' := fun _ _ => Subtype.ext (map_mul f _ _)
    map_add' := fun _ _ => Subtype.ext (map_add f _ _) }
#align non_unital_subsemiring.equiv_map_of_injective NonUnitalSubsemiring.equivMapOfInjective

/- warning: non_unital_subsemiring.coe_equiv_map_of_injective_apply -> NonUnitalSubsemiring.coe_equivMapOfInjective_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_equiv_map_of_injective_apply NonUnitalSubsemiring.coe_equivMapOfInjective_applyₓ'. -/
@[simp]
theorem coe_equivMapOfInjective_apply (f : F) (hf : Function.Injective f) (x : s) :
    (equivMapOfInjective s f hf x : S) = f x :=
  rfl
#align non_unital_subsemiring.coe_equiv_map_of_injective_apply NonUnitalSubsemiring.coe_equivMapOfInjective_apply

end NonUnitalSubsemiring

namespace NonUnitalRingHom

open NonUnitalSubsemiring

variable {F G : Type _} [NonUnitalRingHomClass F R S] [NonUnitalRingHomClass G S T] (f : F) (g : G)

#print NonUnitalRingHom.srange /-
/-- The range of a non-unital ring homomorphism is a non-unital subsemiring.
See note [range copy pattern]. -/
def srange : NonUnitalSubsemiring S :=
  ((⊤ : NonUnitalSubsemiring R).map (f : R →ₙ+* S)).copy (Set.range f) Set.image_univ.symm
#align non_unital_ring_hom.srange NonUnitalRingHom.srange
-/

/- warning: non_unital_ring_hom.coe_srange -> NonUnitalRingHom.coe_srange is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F), Eq.{succ u2} (Set.{u2} S) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (NonUnitalSubsemiring.{u2} S _inst_2) (Set.{u2} S) (HasLiftT.mk.{succ u2, succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (Set.{u2} S) (CoeTCₓ.coe.{succ u2, succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (Set.{u2} S) (SetLike.Set.hasCoeT.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)))) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f)) (Set.range.{u2, succ u1} S R (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_4))) f))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (f : F), Eq.{succ u3} (Set.{u3} S) (SetLike.coe.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f)) (Set.range.{u3, succ u2} S R (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_4)) f))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_srange NonUnitalRingHom.coe_srangeₓ'. -/
@[simp]
theorem coe_srange : (@srange R S _ _ _ _ f : Set S) = Set.range f :=
  rfl
#align non_unital_ring_hom.coe_srange NonUnitalRingHom.coe_srange

/- warning: non_unital_ring_hom.mem_srange -> NonUnitalRingHom.mem_srange is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] {f : F} {y : S}, Iff (Membership.Mem.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.hasMem.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) y (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f)) (Exists.{succ u1} R (fun (x : R) => Eq.{succ u2} S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_4))) f x) y))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] {f : F} {y : S}, Iff (Membership.mem.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2)) y (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f)) (Exists.{succ u2} R (fun (x : R) => Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_4)) f x) y))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.mem_srange NonUnitalRingHom.mem_srangeₓ'. -/
@[simp]
theorem mem_srange {f : F} {y : S} : y ∈ @srange R S _ _ _ _ f ↔ ∃ x, f x = y :=
  Iff.rfl
#align non_unital_ring_hom.mem_srange NonUnitalRingHom.mem_srange

/- warning: non_unital_ring_hom.srange_eq_map -> NonUnitalRingHom.srange_eq_map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F), Eq.{succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f) (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasTop.{u1} R _inst_1)))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (f : F), Eq.{succ u3} (NonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f) (NonUnitalSubsemiring.map.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f (Top.top.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u2} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.srange_eq_map NonUnitalRingHom.srange_eq_mapₓ'. -/
theorem srange_eq_map : @srange R S _ _ _ _ f = (⊤ : NonUnitalSubsemiring R).map f :=
  by
  ext
  simp
#align non_unital_ring_hom.srange_eq_map NonUnitalRingHom.srange_eq_map

/- warning: non_unital_ring_hom.mem_srange_self -> NonUnitalRingHom.mem_srange_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F) (x : R), Membership.Mem.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.hasMem.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_4))) f x) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (f : F) (x : R), Membership.mem.{u3, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) (NonUnitalSubsemiring.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2)) (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_4)) f x) (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f)
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.mem_srange_self NonUnitalRingHom.mem_srange_selfₓ'. -/
theorem mem_srange_self (f : F) (x : R) : f x ∈ @srange R S _ _ _ _ f :=
  mem_srange.mpr ⟨x, rfl⟩
#align non_unital_ring_hom.mem_srange_self NonUnitalRingHom.mem_srange_self

/- warning: non_unital_ring_hom.map_srange -> NonUnitalRingHom.map_srange is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] [_inst_3 : NonUnitalNonAssocSemiring.{u3} T] (g : NonUnitalRingHom.{u2, u3} S T _inst_2 _inst_3) (f : NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2), Eq.{succ u3} (NonUnitalSubsemiring.{u3} T _inst_3) (NonUnitalSubsemiring.map.{u2, u3, max u2 u3} S T _inst_2 _inst_3 (NonUnitalRingHom.{u2, u3} S T _inst_2 _inst_3) (NonUnitalRingHom.nonUnitalRingHomClass.{u2, u3} S T _inst_2 _inst_3) g (NonUnitalRingHom.srange.{u1, u2, max u1 u2} R S _inst_1 _inst_2 (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u2} R S _inst_1 _inst_2) f)) (NonUnitalRingHom.srange.{u1, u3, max u1 u3} R T _inst_1 _inst_3 (NonUnitalRingHom.{u1, u3} R T _inst_1 _inst_3) (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u3} R T _inst_1 _inst_3) (NonUnitalRingHom.comp.{u1, u2, u3} R S T _inst_1 _inst_2 _inst_3 g f))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] [_inst_3 : NonUnitalNonAssocSemiring.{u3} T] (g : NonUnitalRingHom.{u2, u3} S T _inst_2 _inst_3) (f : NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2), Eq.{succ u3} (NonUnitalSubsemiring.{u3} T _inst_3) (NonUnitalSubsemiring.map.{u2, u3, max u2 u3} S T _inst_2 _inst_3 (NonUnitalRingHom.{u2, u3} S T _inst_2 _inst_3) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u3} S T _inst_2 _inst_3) g (NonUnitalRingHom.srange.{u1, u2, max u1 u2} R S _inst_1 _inst_2 (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) f)) (NonUnitalRingHom.srange.{u1, u3, max u3 u1} R T _inst_1 _inst_3 (NonUnitalRingHom.{u1, u3} R T _inst_1 _inst_3) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u3} R T _inst_1 _inst_3) (NonUnitalRingHom.comp.{u1, u2, u3} R S T _inst_1 _inst_2 _inst_3 g f))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.map_srange NonUnitalRingHom.map_srangeₓ'. -/
theorem map_srange (g : S →ₙ+* T) (f : R →ₙ+* S) : map g (srange f) = srange (g.comp f) := by
  simpa only [srange_eq_map] using (⊤ : NonUnitalSubsemiring R).map_map g f
#align non_unital_ring_hom.map_srange NonUnitalRingHom.map_srange

/- warning: non_unital_ring_hom.finite_srange -> NonUnitalRingHom.finite_srange is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] [_inst_6 : Finite.{succ u1} R] (f : F), Finite.{succ u2} (coeSort.{succ u2, succ (succ u2)} (NonUnitalSubsemiring.{u2} S _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] [_inst_6 : Finite.{succ u1} R] (f : F), Finite.{succ u2} (Subtype.{succ u2} S (fun (x : S) => Membership.mem.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.instMembership.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2)) x (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f)))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.finite_srange NonUnitalRingHom.finite_srangeₓ'. -/
/-- The range of a morphism of non-unital semirings is finite if the domain is a finite. -/
instance finite_srange [Finite R] (f : F) : Finite (srange f : NonUnitalSubsemiring S) :=
  (Set.finite_range f).to_subtype
#align non_unital_ring_hom.finite_srange NonUnitalRingHom.finite_srange

end NonUnitalRingHom

namespace NonUnitalSubsemiring

-- should we define this as the range of the zero homomorphism?
instance : Bot (NonUnitalSubsemiring R) :=
  ⟨{  carrier := {0}
      add_mem' := fun _ _ _ _ => by simp_all
      zero_mem' := Set.mem_singleton 0
      mul_mem' := fun _ _ _ _ => by simp_all }⟩

instance : Inhabited (NonUnitalSubsemiring R) :=
  ⟨⊥⟩

/- warning: non_unital_subsemiring.coe_bot -> NonUnitalSubsemiring.coe_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (Bot.bot.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasBot.{u1} R _inst_1))) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (Bot.bot.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instBotNonUnitalSubsemiring.{u1} R _inst_1))) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MulZeroClass.toZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_bot NonUnitalSubsemiring.coe_botₓ'. -/
theorem coe_bot : ((⊥ : NonUnitalSubsemiring R) : Set R) = {0} :=
  rfl
#align non_unital_subsemiring.coe_bot NonUnitalSubsemiring.coe_bot

/- warning: non_unital_subsemiring.mem_bot -> NonUnitalSubsemiring.mem_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {x : R}, Iff (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x (Bot.bot.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasBot.{u1} R _inst_1))) (Eq.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {x : R}, Iff (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x (Bot.bot.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instBotNonUnitalSubsemiring.{u1} R _inst_1))) (Eq.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MulZeroClass.toZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_bot NonUnitalSubsemiring.mem_botₓ'. -/
theorem mem_bot {x : R} : x ∈ (⊥ : NonUnitalSubsemiring R) ↔ x = 0 :=
  Set.mem_singleton_iff
#align non_unital_subsemiring.mem_bot NonUnitalSubsemiring.mem_bot

/-- The inf of two non-unital subsemirings is their intersection. -/
instance : Inf (NonUnitalSubsemiring R) :=
  ⟨fun s t =>
    { s.toSubsemigroup ⊓ t.toSubsemigroup, s.toAddSubmonoid ⊓ t.toAddSubmonoid with
      carrier := s ∩ t }⟩

/- warning: non_unital_subsemiring.coe_inf -> NonUnitalSubsemiring.coe_inf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (p : NonUnitalSubsemiring.{u1} R _inst_1) (p' : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (Inf.inf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasInf.{u1} R _inst_1) p p')) (Inter.inter.{u1} (Set.{u1} R) (Set.hasInter.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) p) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) p'))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (p : NonUnitalSubsemiring.{u1} R _inst_1) (p' : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (Inf.inf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instInfNonUnitalSubsemiring.{u1} R _inst_1) p p')) (Inter.inter.{u1} (Set.{u1} R) (Set.instInterSet.{u1} R) (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) p) (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) p'))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_inf NonUnitalSubsemiring.coe_infₓ'. -/
@[simp]
theorem coe_inf (p p' : NonUnitalSubsemiring R) :
    ((p ⊓ p' : NonUnitalSubsemiring R) : Set R) = p ∩ p' :=
  rfl
#align non_unital_subsemiring.coe_inf NonUnitalSubsemiring.coe_inf

/- warning: non_unital_subsemiring.mem_inf -> NonUnitalSubsemiring.mem_inf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {p : NonUnitalSubsemiring.{u1} R _inst_1} {p' : NonUnitalSubsemiring.{u1} R _inst_1} {x : R}, Iff (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x (Inf.inf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasInf.{u1} R _inst_1) p p')) (And (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x p) (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x p'))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {p : NonUnitalSubsemiring.{u1} R _inst_1} {p' : NonUnitalSubsemiring.{u1} R _inst_1} {x : R}, Iff (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x (Inf.inf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instInfNonUnitalSubsemiring.{u1} R _inst_1) p p')) (And (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x p) (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x p'))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_inf NonUnitalSubsemiring.mem_infₓ'. -/
@[simp]
theorem mem_inf {p p' : NonUnitalSubsemiring R} {x : R} : x ∈ p ⊓ p' ↔ x ∈ p ∧ x ∈ p' :=
  Iff.rfl
#align non_unital_subsemiring.mem_inf NonUnitalSubsemiring.mem_inf

instance : InfSet (NonUnitalSubsemiring R) :=
  ⟨fun s =>
    NonUnitalSubsemiring.mk' (⋂ t ∈ s, ↑t) (⨅ t ∈ s, NonUnitalSubsemiring.toSubsemigroup t)
      (by simp) (⨅ t ∈ s, NonUnitalSubsemiring.toAddSubmonoid t) (by simp)⟩

/- warning: non_unital_subsemiring.coe_Inf -> NonUnitalSubsemiring.coe_sInf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (S : Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)), Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (InfSet.sInf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasInf.{u1} R _inst_1) S)) (Set.iInter.{u1, succ u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (fun (s : NonUnitalSubsemiring.{u1} R _inst_1) => Set.iInter.{u1, 0} R (Membership.Mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.hasMem.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) s S) (fun (H : Membership.Mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.hasMem.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) s S) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) s)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (S : Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)), Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (InfSet.sInf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instInfSetNonUnitalSubsemiring.{u1} R _inst_1) S)) (Set.iInter.{u1, succ u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (fun (s : NonUnitalSubsemiring.{u1} R _inst_1) => Set.iInter.{u1, 0} R (Membership.mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.instMembershipSet.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) s S) (fun (H : Membership.mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.instMembershipSet.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) s S) => SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s)))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_Inf NonUnitalSubsemiring.coe_sInfₓ'. -/
@[simp, norm_cast]
theorem coe_sInf (S : Set (NonUnitalSubsemiring R)) :
    ((sInf S : NonUnitalSubsemiring R) : Set R) = ⋂ s ∈ S, ↑s :=
  rfl
#align non_unital_subsemiring.coe_Inf NonUnitalSubsemiring.coe_sInf

/- warning: non_unital_subsemiring.mem_Inf -> NonUnitalSubsemiring.mem_sInf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {S : Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)} {x : R}, Iff (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x (InfSet.sInf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasInf.{u1} R _inst_1) S)) (forall (p : NonUnitalSubsemiring.{u1} R _inst_1), (Membership.Mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.hasMem.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) p S) -> (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x p))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {S : Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)} {x : R}, Iff (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x (InfSet.sInf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instInfSetNonUnitalSubsemiring.{u1} R _inst_1) S)) (forall (p : NonUnitalSubsemiring.{u1} R _inst_1), (Membership.mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.instMembershipSet.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) p S) -> (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x p))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_Inf NonUnitalSubsemiring.mem_sInfₓ'. -/
theorem mem_sInf {S : Set (NonUnitalSubsemiring R)} {x : R} : x ∈ sInf S ↔ ∀ p ∈ S, x ∈ p :=
  Set.mem_iInter₂
#align non_unital_subsemiring.mem_Inf NonUnitalSubsemiring.mem_sInf

/- warning: non_unital_subsemiring.Inf_to_subsemigroup -> NonUnitalSubsemiring.sInf_toSubsemigroup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)), Eq.{succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (NonUnitalSubsemiring.toSubsemigroup.{u1} R _inst_1 (InfSet.sInf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasInf.{u1} R _inst_1) s)) (iInf.{u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Subsemigroup.hasInf.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (NonUnitalSubsemiring.{u1} R _inst_1) (fun (t : NonUnitalSubsemiring.{u1} R _inst_1) => iInf.{u1, 0} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Subsemigroup.hasInf.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Membership.Mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.hasMem.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) t s) (fun (H : Membership.Mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.hasMem.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) t s) => NonUnitalSubsemiring.toSubsemigroup.{u1} R _inst_1 t)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)), Eq.{succ u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (NonUnitalSubsemiring.toSubsemigroup.{u1} R _inst_1 (InfSet.sInf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instInfSetNonUnitalSubsemiring.{u1} R _inst_1) s)) (iInf.{u1, succ u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (Subsemigroup.instInfSetSubsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (NonUnitalSubsemiring.{u1} R _inst_1) (fun (t : NonUnitalSubsemiring.{u1} R _inst_1) => iInf.{u1, 0} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (Subsemigroup.instInfSetSubsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (Membership.mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.instMembershipSet.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) t s) (fun (H : Membership.mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.instMembershipSet.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) t s) => NonUnitalSubsemiring.toSubsemigroup.{u1} R _inst_1 t)))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.Inf_to_subsemigroup NonUnitalSubsemiring.sInf_toSubsemigroupₓ'. -/
@[simp]
theorem sInf_toSubsemigroup (s : Set (NonUnitalSubsemiring R)) :
    (sInf s).toSubsemigroup = ⨅ t ∈ s, NonUnitalSubsemiring.toSubsemigroup t :=
  mk'_toSubsemigroup _ _
#align non_unital_subsemiring.Inf_to_subsemigroup NonUnitalSubsemiring.sInf_toSubsemigroup

#print NonUnitalSubsemiring.sInf_toAddSubmonoid /-
@[simp]
theorem sInf_toAddSubmonoid (s : Set (NonUnitalSubsemiring R)) :
    (sInf s).toAddSubmonoid = ⨅ t ∈ s, NonUnitalSubsemiring.toAddSubmonoid t :=
  mk'_toAddSubmonoid _ _
#align non_unital_subsemiring.Inf_to_add_submonoid NonUnitalSubsemiring.sInf_toAddSubmonoid
-/

/-- Non-unital subsemirings of a non-unital semiring form a complete lattice. -/
instance : CompleteLattice (NonUnitalSubsemiring R) :=
  {
    completeLatticeOfInf (NonUnitalSubsemiring R) fun s =>
      IsGLB.of_image (fun s t => show (s : Set R) ≤ t ↔ s ≤ t from SetLike.coe_subset_coe)
        isGLB_biInf with
    bot := ⊥
    bot_le := fun s x hx => (mem_bot.mp hx).symm ▸ zero_mem s
    top := ⊤
    le_top := fun s x hx => trivial
    inf := (· ⊓ ·)
    inf_le_left := fun s t x => And.left
    inf_le_right := fun s t x => And.right
    le_inf := fun s t₁ t₂ h₁ h₂ x hx => ⟨h₁ hx, h₂ hx⟩ }

/- warning: non_unital_subsemiring.eq_top_iff' -> NonUnitalSubsemiring.eq_top_iff' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (A : NonUnitalSubsemiring.{u1} R _inst_1), Iff (Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) A (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasTop.{u1} R _inst_1))) (forall (x : R), Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x A)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (A : NonUnitalSubsemiring.{u1} R _inst_1), Iff (Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) A (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u1} R _inst_1))) (forall (x : R), Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x A)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.eq_top_iff' NonUnitalSubsemiring.eq_top_iff'ₓ'. -/
theorem eq_top_iff' (A : NonUnitalSubsemiring R) : A = ⊤ ↔ ∀ x : R, x ∈ A :=
  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩
#align non_unital_subsemiring.eq_top_iff' NonUnitalSubsemiring.eq_top_iff'

section Center

#print NonUnitalSubsemiring.center /-
/-- The center of a semiring `R` is the set of elements that commute with everything in `R` -/
def center (R) [NonUnitalSemiring R] : NonUnitalSubsemiring R :=
  { Subsemigroup.center R with
    carrier := Set.center R
    zero_mem' := Set.zero_mem_center R
    add_mem' := fun a b => Set.add_mem_center }
#align non_unital_subsemiring.center NonUnitalSubsemiring.center
-/

/- warning: non_unital_subsemiring.coe_center -> NonUnitalSubsemiring.coe_center is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_4 : NonUnitalSemiring.{u1} R], Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) R (NonUnitalSubsemiring.setLike.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))))) (NonUnitalSubsemiring.center.{u1} R _inst_4)) (Set.center.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))))
but is expected to have type
  forall (R : Type.{u1}) [_inst_4 : NonUnitalSemiring.{u1} R], Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (NonUnitalSubsemiring.center.{u1} R _inst_4)) (Set.center.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_center NonUnitalSubsemiring.coe_centerₓ'. -/
theorem coe_center (R) [NonUnitalSemiring R] : ↑(center R) = Set.center R :=
  rfl
#align non_unital_subsemiring.coe_center NonUnitalSubsemiring.coe_center

/- warning: non_unital_subsemiring.center_to_subsemigroup -> NonUnitalSubsemiring.center_toSubsemigroup is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_4 : NonUnitalSemiring.{u1} R], Eq.{succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)))) (NonUnitalSubsemiring.toSubsemigroup.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4) (NonUnitalSubsemiring.center.{u1} R _inst_4)) (Subsemigroup.center.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R _inst_4)))
but is expected to have type
  forall (R : Type.{u1}) [_inst_4 : NonUnitalSemiring.{u1} R], Eq.{succ u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (NonUnitalSubsemiring.toSubsemigroup.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4) (NonUnitalSubsemiring.center.{u1} R _inst_4)) (Subsemigroup.center.{u1} R (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R _inst_4)))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.center_to_subsemigroup NonUnitalSubsemiring.center_toSubsemigroupₓ'. -/
@[simp]
theorem center_toSubsemigroup (R) [NonUnitalSemiring R] :
    (center R).toSubsemigroup = Subsemigroup.center R :=
  rfl
#align non_unital_subsemiring.center_to_subsemigroup NonUnitalSubsemiring.center_toSubsemigroup

/- warning: non_unital_subsemiring.mem_center_iff -> NonUnitalSubsemiring.mem_center_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_4 : NonUnitalSemiring.{u1} R] {z : R}, Iff (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) R (NonUnitalSubsemiring.setLike.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) z (NonUnitalSubsemiring.center.{u1} R _inst_4)) (forall (g : R), Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)))) g z) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)))) z g))
but is expected to have type
  forall {R : Type.{u1}} [_inst_4 : NonUnitalSemiring.{u1} R] {z : R}, Iff (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) z (NonUnitalSubsemiring.center.{u1} R _inst_4)) (forall (g : R), Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) g z) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) z g))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_center_iff NonUnitalSubsemiring.mem_center_iffₓ'. -/
theorem mem_center_iff {R} [NonUnitalSemiring R] {z : R} : z ∈ center R ↔ ∀ g, g * z = z * g :=
  Iff.rfl
#align non_unital_subsemiring.mem_center_iff NonUnitalSubsemiring.mem_center_iff

/- warning: non_unital_subsemiring.decidable_mem_center -> NonUnitalSubsemiring.decidableMemCenter is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_4 : NonUnitalSemiring.{u1} R] [_inst_5 : DecidableEq.{succ u1} R] [_inst_6 : Fintype.{u1} R], DecidablePred.{succ u1} R (fun (_x : R) => Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) R (NonUnitalSubsemiring.setLike.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) _x (NonUnitalSubsemiring.center.{u1} R _inst_4))
but is expected to have type
  forall {R : Type.{u1}} [_inst_4 : NonUnitalSemiring.{u1} R] [_inst_5 : DecidableEq.{succ u1} R] [_inst_6 : Fintype.{u1} R], DecidablePred.{succ u1} R (fun (_x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) _x (NonUnitalSubsemiring.center.{u1} R _inst_4))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.decidable_mem_center NonUnitalSubsemiring.decidableMemCenterₓ'. -/
instance decidableMemCenter {R} [NonUnitalSemiring R] [DecidableEq R] [Fintype R] :
    DecidablePred (· ∈ center R) := fun _ => decidable_of_iff' _ mem_center_iff
#align non_unital_subsemiring.decidable_mem_center NonUnitalSubsemiring.decidableMemCenter

/- warning: non_unital_subsemiring.center_eq_top -> NonUnitalSubsemiring.center_eq_top is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_4 : NonUnitalCommSemiring.{u1} R], Eq.{succ u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R _inst_4))) (NonUnitalSubsemiring.center.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R _inst_4)) (Top.top.{u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R _inst_4))) (NonUnitalSubsemiring.hasTop.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R _inst_4))))
but is expected to have type
  forall (R : Type.{u1}) [_inst_4 : NonUnitalCommSemiring.{u1} R], Eq.{succ u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R _inst_4))) (NonUnitalSubsemiring.center.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R _inst_4)) (Top.top.{u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R _inst_4))) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} R _inst_4))))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.center_eq_top NonUnitalSubsemiring.center_eq_topₓ'. -/
@[simp]
theorem center_eq_top (R) [NonUnitalCommSemiring R] : center R = ⊤ :=
  SetLike.coe_injective (Set.center_eq_univ R)
#align non_unital_subsemiring.center_eq_top NonUnitalSubsemiring.center_eq_top

/-- The center is commutative. -/
instance {R} [NonUnitalSemiring R] : NonUnitalCommSemiring (center R) :=
  { Subsemigroup.center.commSemigroup,
    NonUnitalSubsemiringClass.toNonUnitalSemiring (center R) with }

end Center

section Centralizer

#print NonUnitalSubsemiring.centralizer /-
/-- The centralizer of a set as non-unital subsemiring. -/
def centralizer {R} [NonUnitalSemiring R] (s : Set R) : NonUnitalSubsemiring R :=
  { Subsemigroup.centralizer s with
    carrier := s.centralizer
    zero_mem' := Set.zero_mem_centralizer _
    add_mem' := fun x y hx hy => Set.add_mem_centralizer hx hy }
#align non_unital_subsemiring.centralizer NonUnitalSubsemiring.centralizer
-/

/- warning: non_unital_subsemiring.coe_centralizer -> NonUnitalSubsemiring.coe_centralizer is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_4 : NonUnitalSemiring.{u1} R] (s : Set.{u1} R), Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) R (NonUnitalSubsemiring.setLike.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))))) (NonUnitalSubsemiring.centralizer.{u1} R _inst_4 s)) (Set.centralizer.{u1} R s (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_4 : NonUnitalSemiring.{u1} R] (s : Set.{u1} R), Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (NonUnitalSubsemiring.centralizer.{u1} R _inst_4 s)) (Set.centralizer.{u1} R s (NonUnitalNonAssocSemiring.toMul.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_centralizer NonUnitalSubsemiring.coe_centralizerₓ'. -/
@[simp, norm_cast]
theorem coe_centralizer {R} [NonUnitalSemiring R] (s : Set R) :
    (centralizer s : Set R) = s.centralizer :=
  rfl
#align non_unital_subsemiring.coe_centralizer NonUnitalSubsemiring.coe_centralizer

/- warning: non_unital_subsemiring.centralizer_to_subsemigroup -> NonUnitalSubsemiring.centralizer_toSubsemigroup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_4 : NonUnitalSemiring.{u1} R] (s : Set.{u1} R), Eq.{succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)))) (NonUnitalSubsemiring.toSubsemigroup.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4) (NonUnitalSubsemiring.centralizer.{u1} R _inst_4 s)) (Subsemigroup.centralizer.{u1} R s (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R _inst_4)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_4 : NonUnitalSemiring.{u1} R] (s : Set.{u1} R), Eq.{succ u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) (NonUnitalSubsemiring.toSubsemigroup.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4) (NonUnitalSubsemiring.centralizer.{u1} R _inst_4 s)) (Subsemigroup.centralizer.{u1} R s (SemigroupWithZero.toSemigroup.{u1} R (NonUnitalSemiring.toSemigroupWithZero.{u1} R _inst_4)))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.centralizer_to_subsemigroup NonUnitalSubsemiring.centralizer_toSubsemigroupₓ'. -/
theorem centralizer_toSubsemigroup {R} [NonUnitalSemiring R] (s : Set R) :
    (centralizer s).toSubsemigroup = Subsemigroup.centralizer s :=
  rfl
#align non_unital_subsemiring.centralizer_to_subsemigroup NonUnitalSubsemiring.centralizer_toSubsemigroup

/- warning: non_unital_subsemiring.mem_centralizer_iff -> NonUnitalSubsemiring.mem_centralizer_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_4 : NonUnitalSemiring.{u1} R] {s : Set.{u1} R} {z : R}, Iff (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) R (NonUnitalSubsemiring.setLike.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) z (NonUnitalSubsemiring.centralizer.{u1} R _inst_4 s)) (forall (g : R), (Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) g s) -> (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)))) g z) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)))) z g)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_4 : NonUnitalSemiring.{u1} R] {s : Set.{u1} R} {z : R}, Iff (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) z (NonUnitalSubsemiring.centralizer.{u1} R _inst_4 s)) (forall (g : R), (Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) g s) -> (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) g z) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))) z g)))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_centralizer_iff NonUnitalSubsemiring.mem_centralizer_iffₓ'. -/
theorem mem_centralizer_iff {R} [NonUnitalSemiring R] {s : Set R} {z : R} :
    z ∈ centralizer s ↔ ∀ g ∈ s, g * z = z * g :=
  Iff.rfl
#align non_unital_subsemiring.mem_centralizer_iff NonUnitalSubsemiring.mem_centralizer_iff

/- warning: non_unital_subsemiring.centralizer_le -> NonUnitalSubsemiring.centralizer_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_4 : NonUnitalSemiring.{u1} R] (s : Set.{u1} R) (t : Set.{u1} R), (HasSubset.Subset.{u1} (Set.{u1} R) (Set.hasSubset.{u1} R) s t) -> (LE.le.{u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (Preorder.toHasLe.{u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) R (NonUnitalSubsemiring.setLike.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4))))) (NonUnitalSubsemiring.centralizer.{u1} R _inst_4 t) (NonUnitalSubsemiring.centralizer.{u1} R _inst_4 s))
but is expected to have type
  forall {R : Type.{u1}} [_inst_4 : NonUnitalSemiring.{u1} R] (s : Set.{u1} R) (t : Set.{u1} R), (HasSubset.Subset.{u1} (Set.{u1} R) (Set.instHasSubsetSet.{u1} R) s t) -> (LE.le.{u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (Preorder.toLE.{u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (CompleteSemilatticeInf.toPartialOrder.{u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (NonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R _inst_4)))))) (NonUnitalSubsemiring.centralizer.{u1} R _inst_4 t) (NonUnitalSubsemiring.centralizer.{u1} R _inst_4 s))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.centralizer_le NonUnitalSubsemiring.centralizer_leₓ'. -/
theorem centralizer_le {R} [NonUnitalSemiring R] (s t : Set R) (h : s ⊆ t) :
    centralizer t ≤ centralizer s :=
  Set.centralizer_subset h
#align non_unital_subsemiring.centralizer_le NonUnitalSubsemiring.centralizer_le

#print NonUnitalSubsemiring.centralizer_univ /-
@[simp]
theorem centralizer_univ {R} [NonUnitalSemiring R] : centralizer Set.univ = center R :=
  SetLike.ext' (Set.centralizer_univ R)
#align non_unital_subsemiring.centralizer_univ NonUnitalSubsemiring.centralizer_univ
-/

end Centralizer

#print NonUnitalSubsemiring.closure /-
/-- The `non_unital_subsemiring` generated by a set. -/
def closure (s : Set R) : NonUnitalSubsemiring R :=
  sInf { S | s ⊆ S }
#align non_unital_subsemiring.closure NonUnitalSubsemiring.closure
-/

/- warning: non_unital_subsemiring.mem_closure -> NonUnitalSubsemiring.mem_closure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {x : R} {s : Set.{u1} R}, Iff (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x (NonUnitalSubsemiring.closure.{u1} R _inst_1 s)) (forall (S : NonUnitalSubsemiring.{u1} R _inst_1), (HasSubset.Subset.{u1} (Set.{u1} R) (Set.hasSubset.{u1} R) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) S)) -> (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x S))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {x : R} {s : Set.{u1} R}, Iff (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x (NonUnitalSubsemiring.closure.{u1} R _inst_1 s)) (forall (S : NonUnitalSubsemiring.{u1} R _inst_1), (HasSubset.Subset.{u1} (Set.{u1} R) (Set.instHasSubsetSet.{u1} R) s (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) S)) -> (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x S))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_closure NonUnitalSubsemiring.mem_closureₓ'. -/
theorem mem_closure {x : R} {s : Set R} :
    x ∈ closure s ↔ ∀ S : NonUnitalSubsemiring R, s ⊆ S → x ∈ S :=
  mem_sInf
#align non_unital_subsemiring.mem_closure NonUnitalSubsemiring.mem_closure

/- warning: non_unital_subsemiring.subset_closure -> NonUnitalSubsemiring.subset_closure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R}, HasSubset.Subset.{u1} (Set.{u1} R) (Set.hasSubset.{u1} R) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (NonUnitalSubsemiring.closure.{u1} R _inst_1 s))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R}, HasSubset.Subset.{u1} (Set.{u1} R) (Set.instHasSubsetSet.{u1} R) s (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.closure.{u1} R _inst_1 s))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.subset_closure NonUnitalSubsemiring.subset_closureₓ'. -/
/-- The non-unital subsemiring generated by a set includes the set. -/
@[simp]
theorem subset_closure {s : Set R} : s ⊆ closure s := fun x hx => mem_closure.2 fun S hS => hS hx
#align non_unital_subsemiring.subset_closure NonUnitalSubsemiring.subset_closure

/- warning: non_unital_subsemiring.not_mem_of_not_mem_closure -> NonUnitalSubsemiring.not_mem_of_not_mem_closure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {P : R}, (Not (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) P (NonUnitalSubsemiring.closure.{u1} R _inst_1 s))) -> (Not (Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) P s))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {P : R}, (Not (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) P (NonUnitalSubsemiring.closure.{u1} R _inst_1 s))) -> (Not (Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) P s))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.not_mem_of_not_mem_closure NonUnitalSubsemiring.not_mem_of_not_mem_closureₓ'. -/
theorem not_mem_of_not_mem_closure {s : Set R} {P : R} (hP : P ∉ closure s) : P ∉ s := fun h =>
  hP (subset_closure h)
#align non_unital_subsemiring.not_mem_of_not_mem_closure NonUnitalSubsemiring.not_mem_of_not_mem_closure

/- warning: non_unital_subsemiring.closure_le -> NonUnitalSubsemiring.closure_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {t : NonUnitalSubsemiring.{u1} R _inst_1}, Iff (LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toHasLe.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (NonUnitalSubsemiring.closure.{u1} R _inst_1 s) t) (HasSubset.Subset.{u1} (Set.{u1} R) (Set.hasSubset.{u1} R) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) t))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {t : NonUnitalSubsemiring.{u1} R _inst_1}, Iff (LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toLE.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u1} R _inst_1))))) (NonUnitalSubsemiring.closure.{u1} R _inst_1 s) t) (HasSubset.Subset.{u1} (Set.{u1} R) (Set.instHasSubsetSet.{u1} R) s (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) t))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.closure_le NonUnitalSubsemiring.closure_leₓ'. -/
/-- A non-unital subsemiring `S` includes `closure s` if and only if it includes `s`. -/
@[simp]
theorem closure_le {s : Set R} {t : NonUnitalSubsemiring R} : closure s ≤ t ↔ s ⊆ t :=
  ⟨Set.Subset.trans subset_closure, fun h => sInf_le h⟩
#align non_unital_subsemiring.closure_le NonUnitalSubsemiring.closure_le

/- warning: non_unital_subsemiring.closure_mono -> NonUnitalSubsemiring.closure_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {{s : Set.{u1} R}} {{t : Set.{u1} R}}, (HasSubset.Subset.{u1} (Set.{u1} R) (Set.hasSubset.{u1} R) s t) -> (LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toHasLe.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (NonUnitalSubsemiring.closure.{u1} R _inst_1 s) (NonUnitalSubsemiring.closure.{u1} R _inst_1 t))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {{s : Set.{u1} R}} {{t : Set.{u1} R}}, (HasSubset.Subset.{u1} (Set.{u1} R) (Set.instHasSubsetSet.{u1} R) s t) -> (LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toLE.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u1} R _inst_1))))) (NonUnitalSubsemiring.closure.{u1} R _inst_1 s) (NonUnitalSubsemiring.closure.{u1} R _inst_1 t))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.closure_mono NonUnitalSubsemiring.closure_monoₓ'. -/
/-- Subsemiring closure of a set is monotone in its argument: if `s ⊆ t`,
then `closure s ≤ closure t`. -/
theorem closure_mono ⦃s t : Set R⦄ (h : s ⊆ t) : closure s ≤ closure t :=
  closure_le.2 <| Set.Subset.trans h subset_closure
#align non_unital_subsemiring.closure_mono NonUnitalSubsemiring.closure_mono

/- warning: non_unital_subsemiring.closure_eq_of_le -> NonUnitalSubsemiring.closure_eq_of_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {t : NonUnitalSubsemiring.{u1} R _inst_1}, (HasSubset.Subset.{u1} (Set.{u1} R) (Set.hasSubset.{u1} R) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) t)) -> (LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toHasLe.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) t (NonUnitalSubsemiring.closure.{u1} R _inst_1 s)) -> (Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.closure.{u1} R _inst_1 s) t)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {t : NonUnitalSubsemiring.{u1} R _inst_1}, (HasSubset.Subset.{u1} (Set.{u1} R) (Set.instHasSubsetSet.{u1} R) s (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) t)) -> (LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toLE.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u1} R _inst_1))))) t (NonUnitalSubsemiring.closure.{u1} R _inst_1 s)) -> (Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.closure.{u1} R _inst_1 s) t)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.closure_eq_of_le NonUnitalSubsemiring.closure_eq_of_leₓ'. -/
theorem closure_eq_of_le {s : Set R} {t : NonUnitalSubsemiring R} (h₁ : s ⊆ t)
    (h₂ : t ≤ closure s) : closure s = t :=
  le_antisymm (closure_le.2 h₁) h₂
#align non_unital_subsemiring.closure_eq_of_le NonUnitalSubsemiring.closure_eq_of_le

/- warning: non_unital_subsemiring.mem_map_equiv -> NonUnitalSubsemiring.mem_map_equiv is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_map_equiv NonUnitalSubsemiring.mem_map_equivₓ'. -/
theorem mem_map_equiv {f : R ≃+* S} {K : NonUnitalSubsemiring R} {x : S} :
    x ∈ K.map (f : R →ₙ+* S) ↔ f.symm x ∈ K :=
  @Set.mem_image_equiv _ _ (↑K) f.toEquiv x
#align non_unital_subsemiring.mem_map_equiv NonUnitalSubsemiring.mem_map_equiv

/- warning: non_unital_subsemiring.map_equiv_eq_comap_symm -> NonUnitalSubsemiring.map_equiv_eq_comap_symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (K : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.map.{u1, u2, max u1 u2} R S _inst_1 _inst_2 (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u2} R S _inst_1 _inst_2) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S _inst_1 _inst_2 (RingEquivClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))))))) f) K) (NonUnitalSubsemiring.comap.{u2, u1, max u2 u1} S R _inst_2 _inst_1 (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (RingEquivClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) S R _inst_2 _inst_1 (RingEquiv.ringEquivClass.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))) (RingEquiv.symm.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) f) K)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (K : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.map.{u1, u2, max u1 u2} R S _inst_1 _inst_2 (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHomClass.toNonUnitalRingHom.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S _inst_1 _inst_2 (RingEquivClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S _inst_1 _inst_2 (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)))) f) K) (NonUnitalSubsemiring.comap.{u2, u1, max u1 u2} S R _inst_2 _inst_1 (RingEquiv.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (RingEquivClass.toNonUnitalRingHomClass.{max u1 u2, u2, u1} (RingEquiv.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) S R _inst_2 _inst_1 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))) (RingEquiv.symm.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) f) K)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.map_equiv_eq_comap_symm NonUnitalSubsemiring.map_equiv_eq_comap_symmₓ'. -/
theorem map_equiv_eq_comap_symm (f : R ≃+* S) (K : NonUnitalSubsemiring R) :
    K.map (f : R →ₙ+* S) = K.comap f.symm :=
  SetLike.coe_injective (f.toEquiv.image_eq_preimage K)
#align non_unital_subsemiring.map_equiv_eq_comap_symm NonUnitalSubsemiring.map_equiv_eq_comap_symm

/- warning: non_unital_subsemiring.comap_equiv_eq_map_symm -> NonUnitalSubsemiring.comap_equiv_eq_map_symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (K : NonUnitalSubsemiring.{u2} S _inst_2), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.comap.{u1, u2, max u1 u2} R S _inst_1 _inst_2 (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u2} R S _inst_1 _inst_2) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S _inst_1 _inst_2 (RingEquivClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S _inst_1 _inst_2 (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))))))) f) K) (NonUnitalSubsemiring.map.{u2, u1, max u2 u1} S R _inst_2 _inst_1 (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (RingEquivClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) S R _inst_2 _inst_1 (RingEquiv.ringEquivClass.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))) (RingEquiv.symm.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) f) K)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (f : RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (K : NonUnitalSubsemiring.{u2} S _inst_2), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.comap.{u1, u2, max u1 u2} R S _inst_1 _inst_2 (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHomClass.toNonUnitalRingHom.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S _inst_1 _inst_2 (RingEquivClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) R S _inst_1 _inst_2 (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)))) f) K) (NonUnitalSubsemiring.map.{u2, u1, max u1 u2} S R _inst_2 _inst_1 (RingEquiv.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (RingEquivClass.toNonUnitalRingHomClass.{max u1 u2, u2, u1} (RingEquiv.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) S R _inst_2 _inst_1 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))) (RingEquiv.symm.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) f) K)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.comap_equiv_eq_map_symm NonUnitalSubsemiring.comap_equiv_eq_map_symmₓ'. -/
theorem comap_equiv_eq_map_symm (f : R ≃+* S) (K : NonUnitalSubsemiring S) :
    K.comap (f : R →ₙ+* S) = K.map f.symm :=
  (map_equiv_eq_comap_symm f.symm K).symm
#align non_unital_subsemiring.comap_equiv_eq_map_symm NonUnitalSubsemiring.comap_equiv_eq_map_symm

end NonUnitalSubsemiring

namespace Subsemigroup

/- warning: subsemigroup.non_unital_subsemiring_closure -> Subsemigroup.nonUnitalSubsemiringClosure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) -> (NonUnitalSubsemiring.{u1} R _inst_1)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) -> (NonUnitalSubsemiring.{u1} R _inst_1)
Case conversion may be inaccurate. Consider using '#align subsemigroup.non_unital_subsemiring_closure Subsemigroup.nonUnitalSubsemiringClosureₓ'. -/
/-- The additive closure of a non-unital subsemigroup is a non-unital subsemiring. -/
def nonUnitalSubsemiringClosure (M : Subsemigroup R) : NonUnitalSubsemiring R :=
  { AddSubmonoid.closure (M : Set R) with mul_mem' := fun x y => MulMemClass.mul_mem_add_closure }
#align subsemigroup.non_unital_subsemiring_closure Subsemigroup.nonUnitalSubsemiringClosure

/- warning: subsemigroup.non_unital_subsemiring_closure_coe -> Subsemigroup.nonUnitalSubsemiringClosure_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (M : Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))), Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (Subsemigroup.nonUnitalSubsemiringClosure.{u1} R _inst_1 M)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))))))) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) R (Subsemigroup.setLike.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))))) M)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (M : Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)), Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (Subsemigroup.nonUnitalSubsemiringClosure.{u1} R _inst_1 M)) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (SetLike.coe.{u1, u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) R (Subsemigroup.instSetLikeSubsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) M)))
Case conversion may be inaccurate. Consider using '#align subsemigroup.non_unital_subsemiring_closure_coe Subsemigroup.nonUnitalSubsemiringClosure_coeₓ'. -/
theorem nonUnitalSubsemiringClosure_coe :
    (M.nonUnitalSubsemiringClosure : Set R) = AddSubmonoid.closure (M : Set R) :=
  rfl
#align subsemigroup.non_unital_subsemiring_closure_coe Subsemigroup.nonUnitalSubsemiringClosure_coe

/- warning: subsemigroup.non_unital_subsemiring_closure_to_add_submonoid -> Subsemigroup.nonUnitalSubsemiringClosure_toAddSubmonoid is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (M : Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))), Eq.{succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1 (Subsemigroup.nonUnitalSubsemiringClosure.{u1} R _inst_1 M)) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) R (Subsemigroup.setLike.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))))) M))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (M : Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)), Eq.{succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1 (Subsemigroup.nonUnitalSubsemiringClosure.{u1} R _inst_1 M)) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (SetLike.coe.{u1, u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) R (Subsemigroup.instSetLikeSubsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) M))
Case conversion may be inaccurate. Consider using '#align subsemigroup.non_unital_subsemiring_closure_to_add_submonoid Subsemigroup.nonUnitalSubsemiringClosure_toAddSubmonoidₓ'. -/
theorem nonUnitalSubsemiringClosure_toAddSubmonoid :
    M.nonUnitalSubsemiringClosure.toAddSubmonoid = AddSubmonoid.closure (M : Set R) :=
  rfl
#align subsemigroup.non_unital_subsemiring_closure_to_add_submonoid Subsemigroup.nonUnitalSubsemiringClosure_toAddSubmonoid

/- warning: subsemigroup.non_unital_subsemiring_closure_eq_closure -> Subsemigroup.nonUnitalSubsemiringClosure_eq_closure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (M : Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Subsemigroup.nonUnitalSubsemiringClosure.{u1} R _inst_1 M) (NonUnitalSubsemiring.closure.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) R (Subsemigroup.setLike.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))))) M))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (M : Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Subsemigroup.nonUnitalSubsemiringClosure.{u1} R _inst_1 M) (NonUnitalSubsemiring.closure.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) R (Subsemigroup.instSetLikeSubsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) M))
Case conversion may be inaccurate. Consider using '#align subsemigroup.non_unital_subsemiring_closure_eq_closure Subsemigroup.nonUnitalSubsemiringClosure_eq_closureₓ'. -/
/-- The `non_unital_subsemiring` generated by a multiplicative subsemigroup coincides with the
`non_unital_subsemiring.closure` of the subsemigroup itself . -/
theorem nonUnitalSubsemiringClosure_eq_closure :
    M.nonUnitalSubsemiringClosure = NonUnitalSubsemiring.closure (M : Set R) :=
  by
  ext
  refine'
        ⟨fun hx => _, fun hx =>
          (non_unital_subsemiring.mem_closure.mp hx) M.non_unital_subsemiring_closure fun s sM =>
            _⟩ <;>
      rintro - ⟨H1, rfl⟩ <;>
    rintro - ⟨H2, rfl⟩
  · exact add_submonoid.mem_closure.mp hx H1.to_add_submonoid H2
  · exact H2 sM
#align subsemigroup.non_unital_subsemiring_closure_eq_closure Subsemigroup.nonUnitalSubsemiringClosure_eq_closure

end Subsemigroup

namespace NonUnitalSubsemiring

#print NonUnitalSubsemiring.closure_subsemigroup_closure /-
@[simp]
theorem closure_subsemigroup_closure (s : Set R) : closure ↑(Subsemigroup.closure s) = closure s :=
  le_antisymm
    (closure_le.mpr fun y hy =>
      (Subsemigroup.mem_closure.mp hy) (closure s).toSubsemigroup subset_closure)
    (closure_mono Subsemigroup.subset_closure)
#align non_unital_subsemiring.closure_subsemigroup_closure NonUnitalSubsemiring.closure_subsemigroup_closure
-/

/- warning: non_unital_subsemiring.coe_closure_eq -> NonUnitalSubsemiring.coe_closure_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : Set.{u1} R), Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (NonUnitalSubsemiring.closure.{u1} R _inst_1 s)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))))))) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) R (Subsemigroup.setLike.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))))) (Subsemigroup.closure.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) s))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : Set.{u1} R), Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.closure.{u1} R _inst_1 s)) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (SetLike.coe.{u1, u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) R (Subsemigroup.instSetLikeSubsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (Subsemigroup.closure.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) s))))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_closure_eq NonUnitalSubsemiring.coe_closure_eqₓ'. -/
/-- The elements of the non-unital subsemiring closure of `M` are exactly the elements of the
additive closure of a multiplicative subsemigroup `M`. -/
theorem coe_closure_eq (s : Set R) :
    (closure s : Set R) = AddSubmonoid.closure (Subsemigroup.closure s : Set R) := by
  simp [← Subsemigroup.nonUnitalSubsemiringClosure_toAddSubmonoid,
    Subsemigroup.nonUnitalSubsemiringClosure_eq_closure]
#align non_unital_subsemiring.coe_closure_eq NonUnitalSubsemiring.coe_closure_eq

/- warning: non_unital_subsemiring.mem_closure_iff -> NonUnitalSubsemiring.mem_closure_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {x : R}, Iff (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x (NonUnitalSubsemiring.closure.{u1} R _inst_1 s)) (Membership.Mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (SetLike.hasMem.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.setLike.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))))) x (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Subsemigroup.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) R (Subsemigroup.setLike.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))))) (Subsemigroup.closure.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) s))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {x : R}, Iff (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x (NonUnitalSubsemiring.closure.{u1} R _inst_1 s)) (Membership.mem.{u1, u1} R (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (SetLike.instMembership.{u1, u1} (AddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) R (AddSubmonoid.instSetLikeAddSubmonoid.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))))) x (AddSubmonoid.closure.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (SetLike.coe.{u1, u1} (Subsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) R (Subsemigroup.instSetLikeSubsemigroup.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (Subsemigroup.closure.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) s))))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_closure_iff NonUnitalSubsemiring.mem_closure_iffₓ'. -/
theorem mem_closure_iff {s : Set R} {x} :
    x ∈ closure s ↔ x ∈ AddSubmonoid.closure (Subsemigroup.closure s : Set R) :=
  Set.ext_iff.mp (coe_closure_eq s) x
#align non_unital_subsemiring.mem_closure_iff NonUnitalSubsemiring.mem_closure_iff

#print NonUnitalSubsemiring.closure_addSubmonoid_closure /-
@[simp]
theorem closure_addSubmonoid_closure {s : Set R} : closure ↑(AddSubmonoid.closure s) = closure s :=
  by
  ext x
  refine' ⟨fun hx => _, fun hx => closure_mono AddSubmonoid.subset_closure hx⟩
  rintro - ⟨H, rfl⟩
  rintro - ⟨J, rfl⟩
  refine' (add_submonoid.mem_closure.mp (mem_closure_iff.mp hx)) H.to_add_submonoid fun y hy => _
  refine' (subsemigroup.mem_closure.mp hy) H.to_subsemigroup fun z hz => _
  exact (add_submonoid.mem_closure.mp hz) H.to_add_submonoid fun w hw => J hw
#align non_unital_subsemiring.closure_add_submonoid_closure NonUnitalSubsemiring.closure_addSubmonoid_closure
-/

/- warning: non_unital_subsemiring.closure_induction -> NonUnitalSubsemiring.closure_induction is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {p : R -> Prop} {x : R}, (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x (NonUnitalSubsemiring.closure.{u1} R _inst_1 s)) -> (forall (x : R), (Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) x s) -> (p x)) -> (p (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1)))))) -> (forall (x : R) (y : R), (p x) -> (p y) -> (p (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) x y))) -> (forall (x : R) (y : R), (p x) -> (p y) -> (p (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) x y))) -> (p x)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {p : R -> Prop} {x : R}, (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x (NonUnitalSubsemiring.closure.{u1} R _inst_1 s)) -> (forall (x : R), (Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x s) -> (p x)) -> (p (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MulZeroClass.toZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1))))) -> (forall (x : R) (y : R), (p x) -> (p y) -> (p (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) x y))) -> (forall (x : R) (y : R), (p x) -> (p y) -> (p (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) x y))) -> (p x)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.closure_induction NonUnitalSubsemiring.closure_inductionₓ'. -/
/-- An induction principle for closure membership. If `p` holds for `0`, `1`, and all elements
of `s`, and is preserved under addition and multiplication, then `p` holds for all elements
of the closure of `s`. -/
@[elab_as_elim]
theorem closure_induction {s : Set R} {p : R → Prop} {x} (h : x ∈ closure s) (Hs : ∀ x ∈ s, p x)
    (H0 : p 0) (Hadd : ∀ x y, p x → p y → p (x + y)) (Hmul : ∀ x y, p x → p y → p (x * y)) : p x :=
  (@closure_le _ _ _ ⟨p, Hadd, H0, Hmul⟩).2 Hs h
#align non_unital_subsemiring.closure_induction NonUnitalSubsemiring.closure_induction

/- warning: non_unital_subsemiring.closure_induction₂ -> NonUnitalSubsemiring.closure_induction₂ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {p : R -> R -> Prop} {x : R} {y : R}, (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x (NonUnitalSubsemiring.closure.{u1} R _inst_1 s)) -> (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) y (NonUnitalSubsemiring.closure.{u1} R _inst_1 s)) -> (forall (x : R), (Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) x s) -> (forall (y : R), (Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) y s) -> (p x y))) -> (forall (x : R), p (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1))))) x) -> (forall (x : R), p x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1)))))) -> (forall (x₁ : R) (x₂ : R) (y : R), (p x₁ y) -> (p x₂ y) -> (p (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) x₁ x₂) y)) -> (forall (x : R) (y₁ : R) (y₂ : R), (p x y₁) -> (p x y₂) -> (p x (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) y₁ y₂))) -> (forall (x₁ : R) (x₂ : R) (y : R), (p x₁ y) -> (p x₂ y) -> (p (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) x₁ x₂) y)) -> (forall (x : R) (y₁ : R) (y₂ : R), (p x y₁) -> (p x y₂) -> (p x (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) y₁ y₂))) -> (p x y)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : Set.{u1} R} {p : R -> R -> Prop} {x : R} {y : R}, (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x (NonUnitalSubsemiring.closure.{u1} R _inst_1 s)) -> (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) y (NonUnitalSubsemiring.closure.{u1} R _inst_1 s)) -> (forall (x : R), (Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x s) -> (forall (y : R), (Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) y s) -> (p x y))) -> (forall (x : R), p (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MulZeroClass.toZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1)))) x) -> (forall (x : R), p x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MulZeroClass.toZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R _inst_1))))) -> (forall (x₁ : R) (x₂ : R) (y : R), (p x₁ y) -> (p x₂ y) -> (p (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) x₁ x₂) y)) -> (forall (x : R) (y₁ : R) (y₂ : R), (p x y₁) -> (p x y₂) -> (p x (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) y₁ y₂))) -> (forall (x₁ : R) (x₂ : R) (y : R), (p x₁ y) -> (p x₂ y) -> (p (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) x₁ x₂) y)) -> (forall (x : R) (y₁ : R) (y₂ : R), (p x y₁) -> (p x y₂) -> (p x (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) y₁ y₂))) -> (p x y)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.closure_induction₂ NonUnitalSubsemiring.closure_induction₂ₓ'. -/
/-- An induction principle for closure membership for predicates with two arguments. -/
@[elab_as_elim]
theorem closure_induction₂ {s : Set R} {p : R → R → Prop} {x} {y : R} (hx : x ∈ closure s)
    (hy : y ∈ closure s) (Hs : ∀ x ∈ s, ∀ y ∈ s, p x y) (H0_left : ∀ x, p 0 x)
    (H0_right : ∀ x, p x 0) (Hadd_left : ∀ x₁ x₂ y, p x₁ y → p x₂ y → p (x₁ + x₂) y)
    (Hadd_right : ∀ x y₁ y₂, p x y₁ → p x y₂ → p x (y₁ + y₂))
    (Hmul_left : ∀ x₁ x₂ y, p x₁ y → p x₂ y → p (x₁ * x₂) y)
    (Hmul_right : ∀ x y₁ y₂, p x y₁ → p x y₂ → p x (y₁ * y₂)) : p x y :=
  closure_induction hx
    (fun x₁ x₁s => closure_induction hy (Hs x₁ x₁s) (H0_right x₁) (Hadd_right x₁) (Hmul_right x₁))
    (H0_left y) (fun z z' => Hadd_left z z' y) fun z z' => Hmul_left z z' y
#align non_unital_subsemiring.closure_induction₂ NonUnitalSubsemiring.closure_induction₂

variable (R)

/- warning: non_unital_subsemiring.gi -> NonUnitalSubsemiring.gi is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], GaloisInsertion.{u1, u1} (Set.{u1} R) (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (Set.{u1} R) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} R) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} R) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} R) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} R) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} R) (Set.completeBooleanAlgebra.{u1} R))))))) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1))) (NonUnitalSubsemiring.closure.{u1} R _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], GaloisInsertion.{u1, u1} (Set.{u1} R) (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (Set.{u1} R) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} R) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} R) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} R) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} R) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} R) (Set.instCompleteBooleanAlgebraSet.{u1} R))))))) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u1} R _inst_1)))) (NonUnitalSubsemiring.closure.{u1} R _inst_1) (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.gi NonUnitalSubsemiring.giₓ'. -/
/-- `closure` forms a Galois insertion with the coercion to set. -/
protected def gi : GaloisInsertion (@closure R _) coe
    where
  choice s _ := closure s
  gc s t := closure_le
  le_l_u s := subset_closure
  choice_eq s h := rfl
#align non_unital_subsemiring.gi NonUnitalSubsemiring.gi

variable {R} {F : Type _} [NonUnitalRingHomClass F R S]

#print NonUnitalSubsemiring.closure_eq /-
/-- Closure of a non-unital subsemiring `S` equals `S`. -/
theorem closure_eq (s : NonUnitalSubsemiring R) : closure (s : Set R) = s :=
  (NonUnitalSubsemiring.gi R).l_u_eq s
#align non_unital_subsemiring.closure_eq NonUnitalSubsemiring.closure_eq
-/

/- warning: non_unital_subsemiring.closure_empty -> NonUnitalSubsemiring.closure_empty is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.closure.{u1} R _inst_1 (EmptyCollection.emptyCollection.{u1} (Set.{u1} R) (Set.hasEmptyc.{u1} R))) (Bot.bot.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasBot.{u1} R _inst_1))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.closure.{u1} R _inst_1 (EmptyCollection.emptyCollection.{u1} (Set.{u1} R) (Set.instEmptyCollectionSet.{u1} R))) (Bot.bot.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instBotNonUnitalSubsemiring.{u1} R _inst_1))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.closure_empty NonUnitalSubsemiring.closure_emptyₓ'. -/
@[simp]
theorem closure_empty : closure (∅ : Set R) = ⊥ :=
  (NonUnitalSubsemiring.gi R).gc.l_bot
#align non_unital_subsemiring.closure_empty NonUnitalSubsemiring.closure_empty

/- warning: non_unital_subsemiring.closure_univ -> NonUnitalSubsemiring.closure_univ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.closure.{u1} R _inst_1 (Set.univ.{u1} R)) (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasTop.{u1} R _inst_1))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.closure.{u1} R _inst_1 (Set.univ.{u1} R)) (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u1} R _inst_1))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.closure_univ NonUnitalSubsemiring.closure_univₓ'. -/
@[simp]
theorem closure_univ : closure (Set.univ : Set R) = ⊤ :=
  @coe_top R _ ▸ closure_eq ⊤
#align non_unital_subsemiring.closure_univ NonUnitalSubsemiring.closure_univ

#print NonUnitalSubsemiring.closure_union /-
theorem closure_union (s t : Set R) : closure (s ∪ t) = closure s ⊔ closure t :=
  (NonUnitalSubsemiring.gi R).gc.l_sup
#align non_unital_subsemiring.closure_union NonUnitalSubsemiring.closure_union
-/

/- warning: non_unital_subsemiring.closure_Union -> NonUnitalSubsemiring.closure_iUnion is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {ι : Sort.{u2}} (s : ι -> (Set.{u1} R)), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.closure.{u1} R _inst_1 (Set.iUnion.{u1, u2} R ι (fun (i : ι) => s i))) (iSup.{u1, u2} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.completeLattice.{u1} R _inst_1))) ι (fun (i : ι) => NonUnitalSubsemiring.closure.{u1} R _inst_1 (s i)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] {ι : Sort.{u1}} (s : ι -> (Set.{u2} R)), Eq.{succ u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.closure.{u2} R _inst_1 (Set.iUnion.{u2, u1} R ι (fun (i : ι) => s i))) (iSup.{u2, u1} (NonUnitalSubsemiring.{u2} R _inst_1) (CompleteLattice.toSupSet.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u2} R _inst_1)) ι (fun (i : ι) => NonUnitalSubsemiring.closure.{u2} R _inst_1 (s i)))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.closure_Union NonUnitalSubsemiring.closure_iUnionₓ'. -/
theorem closure_iUnion {ι} (s : ι → Set R) : closure (⋃ i, s i) = ⨆ i, closure (s i) :=
  (NonUnitalSubsemiring.gi R).gc.l_iSup
#align non_unital_subsemiring.closure_Union NonUnitalSubsemiring.closure_iUnion

/- warning: non_unital_subsemiring.closure_sUnion -> NonUnitalSubsemiring.closure_sUnion is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : Set.{u1} (Set.{u1} R)), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.closure.{u1} R _inst_1 (Set.sUnion.{u1} R s)) (iSup.{u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.completeLattice.{u1} R _inst_1))) (Set.{u1} R) (fun (t : Set.{u1} R) => iSup.{u1, 0} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.completeLattice.{u1} R _inst_1))) (Membership.Mem.{u1, u1} (Set.{u1} R) (Set.{u1} (Set.{u1} R)) (Set.hasMem.{u1} (Set.{u1} R)) t s) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} R) (Set.{u1} (Set.{u1} R)) (Set.hasMem.{u1} (Set.{u1} R)) t s) => NonUnitalSubsemiring.closure.{u1} R _inst_1 t)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : Set.{u1} (Set.{u1} R)), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.closure.{u1} R _inst_1 (Set.sUnion.{u1} R s)) (iSup.{u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toSupSet.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u1} R _inst_1)) (Set.{u1} R) (fun (t : Set.{u1} R) => iSup.{u1, 0} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toSupSet.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u1} R _inst_1)) (Membership.mem.{u1, u1} (Set.{u1} R) (Set.{u1} (Set.{u1} R)) (Set.instMembershipSet.{u1} (Set.{u1} R)) t s) (fun (H : Membership.mem.{u1, u1} (Set.{u1} R) (Set.{u1} (Set.{u1} R)) (Set.instMembershipSet.{u1} (Set.{u1} R)) t s) => NonUnitalSubsemiring.closure.{u1} R _inst_1 t)))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.closure_sUnion NonUnitalSubsemiring.closure_sUnionₓ'. -/
theorem closure_sUnion (s : Set (Set R)) : closure (⋃₀ s) = ⨆ t ∈ s, closure t :=
  (NonUnitalSubsemiring.gi R).gc.l_sSup
#align non_unital_subsemiring.closure_sUnion NonUnitalSubsemiring.closure_sUnion

/- warning: non_unital_subsemiring.map_sup -> NonUnitalSubsemiring.map_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (s : NonUnitalSubsemiring.{u1} R _inst_1) (t : NonUnitalSubsemiring.{u1} R _inst_1) (f : F), Eq.{succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f (Sup.sup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SemilatticeSup.toHasSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Lattice.toSemilatticeSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toLattice.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.completeLattice.{u1} R _inst_1)))) s t)) (Sup.sup.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (SemilatticeSup.toHasSup.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (Lattice.toSemilatticeSup.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (CompleteLattice.toLattice.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.completeLattice.{u2} S _inst_2)))) (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f s) (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f t))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (s : NonUnitalSubsemiring.{u2} R _inst_1) (t : NonUnitalSubsemiring.{u2} R _inst_1) (f : F), Eq.{succ u3} (NonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalSubsemiring.map.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f (Sup.sup.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (SemilatticeSup.toSup.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (Lattice.toSemilatticeSup.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (CompleteLattice.toLattice.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u2} R _inst_1)))) s t)) (Sup.sup.{u3} (NonUnitalSubsemiring.{u3} S _inst_2) (SemilatticeSup.toSup.{u3} (NonUnitalSubsemiring.{u3} S _inst_2) (Lattice.toSemilatticeSup.{u3} (NonUnitalSubsemiring.{u3} S _inst_2) (CompleteLattice.toLattice.{u3} (NonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u3} S _inst_2)))) (NonUnitalSubsemiring.map.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f s) (NonUnitalSubsemiring.map.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f t))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.map_sup NonUnitalSubsemiring.map_supₓ'. -/
theorem map_sup (s t : NonUnitalSubsemiring R) (f : F) :
    (map f (s ⊔ t) : NonUnitalSubsemiring S) = map f s ⊔ map f t :=
  @GaloisConnection.l_sup _ _ s t _ _ _ _ (gc_map_comap f)
#align non_unital_subsemiring.map_sup NonUnitalSubsemiring.map_sup

/- warning: non_unital_subsemiring.map_supr -> NonUnitalSubsemiring.map_iSup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] {ι : Sort.{u4}} (f : F) (s : ι -> (NonUnitalSubsemiring.{u1} R _inst_1)), Eq.{succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f (iSup.{u1, u4} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.completeLattice.{u1} R _inst_1))) ι s)) (iSup.{u2, u4} (NonUnitalSubsemiring.{u2} S _inst_2) (CompleteSemilatticeSup.toHasSup.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (CompleteLattice.toCompleteSemilatticeSup.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.completeLattice.{u2} S _inst_2))) ι (fun (i : ι) => NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f (s i)))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u4}} [_inst_1 : NonUnitalNonAssocSemiring.{u3} R] [_inst_2 : NonUnitalNonAssocSemiring.{u4} S] {F : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u1, u3, u4} F R S _inst_1 _inst_2] {ι : Sort.{u2}} (f : F) (s : ι -> (NonUnitalSubsemiring.{u3} R _inst_1)), Eq.{succ u4} (NonUnitalSubsemiring.{u4} S _inst_2) (NonUnitalSubsemiring.map.{u3, u4, u1} R S _inst_1 _inst_2 F _inst_4 f (iSup.{u3, u2} (NonUnitalSubsemiring.{u3} R _inst_1) (CompleteLattice.toSupSet.{u3} (NonUnitalSubsemiring.{u3} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u3} R _inst_1)) ι s)) (iSup.{u4, u2} (NonUnitalSubsemiring.{u4} S _inst_2) (CompleteLattice.toSupSet.{u4} (NonUnitalSubsemiring.{u4} S _inst_2) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u4} S _inst_2)) ι (fun (i : ι) => NonUnitalSubsemiring.map.{u3, u4, u1} R S _inst_1 _inst_2 F _inst_4 f (s i)))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.map_supr NonUnitalSubsemiring.map_iSupₓ'. -/
theorem map_iSup {ι : Sort _} (f : F) (s : ι → NonUnitalSubsemiring R) :
    (map f (iSup s) : NonUnitalSubsemiring S) = ⨆ i, map f (s i) :=
  @GaloisConnection.l_iSup _ _ _ _ _ _ _ (gc_map_comap f) s
#align non_unital_subsemiring.map_supr NonUnitalSubsemiring.map_iSup

/- warning: non_unital_subsemiring.comap_inf -> NonUnitalSubsemiring.comap_inf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (s : NonUnitalSubsemiring.{u2} S _inst_2) (t : NonUnitalSubsemiring.{u2} S _inst_2) (f : F), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.comap.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f (Inf.inf.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.hasInf.{u2} S _inst_2) s t)) (Inf.inf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasInf.{u1} R _inst_1) (NonUnitalSubsemiring.comap.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f s) (NonUnitalSubsemiring.comap.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f t))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (s : NonUnitalSubsemiring.{u3} S _inst_2) (t : NonUnitalSubsemiring.{u3} S _inst_2) (f : F), Eq.{succ u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.comap.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f (Inf.inf.{u3} (NonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalSubsemiring.instInfNonUnitalSubsemiring.{u3} S _inst_2) s t)) (Inf.inf.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.instInfNonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.comap.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f s) (NonUnitalSubsemiring.comap.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f t))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.comap_inf NonUnitalSubsemiring.comap_infₓ'. -/
theorem comap_inf (s t : NonUnitalSubsemiring S) (f : F) :
    (comap f (s ⊓ t) : NonUnitalSubsemiring R) = comap f s ⊓ comap f t :=
  @GaloisConnection.u_inf _ _ s t _ _ _ _ (gc_map_comap f)
#align non_unital_subsemiring.comap_inf NonUnitalSubsemiring.comap_inf

/- warning: non_unital_subsemiring.comap_infi -> NonUnitalSubsemiring.comap_iInf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] {ι : Sort.{u4}} (f : F) (s : ι -> (NonUnitalSubsemiring.{u2} S _inst_2)), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.comap.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f (iInf.{u2, u4} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.hasInf.{u2} S _inst_2) ι s)) (iInf.{u1, u4} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasInf.{u1} R _inst_1) ι (fun (i : ι) => NonUnitalSubsemiring.comap.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f (s i)))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u4}} [_inst_1 : NonUnitalNonAssocSemiring.{u3} R] [_inst_2 : NonUnitalNonAssocSemiring.{u4} S] {F : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u1, u3, u4} F R S _inst_1 _inst_2] {ι : Sort.{u2}} (f : F) (s : ι -> (NonUnitalSubsemiring.{u4} S _inst_2)), Eq.{succ u3} (NonUnitalSubsemiring.{u3} R _inst_1) (NonUnitalSubsemiring.comap.{u3, u4, u1} R S _inst_1 _inst_2 F _inst_4 f (iInf.{u4, u2} (NonUnitalSubsemiring.{u4} S _inst_2) (NonUnitalSubsemiring.instInfSetNonUnitalSubsemiring.{u4} S _inst_2) ι s)) (iInf.{u3, u2} (NonUnitalSubsemiring.{u3} R _inst_1) (NonUnitalSubsemiring.instInfSetNonUnitalSubsemiring.{u3} R _inst_1) ι (fun (i : ι) => NonUnitalSubsemiring.comap.{u3, u4, u1} R S _inst_1 _inst_2 F _inst_4 f (s i)))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.comap_infi NonUnitalSubsemiring.comap_iInfₓ'. -/
theorem comap_iInf {ι : Sort _} (f : F) (s : ι → NonUnitalSubsemiring S) :
    (comap f (iInf s) : NonUnitalSubsemiring R) = ⨅ i, comap f (s i) :=
  @GaloisConnection.u_iInf _ _ _ _ _ _ _ (gc_map_comap f) s
#align non_unital_subsemiring.comap_infi NonUnitalSubsemiring.comap_iInf

/- warning: non_unital_subsemiring.map_bot -> NonUnitalSubsemiring.map_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F), Eq.{succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f (Bot.bot.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasBot.{u1} R _inst_1))) (Bot.bot.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.hasBot.{u2} S _inst_2))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (f : F), Eq.{succ u3} (NonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalSubsemiring.map.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f (Bot.bot.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.instBotNonUnitalSubsemiring.{u2} R _inst_1))) (Bot.bot.{u3} (NonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalSubsemiring.instBotNonUnitalSubsemiring.{u3} S _inst_2))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.map_bot NonUnitalSubsemiring.map_botₓ'. -/
@[simp]
theorem map_bot (f : F) : map f (⊥ : NonUnitalSubsemiring R) = (⊥ : NonUnitalSubsemiring S) :=
  (gc_map_comap f).l_bot
#align non_unital_subsemiring.map_bot NonUnitalSubsemiring.map_bot

/- warning: non_unital_subsemiring.comap_top -> NonUnitalSubsemiring.comap_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.comap.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f (Top.top.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.hasTop.{u2} S _inst_2))) (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasTop.{u1} R _inst_1))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_4 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (f : F), Eq.{succ u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.comap.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_4 f (Top.top.{u3} (NonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u3} S _inst_2))) (Top.top.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u2} R _inst_1))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.comap_top NonUnitalSubsemiring.comap_topₓ'. -/
@[simp]
theorem comap_top (f : F) : comap f (⊤ : NonUnitalSubsemiring S) = (⊤ : NonUnitalSubsemiring R) :=
  (gc_map_comap f).u_top
#align non_unital_subsemiring.comap_top NonUnitalSubsemiring.comap_top

/- warning: non_unital_subsemiring.prod -> NonUnitalSubsemiring.prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], (NonUnitalSubsemiring.{u1} R _inst_1) -> (NonUnitalSubsemiring.{u2} S _inst_2) -> (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], (NonUnitalSubsemiring.{u1} R _inst_1) -> (NonUnitalSubsemiring.{u2} S _inst_2) -> (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.prod NonUnitalSubsemiring.prodₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- Given `non_unital_subsemiring`s `s`, `t` of semirings `R`, `S` respectively, `s.prod t` is
`s × t` as a non-unital subsemiring of `R × S`. -/
def prod (s : NonUnitalSubsemiring R) (t : NonUnitalSubsemiring S) : NonUnitalSubsemiring (R × S) :=
  { s.toSubsemigroup.Prod t.toSubsemigroup, s.toAddSubmonoid.Prod t.toAddSubmonoid with
    carrier := (s : Set R) ×ˢ (t : Set S) }
#align non_unital_subsemiring.prod NonUnitalSubsemiring.prod

/- warning: non_unital_subsemiring.coe_prod -> NonUnitalSubsemiring.coe_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (s : NonUnitalSubsemiring.{u1} R _inst_1) (t : NonUnitalSubsemiring.{u2} S _inst_2), Eq.{succ (max u1 u2)} (Set.{max u1 u2} (Prod.{u1, u2} R S)) ((fun (a : Type.{max u1 u2}) (b : Type.{max u1 u2}) [self : HasLiftT.{succ (max u1 u2), succ (max u1 u2)} a b] => self.0) (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (Set.{max u1 u2} (Prod.{u1, u2} R S)) (HasLiftT.mk.{succ (max u1 u2), succ (max u1 u2)} (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (Set.{max u1 u2} (Prod.{u1, u2} R S)) (CoeTCₓ.coe.{succ (max u1 u2), succ (max u1 u2)} (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (Set.{max u1 u2} (Prod.{u1, u2} R S)) (SetLike.Set.hasCoeT.{max u1 u2, max u1 u2} (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (Prod.{u1, u2} R S) (NonUnitalSubsemiring.setLike.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2))))) (NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 s t)) (Set.prod.{u1, u2} R S ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) s) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (NonUnitalSubsemiring.{u2} S _inst_2) (Set.{u2} S) (HasLiftT.mk.{succ u2, succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (Set.{u2} S) (CoeTCₓ.coe.{succ u2, succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (Set.{u2} S) (SetLike.Set.hasCoeT.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)))) t))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (s : NonUnitalSubsemiring.{u1} R _inst_1) (t : NonUnitalSubsemiring.{u2} S _inst_2), Eq.{max (succ u1) (succ u2)} (Set.{max u1 u2} (Prod.{u1, u2} R S)) (SetLike.coe.{max u1 u2, max u1 u2} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (Prod.{u1, u2} R S) (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 s t)) (Set.prod.{u1, u2} R S (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s) (SetLike.coe.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2) t))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_prod NonUnitalSubsemiring.coe_prodₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
@[norm_cast]
theorem coe_prod (s : NonUnitalSubsemiring R) (t : NonUnitalSubsemiring S) :
    (s.Prod t : Set (R × S)) = (s : Set R) ×ˢ (t : Set S) :=
  rfl
#align non_unital_subsemiring.coe_prod NonUnitalSubsemiring.coe_prod

/- warning: non_unital_subsemiring.mem_prod -> NonUnitalSubsemiring.mem_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {s : NonUnitalSubsemiring.{u1} R _inst_1} {t : NonUnitalSubsemiring.{u2} S _inst_2} {p : Prod.{u1, u2} R S}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} R S) (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (SetLike.hasMem.{max u1 u2, max u1 u2} (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (Prod.{u1, u2} R S) (NonUnitalSubsemiring.setLike.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2))) p (NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 s t)) (And (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) (Prod.fst.{u1, u2} R S p) s) (Membership.Mem.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.hasMem.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) (Prod.snd.{u1, u2} R S p) t))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {s : NonUnitalSubsemiring.{u1} R _inst_1} {t : NonUnitalSubsemiring.{u2} S _inst_2} {p : Prod.{u1, u2} R S}, Iff (Membership.mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} R S) (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (SetLike.instMembership.{max u1 u2, max u1 u2} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (Prod.{u1, u2} R S) (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2))) p (NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 s t)) (And (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) (Prod.fst.{u1, u2} R S p) s) (Membership.mem.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.instMembership.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2)) (Prod.snd.{u1, u2} R S p) t))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_prod NonUnitalSubsemiring.mem_prodₓ'. -/
theorem mem_prod {s : NonUnitalSubsemiring R} {t : NonUnitalSubsemiring S} {p : R × S} :
    p ∈ s.Prod t ↔ p.1 ∈ s ∧ p.2 ∈ t :=
  Iff.rfl
#align non_unital_subsemiring.mem_prod NonUnitalSubsemiring.mem_prod

/- warning: non_unital_subsemiring.prod_mono -> NonUnitalSubsemiring.prod_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {{s₁ : NonUnitalSubsemiring.{u1} R _inst_1}} {{s₂ : NonUnitalSubsemiring.{u1} R _inst_1}}, (LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toHasLe.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) s₁ s₂) -> (forall {{t₁ : NonUnitalSubsemiring.{u2} S _inst_2}} {{t₂ : NonUnitalSubsemiring.{u2} S _inst_2}}, (LE.le.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (Preorder.toHasLe.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (PartialOrder.toPreorder.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.partialOrder.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)))) t₁ t₂) -> (LE.le.{max u1 u2} (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (Preorder.toHasLe.{max u1 u2} (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (PartialOrder.toPreorder.{max u1 u2} (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (Prod.{u1, u2} R S) (NonUnitalSubsemiring.setLike.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2))))) (NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 s₁ t₁) (NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 s₂ t₂)))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {{s₁ : NonUnitalSubsemiring.{u1} R _inst_1}} {{s₂ : NonUnitalSubsemiring.{u1} R _inst_1}}, (LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toLE.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u1} R _inst_1))))) s₁ s₂) -> (forall {{t₁ : NonUnitalSubsemiring.{u2} S _inst_2}} {{t₂ : NonUnitalSubsemiring.{u2} S _inst_2}}, (LE.le.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (Preorder.toLE.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (PartialOrder.toPreorder.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u2} S _inst_2))))) t₁ t₂) -> (LE.le.{max u1 u2} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (Preorder.toLE.{max u1 u2} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (PartialOrder.toPreorder.{max u1 u2} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{max u1 u2} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{max u1 u2} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)))))) (NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 s₁ t₁) (NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 s₂ t₂)))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.prod_mono NonUnitalSubsemiring.prod_monoₓ'. -/
@[mono]
theorem prod_mono ⦃s₁ s₂ : NonUnitalSubsemiring R⦄ (hs : s₁ ≤ s₂) ⦃t₁ t₂ : NonUnitalSubsemiring S⦄
    (ht : t₁ ≤ t₂) : s₁.Prod t₁ ≤ s₂.Prod t₂ :=
  Set.prod_mono hs ht
#align non_unital_subsemiring.prod_mono NonUnitalSubsemiring.prod_mono

/- warning: non_unital_subsemiring.prod_mono_right -> NonUnitalSubsemiring.prod_mono_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (s : NonUnitalSubsemiring.{u1} R _inst_1), Monotone.{u2, max u1 u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (PartialOrder.toPreorder.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.partialOrder.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2))) (PartialOrder.toPreorder.{max u1 u2} (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (Prod.{u1, u2} R S) (NonUnitalSubsemiring.setLike.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)))) (fun (t : NonUnitalSubsemiring.{u2} S _inst_2) => NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 s t)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (s : NonUnitalSubsemiring.{u1} R _inst_1), Monotone.{u2, max u1 u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (PartialOrder.toPreorder.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u2} S _inst_2)))) (PartialOrder.toPreorder.{max u1 u2} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{max u1 u2} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{max u1 u2} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2))))) (fun (t : NonUnitalSubsemiring.{u2} S _inst_2) => NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 s t)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.prod_mono_right NonUnitalSubsemiring.prod_mono_rightₓ'. -/
theorem prod_mono_right (s : NonUnitalSubsemiring R) :
    Monotone fun t : NonUnitalSubsemiring S => s.Prod t :=
  prod_mono (le_refl s)
#align non_unital_subsemiring.prod_mono_right NonUnitalSubsemiring.prod_mono_right

/- warning: non_unital_subsemiring.prod_mono_left -> NonUnitalSubsemiring.prod_mono_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (t : NonUnitalSubsemiring.{u2} S _inst_2), Monotone.{u1, max u1 u2} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1))) (PartialOrder.toPreorder.{max u1 u2} (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (Prod.{u1, u2} R S) (NonUnitalSubsemiring.setLike.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)))) (fun (s : NonUnitalSubsemiring.{u1} R _inst_1) => NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 s t)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (t : NonUnitalSubsemiring.{u2} S _inst_2), Monotone.{u1, max u1 u2} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u1} R _inst_1)))) (PartialOrder.toPreorder.{max u1 u2} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{max u1 u2} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{max u1 u2} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2))))) (fun (s : NonUnitalSubsemiring.{u1} R _inst_1) => NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 s t)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.prod_mono_left NonUnitalSubsemiring.prod_mono_leftₓ'. -/
theorem prod_mono_left (t : NonUnitalSubsemiring S) :
    Monotone fun s : NonUnitalSubsemiring R => s.Prod t := fun s₁ s₂ hs => prod_mono hs (le_refl t)
#align non_unital_subsemiring.prod_mono_left NonUnitalSubsemiring.prod_mono_left

/- warning: non_unital_subsemiring.prod_top -> NonUnitalSubsemiring.prod_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (s : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{succ (max u1 u2)} (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 s (Top.top.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.hasTop.{u2} S _inst_2))) (NonUnitalSubsemiring.comap.{max u1 u2, u1, max u1 u2} (Prod.{u1, u2} R S) R (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_1 (NonUnitalRingHom.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_1) (NonUnitalRingHom.nonUnitalRingHomClass.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_1) (NonUnitalRingHom.fst.{u1, u2} R S _inst_1 _inst_2) s)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (s : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{max (succ u1) (succ u2)} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 s (Top.top.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u2} S _inst_2))) (NonUnitalSubsemiring.comap.{max u1 u2, u1, max u1 u2} (Prod.{u1, u2} R S) R (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2) _inst_1 (NonUnitalRingHom.{max u2 u1, u1} (Prod.{u1, u2} R S) R (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2) _inst_1) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2) _inst_1) (NonUnitalRingHom.fst.{u1, u2} R S _inst_1 _inst_2) s)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.prod_top NonUnitalSubsemiring.prod_topₓ'. -/
theorem prod_top (s : NonUnitalSubsemiring R) :
    s.Prod (⊤ : NonUnitalSubsemiring S) = s.comap (NonUnitalRingHom.fst R S) :=
  ext fun x => by simp [mem_prod, MonoidHom.coe_fst]
#align non_unital_subsemiring.prod_top NonUnitalSubsemiring.prod_top

/- warning: non_unital_subsemiring.top_prod -> NonUnitalSubsemiring.top_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (s : NonUnitalSubsemiring.{u2} S _inst_2), Eq.{succ (max u1 u2)} (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasTop.{u1} R _inst_1)) s) (NonUnitalSubsemiring.comap.{max u1 u2, u2, max u1 u2} (Prod.{u1, u2} R S) S (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_2 (NonUnitalRingHom.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_2) (NonUnitalRingHom.nonUnitalRingHomClass.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_2) (NonUnitalRingHom.snd.{u1, u2} R S _inst_1 _inst_2) s)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (s : NonUnitalSubsemiring.{u2} S _inst_2), Eq.{max (succ u1) (succ u2)} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u1} R _inst_1)) s) (NonUnitalSubsemiring.comap.{max u1 u2, u2, max u1 u2} (Prod.{u1, u2} R S) S (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2) _inst_2 (NonUnitalRingHom.{max u2 u1, u2} (Prod.{u1, u2} R S) S (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2) _inst_2) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2) _inst_2) (NonUnitalRingHom.snd.{u1, u2} R S _inst_1 _inst_2) s)
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.top_prod NonUnitalSubsemiring.top_prodₓ'. -/
theorem top_prod (s : NonUnitalSubsemiring S) :
    (⊤ : NonUnitalSubsemiring R).Prod s = s.comap (NonUnitalRingHom.snd R S) :=
  ext fun x => by simp [mem_prod, MonoidHom.coe_snd]
#align non_unital_subsemiring.top_prod NonUnitalSubsemiring.top_prod

/- warning: non_unital_subsemiring.top_prod_top -> NonUnitalSubsemiring.top_prod_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], Eq.{succ (max u1 u2)} (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasTop.{u1} R _inst_1)) (Top.top.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.hasTop.{u2} S _inst_2))) (Top.top.{max u1 u2} (NonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)) (NonUnitalSubsemiring.hasTop.{max u1 u2} (Prod.{u1, u2} R S) (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2)))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], Eq.{max (succ u1) (succ u2)} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (NonUnitalSubsemiring.prod.{u1, u2} R S _inst_1 _inst_2 (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u1} R _inst_1)) (Top.top.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u2} S _inst_2))) (Top.top.{max u1 u2} (NonUnitalSubsemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2)))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.top_prod_top NonUnitalSubsemiring.top_prod_topₓ'. -/
@[simp]
theorem top_prod_top : (⊤ : NonUnitalSubsemiring R).Prod (⊤ : NonUnitalSubsemiring S) = ⊤ :=
  (top_prod _).trans <| comap_top _
#align non_unital_subsemiring.top_prod_top NonUnitalSubsemiring.top_prod_top

/- warning: non_unital_subsemiring.prod_equiv -> NonUnitalSubsemiring.prodEquiv is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.prod_equiv NonUnitalSubsemiring.prodEquivₓ'. -/
/-- Product of non-unital subsemirings is isomorphic to their product as semigroups. -/
def prodEquiv (s : NonUnitalSubsemiring R) (t : NonUnitalSubsemiring S) : s.Prod t ≃+* s × t :=
  { Equiv.Set.prod ↑s ↑t with
    map_mul' := fun x y => rfl
    map_add' := fun x y => rfl }
#align non_unital_subsemiring.prod_equiv NonUnitalSubsemiring.prodEquiv

/- warning: non_unital_subsemiring.mem_supr_of_directed -> NonUnitalSubsemiring.mem_iSup_of_directed is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {ι : Sort.{u2}} [hι : Nonempty.{u2} ι] {S : ι -> (NonUnitalSubsemiring.{u1} R _inst_1)}, (Directed.{u1, u2} (NonUnitalSubsemiring.{u1} R _inst_1) ι (LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toHasLe.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1))))) S) -> (forall {x : R}, Iff (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x (iSup.{u1, u2} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.completeLattice.{u1} R _inst_1))) ι (fun (i : ι) => S i))) (Exists.{u2} ι (fun (i : ι) => Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x (S i))))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] {ι : Sort.{u1}} [hι : Nonempty.{u1} ι] {S : ι -> (NonUnitalSubsemiring.{u2} R _inst_1)}, (Directed.{u2, u1} (NonUnitalSubsemiring.{u2} R _inst_1) ι (fun (x._@.Mathlib.RingTheory.NonUnitalSubsemiring.Basic._hyg.7496 : NonUnitalSubsemiring.{u2} R _inst_1) (x._@.Mathlib.RingTheory.NonUnitalSubsemiring.Basic._hyg.7498 : NonUnitalSubsemiring.{u2} R _inst_1) => LE.le.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (Preorder.toLE.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (PartialOrder.toPreorder.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u2} R _inst_1))))) x._@.Mathlib.RingTheory.NonUnitalSubsemiring.Basic._hyg.7496 x._@.Mathlib.RingTheory.NonUnitalSubsemiring.Basic._hyg.7498) S) -> (forall {x : R}, Iff (Membership.mem.{u2, u2} R (NonUnitalSubsemiring.{u2} R _inst_1) (SetLike.instMembership.{u2, u2} (NonUnitalSubsemiring.{u2} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} R _inst_1)) x (iSup.{u2, u1} (NonUnitalSubsemiring.{u2} R _inst_1) (CompleteLattice.toSupSet.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u2} R _inst_1)) ι (fun (i : ι) => S i))) (Exists.{u1} ι (fun (i : ι) => Membership.mem.{u2, u2} R (NonUnitalSubsemiring.{u2} R _inst_1) (SetLike.instMembership.{u2, u2} (NonUnitalSubsemiring.{u2} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} R _inst_1)) x (S i))))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_supr_of_directed NonUnitalSubsemiring.mem_iSup_of_directedₓ'. -/
theorem mem_iSup_of_directed {ι} [hι : Nonempty ι] {S : ι → NonUnitalSubsemiring R}
    (hS : Directed (· ≤ ·) S) {x : R} : (x ∈ ⨆ i, S i) ↔ ∃ i, x ∈ S i :=
  by
  refine' ⟨_, fun ⟨i, hi⟩ => (SetLike.le_def.1 <| le_iSup S i) hi⟩
  let U : NonUnitalSubsemiring R :=
    NonUnitalSubsemiring.mk' (⋃ i, (S i : Set R)) (⨆ i, (S i).toSubsemigroup)
      (Subsemigroup.coe_iSup_of_directed <| hS.mono_comp _ fun _ _ => id)
      (⨆ i, (S i).toAddSubmonoid)
      (AddSubmonoid.coe_iSup_of_directed <| hS.mono_comp _ fun _ _ => id)
  suffices (⨆ i, S i) ≤ U by simpa using @this x
  exact iSup_le fun i x hx => Set.mem_iUnion.2 ⟨i, hx⟩
#align non_unital_subsemiring.mem_supr_of_directed NonUnitalSubsemiring.mem_iSup_of_directed

/- warning: non_unital_subsemiring.coe_supr_of_directed -> NonUnitalSubsemiring.coe_iSup_of_directed is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {ι : Sort.{u2}} [hι : Nonempty.{u2} ι] {S : ι -> (NonUnitalSubsemiring.{u1} R _inst_1)}, (Directed.{u1, u2} (NonUnitalSubsemiring.{u1} R _inst_1) ι (LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toHasLe.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1))))) S) -> (Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (iSup.{u1, u2} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.completeLattice.{u1} R _inst_1))) ι (fun (i : ι) => S i))) (Set.iUnion.{u1, u2} R ι (fun (i : ι) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (S i))))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] {ι : Sort.{u1}} [hι : Nonempty.{u1} ι] {S : ι -> (NonUnitalSubsemiring.{u2} R _inst_1)}, (Directed.{u2, u1} (NonUnitalSubsemiring.{u2} R _inst_1) ι (fun (x._@.Mathlib.RingTheory.NonUnitalSubsemiring.Basic._hyg.7771 : NonUnitalSubsemiring.{u2} R _inst_1) (x._@.Mathlib.RingTheory.NonUnitalSubsemiring.Basic._hyg.7773 : NonUnitalSubsemiring.{u2} R _inst_1) => LE.le.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (Preorder.toLE.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (PartialOrder.toPreorder.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u2} R _inst_1))))) x._@.Mathlib.RingTheory.NonUnitalSubsemiring.Basic._hyg.7771 x._@.Mathlib.RingTheory.NonUnitalSubsemiring.Basic._hyg.7773) S) -> (Eq.{succ u2} (Set.{u2} R) (SetLike.coe.{u2, u2} (NonUnitalSubsemiring.{u2} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} R _inst_1) (iSup.{u2, u1} (NonUnitalSubsemiring.{u2} R _inst_1) (CompleteLattice.toSupSet.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u2} R _inst_1)) ι (fun (i : ι) => S i))) (Set.iUnion.{u2, u1} R ι (fun (i : ι) => SetLike.coe.{u2, u2} (NonUnitalSubsemiring.{u2} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} R _inst_1) (S i))))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_supr_of_directed NonUnitalSubsemiring.coe_iSup_of_directedₓ'. -/
theorem coe_iSup_of_directed {ι} [hι : Nonempty ι] {S : ι → NonUnitalSubsemiring R}
    (hS : Directed (· ≤ ·) S) : ((⨆ i, S i : NonUnitalSubsemiring R) : Set R) = ⋃ i, ↑(S i) :=
  Set.ext fun x => by simp [mem_supr_of_directed hS]
#align non_unital_subsemiring.coe_supr_of_directed NonUnitalSubsemiring.coe_iSup_of_directed

/- warning: non_unital_subsemiring.mem_Sup_of_directed_on -> NonUnitalSubsemiring.mem_sSup_of_directedOn is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {S : Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)}, (Set.Nonempty.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) S) -> (DirectedOn.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toHasLe.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1))))) S) -> (forall {x : R}, Iff (Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x (SupSet.sSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.completeLattice.{u1} R _inst_1))) S)) (Exists.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (fun (s : NonUnitalSubsemiring.{u1} R _inst_1) => Exists.{0} (Membership.Mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.hasMem.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) s S) (fun (H : Membership.Mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.hasMem.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) s S) => Membership.Mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) x s))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {S : Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)}, (Set.Nonempty.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) S) -> (DirectedOn.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (fun (x._@.Mathlib.RingTheory.NonUnitalSubsemiring.Basic._hyg.7874 : NonUnitalSubsemiring.{u1} R _inst_1) (x._@.Mathlib.RingTheory.NonUnitalSubsemiring.Basic._hyg.7876 : NonUnitalSubsemiring.{u1} R _inst_1) => LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toLE.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u1} R _inst_1))))) x._@.Mathlib.RingTheory.NonUnitalSubsemiring.Basic._hyg.7874 x._@.Mathlib.RingTheory.NonUnitalSubsemiring.Basic._hyg.7876) S) -> (forall {x : R}, Iff (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x (SupSet.sSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toSupSet.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u1} R _inst_1)) S)) (Exists.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (fun (s : NonUnitalSubsemiring.{u1} R _inst_1) => And (Membership.mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.instMembershipSet.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) s S) (Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s))))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.mem_Sup_of_directed_on NonUnitalSubsemiring.mem_sSup_of_directedOnₓ'. -/
theorem mem_sSup_of_directedOn {S : Set (NonUnitalSubsemiring R)} (Sne : S.Nonempty)
    (hS : DirectedOn (· ≤ ·) S) {x : R} : x ∈ sSup S ↔ ∃ s ∈ S, x ∈ s :=
  by
  haveI : Nonempty S := Sne.to_subtype
  simp only [sSup_eq_iSup', mem_supr_of_directed hS.directed_coe, SetCoe.exists, Subtype.coe_mk]
#align non_unital_subsemiring.mem_Sup_of_directed_on NonUnitalSubsemiring.mem_sSup_of_directedOn

/- warning: non_unital_subsemiring.coe_Sup_of_directed_on -> NonUnitalSubsemiring.coe_sSup_of_directedOn is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {S : Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)}, (Set.Nonempty.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) S) -> (DirectedOn.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toHasLe.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1))))) S) -> (Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (SupSet.sSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeSup.toHasSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.completeLattice.{u1} R _inst_1))) S)) (Set.iUnion.{u1, succ u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (fun (s : NonUnitalSubsemiring.{u1} R _inst_1) => Set.iUnion.{u1, 0} R (Membership.Mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.hasMem.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) s S) (fun (H : Membership.Mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.hasMem.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) s S) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) s))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {S : Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)}, (Set.Nonempty.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) S) -> (DirectedOn.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (fun (x._@.Mathlib.RingTheory.NonUnitalSubsemiring.Basic._hyg.7977 : NonUnitalSubsemiring.{u1} R _inst_1) (x._@.Mathlib.RingTheory.NonUnitalSubsemiring.Basic._hyg.7979 : NonUnitalSubsemiring.{u1} R _inst_1) => LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toLE.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u1} R _inst_1))))) x._@.Mathlib.RingTheory.NonUnitalSubsemiring.Basic._hyg.7977 x._@.Mathlib.RingTheory.NonUnitalSubsemiring.Basic._hyg.7979) S) -> (Eq.{succ u1} (Set.{u1} R) (SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (SupSet.sSup.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toSupSet.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u1} R _inst_1)) S)) (Set.iUnion.{u1, succ u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (fun (s : NonUnitalSubsemiring.{u1} R _inst_1) => Set.iUnion.{u1, 0} R (Membership.mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.instMembershipSet.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) s S) (fun (H : Membership.mem.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) (Set.instMembershipSet.{u1} (NonUnitalSubsemiring.{u1} R _inst_1)) s S) => SetLike.coe.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s))))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.coe_Sup_of_directed_on NonUnitalSubsemiring.coe_sSup_of_directedOnₓ'. -/
theorem coe_sSup_of_directedOn {S : Set (NonUnitalSubsemiring R)} (Sne : S.Nonempty)
    (hS : DirectedOn (· ≤ ·) S) : (↑(sSup S) : Set R) = ⋃ s ∈ S, ↑s :=
  Set.ext fun x => by simp [mem_Sup_of_directed_on Sne hS]
#align non_unital_subsemiring.coe_Sup_of_directed_on NonUnitalSubsemiring.coe_sSup_of_directedOn

end NonUnitalSubsemiring

namespace NonUnitalRingHom

variable {F : Type _} [NonUnitalNonAssocSemiring T] [NonUnitalRingHomClass F R S]
  {s : NonUnitalSubsemiring R}

open NonUnitalSubsemiringClass NonUnitalSubsemiring

/- warning: non_unital_ring_hom.cod_restrict -> NonUnitalRingHom.codRestrict is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_5 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F) (s : NonUnitalSubsemiring.{u2} S _inst_2), (forall (x : R), Membership.Mem.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.hasMem.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5))) f x) s) -> (NonUnitalRingHom.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (NonUnitalSubsemiring.{u2} S _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) s) _inst_1 (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) _inst_2 (NonUnitalSubsemiring.setLike.{u2} S _inst_2) (NonUnitalSubsemiring.nonUnitalSubsemiringClass.{u2} S _inst_2) s))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_5 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F) (s : NonUnitalSubsemiring.{u2} S _inst_2), (forall (x : R), Membership.mem.{u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) x) (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.instMembership.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2)) (FunLike.coe.{succ u3, succ u1, succ u2} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u3, u1, u2} F R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5)) f x) s) -> (NonUnitalRingHom.{u1, u2} R (Subtype.{succ u2} S (fun (x : S) => Membership.mem.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.instMembership.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2)) x s)) _inst_1 (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) _inst_2 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u2} S _inst_2) s))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.cod_restrict NonUnitalRingHom.codRestrictₓ'. -/
/-- Restriction of a non-unital ring homomorphism to a non-unital subsemiring of the codomain. -/
def codRestrict (f : F) (s : NonUnitalSubsemiring S) (h : ∀ x, f x ∈ s) : R →ₙ+* s :=
  { (f : R →ₙ* S).codRestrict s.toSubsemigroup h, (f : R →+ S).codRestrict s.toAddSubmonoid h with
    toFun := fun n => ⟨f n, h n⟩ }
#align non_unital_ring_hom.cod_restrict NonUnitalRingHom.codRestrict

/- warning: non_unital_ring_hom.srange_restrict -> NonUnitalRingHom.srangeRestrict is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_5 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F), NonUnitalRingHom.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (NonUnitalSubsemiring.{u2} S _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f)) _inst_1 (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) _inst_2 (NonUnitalSubsemiring.setLike.{u2} S _inst_2) (NonUnitalSubsemiring.nonUnitalSubsemiringClass.{u2} S _inst_2) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_5 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F), NonUnitalRingHom.{u1, u2} R (Subtype.{succ u2} S (fun (x : S) => Membership.mem.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.instMembership.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2)) x (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f))) _inst_1 (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) _inst_2 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.srange_restrict NonUnitalRingHom.srangeRestrictₓ'. -/
/-- Restriction of a non-unital ring homomorphism to its range interpreted as a
non-unital subsemiring.

This is the bundled version of `set.range_factorization`. -/
def srangeRestrict (f : F) : R →ₙ+* (srange f : NonUnitalSubsemiring S) :=
  codRestrict f (srange f) (mem_srange_self f)
#align non_unital_ring_hom.srange_restrict NonUnitalRingHom.srangeRestrict

/- warning: non_unital_ring_hom.coe_srange_restrict -> NonUnitalRingHom.coe_srangeRestrict is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_srange_restrict NonUnitalRingHom.coe_srangeRestrictₓ'. -/
@[simp]
theorem coe_srangeRestrict (f : F) (x : R) : (srangeRestrict f x : S) = f x :=
  rfl
#align non_unital_ring_hom.coe_srange_restrict NonUnitalRingHom.coe_srangeRestrict

/- warning: non_unital_ring_hom.srange_restrict_surjective -> NonUnitalRingHom.srangeRestrict_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_5 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F), Function.Surjective.{succ u1, succ u2} R (coeSort.{succ u2, succ (succ u2)} (NonUnitalSubsemiring.{u2} S _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (NonUnitalSubsemiring.{u2} S _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f)) _inst_1 (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) _inst_2 (NonUnitalSubsemiring.setLike.{u2} S _inst_2) (NonUnitalSubsemiring.nonUnitalSubsemiringClass.{u2} S _inst_2) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f))) (fun (_x : NonUnitalRingHom.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (NonUnitalSubsemiring.{u2} S _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f)) _inst_1 (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) _inst_2 (NonUnitalSubsemiring.setLike.{u2} S _inst_2) (NonUnitalSubsemiring.nonUnitalSubsemiringClass.{u2} S _inst_2) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f))) => R -> (coeSort.{succ u2, succ (succ u2)} (NonUnitalSubsemiring.{u2} S _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f))) (NonUnitalRingHom.hasCoeToFun.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (NonUnitalSubsemiring.{u2} S _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f)) _inst_1 (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) _inst_2 (NonUnitalSubsemiring.setLike.{u2} S _inst_2) (NonUnitalSubsemiring.nonUnitalSubsemiringClass.{u2} S _inst_2) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f))) (NonUnitalRingHom.srangeRestrict.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_5 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (f : F), Function.Surjective.{succ u2, succ u3} R (Subtype.{succ u3} S (fun (x : S) => Membership.mem.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2)) x (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f))) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (NonUnitalRingHom.{u2, u3} R (Subtype.{succ u3} S (fun (x : S) => Membership.mem.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2)) x (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f))) _inst_1 (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) _inst_2 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => Subtype.{succ u3} S (fun (x : S) => Membership.mem.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2)) x (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f))) _x) (MulHomClass.toFunLike.{max u2 u3, u2, u3} (NonUnitalRingHom.{u2, u3} R (Subtype.{succ u3} S (fun (x : S) => Membership.mem.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2)) x (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f))) _inst_1 (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) _inst_2 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f))) R (Subtype.{succ u3} S (fun (x : S) => Membership.mem.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2)) x (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f))) (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} (Subtype.{succ u3} S (fun (x : S) => Membership.mem.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2)) x (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f))) (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) _inst_2 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u3, u2, u3} (NonUnitalRingHom.{u2, u3} R (Subtype.{succ u3} S (fun (x : S) => Membership.mem.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2)) x (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f))) _inst_1 (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) _inst_2 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f))) R (Subtype.{succ u3} S (fun (x : S) => Membership.mem.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2)) x (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f))) _inst_1 (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) _inst_2 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f)) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u3} R (Subtype.{succ u3} S (fun (x : S) => Membership.mem.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (NonUnitalSubsemiring.{u3} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2)) x (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f))) _inst_1 (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u3, u3} S (NonUnitalSubsemiring.{u3} S _inst_2) _inst_2 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f))))) (NonUnitalRingHom.srangeRestrict.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.srange_restrict_surjective NonUnitalRingHom.srangeRestrict_surjectiveₓ'. -/
theorem srangeRestrict_surjective (f : F) :
    Function.Surjective (srangeRestrict f : R → (srange f : NonUnitalSubsemiring S)) :=
  fun ⟨y, hy⟩ =>
  let ⟨x, hx⟩ := mem_srange.mp hy
  ⟨x, Subtype.ext hx⟩
#align non_unital_ring_hom.srange_restrict_surjective NonUnitalRingHom.srangeRestrict_surjective

/- warning: non_unital_ring_hom.srange_top_iff_surjective -> NonUnitalRingHom.srange_top_iff_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_5 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] {f : F}, Iff (Eq.{succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f) (Top.top.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.hasTop.{u2} S _inst_2))) (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5))) f))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_5 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] {f : F}, Iff (Eq.{succ u3} (NonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f) (Top.top.{u3} (NonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u3} S _inst_2))) (Function.Surjective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_5)) f))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.srange_top_iff_surjective NonUnitalRingHom.srange_top_iff_surjectiveₓ'. -/
theorem srange_top_iff_surjective {f : F} :
    srange f = (⊤ : NonUnitalSubsemiring S) ↔ Function.Surjective (f : R → S) :=
  SetLike.ext'_iff.trans <| Iff.trans (by rw [coe_srange, coe_top]) Set.range_iff_surjective
#align non_unital_ring_hom.srange_top_iff_surjective NonUnitalRingHom.srange_top_iff_surjective

/- warning: non_unital_ring_hom.srange_top_of_surjective -> NonUnitalRingHom.srange_top_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_5 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5))) f)) -> (Eq.{succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f) (Top.top.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.hasTop.{u2} S _inst_2)))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_5 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (f : F), (Function.Surjective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_5)) f)) -> (Eq.{succ u3} (NonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalRingHom.srange.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f) (Top.top.{u3} (NonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u3} S _inst_2)))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.srange_top_of_surjective NonUnitalRingHom.srange_top_of_surjectiveₓ'. -/
/-- The range of a surjective non-unital ring homomorphism is the whole of the codomain. -/
theorem srange_top_of_surjective (f : F) (hf : Function.Surjective (f : R → S)) :
    srange f = (⊤ : NonUnitalSubsemiring S) :=
  srange_top_iff_surjective.2 hf
#align non_unital_ring_hom.srange_top_of_surjective NonUnitalRingHom.srange_top_of_surjective

#print NonUnitalRingHom.eqSlocus /-
/-- The non-unital subsemiring of elements `x : R` such that `f x = g x` -/
def eqSlocus (f g : F) : NonUnitalSubsemiring R :=
  { (f : R →ₙ* S).eqLocus (g : R →ₙ* S), (f : R →+ S).eqLocus g with carrier := { x | f x = g x } }
#align non_unital_ring_hom.eq_slocus NonUnitalRingHom.eqSlocus
-/

/- warning: non_unital_ring_hom.eq_on_sclosure -> NonUnitalRingHom.eqOn_sclosure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_5 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] {f : F} {g : F} {s : Set.{u1} R}, (Set.EqOn.{u1, u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5))) f) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5))) g) s) -> (Set.EqOn.{u1, u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5))) f) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5))) g) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (NonUnitalSubsemiring.closure.{u1} R _inst_1 s)))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_5 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] {f : F} {g : F} {s : Set.{u2} R}, (Set.EqOn.{u2, u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_5)) f) (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_5)) g) s) -> (Set.EqOn.{u2, u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_5)) f) (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_5)) g) (SetLike.coe.{u2, u2} (NonUnitalSubsemiring.{u2} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.closure.{u2} R _inst_1 s)))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.eq_on_sclosure NonUnitalRingHom.eqOn_sclosureₓ'. -/
/-- If two non-unital ring homomorphisms are equal on a set, then they are equal on its
non-unital subsemiring closure. -/
theorem eqOn_sclosure {f g : F} {s : Set R} (h : Set.EqOn (f : R → S) (g : R → S) s) :
    Set.EqOn f g (closure s) :=
  show closure s ≤ eqSlocus f g from closure_le.2 h
#align non_unital_ring_hom.eq_on_sclosure NonUnitalRingHom.eqOn_sclosure

/- warning: non_unital_ring_hom.eq_of_eq_on_stop -> NonUnitalRingHom.eq_of_eqOn_stop is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_5 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] {f : F} {g : F}, (Set.EqOn.{u1, u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5))) f) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5))) g) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasTop.{u1} R _inst_1)))) -> (Eq.{succ u3} F f g)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_5 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] {f : F} {g : F}, (Set.EqOn.{u2, u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_5)) f) (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_5)) g) (SetLike.coe.{u2, u2} (NonUnitalSubsemiring.{u2} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} R _inst_1) (Top.top.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u2} R _inst_1)))) -> (Eq.{succ u1} F f g)
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.eq_of_eq_on_stop NonUnitalRingHom.eq_of_eqOn_stopₓ'. -/
theorem eq_of_eqOn_stop {f g : F}
    (h : Set.EqOn (f : R → S) (g : R → S) (⊤ : NonUnitalSubsemiring R)) : f = g :=
  FunLike.ext _ _ fun x => h trivial
#align non_unital_ring_hom.eq_of_eq_on_stop NonUnitalRingHom.eq_of_eqOn_stop

/- warning: non_unital_ring_hom.eq_of_eq_on_sdense -> NonUnitalRingHom.eq_of_eqOn_sdense is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_5 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] {s : Set.{u1} R}, (Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.closure.{u1} R _inst_1 s) (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasTop.{u1} R _inst_1))) -> (forall {f : F} {g : F}, (Set.EqOn.{u1, u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5))) f) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5))) g) s) -> (Eq.{succ u3} F f g))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_5 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] {s : Set.{u2} R}, (Eq.{succ u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.closure.{u2} R _inst_1 s) (Top.top.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u2} R _inst_1))) -> (forall {f : F} {g : F}, (Set.EqOn.{u2, u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_5)) f) (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_5)) g) s) -> (Eq.{succ u1} F f g))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.eq_of_eq_on_sdense NonUnitalRingHom.eq_of_eqOn_sdenseₓ'. -/
theorem eq_of_eqOn_sdense {s : Set R} (hs : closure s = ⊤) {f g : F}
    (h : s.EqOn (f : R → S) (g : R → S)) : f = g :=
  eq_of_eqOn_stop <| hs ▸ eqOn_sclosure h
#align non_unital_ring_hom.eq_of_eq_on_sdense NonUnitalRingHom.eq_of_eqOn_sdense

/- warning: non_unital_ring_hom.sclosure_preimage_le -> NonUnitalRingHom.sclosure_preimage_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_5 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F) (s : Set.{u2} S), LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toHasLe.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) (NonUnitalSubsemiring.closure.{u1} R _inst_1 (Set.preimage.{u1, u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5))) f) s)) (NonUnitalSubsemiring.comap.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f (NonUnitalSubsemiring.closure.{u2} S _inst_2 s))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_5 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (f : F) (s : Set.{u3} S), LE.le.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (Preorder.toLE.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (PartialOrder.toPreorder.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (NonUnitalSubsemiring.{u2} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u2} R _inst_1))))) (NonUnitalSubsemiring.closure.{u2} R _inst_1 (Set.preimage.{u2, u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_5)) f) s)) (NonUnitalSubsemiring.comap.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f (NonUnitalSubsemiring.closure.{u3} S _inst_2 s))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.sclosure_preimage_le NonUnitalRingHom.sclosure_preimage_leₓ'. -/
theorem sclosure_preimage_le (f : F) (s : Set S) :
    closure ((f : R → S) ⁻¹' s) ≤ (closure s).comap f :=
  closure_le.2 fun x hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx
#align non_unital_ring_hom.sclosure_preimage_le NonUnitalRingHom.sclosure_preimage_le

/- warning: non_unital_ring_hom.map_sclosure -> NonUnitalRingHom.map_sclosure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_5 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] (f : F) (s : Set.{u1} R), Eq.{succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.map.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_5 f (NonUnitalSubsemiring.closure.{u1} R _inst_1 s)) (NonUnitalSubsemiring.closure.{u2} S _inst_2 (Set.image.{u1, u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_5))) f) s))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : NonUnitalNonAssocSemiring.{u2} R] [_inst_2 : NonUnitalNonAssocSemiring.{u3} S] {F : Type.{u1}} [_inst_5 : NonUnitalRingHomClass.{u1, u2, u3} F R S _inst_1 _inst_2] (f : F) (s : Set.{u2} R), Eq.{succ u3} (NonUnitalSubsemiring.{u3} S _inst_2) (NonUnitalSubsemiring.map.{u2, u3, u1} R S _inst_1 _inst_2 F _inst_5 f (NonUnitalSubsemiring.closure.{u2} R _inst_1 s)) (NonUnitalSubsemiring.closure.{u3} S _inst_2 (Set.image.{u2, u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u3} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S _inst_1 _inst_2 _inst_5)) f) s))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.map_sclosure NonUnitalRingHom.map_sclosureₓ'. -/
/-- The image under a ring homomorphism of the subsemiring generated by a set equals
the subsemiring generated by the image of the set. -/
theorem map_sclosure (f : F) (s : Set R) : (closure s).map f = closure ((f : R → S) '' s) :=
  le_antisymm
    (map_le_iff_le_comap.2 <|
      le_trans (closure_mono <| Set.subset_preimage_image _ _) (sclosure_preimage_le _ _))
    (closure_le.2 <| Set.image_subset _ subset_closure)
#align non_unital_ring_hom.map_sclosure NonUnitalRingHom.map_sclosure

end NonUnitalRingHom

namespace NonUnitalSubsemiring

open NonUnitalRingHom NonUnitalSubsemiringClass

/- warning: non_unital_subsemiring.inclusion -> NonUnitalSubsemiring.inclusion is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {S : NonUnitalSubsemiring.{u1} R _inst_1} {T : NonUnitalSubsemiring.{u1} R _inst_1}, (LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toHasLe.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.partialOrder.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)))) S T) -> (NonUnitalRingHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) S) (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) T) (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (NonUnitalSubsemiring.nonUnitalSubsemiringClass.{u1} R _inst_1) S) (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (NonUnitalSubsemiring.nonUnitalSubsemiringClass.{u1} R _inst_1) T))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {S : NonUnitalSubsemiring.{u1} R _inst_1} {T : NonUnitalSubsemiring.{u1} R _inst_1}, (LE.le.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (Preorder.toLE.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instCompleteLatticeNonUnitalSubsemiring.{u1} R _inst_1))))) S T) -> (NonUnitalRingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x S)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x T)) (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u1} R _inst_1) S) (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u1} R _inst_1) T))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.inclusion NonUnitalSubsemiring.inclusionₓ'. -/
/-- The non-unital ring homomorphism associated to an inclusion of
non-unital subsemirings. -/
def inclusion {S T : NonUnitalSubsemiring R} (h : S ≤ T) : S →ₙ+* T :=
  codRestrict (Subtype S) _ fun x => h x.2
#align non_unital_subsemiring.inclusion NonUnitalSubsemiring.inclusion

/- warning: non_unital_subsemiring.srange_subtype -> NonUnitalSubsemiring.srange_subtype is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalRingHom.srange.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (NonUnitalSubsemiring.nonUnitalSubsemiringClass.{u1} R _inst_1) s) _inst_1 (NonUnitalRingHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (NonUnitalSubsemiring.nonUnitalSubsemiringClass.{u1} R _inst_1) s) _inst_1) (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) R (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (NonUnitalSubsemiring.nonUnitalSubsemiringClass.{u1} R _inst_1) s) _inst_1) (NonUnitalSubsemiringClass.subtype.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (NonUnitalSubsemiring.nonUnitalSubsemiringClass.{u1} R _inst_1) s)) s
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] (s : NonUnitalSubsemiring.{u1} R _inst_1), Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalRingHom.srange.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) R (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s) _inst_1 (NonUnitalRingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) R (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s) _inst_1) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) R (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s) _inst_1) (NonUnitalSubsemiringClass.subtype.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s)) s
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.srange_subtype NonUnitalSubsemiring.srange_subtypeₓ'. -/
@[simp]
theorem srange_subtype (s : NonUnitalSubsemiring R) : (Subtype s).srange = s :=
  SetLike.coe_injective <| (coe_srange _).trans Subtype.range_coe
#align non_unital_subsemiring.srange_subtype NonUnitalSubsemiring.srange_subtype

/- warning: non_unital_subsemiring.range_fst -> NonUnitalSubsemiring.range_fst is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalRingHom.srange.{max u1 u2, u1, max u1 u2} (Prod.{u1, u2} R S) R (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_1 (NonUnitalRingHom.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_1) (NonUnitalRingHom.nonUnitalRingHomClass.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_1) (NonUnitalRingHom.fst.{u1, u2} R S _inst_1 _inst_2)) (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.hasTop.{u1} R _inst_1))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalRingHom.srange.{max u1 u2, u1, max u1 u2} (Prod.{u1, u2} R S) R (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2) _inst_1 (NonUnitalRingHom.{max u2 u1, u1} (Prod.{u1, u2} R S) R (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2) _inst_1) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2) _inst_1) (NonUnitalRingHom.fst.{u1, u2} R S _inst_1 _inst_2)) (Top.top.{u1} (NonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u1} R _inst_1))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.range_fst NonUnitalSubsemiring.range_fstₓ'. -/
@[simp]
theorem range_fst : (fst R S).srange = ⊤ :=
  NonUnitalRingHom.srange_top_of_surjective (fst R S) Prod.fst_surjective
#align non_unital_subsemiring.range_fst NonUnitalSubsemiring.range_fst

/- warning: non_unital_subsemiring.range_snd -> NonUnitalSubsemiring.range_snd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], Eq.{succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalRingHom.srange.{max u1 u2, u2, max u1 u2} (Prod.{u1, u2} R S) S (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_2 (NonUnitalRingHom.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_2) (NonUnitalRingHom.nonUnitalRingHomClass.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonUnitalNonAssocSemiring.{u1, u2} R S _inst_1 _inst_2) _inst_2) (NonUnitalRingHom.snd.{u1, u2} R S _inst_1 _inst_2)) (Top.top.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.hasTop.{u2} S _inst_2))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S], Eq.{succ u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalRingHom.srange.{max u1 u2, u2, max u1 u2} (Prod.{u1, u2} R S) S (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2) _inst_2 (NonUnitalRingHom.{max u2 u1, u2} (Prod.{u1, u2} R S) S (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2) _inst_2) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.instNonUnitalNonAssocSemiringProd.{u1, u2} R S _inst_1 _inst_2) _inst_2) (NonUnitalRingHom.snd.{u1, u2} R S _inst_1 _inst_2)) (Top.top.{u2} (NonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.instTopNonUnitalSubsemiring.{u2} S _inst_2))
Case conversion may be inaccurate. Consider using '#align non_unital_subsemiring.range_snd NonUnitalSubsemiring.range_sndₓ'. -/
@[simp]
theorem range_snd : (snd R S).srange = ⊤ :=
  NonUnitalRingHom.srange_top_of_surjective (snd R S) <| Prod.snd_surjective
#align non_unital_subsemiring.range_snd NonUnitalSubsemiring.range_snd

end NonUnitalSubsemiring

namespace RingEquiv

open NonUnitalRingHom NonUnitalSubsemiringClass

variable {s t : NonUnitalSubsemiring R}

variable {F : Type _} [NonUnitalRingHomClass F R S]

/- warning: ring_equiv.non_unital_subsemiring_congr -> RingEquiv.nonUnitalSubsemiringCongr is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : NonUnitalSubsemiring.{u1} R _inst_1} {t : NonUnitalSubsemiring.{u1} R _inst_1}, (Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) s t) -> (RingEquiv.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) t) (MulMemClass.mul.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (RingEquiv.nonUnitalSubsemiringCongr._proof_1.{u1} R _inst_1) s) (AddMemClass.add.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (AddZeroClass.toHasAdd.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (RingEquiv.nonUnitalSubsemiringCongr._proof_2.{u1} R _inst_1) s) (MulMemClass.mul.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (RingEquiv.nonUnitalSubsemiringCongr._proof_3.{u1} R _inst_1) t) (AddMemClass.add.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (AddZeroClass.toHasAdd.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (RingEquiv.nonUnitalSubsemiringCongr._proof_4.{u1} R _inst_1) t))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] {s : NonUnitalSubsemiring.{u1} R _inst_1} {t : NonUnitalSubsemiring.{u1} R _inst_1}, (Eq.{succ u1} (NonUnitalSubsemiring.{u1} R _inst_1) s t) -> (RingEquiv.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x t)) (NonUnitalNonAssocSemiring.toMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s)) (NonUnitalNonAssocSemiring.toMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x t)) (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u1} R _inst_1) t)) (AddSubmonoid.add.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1 s)) (AddSubmonoid.add.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1 t)))
Case conversion may be inaccurate. Consider using '#align ring_equiv.non_unital_subsemiring_congr RingEquiv.nonUnitalSubsemiringCongrₓ'. -/
/-- Makes the identity isomorphism from a proof two non-unital subsemirings of a multiplicative
monoid are equal. -/
def nonUnitalSubsemiringCongr (h : s = t) : s ≃+* t :=
  {
    Equiv.setCongr <| congr_arg _ h with
    map_mul' := fun _ _ => rfl
    map_add' := fun _ _ => rfl }
#align ring_equiv.non_unital_subsemiring_congr RingEquiv.nonUnitalSubsemiringCongr

/- warning: ring_equiv.sof_left_inverse' -> RingEquiv.sofLeftInverse' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] {g : S -> R} {f : F}, (Function.LeftInverse.{succ u1, succ u2} R S g (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_4))) f)) -> (RingEquiv.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (NonUnitalSubsemiring.{u2} S _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f)) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (MulMemClass.mul.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalSubsemiring.setLike.{u2} S _inst_2) (RingEquiv.sofLeftInverse'._proof_1.{u2} S _inst_2) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f)) (AddMemClass.add.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (AddZeroClass.toHasAdd.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S _inst_2)))) (NonUnitalSubsemiring.setLike.{u2} S _inst_2) (RingEquiv.sofLeftInverse'._proof_2.{u2} S _inst_2) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f)))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] {F : Type.{u3}} [_inst_4 : NonUnitalRingHomClass.{u3, u1, u2} F R S _inst_1 _inst_2] {g : S -> R} {f : F}, (Function.LeftInverse.{succ u1, succ u2} R S g (FunLike.coe.{succ u3, succ u1, succ u2} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{u3, u1, u2} F R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S _inst_1 _inst_2 _inst_4)) f)) -> (RingEquiv.{u1, u2} R (Subtype.{succ u2} S (fun (x : S) => Membership.mem.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.instMembership.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2)) x (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f))) (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} (Subtype.{succ u2} S (fun (x : S) => Membership.mem.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.instMembership.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2)) x (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f))) (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) _inst_2 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (AddSubmonoid.add.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S _inst_2))) (NonUnitalSubsemiring.toAddSubmonoid.{u2} S _inst_2 (NonUnitalRingHom.srange.{u1, u2, u3} R S _inst_1 _inst_2 F _inst_4 f))))
Case conversion may be inaccurate. Consider using '#align ring_equiv.sof_left_inverse' RingEquiv.sofLeftInverse'ₓ'. -/
/-- Restrict a non-unital ring homomorphism with a left inverse to a ring isomorphism to its
`non_unital_ring_hom.srange`. -/
def sofLeftInverse' {g : S → R} {f : F} (h : Function.LeftInverse g f) : R ≃+* srange f :=
  { srangeRestrict f with
    toFun := srangeRestrict f
    invFun := fun x => g (Subtype (srange f) x)
    left_inv := h
    right_inv := fun x =>
      Subtype.ext <|
        let ⟨x', hx'⟩ := NonUnitalRingHom.mem_srange.mp x.Prop
        show f (g x) = x by rw [← hx', h x'] }
#align ring_equiv.sof_left_inverse' RingEquiv.sofLeftInverse'

/- warning: ring_equiv.sof_left_inverse'_apply -> RingEquiv.sofLeftInverse'_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align ring_equiv.sof_left_inverse'_apply RingEquiv.sofLeftInverse'_applyₓ'. -/
@[simp]
theorem sofLeftInverse'_apply {g : S → R} {f : F} (h : Function.LeftInverse g f) (x : R) :
    ↑(sofLeftInverse' h x) = f x :=
  rfl
#align ring_equiv.sof_left_inverse'_apply RingEquiv.sofLeftInverse'_apply

/- warning: ring_equiv.sof_left_inverse'_symm_apply -> RingEquiv.sofLeftInverse'_symm_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align ring_equiv.sof_left_inverse'_symm_apply RingEquiv.sofLeftInverse'_symm_applyₓ'. -/
@[simp]
theorem sofLeftInverse'_symm_apply {g : S → R} {f : F} (h : Function.LeftInverse g f)
    (x : srange f) : (sofLeftInverse' h).symm x = g x :=
  rfl
#align ring_equiv.sof_left_inverse'_symm_apply RingEquiv.sofLeftInverse'_symm_apply

/- warning: ring_equiv.non_unital_subsemiring_map -> RingEquiv.nonUnitalSubsemiringMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (e : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (s : NonUnitalSubsemiring.{u1} R _inst_1), RingEquiv.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (NonUnitalSubsemiring.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.setLike.{u1} R _inst_1)) s) (coeSort.{succ u2, succ (succ u2)} (NonUnitalSubsemiring.{u2} S _inst_2) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.setLike.{u2} S _inst_2)) (NonUnitalSubsemiring.map.{u1, u2, max u1 u2} R S _inst_1 _inst_2 (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u2} R S _inst_1 _inst_2) (RingEquiv.toNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2 e) s)) (MulMemClass.mul.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (RingEquiv.nonUnitalSubsemiringMap._proof_1.{u1} R _inst_1) s) (AddMemClass.add.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (AddZeroClass.toHasAdd.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))) (NonUnitalSubsemiring.setLike.{u1} R _inst_1) (RingEquiv.nonUnitalSubsemiringMap._proof_2.{u1} R _inst_1) s) (MulMemClass.mul.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2)) (NonUnitalSubsemiring.setLike.{u2} S _inst_2) (RingEquiv.nonUnitalSubsemiringMap._proof_3.{u2} S _inst_2) (NonUnitalSubsemiring.map.{u1, u2, max u1 u2} R S _inst_1 _inst_2 (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u2} R S _inst_1 _inst_2) (RingEquiv.toNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2 e) s)) (AddMemClass.add.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (AddZeroClass.toHasAdd.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S _inst_2)))) (NonUnitalSubsemiring.setLike.{u2} S _inst_2) (RingEquiv.nonUnitalSubsemiringMap._proof_4.{u2} S _inst_2) (NonUnitalSubsemiring.map.{u1, u2, max u1 u2} R S _inst_1 _inst_2 (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u2} R S _inst_1 _inst_2) (RingEquiv.toNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2 e) s))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R] [_inst_2 : NonUnitalNonAssocSemiring.{u2} S] (e : RingEquiv.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} S _inst_2) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S _inst_2))) (s : NonUnitalSubsemiring.{u1} R _inst_1), RingEquiv.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (Subtype.{succ u2} S (fun (x : S) => Membership.mem.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.instMembership.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2)) x (NonUnitalSubsemiring.map.{u1, u2, max u1 u2} R S _inst_1 _inst_2 (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (RingEquiv.toNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2 e) s))) (NonUnitalNonAssocSemiring.toMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) (SetLike.instMembership.{u1, u1} (NonUnitalSubsemiring.{u1} R _inst_1) R (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1)) x s)) (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u1, u1} R (NonUnitalSubsemiring.{u1} R _inst_1) _inst_1 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u1} R _inst_1) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u1} R _inst_1) s)) (NonUnitalNonAssocSemiring.toMul.{u2} (Subtype.{succ u2} S (fun (x : S) => Membership.mem.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) (SetLike.instMembership.{u2, u2} (NonUnitalSubsemiring.{u2} S _inst_2) S (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2)) x (NonUnitalSubsemiring.map.{u1, u2, max u1 u2} R S _inst_1 _inst_2 (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (RingEquiv.toNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2 e) s))) (NonUnitalSubsemiringClass.toNonUnitalNonAssocSemiring.{u2, u2} S (NonUnitalSubsemiring.{u2} S _inst_2) _inst_2 (NonUnitalSubsemiring.instSetLikeNonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.instNonUnitalSubsemiringClassNonUnitalSubsemiringInstSetLikeNonUnitalSubsemiring.{u2} S _inst_2) (NonUnitalSubsemiring.map.{u1, u2, max u1 u2} R S _inst_1 _inst_2 (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (RingEquiv.toNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2 e) s))) (AddSubmonoid.add.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (NonUnitalSubsemiring.toAddSubmonoid.{u1} R _inst_1 s)) (AddSubmonoid.add.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S _inst_2))) (NonUnitalSubsemiring.toAddSubmonoid.{u2} S _inst_2 (NonUnitalSubsemiring.map.{u1, u2, max u1 u2} R S _inst_1 _inst_2 (NonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2) (RingEquiv.toNonUnitalRingHom.{u1, u2} R S _inst_1 _inst_2 e) s)))
Case conversion may be inaccurate. Consider using '#align ring_equiv.non_unital_subsemiring_map RingEquiv.nonUnitalSubsemiringMapₓ'. -/
/-- Given an equivalence `e : R ≃+* S` of non-unital semirings and a non-unital subsemiring
`s` of `R`, `non_unital_subsemiring_map e s` is the induced equivalence between `s` and
`s.map e` -/
@[simps]
def nonUnitalSubsemiringMap (e : R ≃+* S) (s : NonUnitalSubsemiring R) :
    s ≃+* NonUnitalSubsemiring.map e.toNonUnitalRingHom s :=
  { e.toAddEquiv.addSubmonoidMap s.toAddSubmonoid,
    e.toMulEquiv.subsemigroupMap s.toSubsemigroup with }
#align ring_equiv.non_unital_subsemiring_map RingEquiv.nonUnitalSubsemiringMap

end RingEquiv

