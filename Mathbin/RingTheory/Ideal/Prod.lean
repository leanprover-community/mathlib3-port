/-
Copyright (c) 2020 Markus Himmel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Markus Himmel

! This file was ported from Lean 3 source module ring_theory.ideal.prod
! leanprover-community/mathlib commit 052f6013363326d50cb99c6939814a4b8eb7b301
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.RingTheory.Ideal.Operations

/-!
# Ideals in product rings

For commutative rings `R` and `S` and ideals `I ≤ R`, `J ≤ S`, we define `ideal.prod I J` as the
product `I × J`, viewed as an ideal of `R × S`. In `ideal_prod_eq` we show that every ideal of
`R × S` is of this form.  Furthermore, we show that every prime ideal of `R × S` is of the form
`p × S` or `R × p`, where `p` is a prime ideal.
-/


universe u v

variable {R : Type u} {S : Type v} [Ring R] [Ring S] (I I' : Ideal R) (J J' : Ideal S)

namespace Ideal

/- warning: ideal.prod -> Ideal.prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S], (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) -> (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) -> (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S], (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) -> (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) -> (Ideal.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)))
Case conversion may be inaccurate. Consider using '#align ideal.prod Ideal.prodₓ'. -/
/-- `I × J` as an ideal of `R × S`. -/
def prod : Ideal (R × S) where
  carrier := { x | x.fst ∈ I ∧ x.snd ∈ J }
  zero_mem' := by simp
  add_mem' := by
    rintro ⟨a₁, a₂⟩ ⟨b₁, b₂⟩ ⟨ha₁, ha₂⟩ ⟨hb₁, hb₂⟩
    exact ⟨I.add_mem ha₁ hb₁, J.add_mem ha₂ hb₂⟩
  smul_mem' := by
    rintro ⟨a₁, a₂⟩ ⟨b₁, b₂⟩ ⟨hb₁, hb₂⟩
    exact ⟨I.mul_mem_left _ hb₁, J.mul_mem_left _ hb₂⟩
#align ideal.prod Ideal.prod

#print Ideal.mem_prod /-
@[simp]
theorem mem_prod {r : R} {s : S} : (⟨r, s⟩ : R × S) ∈ prod I J ↔ r ∈ I ∧ s ∈ J :=
  Iff.rfl
#align ideal.mem_prod Ideal.mem_prod
-/

/- warning: ideal.prod_top_top -> Ideal.prod_top_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S], Eq.{succ (max u1 u2)} (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Top.top.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.hasTop.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))) (Top.top.{max u1 u2} (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) (Submodule.hasTop.{max u1 u2, max u1 u2} (Prod.{u1, u2} R S) (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u2} (Prod.{u1, u2} R S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (Prod.{u1, u2} R S) (Semiring.toNonAssocSemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))))) (Semiring.toModule.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S], Eq.{max (succ u1) (succ u2)} (Ideal.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Top.top.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.instTopSubmodule.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))) (Top.top.{max u1 u2} (Ideal.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) (Submodule.instTopSubmodule.{max u1 u2, max u1 u2} (Prod.{u1, u2} R S) (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u1} (Prod.{u1, u2} R S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (Prod.{u1, u2} R S) (Semiring.toNonAssocSemiring.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))))) (Semiring.toModule.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)))))
Case conversion may be inaccurate. Consider using '#align ideal.prod_top_top Ideal.prod_top_topₓ'. -/
@[simp]
theorem prod_top_top : prod (⊤ : Ideal R) (⊤ : Ideal S) = ⊤ :=
  Ideal.ext <| by simp
#align ideal.prod_top_top Ideal.prod_top_top

/- warning: ideal.ideal_prod_eq -> Ideal.ideal_prod_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))), Eq.{succ (max u1 u2)} (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) I (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 (Ideal.map.{max u1 u2, u1, max u1 u2} (Prod.{u1, u2} R S) R (RingHom.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonAssocSemiring.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ring.toSemiring.{u1} R _inst_1) (RingHom.ringHomClass.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonAssocSemiring.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (RingHom.fst.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) I) (Ideal.map.{max u1 u2, u2, max u1 u2} (Prod.{u1, u2} R S) S (RingHom.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonAssocSemiring.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ring.toSemiring.{u2} S _inst_2) (RingHom.ringHomClass.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonAssocSemiring.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHom.snd.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) I))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))), Eq.{max (succ u1) (succ u2)} (Ideal.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) I (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 (Ideal.map.{max u1 u2, u1, max u1 u2} (Prod.{u1, u2} R S) R (RingHom.{max u2 u1, u1} (Prod.{u1, u2} R S) R (Prod.instNonAssocSemiringProd.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ring.toSemiring.{u1} R _inst_1) (RingHom.instRingHomClassRingHom.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.instNonAssocSemiringProd.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHom.fst.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) I) (Ideal.map.{max u1 u2, u2, max u1 u2} (Prod.{u1, u2} R S) S (RingHom.{max u2 u1, u2} (Prod.{u1, u2} R S) S (Prod.instNonAssocSemiringProd.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ring.toSemiring.{u2} S _inst_2) (RingHom.instRingHomClassRingHom.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.instNonAssocSemiringProd.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (RingHom.snd.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) I))
Case conversion may be inaccurate. Consider using '#align ideal.ideal_prod_eq Ideal.ideal_prod_eqₓ'. -/
/-- Every ideal of the product ring is of the form `I × J`, where `I` and `J` can be explicitly
    given as the image under the projection maps. -/
theorem ideal_prod_eq (I : Ideal (R × S)) :
    I = Ideal.prod (map (RingHom.fst R S) I) (map (RingHom.snd R S) I) :=
  by
  apply Ideal.ext
  rintro ⟨r, s⟩
  rw [mem_prod, mem_map_iff_of_surjective (RingHom.fst R S) Prod.fst_surjective,
    mem_map_iff_of_surjective (RingHom.snd R S) Prod.snd_surjective]
  refine' ⟨fun h => ⟨⟨_, ⟨h, rfl⟩⟩, ⟨_, ⟨h, rfl⟩⟩⟩, _⟩
  rintro ⟨⟨⟨r, s'⟩, ⟨h₁, rfl⟩⟩, ⟨⟨r', s⟩, ⟨h₂, rfl⟩⟩⟩
  simpa using I.add_mem (I.mul_mem_left (1, 0) h₁) (I.mul_mem_left (0, 1) h₂)
#align ideal.ideal_prod_eq Ideal.ideal_prod_eq

/- warning: ideal.map_fst_prod -> Ideal.map_fst_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)), Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.map.{max u1 u2, u1, max u1 u2} (Prod.{u1, u2} R S) R (RingHom.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonAssocSemiring.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ring.toSemiring.{u1} R _inst_1) (RingHom.ringHomClass.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.nonAssocSemiring.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (RingHom.fst.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I J)) I
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)), Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.map.{max u2 u1, u1, max u1 u2} (Prod.{u1, u2} R S) R (RingHom.{max u2 u1, u1} (Prod.{u1, u2} R S) R (Prod.instNonAssocSemiringProd.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ring.toSemiring.{u1} R _inst_1) (RingHom.instRingHomClassRingHom.{max u1 u2, u1} (Prod.{u1, u2} R S) R (Prod.instNonAssocSemiringProd.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHom.fst.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I J)) I
Case conversion may be inaccurate. Consider using '#align ideal.map_fst_prod Ideal.map_fst_prodₓ'. -/
@[simp]
theorem map_fst_prod (I : Ideal R) (J : Ideal S) : map (RingHom.fst R S) (prod I J) = I :=
  by
  ext
  rw [mem_map_iff_of_surjective (RingHom.fst R S) Prod.fst_surjective]
  exact
    ⟨by
      rintro ⟨x, ⟨h, rfl⟩⟩
      exact h.1, fun h => ⟨⟨x, 0⟩, ⟨⟨h, Ideal.zero_mem _⟩, rfl⟩⟩⟩
#align ideal.map_fst_prod Ideal.map_fst_prod

/- warning: ideal.map_snd_prod -> Ideal.map_snd_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)), Eq.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Ideal.map.{max u1 u2, u2, max u1 u2} (Prod.{u1, u2} R S) S (RingHom.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonAssocSemiring.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ring.toSemiring.{u2} S _inst_2) (RingHom.ringHomClass.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.nonAssocSemiring.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHom.snd.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I J)) J
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)), Eq.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Ideal.map.{max u2 u1, u2, max u1 u2} (Prod.{u1, u2} R S) S (RingHom.{max u2 u1, u2} (Prod.{u1, u2} R S) S (Prod.instNonAssocSemiringProd.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ring.toSemiring.{u2} S _inst_2) (RingHom.instRingHomClassRingHom.{max u1 u2, u2} (Prod.{u1, u2} R S) S (Prod.instNonAssocSemiringProd.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (RingHom.snd.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I J)) J
Case conversion may be inaccurate. Consider using '#align ideal.map_snd_prod Ideal.map_snd_prodₓ'. -/
@[simp]
theorem map_snd_prod (I : Ideal R) (J : Ideal S) : map (RingHom.snd R S) (prod I J) = J :=
  by
  ext
  rw [mem_map_iff_of_surjective (RingHom.snd R S) Prod.snd_surjective]
  exact
    ⟨by
      rintro ⟨x, ⟨h, rfl⟩⟩
      exact h.2, fun h => ⟨⟨0, x⟩, ⟨⟨Ideal.zero_mem _, h⟩, rfl⟩⟩⟩
#align ideal.map_snd_prod Ideal.map_snd_prod

/- warning: ideal.map_prod_comm_prod -> Ideal.map_prodComm_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)), Eq.{succ (max u2 u1)} (Ideal.{max u2 u1} (Prod.{u2, u1} S R) (Prod.semiring.{u2, u1} S R (Ring.toSemiring.{u2} S _inst_2) (Ring.toSemiring.{u1} R _inst_1))) (Ideal.map.{max u1 u2, max u2 u1, max (max u1 u2) u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (RingHom.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (Prod.nonAssocSemiring.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Prod.semiring.{u2, u1} S R (Ring.toSemiring.{u2} S _inst_2) (Ring.toSemiring.{u1} R _inst_1)) (RingHom.ringHomClass.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (Prod.nonAssocSemiring.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))) ((fun (a : Sort.{max (succ (max u1 u2)) (succ (max u2 u1))}) (b : Sort.{max (succ (max u1 u2)) (succ (max u2 u1))}) [self : HasLiftT.{max (succ (max u1 u2)) (succ (max u2 u1)), max (succ (max u1 u2)) (succ (max u2 u1))} a b] => self.0) (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)))))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)))))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))))) (RingHom.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (Prod.nonAssocSemiring.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))) (HasLiftT.mk.{max (succ (max u1 u2)) (succ (max u2 u1)), max (succ (max u1 u2)) (succ (max u2 u1))} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)))))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)))))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))))) (RingHom.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (Prod.nonAssocSemiring.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))) (CoeTCₓ.coe.{max (succ (max u1 u2)) (succ (max u2 u1)), max (succ (max u1 u2)) (succ (max u2 u1))} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)))))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)))))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))))) (RingHom.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (Prod.nonAssocSemiring.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))) (RingHom.hasCoeT.{max (max u1 u2) u2 u1, max u1 u2, max u2 u1} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)))))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)))))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))))) (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (Prod.nonAssocSemiring.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (RingEquivClass.toRingHomClass.{max (max u1 u2) u2 u1, max u1 u2, max u2 u1} (RingEquiv.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)))))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)))))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))))) (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.nonAssocSemiring.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (Prod.nonAssocSemiring.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (RingEquiv.ringEquivClass.{max u1 u2, max u2 u1} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.hasMul.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)))))) (Prod.hasAdd.{u1, u2} R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)))))) (Prod.hasMul.{u2, u1} S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) (Prod.hasAdd.{u2, u1} S R (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))))))))) (RingEquiv.prodComm.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)))) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I J)) (Ideal.prod.{u2, u1} S R _inst_2 _inst_1 J I)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)), Eq.{max (succ u1) (succ u2)} (Ideal.{max u1 u2} (Prod.{u2, u1} S R) (Prod.instSemiringProd.{u2, u1} S R (Ring.toSemiring.{u2} S _inst_2) (Ring.toSemiring.{u1} R _inst_1))) (Ideal.map.{max u2 u1, max u1 u2, max u1 u2} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (RingHom.{max u1 u2, max u1 u2} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.instNonAssocSemiringProd.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Prod.instNonAssocSemiringProd.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Prod.instSemiringProd.{u2, u1} S R (Ring.toSemiring.{u2} S _inst_2) (Ring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{max u1 u2, max u1 u2} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.instNonAssocSemiringProd.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Prod.instNonAssocSemiringProd.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (RingHomClass.toRingHom.{max u1 u2, max u1 u2, max u1 u2} (RingEquiv.{max u2 u1, max u1 u2} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.instMulProd.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))))) (Prod.instMulProd.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Prod.instAddSum.{u1, u2} R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))))) (Prod.instAddSum.{u2, u1} S R (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.instNonAssocSemiringProd.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Prod.instNonAssocSemiringProd.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingEquivClass.toRingHomClass.{max u1 u2, max u1 u2, max u1 u2} (RingEquiv.{max u2 u1, max u1 u2} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.instMulProd.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))))) (Prod.instMulProd.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Prod.instAddSum.{u1, u2} R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))))) (Prod.instAddSum.{u2, u1} S R (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.instNonAssocSemiringProd.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Prod.instNonAssocSemiringProd.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingEquiv.instRingEquivClassRingEquiv.{max u1 u2, max u1 u2} (Prod.{u1, u2} R S) (Prod.{u2, u1} S R) (Prod.instMulProd.{u1, u2} R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))))) (Prod.instMulProd.{u2, u1} S R (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Prod.instAddSum.{u1, u2} R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))))) (Prod.instAddSum.{u2, u1} S R (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))))) (RingEquiv.prodComm.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I J)) (Ideal.prod.{u2, u1} S R _inst_2 _inst_1 J I)
Case conversion may be inaccurate. Consider using '#align ideal.map_prod_comm_prod Ideal.map_prodComm_prodₓ'. -/
@[simp]
theorem map_prodComm_prod :
    map ((RingEquiv.prodComm : R × S ≃+* S × R) : R × S →+* S × R) (prod I J) = prod J I :=
  by
  refine' trans (ideal_prod_eq _) _
  simp [map_map]
#align ideal.map_prod_comm_prod Ideal.map_prodComm_prod

/- warning: ideal.ideal_prod_equiv -> Ideal.idealProdEquiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S], Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) (Prod.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S], Equiv.{succ (max u2 u1), max (succ u2) (succ u1)} (Ideal.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) (Prod.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)))
Case conversion may be inaccurate. Consider using '#align ideal.ideal_prod_equiv Ideal.idealProdEquivₓ'. -/
/-- Ideals of `R × S` are in one-to-one correspondence with pairs of ideals of `R` and ideals of
    `S`. -/
def idealProdEquiv : Ideal (R × S) ≃ Ideal R × Ideal S
    where
  toFun I := ⟨map (RingHom.fst R S) I, map (RingHom.snd R S) I⟩
  invFun I := prod I.1 I.2
  left_inv I := (ideal_prod_eq I).symm
  right_inv := fun ⟨I, J⟩ => by simp
#align ideal.ideal_prod_equiv Ideal.idealProdEquiv

/- warning: ideal.ideal_prod_equiv_symm_apply -> Ideal.idealProdEquiv_symm_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)), Eq.{succ (max u1 u2)} (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (Prod.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)))) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (Prod.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)))) => (Prod.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2))) -> (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (Prod.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)))) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) (Prod.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Ideal.idealProdEquiv.{u1, u2} R S _inst_1 _inst_2)) (Prod.mk.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) I J)) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I J)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2))) => Ideal.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) (Prod.mk.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) I J)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Prod.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Ideal.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)))) (Prod.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (fun (_x : Prod.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2))) => Ideal.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Prod.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Ideal.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)))) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Ideal.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) (Prod.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Ideal.idealProdEquiv.{u1, u2} R S _inst_1 _inst_2)) (Prod.mk.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) I J)) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I J)
Case conversion may be inaccurate. Consider using '#align ideal.ideal_prod_equiv_symm_apply Ideal.idealProdEquiv_symm_applyₓ'. -/
@[simp]
theorem idealProdEquiv_symm_apply (I : Ideal R) (J : Ideal S) :
    idealProdEquiv.symm ⟨I, J⟩ = prod I J :=
  rfl
#align ideal.ideal_prod_equiv_symm_apply Ideal.idealProdEquiv_symm_apply

/- warning: ideal.prod.ext_iff -> Ideal.prod.ext_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)} {I' : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)} {J' : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)}, Iff (Eq.{succ (max u1 u2)} (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I J) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I' J')) (And (Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) I I') (Eq.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) J J'))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)} {I' : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)} {J' : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)}, Iff (Eq.{max (succ u1) (succ u2)} (Ideal.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I J) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I' J')) (And (Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) I I') (Eq.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) J J'))
Case conversion may be inaccurate. Consider using '#align ideal.prod.ext_iff Ideal.prod.ext_iffₓ'. -/
theorem prod.ext_iff {I I' : Ideal R} {J J' : Ideal S} : prod I J = prod I' J' ↔ I = I' ∧ J = J' :=
  by
  simp only [← ideal_prod_equiv_symm_apply, ideal_prod_equiv.symm.injective.eq_iff, Prod.mk.inj_iff]
#align ideal.prod.ext_iff Ideal.prod.ext_iff

/- warning: ideal.is_prime_of_is_prime_prod_top -> Ideal.isPrime_of_isPrime_prod_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)}, (Ideal.IsPrime.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I (Top.top.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.hasTop.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2)))))) -> (Ideal.IsPrime.{u1} R (Ring.toSemiring.{u1} R _inst_1) I)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)}, (Ideal.IsPrime.{max u1 u2} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I (Top.top.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.instTopSubmodule.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2)))))) -> (Ideal.IsPrime.{u1} R (Ring.toSemiring.{u1} R _inst_1) I)
Case conversion may be inaccurate. Consider using '#align ideal.is_prime_of_is_prime_prod_top Ideal.isPrime_of_isPrime_prod_topₓ'. -/
theorem isPrime_of_isPrime_prod_top {I : Ideal R} (h : (Ideal.prod I (⊤ : Ideal S)).IsPrime) :
    I.IsPrime := by
  constructor
  · contrapose! h
    simp [is_prime_iff, h]
  · intro x y hxy
    have : (⟨x, 1⟩ : R × S) * ⟨y, 1⟩ ∈ Prod I ⊤ :=
      by
      rw [Prod.mk_mul_mk, mul_one, mem_prod]
      exact ⟨hxy, trivial⟩
    simpa using h.mem_or_mem this
#align ideal.is_prime_of_is_prime_prod_top Ideal.isPrime_of_isPrime_prod_top

/- warning: ideal.is_prime_of_is_prime_prod_top' -> Ideal.isPrime_of_isPrime_prod_top' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] {I : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)}, (Ideal.IsPrime.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) I)) -> (Ideal.IsPrime.{u2} S (Ring.toSemiring.{u2} S _inst_2) I)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] {I : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)}, (Ideal.IsPrime.{max u1 u2} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) I)) -> (Ideal.IsPrime.{u2} S (Ring.toSemiring.{u2} S _inst_2) I)
Case conversion may be inaccurate. Consider using '#align ideal.is_prime_of_is_prime_prod_top' Ideal.isPrime_of_isPrime_prod_top'ₓ'. -/
theorem isPrime_of_isPrime_prod_top' {I : Ideal S} (h : (Ideal.prod (⊤ : Ideal R) I).IsPrime) :
    I.IsPrime := by
  apply @is_prime_of_is_prime_prod_top _ R
  rw [← map_prod_comm_prod]
  exact map_is_prime_of_equiv _
#align ideal.is_prime_of_is_prime_prod_top' Ideal.isPrime_of_isPrime_prod_top'

/- warning: ideal.is_prime_ideal_prod_top -> Ideal.isPrime_ideal_prod_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)} [h : Ideal.IsPrime.{u1} R (Ring.toSemiring.{u1} R _inst_1) I], Ideal.IsPrime.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I (Top.top.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.hasTop.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2)))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)} [h : Ideal.IsPrime.{u1} R (Ring.toSemiring.{u1} R _inst_1) I], Ideal.IsPrime.{max u1 u2} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I (Top.top.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.instTopSubmodule.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2)))))
Case conversion may be inaccurate. Consider using '#align ideal.is_prime_ideal_prod_top Ideal.isPrime_ideal_prod_topₓ'. -/
theorem isPrime_ideal_prod_top {I : Ideal R} [h : I.IsPrime] : (prod I (⊤ : Ideal S)).IsPrime :=
  by
  constructor
  · rcases h with ⟨h, -⟩
    contrapose! h
    rw [← prod_top_top, Prod.ext_iff] at h
    exact h.1
  rintro ⟨r₁, s₁⟩ ⟨r₂, s₂⟩ ⟨h₁, h₂⟩
  cases' h.mem_or_mem h₁ with h h
  · exact Or.inl ⟨h, trivial⟩
  · exact Or.inr ⟨h, trivial⟩
#align ideal.is_prime_ideal_prod_top Ideal.isPrime_ideal_prod_top

/- warning: ideal.is_prime_ideal_prod_top' -> Ideal.isPrime_ideal_prod_top' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] {I : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)} [h : Ideal.IsPrime.{u2} S (Ring.toSemiring.{u2} S _inst_2) I], Ideal.IsPrime.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) I)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] {I : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)} [h : Ideal.IsPrime.{u2} S (Ring.toSemiring.{u2} S _inst_2) I], Ideal.IsPrime.{max u1 u2} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) I)
Case conversion may be inaccurate. Consider using '#align ideal.is_prime_ideal_prod_top' Ideal.isPrime_ideal_prod_top'ₓ'. -/
theorem isPrime_ideal_prod_top' {I : Ideal S} [h : I.IsPrime] : (prod (⊤ : Ideal R) I).IsPrime :=
  by
  rw [← map_prod_comm_prod]
  apply map_is_prime_of_equiv _
  exact is_prime_ideal_prod_top
#align ideal.is_prime_ideal_prod_top' Ideal.isPrime_ideal_prod_top'

/- warning: ideal.ideal_prod_prime_aux -> Ideal.ideal_prod_prime_aux is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)}, (Ideal.IsPrime.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I J)) -> (Or (Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) I (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Eq.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) J (Top.top.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.hasTop.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)}, (Ideal.IsPrime.{max u1 u2} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 I J)) -> (Or (Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) I (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Eq.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) J (Top.top.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.instTopSubmodule.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))))
Case conversion may be inaccurate. Consider using '#align ideal.ideal_prod_prime_aux Ideal.ideal_prod_prime_auxₓ'. -/
theorem ideal_prod_prime_aux {I : Ideal R} {J : Ideal S} :
    (Ideal.prod I J).IsPrime → I = ⊤ ∨ J = ⊤ :=
  by
  contrapose!
  simp only [ne_top_iff_one, is_prime_iff, not_and, not_forall, not_or]
  exact fun ⟨hI, hJ⟩ hIJ => ⟨⟨0, 1⟩, ⟨1, 0⟩, by simp, by simp [hJ], by simp [hI]⟩
#align ideal.ideal_prod_prime_aux Ideal.ideal_prod_prime_aux

/- warning: ideal.ideal_prod_prime -> Ideal.ideal_prod_prime is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))), Iff (Ideal.IsPrime.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) I) (Or (Exists.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (fun (p : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) => And (Ideal.IsPrime.{u1} R (Ring.toSemiring.{u1} R _inst_1) p) (Eq.{succ (max u1 u2)} (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) I (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 p (Top.top.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.hasTop.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2)))))))) (Exists.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (fun (p : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) => And (Ideal.IsPrime.{u2} S (Ring.toSemiring.{u2} S _inst_2) p) (Eq.{succ (max u1 u2)} (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.semiring.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) I (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) p)))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))), Iff (Ideal.IsPrime.{max u1 u2} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2)) I) (Or (Exists.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (fun (p : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) => And (Ideal.IsPrime.{u1} R (Ring.toSemiring.{u1} R _inst_1) p) (Eq.{max (succ u1) (succ u2)} (Ideal.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) I (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 p (Top.top.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.instTopSubmodule.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2)))))))) (Exists.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (fun (p : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) => And (Ideal.IsPrime.{u2} S (Ring.toSemiring.{u2} S _inst_2) p) (Eq.{max (succ u1) (succ u2)} (Ideal.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instSemiringProd.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2))) I (Ideal.prod.{u1, u2} R S _inst_1 _inst_2 (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) p)))))
Case conversion may be inaccurate. Consider using '#align ideal.ideal_prod_prime Ideal.ideal_prod_primeₓ'. -/
/-- Classification of prime ideals in product rings: the prime ideals of `R × S` are precisely the
    ideals of the form `p × S` or `R × p`, where `p` is a prime ideal of `R` or `S`. -/
theorem ideal_prod_prime (I : Ideal (R × S)) :
    I.IsPrime ↔
      (∃ p : Ideal R, p.IsPrime ∧ I = Ideal.prod p ⊤) ∨
        ∃ p : Ideal S, p.IsPrime ∧ I = Ideal.prod ⊤ p :=
  by
  constructor
  · rw [ideal_prod_eq I]
    intro hI
    rcases ideal_prod_prime_aux hI with (h | h)
    · right
      rw [h] at hI⊢
      exact ⟨_, ⟨is_prime_of_is_prime_prod_top' hI, rfl⟩⟩
    · left
      rw [h] at hI⊢
      exact ⟨_, ⟨is_prime_of_is_prime_prod_top hI, rfl⟩⟩
  · rintro (⟨p, ⟨h, rfl⟩⟩ | ⟨p, ⟨h, rfl⟩⟩)
    · exact is_prime_ideal_prod_top
    · exact is_prime_ideal_prod_top'
#align ideal.ideal_prod_prime Ideal.ideal_prod_prime

end Ideal

