/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau

! This file was ported from Lean 3 source module ring_theory.ideal.operations
! leanprover-community/mathlib commit 69c6a5a12d8a2b159f20933e60115a4f2de62b58
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Algebra.Operations
import Mathbin.Algebra.Ring.Equiv
import Mathbin.Data.Nat.Choose.Sum
import Mathbin.LinearAlgebra.Basis.Bilinear
import Mathbin.RingTheory.Coprime.Lemmas
import Mathbin.RingTheory.Ideal.Basic
import Mathbin.RingTheory.NonZeroDivisors

/-!
# More operations on modules and ideals

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.
-/


universe u v w x

open BigOperators Pointwise

namespace Submodule

variable {R : Type u} {M : Type v} {F : Type _} {G : Type _}

section CommSemiring

variable [CommSemiring R] [AddCommMonoid M] [Module R M]

open Pointwise

#print Submodule.hasSmul' /-
instance hasSmul' : SMul (Ideal R) (Submodule R M) :=
  ⟨Submodule.map₂ (LinearMap.lsmul R M)⟩
#align submodule.has_smul' Submodule.hasSmul'
-/

#print Ideal.smul_eq_mul /-
/-- This duplicates the global `smul_eq_mul`, but doesn't have to unfold anywhere near as much to
apply. -/
protected theorem Ideal.smul_eq_mul (I J : Ideal R) : I • J = I * J :=
  rfl
#align ideal.smul_eq_mul Ideal.smul_eq_mul
-/

#print Submodule.annihilator /-
/-- `N.annihilator` is the ideal of all elements `r : R` such that `r • N = 0`. -/
def annihilator (N : Submodule R M) : Ideal R :=
  (LinearMap.lsmul R N).ker
#align submodule.annihilator Submodule.annihilator
-/

variable {I J : Ideal R} {N P : Submodule R M}

/- warning: submodule.mem_annihilator -> Submodule.mem_annihilator is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3} {r : R}, Iff (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 N)) (forall (n : M), (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) n N) -> (Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) r n) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3} {r : R}, Iff (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 N)) (forall (n : M), (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) n N) -> (Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) r n) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))
Case conversion may be inaccurate. Consider using '#align submodule.mem_annihilator Submodule.mem_annihilatorₓ'. -/
theorem mem_annihilator {r} : r ∈ N.annihilator ↔ ∀ n ∈ N, r • n = (0 : M) :=
  ⟨fun hr n hn => congr_arg Subtype.val (LinearMap.ext_iff.1 (LinearMap.mem_ker.1 hr) ⟨n, hn⟩),
    fun h => LinearMap.mem_ker.2 <| LinearMap.ext fun n => Subtype.eq <| h n.1 n.2⟩
#align submodule.mem_annihilator Submodule.mem_annihilator

/- warning: submodule.mem_annihilator' -> Submodule.mem_annihilator' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3} {r : R}, Iff (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 N)) (LE.le.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) N (Submodule.comap.{u1, u1, u2, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M _inst_2 _inst_2 _inst_3 _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (SMul.smul.{u1, u2} R (LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M _inst_2 _inst_2 _inst_3 _inst_3) (LinearMap.hasSmul.{u1, u1, u1, u2, u2} R R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Module.toDistribMulAction.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (smulCommClass_self.{u1, u2} R M (CommSemiring.toCommMonoid.{u1} R _inst_1) (MulActionWithZero.toMulAction.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) r (LinearMap.id.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Bot.bot.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasBot.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3} {r : R}, Iff (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 N)) (LE.le.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) N (Submodule.comap.{u1, u1, u2, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M _inst_2 _inst_2 _inst_3 _inst_3) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (HSMul.hSMul.{u1, u2, u2} R (LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M _inst_2 _inst_2 _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M _inst_2 _inst_2 _inst_3 _inst_3) (instHSMul.{u1, u2} R (LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M _inst_2 _inst_2 _inst_3 _inst_3) (LinearMap.instSMulLinearMap.{u1, u1, u1, u2, u2} R R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Module.toDistribMulAction.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (smulCommClass_self.{u1, u2} R M (CommSemiring.toCommMonoid.{u1} R _inst_1) (MulActionWithZero.toMulAction.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) r (LinearMap.id.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Bot.bot.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.instBotSubmodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))
Case conversion may be inaccurate. Consider using '#align submodule.mem_annihilator' Submodule.mem_annihilator'ₓ'. -/
theorem mem_annihilator' {r} : r ∈ N.annihilator ↔ N ≤ comap (r • (LinearMap.id : M →ₗ[R] M)) ⊥ :=
  mem_annihilator.trans ⟨fun H n hn => (mem_bot R).2 <| H n hn, fun H n hn => (mem_bot R).1 <| H hn⟩
#align submodule.mem_annihilator' Submodule.mem_annihilator'

/- warning: submodule.mem_annihilator_span -> Submodule.mem_annihilator_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (s : Set.{u2} M) (r : R), Iff (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 s))) (forall (n : coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s), Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) r ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x s))))) n)) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (s : Set.{u2} M) (r : R), Iff (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 s))) (forall (n : Set.Elem.{u2} M s), Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) r (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x s) n)) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align submodule.mem_annihilator_span Submodule.mem_annihilator_spanₓ'. -/
theorem mem_annihilator_span (s : Set M) (r : R) :
    r ∈ (Submodule.span R s).annihilator ↔ ∀ n : s, r • (n : M) = 0 :=
  by
  rw [Submodule.mem_annihilator]
  constructor
  · intro h n
    exact h _ (Submodule.subset_span n.prop)
  · intro h n hn
    apply Submodule.span_induction hn
    · intro x hx
      exact h ⟨x, hx⟩
    · exact smul_zero _
    · intro x y hx hy
      rw [smul_add, hx, hy, zero_add]
    · intro a x hx
      rw [smul_comm, hx, smul_zero]
#align submodule.mem_annihilator_span Submodule.mem_annihilator_span

/- warning: submodule.mem_annihilator_span_singleton -> Submodule.mem_annihilator_span_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (g : M) (r : R), Iff (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) g)))) (Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) r g) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (g : M) (r : R), Iff (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) g)))) (Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) r g) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align submodule.mem_annihilator_span_singleton Submodule.mem_annihilator_span_singletonₓ'. -/
theorem mem_annihilator_span_singleton (g : M) (r : R) :
    r ∈ (Submodule.span R ({g} : Set M)).annihilator ↔ r • g = 0 := by simp [mem_annihilator_span]
#align submodule.mem_annihilator_span_singleton Submodule.mem_annihilator_span_singleton

/- warning: submodule.annihilator_bot -> Submodule.annihilator_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2], Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Bot.bot.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasBot.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2], Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Bot.bot.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.instBotSubmodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align submodule.annihilator_bot Submodule.annihilator_botₓ'. -/
theorem annihilator_bot : (⊥ : Submodule R M).annihilator = ⊤ :=
  (Ideal.eq_top_iff_one _).2 <| mem_annihilator'.2 bot_le
#align submodule.annihilator_bot Submodule.annihilator_bot

/- warning: submodule.annihilator_eq_top_iff -> Submodule.annihilator_eq_top_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3}, Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 N) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) N (Bot.bot.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasBot.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3}, Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 N) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) N (Bot.bot.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.instBotSubmodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align submodule.annihilator_eq_top_iff Submodule.annihilator_eq_top_iffₓ'. -/
theorem annihilator_eq_top_iff : N.annihilator = ⊤ ↔ N = ⊥ :=
  ⟨fun H =>
    eq_bot_iff.2 fun (n : M) hn =>
      (mem_bot R).2 <| one_smul R n ▸ mem_annihilator.1 ((Ideal.eq_top_iff_one _).1 H) n hn,
    fun H => H.symm ▸ annihilator_bot⟩
#align submodule.annihilator_eq_top_iff Submodule.annihilator_eq_top_iff

#print Submodule.annihilator_mono /-
theorem annihilator_mono (h : N ≤ P) : P.annihilator ≤ N.annihilator := fun r hrp =>
  mem_annihilator.2 fun n hn => mem_annihilator.1 hrp n <| h hn
#align submodule.annihilator_mono Submodule.annihilator_mono
-/

/- warning: submodule.annihilator_supr -> Submodule.annihilator_supᵢ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (ι : Sort.{u3}) (f : ι -> (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 (supᵢ.{u2, u3} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) ι (fun (i : ι) => f i))) (infᵢ.{u1, u3} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasInf.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) ι (fun (i : ι) => Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 (f i)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (ι : Sort.{u3}) (f : ι -> (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 (supᵢ.{u2, u3} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) ι (fun (i : ι) => f i))) (infᵢ.{u1, u3} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instInfSetSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) ι (fun (i : ι) => Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 (f i)))
Case conversion may be inaccurate. Consider using '#align submodule.annihilator_supr Submodule.annihilator_supᵢₓ'. -/
theorem annihilator_supᵢ (ι : Sort w) (f : ι → Submodule R M) :
    annihilator (⨆ i, f i) = ⨅ i, annihilator (f i) :=
  le_antisymm (le_infᵢ fun i => annihilator_mono <| le_supᵢ _ _) fun r H =>
    mem_annihilator'.2 <|
      supᵢ_le fun i =>
        have := (mem_infᵢ _).1 H i
        mem_annihilator'.1 this
#align submodule.annihilator_supr Submodule.annihilator_supᵢ

#print Submodule.smul_mem_smul /-
theorem smul_mem_smul {r} {n} (hr : r ∈ I) (hn : n ∈ N) : r • n ∈ I • N :=
  apply_mem_map₂ _ hr hn
#align submodule.smul_mem_smul Submodule.smul_mem_smul
-/

#print Submodule.smul_le /-
theorem smul_le {P : Submodule R M} : I • N ≤ P ↔ ∀ r ∈ I, ∀ n ∈ N, r • n ∈ P :=
  map₂_le
#align submodule.smul_le Submodule.smul_le
-/

/- warning: submodule.smul_induction_on -> Submodule.smul_induction_on is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3} {p : M -> Prop} {x : M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I N)) -> (forall (r : R), (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r I) -> (forall (n : M), (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) n N) -> (p (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) r n)))) -> (forall (x : M) (y : M), (p x) -> (p y) -> (p (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x y))) -> (p x)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3} {p : M -> Prop} {x : M}, (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3)) I N)) -> (forall (r : R), (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r I) -> (forall (n : M), (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) n N) -> (p (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) r n)))) -> (forall (x : M) (y : M), (p x) -> (p y) -> (p (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x y))) -> (p x)
Case conversion may be inaccurate. Consider using '#align submodule.smul_induction_on Submodule.smul_induction_onₓ'. -/
@[elab_as_elim]
theorem smul_induction_on {p : M → Prop} {x} (H : x ∈ I • N) (Hb : ∀ r ∈ I, ∀ n ∈ N, p (r • n))
    (H1 : ∀ x y, p x → p y → p (x + y)) : p x :=
  by
  have H0 : p 0 := by simpa only [zero_smul] using Hb 0 I.zero_mem 0 N.zero_mem
  refine' Submodule.supᵢ_induction _ H _ H0 H1
  rintro ⟨i, hi⟩ m ⟨j, hj, rfl : i • _ = m⟩
  exact Hb _ hi _ hj
#align submodule.smul_induction_on Submodule.smul_induction_on

/- warning: submodule.smul_induction_on' -> Submodule.smul_induction_on' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3} {x : M} (hx : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I N)) {p : forall (x : M), (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I N)) -> Prop}, (forall (r : R) (hr : Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r I) (n : M) (hn : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) n N), p (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) r n) (Submodule.smul_mem_smul.{u1, u2} R M _inst_1 _inst_2 _inst_3 I N r n hr hn)) -> (forall (x : M) (hx : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I N)) (y : M) (hy : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) y (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I N)), (p x hx) -> (p y hy) -> (p (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x y) (Submodule.add_mem.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I N) x y hx hy))) -> (p x hx)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3} {x : M} (hx : Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3)) I N)) {p : forall (x : M), (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3)) I N)) -> Prop}, (forall (r : R) (hr : Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r I) (n : M) (hn : Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) n N), p (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) r n) (Submodule.smul_mem_smul.{u1, u2} R M _inst_1 _inst_2 _inst_3 I N r n hr hn)) -> (forall (x : M) (hx : Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3)) I N)) (y : M) (hy : Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) y (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3)) I N)), (p x hx) -> (p y hy) -> (p (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x y) (Submodule.add_mem.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3)) I N) x y hx hy))) -> (p x hx)
Case conversion may be inaccurate. Consider using '#align submodule.smul_induction_on' Submodule.smul_induction_on'ₓ'. -/
/-- Dependent version of `submodule.smul_induction_on`. -/
@[elab_as_elim]
theorem smul_induction_on' {x : M} (hx : x ∈ I • N) {p : ∀ x, x ∈ I • N → Prop}
    (Hb : ∀ (r : R) (hr : r ∈ I) (n : M) (hn : n ∈ N), p (r • n) (smul_mem_smul hr hn))
    (H1 : ∀ x hx y hy, p x hx → p y hy → p (x + y) (Submodule.add_mem _ ‹_› ‹_›)) : p x hx :=
  by
  refine' Exists.elim _ fun (h : x ∈ I • N) (H : p x h) => H
  exact
    smul_induction_on hx (fun a ha x hx => ⟨_, Hb _ ha _ hx⟩) fun x y ⟨_, hx⟩ ⟨_, hy⟩ =>
      ⟨_, H1 _ _ _ _ hx hy⟩
#align submodule.smul_induction_on' Submodule.smul_induction_on'

/- warning: submodule.mem_smul_span_singleton -> Submodule.mem_smul_span_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {m : M} {x : M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I (Submodule.span.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) m)))) (Exists.{succ u1} R (fun (y : R) => Exists.{0} (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) y I) (fun (H : Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) y I) => Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) y m) x)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {m : M} {x : M}, Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3)) I (Submodule.span.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) m)))) (Exists.{succ u1} R (fun (y : R) => And (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) y I) (Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) y m) x)))
Case conversion may be inaccurate. Consider using '#align submodule.mem_smul_span_singleton Submodule.mem_smul_span_singletonₓ'. -/
theorem mem_smul_span_singleton {I : Ideal R} {m : M} {x : M} :
    x ∈ I • span R ({m} : Set M) ↔ ∃ y ∈ I, y • m = x :=
  ⟨fun hx =>
    smul_induction_on hx
      (fun r hri n hnm =>
        let ⟨s, hs⟩ := mem_span_singleton.1 hnm
        ⟨r * s, I.mul_mem_right _ hri, hs ▸ mul_smul r s m⟩)
      fun m1 m2 ⟨y1, hyi1, hy1⟩ ⟨y2, hyi2, hy2⟩ =>
      ⟨y1 + y2, I.add_mem hyi1 hyi2, by rw [add_smul, hy1, hy2]⟩,
    fun ⟨y, hyi, hy⟩ => hy ▸ smul_mem_smul hyi (subset_span <| Set.mem_singleton m)⟩
#align submodule.mem_smul_span_singleton Submodule.mem_smul_span_singleton

#print Submodule.smul_le_right /-
theorem smul_le_right : I • N ≤ N :=
  smul_le.2 fun r hr n => N.smul_mem r
#align submodule.smul_le_right Submodule.smul_le_right
-/

#print Submodule.smul_mono /-
theorem smul_mono (hij : I ≤ J) (hnp : N ≤ P) : I • N ≤ J • P :=
  map₂_le_map₂ hij hnp
#align submodule.smul_mono Submodule.smul_mono
-/

#print Submodule.smul_mono_left /-
theorem smul_mono_left (h : I ≤ J) : I • N ≤ J • N :=
  map₂_le_map₂_left h
#align submodule.smul_mono_left Submodule.smul_mono_left
-/

#print Submodule.smul_mono_right /-
theorem smul_mono_right (h : N ≤ P) : I • N ≤ I • P :=
  map₂_le_map₂_right h
#align submodule.smul_mono_right Submodule.smul_mono_right
-/

/- warning: submodule.map_le_smul_top -> Submodule.map_le_smul_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (f : LinearMap.{u1, u1, u1, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) _inst_2 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) _inst_3), LE.le.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) (Submodule.map.{u1, u1, u1, u2, max u1 u2} R R R M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) _inst_2 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u1, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) _inst_2 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u1, u2} R R R M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) _inst_2 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f I) (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I (Top.top.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasTop.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (f : LinearMap.{u1, u1, u1, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) _inst_2 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) _inst_3), LE.le.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) (Submodule.map.{u1, u1, u1, u2, max u1 u2} R R R M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) _inst_2 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u1, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) _inst_2 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) _inst_3) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u1, u2} R R R M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) _inst_2 (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f I) (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3)) I (Top.top.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.instTopSubmodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align submodule.map_le_smul_top Submodule.map_le_smul_topₓ'. -/
theorem map_le_smul_top (I : Ideal R) (f : R →ₗ[R] M) :
    Submodule.map f I ≤ I • (⊤ : Submodule R M) :=
  by
  rintro _ ⟨y, hy, rfl⟩
  rw [← mul_one y, ← smul_eq_mul, f.map_smul]
  exact smul_mem_smul hy mem_top
#align submodule.map_le_smul_top Submodule.map_le_smul_top

/- warning: submodule.annihilator_smul -> Submodule.annihilator_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3), Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 N) N) (Bot.bot.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasBot.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3), Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.annihilator.{u1, u2} R M _inst_1 _inst_2 _inst_3 N) N) (Bot.bot.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.instBotSubmodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.annihilator_smul Submodule.annihilator_smulₓ'. -/
@[simp]
theorem annihilator_smul (N : Submodule R M) : annihilator N • N = ⊥ :=
  eq_bot_iff.2 (smul_le.2 fun r => mem_annihilator.1)
#align submodule.annihilator_smul Submodule.annihilator_smul

/- warning: submodule.annihilator_mul -> Submodule.annihilator_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.mul.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))) (Submodule.annihilator.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) I) I) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasBot.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.mul.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))) (Submodule.annihilator.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) I) I) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instBotSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align submodule.annihilator_mul Submodule.annihilator_mulₓ'. -/
@[simp]
theorem annihilator_mul (I : Ideal R) : annihilator I * I = ⊥ :=
  annihilator_smul I
#align submodule.annihilator_mul Submodule.annihilator_mul

/- warning: submodule.mul_annihilator -> Submodule.mul_annihilator is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.mul.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))) I (Submodule.annihilator.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) I)) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasBot.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.mul.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))) I (Submodule.annihilator.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) I)) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instBotSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align submodule.mul_annihilator Submodule.mul_annihilatorₓ'. -/
@[simp]
theorem mul_annihilator (I : Ideal R) : I * annihilator I = ⊥ := by rw [mul_comm, annihilator_mul]
#align submodule.mul_annihilator Submodule.mul_annihilator

variable (I J N P)

#print Submodule.smul_bot /-
@[simp]
theorem smul_bot : I • (⊥ : Submodule R M) = ⊥ :=
  map₂_bot_right _ _
#align submodule.smul_bot Submodule.smul_bot
-/

/- warning: submodule.bot_smul -> Submodule.bot_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3), Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasBot.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) N) (Bot.bot.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasBot.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3), Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instBotSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) N) (Bot.bot.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.instBotSubmodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.bot_smul Submodule.bot_smulₓ'. -/
@[simp]
theorem bot_smul : (⊥ : Ideal R) • N = ⊥ :=
  map₂_bot_left _ _
#align submodule.bot_smul Submodule.bot_smul

/- warning: submodule.top_smul -> Submodule.top_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3), Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) N) N
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3), Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) N) N
Case conversion may be inaccurate. Consider using '#align submodule.top_smul Submodule.top_smulₓ'. -/
@[simp]
theorem top_smul : (⊤ : Ideal R) • N = N :=
  le_antisymm smul_le_right fun r hri => one_smul R r ▸ smul_mem_smul mem_top hri
#align submodule.top_smul Submodule.top_smul

#print Submodule.smul_sup /-
theorem smul_sup : I • (N ⊔ P) = I • N ⊔ I • P :=
  map₂_sup_right _ _ _ _
#align submodule.smul_sup Submodule.smul_sup
-/

/- warning: submodule.sup_smul -> Submodule.sup_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3), Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I J) N) (Sup.sup.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I N) (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) J N))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3), Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I J) N) (Sup.sup.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SemilatticeSup.toSup.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3)) I N) (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3)) J N))
Case conversion may be inaccurate. Consider using '#align submodule.sup_smul Submodule.sup_smulₓ'. -/
theorem sup_smul : (I ⊔ J) • N = I • N ⊔ J • N :=
  map₂_sup_left _ _ _ _
#align submodule.sup_smul Submodule.sup_smul

#print Submodule.smul_assoc /-
protected theorem smul_assoc : (I • J) • N = I • J • N :=
  le_antisymm
    (smul_le.2 fun rs hrsij t htn =>
      smul_induction_on hrsij
        (fun r hr s hs =>
          (@smul_eq_mul R _ r s).symm ▸ smul_smul r s t ▸ smul_mem_smul hr (smul_mem_smul hs htn))
        fun x y => (add_smul x y t).symm ▸ Submodule.add_mem _)
    (smul_le.2 fun r hr sn hsn =>
      suffices J • N ≤ Submodule.comap (r • (LinearMap.id : M →ₗ[R] M)) ((I • J) • N) from this hsn
      smul_le.2 fun s hs n hn =>
        show r • s • n ∈ (I • J) • N from mul_smul r s n ▸ smul_mem_smul (smul_mem_smul hr hs) hn)
#align submodule.smul_assoc Submodule.smul_assoc
-/

#print Submodule.smul_inf_le /-
theorem smul_inf_le (M₁ M₂ : Submodule R M) : I • (M₁ ⊓ M₂) ≤ I • M₁ ⊓ I • M₂ :=
  le_inf (Submodule.smul_mono_right inf_le_left) (Submodule.smul_mono_right inf_le_right)
#align submodule.smul_inf_le Submodule.smul_inf_le
-/

/- warning: submodule.smul_supr -> Submodule.smul_supᵢ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {ι : Sort.{u3}} {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {t : ι -> (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)}, Eq.{succ u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I (supᵢ.{u2, u3} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) ι t)) (supᵢ.{u2, u3} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) ι (fun (i : ι) => SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I (t i)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] {ι : Sort.{u1}} {I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)} {t : ι -> (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3)}, Eq.{succ u3} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (HSMul.hSMul.{u2, u3, u3} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (instHSMul.{u2, u3} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u2, u3} R M _inst_1 _inst_2 _inst_3)) I (supᵢ.{u3, u1} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u3} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3))) ι t)) (supᵢ.{u3, u1} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u3} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3))) ι (fun (i : ι) => HSMul.hSMul.{u2, u3, u3} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (instHSMul.{u2, u3} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u2, u3} R M _inst_1 _inst_2 _inst_3)) I (t i)))
Case conversion may be inaccurate. Consider using '#align submodule.smul_supr Submodule.smul_supᵢₓ'. -/
theorem smul_supᵢ {ι : Sort _} {I : Ideal R} {t : ι → Submodule R M} : I • supᵢ t = ⨆ i, I • t i :=
  map₂_supᵢ_right _ _ _
#align submodule.smul_supr Submodule.smul_supᵢ

/- warning: submodule.smul_infi_le -> Submodule.smul_infᵢ_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {ι : Sort.{u3}} {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {t : ι -> (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)}, LE.le.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I (infᵢ.{u2, u3} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasInf.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) ι t)) (infᵢ.{u2, u3} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasInf.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) ι (fun (i : ι) => SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I (t i)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] {ι : Sort.{u1}} {I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)} {t : ι -> (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3)}, LE.le.{u3} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Preorder.toLE.{u3} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (PartialOrder.toPreorder.{u3} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.completeLattice.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3))))) (HSMul.hSMul.{u2, u3, u3} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (instHSMul.{u2, u3} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u2, u3} R M _inst_1 _inst_2 _inst_3)) I (infᵢ.{u3, u1} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.instInfSetSubmodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) ι t)) (infᵢ.{u3, u1} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.instInfSetSubmodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) ι (fun (i : ι) => HSMul.hSMul.{u2, u3, u3} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (instHSMul.{u2, u3} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u2, u3} R M _inst_1 _inst_2 _inst_3)) I (t i)))
Case conversion may be inaccurate. Consider using '#align submodule.smul_infi_le Submodule.smul_infᵢ_leₓ'. -/
theorem smul_infᵢ_le {ι : Sort _} {I : Ideal R} {t : ι → Submodule R M} :
    I • infᵢ t ≤ ⨅ i, I • t i :=
  le_infᵢ fun i => smul_mono_right (infᵢ_le _ _)
#align submodule.smul_infi_le Submodule.smul_infᵢ_le

variable (S : Set R) (T : Set M)

#print Submodule.span_smul_span /-
theorem span_smul_span : Ideal.span S • span R T = span R (⋃ (s ∈ S) (t ∈ T), {s • t}) :=
  (map₂_span_span _ _ _ _).trans <| congr_arg _ <| Set.image2_eq_unionᵢ _ _ _
#align submodule.span_smul_span Submodule.span_smul_span
-/

#print Submodule.ideal_span_singleton_smul /-
theorem ideal_span_singleton_smul (r : R) (N : Submodule R M) :
    (Ideal.span {r} : Ideal R) • N = r • N :=
  by
  have : span R (⋃ (t : M) (x : t ∈ N), {r • t}) = r • N :=
    by
    convert span_eq _
    exact (Set.image_eq_unionᵢ _ (N : Set M)).symm
  conv_lhs => rw [← span_eq N, span_smul_span]
  simpa
#align submodule.ideal_span_singleton_smul Submodule.ideal_span_singleton_smul
-/

/- warning: submodule.mem_of_span_top_of_smul_mem -> Submodule.mem_of_span_top_of_smul_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (M' : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (s : Set.{u1} R), (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) s) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (forall (x : M), (forall (r : coeSort.{succ u1, succ (succ u1)} (Set.{u1} R) Type.{u1} (Set.hasCoeToSort.{u1} R) s), Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} R) Type.{u1} (Set.hasCoeToSort.{u1} R) s) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} R) Type.{u1} (Set.hasCoeToSort.{u1} R) s) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} R) Type.{u1} (Set.hasCoeToSort.{u1} R) s) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} R) Type.{u1} (Set.hasCoeToSort.{u1} R) s) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) x s))))) r) x) M') -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x M'))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (M' : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (s : Set.{u1} R), (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) s) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (forall (x : M), (forall (r : Set.Elem.{u1} R s), Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x s) r) x) M') -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x M'))
Case conversion may be inaccurate. Consider using '#align submodule.mem_of_span_top_of_smul_mem Submodule.mem_of_span_top_of_smul_memₓ'. -/
theorem mem_of_span_top_of_smul_mem (M' : Submodule R M) (s : Set R) (hs : Ideal.span s = ⊤) (x : M)
    (H : ∀ r : s, (r : R) • x ∈ M') : x ∈ M' :=
  by
  suffices (⊤ : Ideal R) • span R ({x} : Set M) ≤ M'
    by
    rw [top_smul] at this
    exact this (subset_span (Set.mem_singleton x))
  rw [← hs, span_smul_span, span_le]
  simpa using H
#align submodule.mem_of_span_top_of_smul_mem Submodule.mem_of_span_top_of_smul_mem

/- warning: submodule.mem_of_span_eq_top_of_smul_pow_mem -> Submodule.mem_of_span_eq_top_of_smul_pow_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (M' : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (s : Set.{u1} R), (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) s) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (forall (x : M), (forall (r : coeSort.{succ u1, succ (succ u1)} (Set.{u1} R) Type.{u1} (Set.hasCoeToSort.{u1} R) s), Exists.{1} Nat (fun (n : Nat) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} R) Type.{u1} (Set.hasCoeToSort.{u1} R) s) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} R) Type.{u1} (Set.hasCoeToSort.{u1} R) s) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} R) Type.{u1} (Set.hasCoeToSort.{u1} R) s) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} R) Type.{u1} (Set.hasCoeToSort.{u1} R) s) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) x s))))) r) n) x) M')) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x M'))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (M' : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (s : Set.{u1} R), (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) s) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (forall (x : M), (forall (r : Set.Elem.{u1} R s), Exists.{1} Nat (fun (n : Nat) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x s) r) n) x) M')) -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x M'))
Case conversion may be inaccurate. Consider using '#align submodule.mem_of_span_eq_top_of_smul_pow_mem Submodule.mem_of_span_eq_top_of_smul_pow_memₓ'. -/
/-- Given `s`, a generating set of `R`, to check that an `x : M` falls in a
submodule `M'` of `x`, we only need to show that `r ^ n • x ∈ M'` for some `n` for each `r : s`. -/
theorem mem_of_span_eq_top_of_smul_pow_mem (M' : Submodule R M) (s : Set R) (hs : Ideal.span s = ⊤)
    (x : M) (H : ∀ r : s, ∃ n : ℕ, (r ^ n : R) • x ∈ M') : x ∈ M' :=
  by
  obtain ⟨s', hs₁, hs₂⟩ := (Ideal.span_eq_top_iff_finite _).mp hs
  replace H : ∀ r : s', ∃ n : ℕ, (r ^ n : R) • x ∈ M' := fun r => H ⟨_, hs₁ r.Prop⟩
  choose n₁ n₂ using H
  let N := s'.attach.sup n₁
  have hs' := Ideal.span_pow_eq_top (s' : Set R) hs₂ N
  apply M'.mem_of_span_top_of_smul_mem _ hs'
  rintro ⟨_, r, hr, rfl⟩
  convert M'.smul_mem (r ^ (N - n₁ ⟨r, hr⟩)) (n₂ ⟨r, hr⟩) using 1
  simp only [Subtype.coe_mk, smul_smul, ← pow_add]
  rw [tsub_add_cancel_of_le (Finset.le_sup (s'.mem_attach _) : n₁ ⟨r, hr⟩ ≤ N)]
#align submodule.mem_of_span_eq_top_of_smul_pow_mem Submodule.mem_of_span_eq_top_of_smul_pow_mem

variable {M' : Type w} [AddCommMonoid M'] [Module R M']

/- warning: submodule.map_smul'' -> Submodule.map_smul'' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) {M' : Type.{u3}} [_inst_4 : AddCommMonoid.{u3} M'] [_inst_5 : Module.{u1, u3} R M' (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4] (f : LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M' _inst_2 _inst_4 _inst_3 _inst_5), Eq.{succ u3} (Submodule.{u1, u3} R M' (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_5) (Submodule.map.{u1, u1, u2, u3, max u2 u3} R R M M' (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4 _inst_3 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M' _inst_2 _inst_4 _inst_3 _inst_5) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} R R M M' (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4 _inst_3 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I N)) (SMul.smul.{u1, u3} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u3} R M' (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_5) (Submodule.hasSmul'.{u1, u3} R M' _inst_1 _inst_4 _inst_5) I (Submodule.map.{u1, u1, u2, u3, max u2 u3} R R M M' (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4 _inst_3 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M' _inst_2 _inst_4 _inst_3 _inst_5) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} R R M M' (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4 _inst_3 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f N))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) {M' : Type.{u3}} [_inst_4 : AddCommMonoid.{u3} M'] [_inst_5 : Module.{u1, u3} R M' (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4] (f : LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M' _inst_2 _inst_4 _inst_3 _inst_5), Eq.{succ u3} (Submodule.{u1, u3} R M' (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_5) (Submodule.map.{u1, u1, u2, u3, max u2 u3} R R M M' (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4 _inst_3 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M' _inst_2 _inst_4 _inst_3 _inst_5) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u3} R R M M' (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4 _inst_3 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3)) I N)) (HSMul.hSMul.{u1, u3, u3} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u3} R M' (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_5) (Submodule.{u1, u3} R M' (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_5) (instHSMul.{u1, u3} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u3} R M' (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_5) (Submodule.hasSmul'.{u1, u3} R M' _inst_1 _inst_4 _inst_5)) I (Submodule.map.{u1, u1, u2, u3, max u2 u3} R R M M' (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4 _inst_3 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M' _inst_2 _inst_4 _inst_3 _inst_5) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u3} R R M M' (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4 _inst_3 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f N))
Case conversion may be inaccurate. Consider using '#align submodule.map_smul'' Submodule.map_smul''ₓ'. -/
theorem map_smul'' (f : M →ₗ[R] M') : (I • N).map f = I • N.map f :=
  le_antisymm
      (map_le_iff_le_comap.2 <|
        smul_le.2 fun r hr n hn =>
          show f (r • n) ∈ I • N.map f from
            (f.map_smul r n).symm ▸ smul_mem_smul hr (mem_map_of_mem hn)) <|
    smul_le.2 fun r hr n hn =>
      let ⟨p, hp, hfp⟩ := mem_map.1 hn
      hfp ▸ f.map_smul r p ▸ mem_map_of_mem (smul_mem_smul hr hp)
#align submodule.map_smul'' Submodule.map_smul''

variable {I}

#print Submodule.mem_smul_span /-
theorem mem_smul_span {s : Set M} {x : M} :
    x ∈ I • Submodule.span R s ↔ x ∈ Submodule.span R (⋃ (a ∈ I) (b ∈ s), ({a • b} : Set M)) := by
  rw [← I.span_eq, Submodule.span_smul_span, I.span_eq] <;> rfl
#align submodule.mem_smul_span Submodule.mem_smul_span
-/

variable (I)

/- warning: submodule.mem_ideal_smul_span_iff_exists_sum -> Submodule.mem_ideal_smul_span_iff_exists_sum is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) {ι : Type.{u3}} (f : ι -> M) (x : M), Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I (Submodule.span.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Set.range.{u2, succ u3} M ι f)))) (Exists.{max (succ u3) (succ u1)} (Finsupp.{u3, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (fun (a : Finsupp.{u3, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) => Exists.{0} (forall (i : ι), Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (Finsupp.{u3, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (fun (_x : Finsupp.{u3, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) => ι -> R) (Finsupp.coeFun.{u3, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) a i) I) (fun (ha : forall (i : ι), Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (Finsupp.{u3, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (fun (_x : Finsupp.{u3, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) => ι -> R) (Finsupp.coeFun.{u3, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) a i) I) => Eq.{succ u2} M (Finsupp.sum.{u3, u1, u2} ι R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) _inst_2 a (fun (i : ι) (c : R) => SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) c (f i))) x)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] (I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) {ι : Type.{u1}} (f : ι -> M) (x : M), Iff (Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3)) x (HSMul.hSMul.{u2, u3, u3} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (instHSMul.{u2, u3} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u2, u3} R M _inst_1 _inst_2 _inst_3)) I (Submodule.span.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3 (Set.range.{u3, succ u1} M ι f)))) (Exists.{max (succ u2) (succ u1)} (Finsupp.{u1, u2} ι R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1))) (fun (a : Finsupp.{u1, u2} ι R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1))) => Exists.{0} (forall (i : ι), Membership.mem.{u2, u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => R) i) (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} ι R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => R) _x) (Finsupp.funLike.{u1, u2} ι R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1))) a i) I) (fun (ha : forall (i : ι), Membership.mem.{u2, u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => R) i) (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} ι R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => R) _x) (Finsupp.funLike.{u1, u2} ι R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1))) a i) I) => Eq.{succ u3} M (Finsupp.sum.{u1, u2, u3} ι R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1)) _inst_2 a (fun (i : ι) (c : R) => HSMul.hSMul.{u2, u3, u3} R M M (instHSMul.{u2, u3} R M (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3))))) c (f i))) x)))
Case conversion may be inaccurate. Consider using '#align submodule.mem_ideal_smul_span_iff_exists_sum Submodule.mem_ideal_smul_span_iff_exists_sumₓ'. -/
/-- If `x` is an `I`-multiple of the submodule spanned by `f '' s`,
then we can write `x` as an `I`-linear combination of the elements of `f '' s`. -/
theorem mem_ideal_smul_span_iff_exists_sum {ι : Type _} (f : ι → M) (x : M) :
    x ∈ I • span R (Set.range f) ↔
      ∃ (a : ι →₀ R)(ha : ∀ i, a i ∈ I), (a.Sum fun i c => c • f i) = x :=
  by
  constructor; swap
  · rintro ⟨a, ha, rfl⟩
    exact Submodule.sum_mem _ fun c _ => smul_mem_smul (ha c) <| subset_span <| Set.mem_range_self _
  refine' fun hx => span_induction (mem_smul_span.mp hx) _ _ _ _
  · simp only [Set.mem_unionᵢ, Set.mem_range, Set.mem_singleton_iff]
    rintro x ⟨y, hy, x, ⟨i, rfl⟩, rfl⟩
    refine' ⟨Finsupp.single i y, fun j => _, _⟩
    · letI := Classical.decEq ι
      rw [Finsupp.single_apply]
      split_ifs
      · assumption
      · exact I.zero_mem
    refine' @Finsupp.sum_single_index ι R M _ _ i _ (fun i y => y • f i) _
    simp
  · exact ⟨0, fun i => I.zero_mem, Finsupp.sum_zero_index⟩
  · rintro x y ⟨ax, hax, rfl⟩ ⟨ay, hay, rfl⟩
    refine' ⟨ax + ay, fun i => I.add_mem (hax i) (hay i), Finsupp.sum_add_index' _ _⟩ <;> intros <;>
      simp only [zero_smul, add_smul]
  · rintro c x ⟨a, ha, rfl⟩
    refine' ⟨c • a, fun i => I.mul_mem_left c (ha i), _⟩
    rw [Finsupp.sum_smul_index, Finsupp.smul_sum] <;> intros <;> simp only [zero_smul, mul_smul]
#align submodule.mem_ideal_smul_span_iff_exists_sum Submodule.mem_ideal_smul_span_iff_exists_sum

/- warning: submodule.mem_ideal_smul_span_iff_exists_sum' -> Submodule.mem_ideal_smul_span_iff_exists_sum' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) {ι : Type.{u3}} (s : Set.{u3} ι) (f : ι -> M) (x : M), Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I (Submodule.span.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 (Set.image.{u3, u2} ι M f s)))) (Exists.{max (succ u3) (succ u1)} (Finsupp.{u3, u1} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (fun (a : Finsupp.{u3, u1} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) => Exists.{0} (forall (i : coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s), Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (Finsupp.{u3, u1} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (fun (_x : Finsupp.{u3, u1} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) => (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) -> R) (Finsupp.coeFun.{u3, u1} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) a i) I) (fun (ha : forall (i : coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s), Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (Finsupp.{u3, u1} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (fun (_x : Finsupp.{u3, u1} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) => (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) -> R) (Finsupp.coeFun.{u3, u1} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) a i) I) => Eq.{succ u2} M (Finsupp.sum.{u3, u1, u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) _inst_2 a (fun (i : coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) (c : R) => SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) c (f ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (coeSubtype.{succ u3} ι (fun (x : ι) => Membership.Mem.{u3, u3} ι (Set.{u3} ι) (Set.hasMem.{u3} ι) x s))))) i)))) x)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2] (I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) {ι : Type.{u1}} (s : Set.{u1} ι) (f : ι -> M) (x : M), Iff (Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3)) x (HSMul.hSMul.{u2, u3, u3} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (instHSMul.{u2, u3} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u2, u3} R M _inst_1 _inst_2 _inst_3)) I (Submodule.span.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3 (Set.image.{u1, u3} ι M f s)))) (Exists.{max (succ u2) (succ u1)} (Finsupp.{u1, u2} (Set.Elem.{u1} ι s) R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1))) (fun (a : Finsupp.{u1, u2} (Set.Elem.{u1} ι s) R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1))) => Exists.{0} (forall (i : Set.Elem.{u1} ι s), Membership.mem.{u2, u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Set.Elem.{u1} ι s) => R) i) (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} (Set.Elem.{u1} ι s) R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1))) (Set.Elem.{u1} ι s) (fun (_x : Set.Elem.{u1} ι s) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Set.Elem.{u1} ι s) => R) _x) (Finsupp.funLike.{u1, u2} (Set.Elem.{u1} ι s) R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1))) a i) I) (fun (ha : forall (i : Set.Elem.{u1} ι s), Membership.mem.{u2, u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Set.Elem.{u1} ι s) => R) i) (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} (Set.Elem.{u1} ι s) R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1))) (Set.Elem.{u1} ι s) (fun (_x : Set.Elem.{u1} ι s) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Set.Elem.{u1} ι s) => R) _x) (Finsupp.funLike.{u1, u2} (Set.Elem.{u1} ι s) R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1))) a i) I) => Eq.{succ u3} M (Finsupp.sum.{u1, u2, u3} (Set.Elem.{u1} ι s) R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1)) _inst_2 a (fun (i : Set.Elem.{u1} ι s) (c : R) => HSMul.hSMul.{u2, u3, u3} R M M (instHSMul.{u2, u3} R M (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Module.toMulActionWithZero.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_2 _inst_3))))) c (f (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x s) i)))) x)))
Case conversion may be inaccurate. Consider using '#align submodule.mem_ideal_smul_span_iff_exists_sum' Submodule.mem_ideal_smul_span_iff_exists_sum'ₓ'. -/
theorem mem_ideal_smul_span_iff_exists_sum' {ι : Type _} (s : Set ι) (f : ι → M) (x : M) :
    x ∈ I • span R (f '' s) ↔ ∃ (a : s →₀ R)(ha : ∀ i, a i ∈ I), (a.Sum fun i c => c • f i) = x :=
  by rw [← Submodule.mem_ideal_smul_span_iff_exists_sum, ← Set.image_eq_range]
#align submodule.mem_ideal_smul_span_iff_exists_sum' Submodule.mem_ideal_smul_span_iff_exists_sum'

/- warning: submodule.mem_smul_top_iff -> Submodule.mem_smul_top_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) N), Iff (Membership.Mem.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) N) (Submodule.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) N) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N)) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) N) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) N) (Submodule.setLike.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) N) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N))) x (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) N) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N)) (Submodule.hasSmul'.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) N) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N)) I (Top.top.{u2} (Submodule.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) N) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N)) (Submodule.hasTop.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) N) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N))))) (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) N) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) N) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) N) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) N) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x N))))) x) (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3) I N))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (N : Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x N)), Iff (Membership.mem.{u2, u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x N)) (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x N)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N)) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x N)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x N)) (Submodule.setLike.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x N)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N))) x (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x N)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N)) (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x N)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N)) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x N)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N)) (Submodule.hasSmul'.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x N)) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N))) I (Top.top.{u2} (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x N)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N)) (Submodule.instTopSubmodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) x N)) (CommSemiring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N) (Submodule.module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 N))))) (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) N)) x) (HSMul.hSMul.{u1, u2, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (instHSMul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Submodule.hasSmul'.{u1, u2} R M _inst_1 _inst_2 _inst_3)) I N))
Case conversion may be inaccurate. Consider using '#align submodule.mem_smul_top_iff Submodule.mem_smul_top_iffₓ'. -/
theorem mem_smul_top_iff (N : Submodule R M) (x : N) :
    x ∈ I • (⊤ : Submodule R N) ↔ (x : M) ∈ I • N :=
  by
  change _ ↔ N.subtype x ∈ I • N
  have : Submodule.map N.subtype (I • ⊤) = I • N := by
    rw [Submodule.map_smul'', Submodule.map_top, Submodule.range_subtype]
  rw [← this]
  convert(Function.Injective.mem_set_image N.injective_subtype).symm using 1
  rfl
#align submodule.mem_smul_top_iff Submodule.mem_smul_top_iff

#print Submodule.smul_comap_le_comap_smul /-
@[simp]
theorem smul_comap_le_comap_smul (f : M →ₗ[R] M') (S : Submodule R M') (I : Ideal R) :
    I • S.comap f ≤ (I • S).comap f :=
  by
  refine' submodule.smul_le.mpr fun r hr x hx => _
  rw [Submodule.mem_comap] at hx⊢
  rw [f.map_smul]
  exact Submodule.smul_mem_smul hr hx
#align submodule.smul_comap_le_comap_smul Submodule.smul_comap_le_comap_smul
-/

end CommSemiring

section CommRing

variable [CommRing R] [AddCommGroup M] [Module R M]

variable {N N₁ N₂ P P₁ P₂ : Submodule R M}

#print Submodule.colon /-
/-- `N.colon P` is the ideal of all elements `r : R` such that `r • P ⊆ N`. -/
def colon (N P : Submodule R M) : Ideal R :=
  annihilator (P.map N.mkQ)
#align submodule.colon Submodule.colon
-/

#print Submodule.mem_colon /-
theorem mem_colon {r} : r ∈ N.colon P ↔ ∀ p ∈ P, r • p ∈ N :=
  mem_annihilator.trans
    ⟨fun H p hp => (Quotient.mk_eq_zero N).1 (H (Quotient.mk p) (mem_map_of_mem hp)),
      fun H m ⟨p, hp, hpm⟩ => hpm ▸ N.mkQ.map_smul r p ▸ (Quotient.mk_eq_zero N).2 <| H p hp⟩
#align submodule.mem_colon Submodule.mem_colon
-/

#print Submodule.mem_colon' /-
theorem mem_colon' {r} : r ∈ N.colon P ↔ P ≤ comap (r • (LinearMap.id : M →ₗ[R] M)) N :=
  mem_colon
#align submodule.mem_colon' Submodule.mem_colon'
-/

#print Submodule.colon_mono /-
theorem colon_mono (hn : N₁ ≤ N₂) (hp : P₁ ≤ P₂) : N₁.colon P₂ ≤ N₂.colon P₁ := fun r hrnp =>
  mem_colon.2 fun p₁ hp₁ => hn <| mem_colon.1 hrnp p₁ <| hp hp₁
#align submodule.colon_mono Submodule.colon_mono
-/

/- warning: submodule.infi_colon_supr -> Submodule.infᵢ_colon_supᵢ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (ι₁ : Sort.{u3}) (f : ι₁ -> (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)) (ι₂ : Sort.{u4}) (g : ι₂ -> (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)), Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.colon.{u1, u2} R M _inst_1 _inst_2 _inst_3 (infᵢ.{u2, u3} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.hasInf.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) ι₁ (fun (i : ι₁) => f i)) (supᵢ.{u2, u4} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))) ι₂ (fun (j : ι₂) => g j))) (infᵢ.{u1, u3} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.hasInf.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) ι₁ (fun (i : ι₁) => infᵢ.{u1, u4} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.hasInf.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) ι₂ (fun (j : ι₂) => Submodule.colon.{u1, u2} R M _inst_1 _inst_2 _inst_3 (f i) (g j))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (ι₁ : Sort.{u3}) (f : ι₁ -> (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)) (ι₂ : Sort.{u4}) (g : ι₂ -> (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.colon.{u1, u2} R M _inst_1 _inst_2 _inst_3 (infᵢ.{u2, u3} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.instInfSetSubmodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) ι₁ (fun (i : ι₁) => f i)) (supᵢ.{u2, u4} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} R M (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))) ι₂ (fun (j : ι₂) => g j))) (infᵢ.{u1, u3} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.instInfSetSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) ι₁ (fun (i : ι₁) => infᵢ.{u1, u4} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.instInfSetSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) ι₂ (fun (j : ι₂) => Submodule.colon.{u1, u2} R M _inst_1 _inst_2 _inst_3 (f i) (g j))))
Case conversion may be inaccurate. Consider using '#align submodule.infi_colon_supr Submodule.infᵢ_colon_supᵢₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
theorem infᵢ_colon_supᵢ (ι₁ : Sort w) (f : ι₁ → Submodule R M) (ι₂ : Sort x)
    (g : ι₂ → Submodule R M) : (⨅ i, f i).colon (⨆ j, g j) = ⨅ (i) (j), (f i).colon (g j) :=
  le_antisymm (le_infᵢ fun i => le_infᵢ fun j => colon_mono (infᵢ_le _ _) (le_supᵢ _ _)) fun r H =>
    mem_colon'.2 <|
      supᵢ_le fun j =>
        map_le_iff_le_comap.1 <|
          le_infᵢ fun i =>
            map_le_iff_le_comap.2 <|
              mem_colon'.1 <|
                have := (mem_infᵢ _).1 H i
                have := (mem_infᵢ _).1 this j
                this
#align submodule.infi_colon_supr Submodule.infᵢ_colon_supᵢ

#print Submodule.mem_colon_singleton /-
@[simp]
theorem mem_colon_singleton {N : Submodule R M} {x : M} {r : R} :
    r ∈ N.colon (Submodule.span R {x}) ↔ r • x ∈ N :=
  calc
    r ∈ N.colon (Submodule.span R {x}) ↔ ∀ a : R, r • a • x ∈ N := by
      simp [Submodule.mem_colon, Submodule.mem_span_singleton]
    _ ↔ r • x ∈ N := by simp_rw [smul_comm r] <;> exact SetLike.forall_smul_mem_iff
    
#align submodule.mem_colon_singleton Submodule.mem_colon_singleton
-/

/- warning: ideal.mem_colon_singleton -> Ideal.mem_colon_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {x : R} {r : R}, Iff (Membership.Mem.{u1, u1} R (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) r (Submodule.colon.{u1, u1} R R _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) I (Ideal.span.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x)))) (Membership.Mem.{u1, u1} R (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1)))) r x) I)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))} {x : R} {r : R}, Iff (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) r (Submodule.colon.{u1, u1} R R _inst_1 (Ring.toAddCommGroup.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) I (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x)))) (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (NonUnitalCommRing.toNonUnitalRing.{u1} R (CommRing.toNonUnitalCommRing.{u1} R _inst_1))))) r x) I)
Case conversion may be inaccurate. Consider using '#align ideal.mem_colon_singleton Ideal.mem_colon_singletonₓ'. -/
@[simp]
theorem Ideal.mem_colon_singleton {I : Ideal R} {x r : R} :
    r ∈ I.colon (Ideal.span {x}) ↔ r * x ∈ I := by
  simp [← Ideal.submodule_span_eq, Submodule.mem_colon_singleton, smul_eq_mul]
#align ideal.mem_colon_singleton Ideal.mem_colon_singleton

end CommRing

end Submodule

namespace Ideal

section Add

variable {R : Type u} [Semiring R]

/- warning: ideal.add_eq_sup -> Ideal.add_eq_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {I : Ideal.{u1} R _inst_1} {J : Ideal.{u1} R _inst_1}, Eq.{succ u1} (Ideal.{u1} R _inst_1) (HAdd.hAdd.{u1, u1, u1} (Ideal.{u1} R _inst_1) (Ideal.{u1} R _inst_1) (Ideal.{u1} R _inst_1) (instHAdd.{u1} (Ideal.{u1} R _inst_1) (AddZeroClass.toHasAdd.{u1} (Ideal.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Ideal.{u1} R _inst_1) (AddCommMonoid.toAddMonoid.{u1} (Ideal.{u1} R _inst_1) (Submodule.pointwiseAddCommMonoid.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) I J) (Sup.sup.{u1} (Ideal.{u1} R _inst_1) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R _inst_1) (Lattice.toSemilatticeSup.{u1} (Ideal.{u1} R _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) I J)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {I : Ideal.{u1} R _inst_1} {J : Ideal.{u1} R _inst_1}, Eq.{succ u1} (Ideal.{u1} R _inst_1) (HAdd.hAdd.{u1, u1, u1} (Ideal.{u1} R _inst_1) (Ideal.{u1} R _inst_1) (Ideal.{u1} R _inst_1) (instHAdd.{u1} (Ideal.{u1} R _inst_1) (AddZeroClass.toAdd.{u1} (Ideal.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Ideal.{u1} R _inst_1) (AddCommMonoid.toAddMonoid.{u1} (Ideal.{u1} R _inst_1) (Submodule.pointwiseAddCommMonoid.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) I J) (Sup.sup.{u1} (Ideal.{u1} R _inst_1) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R _inst_1) (Lattice.toSemilatticeSup.{u1} (Ideal.{u1} R _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) I J)
Case conversion may be inaccurate. Consider using '#align ideal.add_eq_sup Ideal.add_eq_supₓ'. -/
@[simp]
theorem add_eq_sup {I J : Ideal R} : I + J = I ⊔ J :=
  rfl
#align ideal.add_eq_sup Ideal.add_eq_sup

/- warning: ideal.zero_eq_bot -> Ideal.zero_eq_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], Eq.{succ u1} (Ideal.{u1} R _inst_1) (OfNat.ofNat.{u1} (Ideal.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Ideal.{u1} R _inst_1) 0 (Zero.zero.{u1} (Ideal.{u1} R _inst_1) (AddZeroClass.toHasZero.{u1} (Ideal.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Ideal.{u1} R _inst_1) (AddCommMonoid.toAddMonoid.{u1} (Ideal.{u1} R _inst_1) (Submodule.pointwiseAddCommMonoid.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))))) (Bot.bot.{u1} (Ideal.{u1} R _inst_1) (Submodule.hasBot.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R], Eq.{succ u1} (Ideal.{u1} R _inst_1) (OfNat.ofNat.{u1} (Ideal.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Ideal.{u1} R _inst_1) (AddMonoid.toZero.{u1} (Ideal.{u1} R _inst_1) (AddCommMonoid.toAddMonoid.{u1} (Ideal.{u1} R _inst_1) (Submodule.pointwiseAddCommMonoid.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) (Bot.bot.{u1} (Ideal.{u1} R _inst_1) (Submodule.instBotSubmodule.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align ideal.zero_eq_bot Ideal.zero_eq_botₓ'. -/
@[simp]
theorem zero_eq_bot : (0 : Ideal R) = ⊥ :=
  rfl
#align ideal.zero_eq_bot Ideal.zero_eq_bot

/- warning: ideal.sum_eq_sup -> Ideal.sum_eq_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} (s : Finset.{u2} ι) (f : ι -> (Ideal.{u1} R _inst_1)), Eq.{succ u1} (Ideal.{u1} R _inst_1) (Finset.sum.{u1, u2} (Ideal.{u1} R _inst_1) ι (Submodule.pointwiseAddCommMonoid.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) s f) (Finset.sup.{u1, u2} (Ideal.{u1} R _inst_1) ι (Lattice.toSemilatticeSup.{u1} (Ideal.{u1} R _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))))) (Submodule.orderBot.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) s f)
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] {ι : Type.{u1}} (s : Finset.{u1} ι) (f : ι -> (Ideal.{u2} R _inst_1)), Eq.{succ u2} (Ideal.{u2} R _inst_1) (Finset.sum.{u2, u1} (Ideal.{u2} R _inst_1) ι (Submodule.pointwiseAddCommMonoid.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) s f) (Finset.sup.{u2, u1} (Ideal.{u2} R _inst_1) ι (Lattice.toSemilatticeSup.{u2} (Ideal.{u2} R _inst_1) (ConditionallyCompleteLattice.toLattice.{u2} (Ideal.{u2} R _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} R _inst_1) (Submodule.completeLattice.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) s f)
Case conversion may be inaccurate. Consider using '#align ideal.sum_eq_sup Ideal.sum_eq_supₓ'. -/
@[simp]
theorem sum_eq_sup {ι : Type _} (s : Finset ι) (f : ι → Ideal R) : s.Sum f = s.sup f :=
  rfl
#align ideal.sum_eq_sup Ideal.sum_eq_sup

end Add

section MulAndRadical

variable {R : Type u} {ι : Type _} [CommSemiring R]

variable {I J K L : Ideal R}

instance : Mul (Ideal R) :=
  ⟨(· • ·)⟩

/- warning: ideal.one_eq_top -> Ideal.one_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R], Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (OfNat.mk.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (One.one.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.one.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R], Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (One.toOfNat1.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.one.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align ideal.one_eq_top Ideal.one_eq_topₓ'. -/
@[simp]
theorem one_eq_top : (1 : Ideal R) = ⊤ := by erw [Submodule.one_eq_range, LinearMap.range_id]
#align ideal.one_eq_top Ideal.one_eq_top

/- warning: ideal.mul_mem_mul -> Ideal.mul_mem_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {r : R} {s : R}, (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r I) -> (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) s J) -> (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) r s) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) I J))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {r : R} {s : R}, (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r I) -> (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) s J) -> (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) r s) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) I J))
Case conversion may be inaccurate. Consider using '#align ideal.mul_mem_mul Ideal.mul_mem_mulₓ'. -/
theorem mul_mem_mul {r s} (hr : r ∈ I) (hs : s ∈ J) : r * s ∈ I * J :=
  Submodule.smul_mem_smul hr hs
#align ideal.mul_mem_mul Ideal.mul_mem_mul

/- warning: ideal.mul_mem_mul_rev -> Ideal.mul_mem_mul_rev is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {r : R} {s : R}, (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r I) -> (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) s J) -> (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) s r) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) I J))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {r : R} {s : R}, (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r I) -> (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) s J) -> (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) s r) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) I J))
Case conversion may be inaccurate. Consider using '#align ideal.mul_mem_mul_rev Ideal.mul_mem_mul_revₓ'. -/
theorem mul_mem_mul_rev {r s} (hr : r ∈ I) (hs : s ∈ J) : s * r ∈ I * J :=
  mul_comm r s ▸ mul_mem_mul hr hs
#align ideal.mul_mem_mul_rev Ideal.mul_mem_mul_rev

#print Ideal.pow_mem_pow /-
theorem pow_mem_pow {x : R} (hx : x ∈ I) (n : ℕ) : x ^ n ∈ I ^ n :=
  Submodule.pow_mem_pow _ hx _
#align ideal.pow_mem_pow Ideal.pow_mem_pow
-/

/- warning: ideal.prod_mem_prod -> Ideal.prod_mem_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {ι : Type.{u2}} {s : Finset.{u2} ι} {I : ι -> (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))} {x : ι -> R}, (forall (i : ι), (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) -> (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (x i) (I i))) -> (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Finset.prod.{u1, u2} R ι (CommSemiring.toCommMonoid.{u1} R _inst_1) s (fun (i : ι) => x i)) (Finset.prod.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) ι (CommSemiring.toCommMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemCommSemiring.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) s (fun (i : ι) => I i)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {ι : Type.{u1}} {s : Finset.{u1} ι} {I : ι -> (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))} {x : ι -> R}, (forall (i : ι), (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) -> (Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (x i) (I i))) -> (Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Finset.prod.{u2, u1} R ι (CommSemiring.toCommMonoid.{u2} R _inst_1) s (fun (i : ι) => x i)) (Finset.prod.{u2, u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) ι (CommSemiring.toCommMonoid.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u2, u2} R _inst_1 R _inst_1 (Algebra.id.{u2} R _inst_1)))) s (fun (i : ι) => I i)))
Case conversion may be inaccurate. Consider using '#align ideal.prod_mem_prod Ideal.prod_mem_prodₓ'. -/
theorem prod_mem_prod {ι : Type _} {s : Finset ι} {I : ι → Ideal R} {x : ι → R} :
    (∀ i ∈ s, x i ∈ I i) → (∏ i in s, x i) ∈ ∏ i in s, I i := by
  classical
    apply Finset.induction_on s
    · intro
      rw [Finset.prod_empty, Finset.prod_empty, one_eq_top]
      exact Submodule.mem_top
    · intro a s ha IH h
      rw [Finset.prod_insert ha, Finset.prod_insert ha]
      exact
        mul_mem_mul (h a <| Finset.mem_insert_self a s)
          (IH fun i hi => h i <| Finset.mem_insert_of_mem hi)
#align ideal.prod_mem_prod Ideal.prod_mem_prod

/- warning: ideal.mul_le -> Ideal.mul_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {K : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) I J) K) (forall (r : R), (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r I) -> (forall (s : R), (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) s J) -> (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) r s) K)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {K : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) I J) K) (forall (r : R), (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) r I) -> (forall (s : R), (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) s J) -> (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) r s) K)))
Case conversion may be inaccurate. Consider using '#align ideal.mul_le Ideal.mul_leₓ'. -/
theorem mul_le : I * J ≤ K ↔ ∀ r ∈ I, ∀ s ∈ J, r * s ∈ K :=
  Submodule.smul_le
#align ideal.mul_le Ideal.mul_le

#print Ideal.mul_le_left /-
theorem mul_le_left : I * J ≤ J :=
  Ideal.mul_le.2 fun r hr s => J.mul_mem_left _
#align ideal.mul_le_left Ideal.mul_le_left
-/

#print Ideal.mul_le_right /-
theorem mul_le_right : I * J ≤ I :=
  Ideal.mul_le.2 fun r hr s hs => I.mul_mem_right _ hr
#align ideal.mul_le_right Ideal.mul_le_right
-/

/- warning: ideal.sup_mul_right_self -> Ideal.sup_mul_right_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) I J)) I
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) I J)) I
Case conversion may be inaccurate. Consider using '#align ideal.sup_mul_right_self Ideal.sup_mul_right_selfₓ'. -/
@[simp]
theorem sup_mul_right_self : I ⊔ I * J = I :=
  sup_eq_left.2 Ideal.mul_le_right
#align ideal.sup_mul_right_self Ideal.sup_mul_right_self

/- warning: ideal.sup_mul_left_self -> Ideal.sup_mul_left_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) J I)) I
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) J I)) I
Case conversion may be inaccurate. Consider using '#align ideal.sup_mul_left_self Ideal.sup_mul_left_selfₓ'. -/
@[simp]
theorem sup_mul_left_self : I ⊔ J * I = I :=
  sup_eq_left.2 Ideal.mul_le_left
#align ideal.sup_mul_left_self Ideal.sup_mul_left_self

/- warning: ideal.mul_right_self_sup -> Ideal.mul_right_self_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) I J) I) I
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) I J) I) I
Case conversion may be inaccurate. Consider using '#align ideal.mul_right_self_sup Ideal.mul_right_self_supₓ'. -/
@[simp]
theorem mul_right_self_sup : I * J ⊔ I = I :=
  sup_eq_right.2 Ideal.mul_le_right
#align ideal.mul_right_self_sup Ideal.mul_right_self_sup

/- warning: ideal.mul_left_self_sup -> Ideal.mul_left_self_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) J I) I) I
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) J I) I) I
Case conversion may be inaccurate. Consider using '#align ideal.mul_left_self_sup Ideal.mul_left_self_supₓ'. -/
@[simp]
theorem mul_left_self_sup : J * I ⊔ I = I :=
  sup_eq_right.2 Ideal.mul_le_left
#align ideal.mul_left_self_sup Ideal.mul_left_self_sup

variable (I J K)

#print Ideal.mul_comm /-
protected theorem mul_comm : I * J = J * I :=
  le_antisymm (mul_le.2 fun r hrI s hsJ => mul_mem_mul_rev hsJ hrI)
    (mul_le.2 fun r hrJ s hsI => mul_mem_mul_rev hsI hrJ)
#align ideal.mul_comm Ideal.mul_comm
-/

#print Ideal.mul_assoc /-
protected theorem mul_assoc : I * J * K = I * (J * K) :=
  Submodule.smul_assoc I J K
#align ideal.mul_assoc Ideal.mul_assoc
-/

#print Ideal.span_mul_span /-
theorem span_mul_span (S T : Set R) : span S * span T = span (⋃ (s ∈ S) (t ∈ T), {s * t}) :=
  Submodule.span_smul_span S T
#align ideal.span_mul_span Ideal.span_mul_span
-/

variable {I J K}

/- warning: ideal.span_mul_span' -> Ideal.span_mul_span' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (S : Set.{u1} R) (T : Set.{u1} R), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) S) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) T)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (HMul.hMul.{u1, u1, u1} (Set.{u1} R) (Set.{u1} R) (Set.{u1} R) (instHMul.{u1} (Set.{u1} R) (Set.mul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) S T))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (S : Set.{u1} R) (T : Set.{u1} R), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) S) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) T)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (HMul.hMul.{u1, u1, u1} (Set.{u1} R) (Set.{u1} R) (Set.{u1} R) (instHMul.{u1} (Set.{u1} R) (Set.mul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) S T))
Case conversion may be inaccurate. Consider using '#align ideal.span_mul_span' Ideal.span_mul_span'ₓ'. -/
theorem span_mul_span' (S T : Set R) : span S * span T = span (S * T) :=
  by
  unfold span
  rw [Submodule.span_mul_span]
#align ideal.span_mul_span' Ideal.span_mul_span'

/- warning: ideal.span_singleton_mul_span_singleton -> Ideal.span_singleton_mul_span_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (r : R) (s : R), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) r)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) s))) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) r s)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (r : R) (s : R), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) r)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) s))) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) r s)))
Case conversion may be inaccurate. Consider using '#align ideal.span_singleton_mul_span_singleton Ideal.span_singleton_mul_span_singletonₓ'. -/
theorem span_singleton_mul_span_singleton (r s : R) :
    span {r} * span {s} = (span {r * s} : Ideal R) :=
  by
  unfold span
  rw [Submodule.span_mul_span, Set.singleton_mul_singleton]
#align ideal.span_singleton_mul_span_singleton Ideal.span_singleton_mul_span_singleton

#print Ideal.span_singleton_pow /-
theorem span_singleton_pow (s : R) (n : ℕ) : span {s} ^ n = (span {s ^ n} : Ideal R) :=
  by
  induction' n with n ih; · simp [Set.singleton_one]
  simp only [pow_succ, ih, span_singleton_mul_span_singleton]
#align ideal.span_singleton_pow Ideal.span_singleton_pow
-/

/- warning: ideal.mem_mul_span_singleton -> Ideal.mem_mul_span_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : R} {y : R} {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) I (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) y)))) (Exists.{succ u1} R (fun (z : R) => Exists.{0} (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) z I) (fun (H : Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) z I) => Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) z y) x)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : R} {y : R} {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) I (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) y)))) (Exists.{succ u1} R (fun (z : R) => And (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) z I) (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) z y) x)))
Case conversion may be inaccurate. Consider using '#align ideal.mem_mul_span_singleton Ideal.mem_mul_span_singletonₓ'. -/
theorem mem_mul_span_singleton {x y : R} {I : Ideal R} : x ∈ I * span {y} ↔ ∃ z ∈ I, z * y = x :=
  Submodule.mem_smul_span_singleton
#align ideal.mem_mul_span_singleton Ideal.mem_mul_span_singleton

/- warning: ideal.mem_span_singleton_mul -> Ideal.mem_span_singleton_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : R} {y : R} {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) y)) I)) (Exists.{succ u1} R (fun (z : R) => Exists.{0} (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) z I) (fun (H : Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) z I) => Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) y z) x)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : R} {y : R} {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) y)) I)) (Exists.{succ u1} R (fun (z : R) => And (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) z I) (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) y z) x)))
Case conversion may be inaccurate. Consider using '#align ideal.mem_span_singleton_mul Ideal.mem_span_singleton_mulₓ'. -/
theorem mem_span_singleton_mul {x y : R} {I : Ideal R} : x ∈ span {y} * I ↔ ∃ z ∈ I, y * z = x := by
  simp only [mul_comm, mem_mul_span_singleton]
#align ideal.mem_span_singleton_mul Ideal.mem_span_singleton_mul

/- warning: ideal.le_span_singleton_mul_iff -> Ideal.le_span_singleton_mul_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : R} {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) I (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x)) J)) (forall (zI : R), (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zI I) -> (Exists.{succ u1} R (fun (zJ : R) => Exists.{0} (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zJ J) (fun (H : Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zJ J) => Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) x zJ) zI))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : R} {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) I (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x)) J)) (forall (zI : R), (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zI I) -> (Exists.{succ u1} R (fun (zJ : R) => And (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zJ J) (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) x zJ) zI))))
Case conversion may be inaccurate. Consider using '#align ideal.le_span_singleton_mul_iff Ideal.le_span_singleton_mul_iffₓ'. -/
theorem le_span_singleton_mul_iff {x : R} {I J : Ideal R} :
    I ≤ span {x} * J ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI :=
  show (∀ {zI} (hzI : zI ∈ I), zI ∈ span {x} * J) ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI by
    simp only [mem_span_singleton_mul]
#align ideal.le_span_singleton_mul_iff Ideal.le_span_singleton_mul_iff

/- warning: ideal.span_singleton_mul_le_iff -> Ideal.span_singleton_mul_le_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : R} {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x)) I) J) (forall (z : R), (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) z I) -> (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) x z) J))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : R} {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x)) I) J) (forall (z : R), (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) z I) -> (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) x z) J))
Case conversion may be inaccurate. Consider using '#align ideal.span_singleton_mul_le_iff Ideal.span_singleton_mul_le_iffₓ'. -/
theorem span_singleton_mul_le_iff {x : R} {I J : Ideal R} : span {x} * I ≤ J ↔ ∀ z ∈ I, x * z ∈ J :=
  by
  simp only [mul_le, mem_span_singleton_mul, mem_span_singleton]
  constructor
  · intro h zI hzI
    exact h x (dvd_refl x) zI hzI
  · rintro h _ ⟨z, rfl⟩ zI hzI
    rw [mul_comm x z, mul_assoc]
    exact J.mul_mem_left _ (h zI hzI)
#align ideal.span_singleton_mul_le_iff Ideal.span_singleton_mul_le_iff

/- warning: ideal.span_singleton_mul_le_span_singleton_mul -> Ideal.span_singleton_mul_le_span_singleton_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : R} {y : R} {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x)) I) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) y)) J)) (forall (zI : R), (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zI I) -> (Exists.{succ u1} R (fun (zJ : R) => Exists.{0} (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zJ J) (fun (H : Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zJ J) => Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) x zI) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) y zJ)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : R} {y : R} {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x)) I) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) y)) J)) (forall (zI : R), (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zI I) -> (Exists.{succ u1} R (fun (zJ : R) => And (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zJ J) (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) x zI) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) y zJ)))))
Case conversion may be inaccurate. Consider using '#align ideal.span_singleton_mul_le_span_singleton_mul Ideal.span_singleton_mul_le_span_singleton_mulₓ'. -/
theorem span_singleton_mul_le_span_singleton_mul {x y : R} {I J : Ideal R} :
    span {x} * I ≤ span {y} * J ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zI = y * zJ := by
  simp only [span_singleton_mul_le_iff, mem_span_singleton_mul, eq_comm]
#align ideal.span_singleton_mul_le_span_singleton_mul Ideal.span_singleton_mul_le_span_singleton_mul

/- warning: ideal.span_singleton_mul_right_mono -> Ideal.span_singleton_mul_right_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)] {x : R}, (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))))) -> (Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x)) I) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x)) J)) (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) I J))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)] {x : R}, (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R _inst_1 _inst_2)))))) -> (Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x)) I) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x)) J)) (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) I J))
Case conversion may be inaccurate. Consider using '#align ideal.span_singleton_mul_right_mono Ideal.span_singleton_mul_right_monoₓ'. -/
theorem span_singleton_mul_right_mono [IsDomain R] {x : R} (hx : x ≠ 0) :
    span {x} * I ≤ span {x} * J ↔ I ≤ J := by
  simp_rw [span_singleton_mul_le_span_singleton_mul, mul_right_inj' hx, exists_prop,
    exists_eq_right', SetLike.le_def]
#align ideal.span_singleton_mul_right_mono Ideal.span_singleton_mul_right_mono

/- warning: ideal.span_singleton_mul_left_mono -> Ideal.span_singleton_mul_left_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)] {x : R}, (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))))) -> (Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) I (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) J (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x)))) (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) I J))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)] {x : R}, (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R _inst_1 _inst_2)))))) -> (Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) I (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) J (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x)))) (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) I J))
Case conversion may be inaccurate. Consider using '#align ideal.span_singleton_mul_left_mono Ideal.span_singleton_mul_left_monoₓ'. -/
theorem span_singleton_mul_left_mono [IsDomain R] {x : R} (hx : x ≠ 0) :
    I * span {x} ≤ J * span {x} ↔ I ≤ J := by
  simpa only [mul_comm I, mul_comm J] using span_singleton_mul_right_mono hx
#align ideal.span_singleton_mul_left_mono Ideal.span_singleton_mul_left_mono

/- warning: ideal.span_singleton_mul_right_inj -> Ideal.span_singleton_mul_right_inj is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)] {x : R}, (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))))) -> (Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x)) I) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x)) J)) (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) I J))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)] {x : R}, (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R _inst_1 _inst_2)))))) -> (Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x)) I) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x)) J)) (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) I J))
Case conversion may be inaccurate. Consider using '#align ideal.span_singleton_mul_right_inj Ideal.span_singleton_mul_right_injₓ'. -/
theorem span_singleton_mul_right_inj [IsDomain R] {x : R} (hx : x ≠ 0) :
    span {x} * I = span {x} * J ↔ I = J := by
  simp only [le_antisymm_iff, span_singleton_mul_right_mono hx]
#align ideal.span_singleton_mul_right_inj Ideal.span_singleton_mul_right_inj

/- warning: ideal.span_singleton_mul_left_inj -> Ideal.span_singleton_mul_left_inj is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)] {x : R}, (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))))) -> (Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) I (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) J (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x)))) (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) I J))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)] {x : R}, (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R _inst_1 _inst_2)))))) -> (Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) I (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) J (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x)))) (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) I J))
Case conversion may be inaccurate. Consider using '#align ideal.span_singleton_mul_left_inj Ideal.span_singleton_mul_left_injₓ'. -/
theorem span_singleton_mul_left_inj [IsDomain R] {x : R} (hx : x ≠ 0) :
    I * span {x} = J * span {x} ↔ I = J := by
  simp only [le_antisymm_iff, span_singleton_mul_left_mono hx]
#align ideal.span_singleton_mul_left_inj Ideal.span_singleton_mul_left_inj

/- warning: ideal.span_singleton_mul_right_injective -> Ideal.span_singleton_mul_right_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)] {x : R}, (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))))) -> (Function.Injective.{succ u1, succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)] {x : R}, (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R _inst_1 _inst_2)))))) -> (Function.Injective.{succ u1, succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) ((fun (x._@.Mathlib.RingTheory.Ideal.Operations._hyg.8044 : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (x._@.Mathlib.RingTheory.Ideal.Operations._hyg.8046 : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) => HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) x._@.Mathlib.RingTheory.Ideal.Operations._hyg.8044 x._@.Mathlib.RingTheory.Ideal.Operations._hyg.8046) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x))))
Case conversion may be inaccurate. Consider using '#align ideal.span_singleton_mul_right_injective Ideal.span_singleton_mul_right_injectiveₓ'. -/
theorem span_singleton_mul_right_injective [IsDomain R] {x : R} (hx : x ≠ 0) :
    Function.Injective ((· * ·) (span {x} : Ideal R)) := fun _ _ =>
  (span_singleton_mul_right_inj hx).mp
#align ideal.span_singleton_mul_right_injective Ideal.span_singleton_mul_right_injective

/- warning: ideal.span_singleton_mul_left_injective -> Ideal.span_singleton_mul_left_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)] {x : R}, (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))))) -> (Function.Injective.{succ u1, succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (fun (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) => HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) I (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)] {x : R}, (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R _inst_1 _inst_2)))))) -> (Function.Injective.{succ u1, succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (fun (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) => HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) I (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x))))
Case conversion may be inaccurate. Consider using '#align ideal.span_singleton_mul_left_injective Ideal.span_singleton_mul_left_injectiveₓ'. -/
theorem span_singleton_mul_left_injective [IsDomain R] {x : R} (hx : x ≠ 0) :
    Function.Injective fun I : Ideal R => I * span {x} := fun _ _ =>
  (span_singleton_mul_left_inj hx).mp
#align ideal.span_singleton_mul_left_injective Ideal.span_singleton_mul_left_injective

/- warning: ideal.eq_span_singleton_mul -> Ideal.eq_span_singleton_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : R} (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) I (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x)) J)) (And (forall (zI : R), (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zI I) -> (Exists.{succ u1} R (fun (zJ : R) => Exists.{0} (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zJ J) (fun (H : Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zJ J) => Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) x zJ) zI)))) (forall (z : R), (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) z J) -> (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) x z) I)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : R} (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) I (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x)) J)) (And (forall (zI : R), (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zI I) -> (Exists.{succ u1} R (fun (zJ : R) => And (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zJ J) (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) x zJ) zI)))) (forall (z : R), (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) z J) -> (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) x z) I)))
Case conversion may be inaccurate. Consider using '#align ideal.eq_span_singleton_mul Ideal.eq_span_singleton_mulₓ'. -/
theorem eq_span_singleton_mul {x : R} (I J : Ideal R) :
    I = span {x} * J ↔ (∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI) ∧ ∀ z ∈ J, x * z ∈ I := by
  simp only [le_antisymm_iff, le_span_singleton_mul_iff, span_singleton_mul_le_iff]
#align ideal.eq_span_singleton_mul Ideal.eq_span_singleton_mul

/- warning: ideal.span_singleton_mul_eq_span_singleton_mul -> Ideal.span_singleton_mul_eq_span_singleton_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : R} {y : R} (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x)) I) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) y)) J)) (And (forall (zI : R), (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zI I) -> (Exists.{succ u1} R (fun (zJ : R) => Exists.{0} (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zJ J) (fun (H : Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zJ J) => Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) x zI) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) y zJ))))) (forall (zJ : R), (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zJ J) -> (Exists.{succ u1} R (fun (zI : R) => Exists.{0} (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zI I) (fun (H : Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zI I) => Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) x zI) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) y zJ))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {x : R} {y : R} (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x)) I) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) y)) J)) (And (forall (zI : R), (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zI I) -> (Exists.{succ u1} R (fun (zJ : R) => And (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zJ J) (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) x zI) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) y zJ))))) (forall (zJ : R), (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zJ J) -> (Exists.{succ u1} R (fun (zI : R) => And (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) zI I) (Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) x zI) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) y zJ))))))
Case conversion may be inaccurate. Consider using '#align ideal.span_singleton_mul_eq_span_singleton_mul Ideal.span_singleton_mul_eq_span_singleton_mulₓ'. -/
theorem span_singleton_mul_eq_span_singleton_mul {x y : R} (I J : Ideal R) :
    span {x} * I = span {y} * J ↔
      (∀ zI ∈ I, ∃ zJ ∈ J, x * zI = y * zJ) ∧ ∀ zJ ∈ J, ∃ zI ∈ I, x * zI = y * zJ :=
  by simp only [le_antisymm_iff, span_singleton_mul_le_span_singleton_mul, eq_comm]
#align ideal.span_singleton_mul_eq_span_singleton_mul Ideal.span_singleton_mul_eq_span_singleton_mul

/- warning: ideal.prod_span -> Ideal.prod_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {ι : Type.{u2}} (s : Finset.{u2} ι) (I : ι -> (Set.{u1} R)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Finset.prod.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) ι (CommSemiring.toCommMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemCommSemiring.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) s (fun (i : ι) => Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (I i))) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Finset.prod.{u1, u2} (Set.{u1} R) ι (Set.commMonoid.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1)) s (fun (i : ι) => I i)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {ι : Type.{u1}} (s : Finset.{u1} ι) (I : ι -> (Set.{u2} R)), Eq.{succ u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Finset.prod.{u2, u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) ι (CommSemiring.toCommMonoid.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u2, u2} R _inst_1 R _inst_1 (Algebra.id.{u2} R _inst_1)))) s (fun (i : ι) => Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1) (I i))) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1) (Finset.prod.{u2, u1} (Set.{u2} R) ι (Set.commMonoid.{u2} R (CommSemiring.toCommMonoid.{u2} R _inst_1)) s (fun (i : ι) => I i)))
Case conversion may be inaccurate. Consider using '#align ideal.prod_span Ideal.prod_spanₓ'. -/
theorem prod_span {ι : Type _} (s : Finset ι) (I : ι → Set R) :
    (∏ i in s, Ideal.span (I i)) = Ideal.span (∏ i in s, I i) :=
  Submodule.prod_span s I
#align ideal.prod_span Ideal.prod_span

/- warning: ideal.prod_span_singleton -> Ideal.prod_span_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {ι : Type.{u2}} (s : Finset.{u2} ι) (I : ι -> R), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Finset.prod.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) ι (CommSemiring.toCommMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemCommSemiring.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) s (fun (i : ι) => Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) (I i)))) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) (Finset.prod.{u1, u2} R ι (CommSemiring.toCommMonoid.{u1} R _inst_1) s (fun (i : ι) => I i))))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {ι : Type.{u1}} (s : Finset.{u1} ι) (I : ι -> R), Eq.{succ u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Finset.prod.{u2, u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) ι (CommSemiring.toCommMonoid.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u2, u2} R _inst_1 R _inst_1 (Algebra.id.{u2} R _inst_1)))) s (fun (i : ι) => Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (I i)))) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Finset.prod.{u2, u1} R ι (CommSemiring.toCommMonoid.{u2} R _inst_1) s (fun (i : ι) => I i))))
Case conversion may be inaccurate. Consider using '#align ideal.prod_span_singleton Ideal.prod_span_singletonₓ'. -/
theorem prod_span_singleton {ι : Type _} (s : Finset ι) (I : ι → R) :
    (∏ i in s, Ideal.span ({I i} : Set R)) = Ideal.span {∏ i in s, I i} :=
  Submodule.prod_span_singleton s I
#align ideal.prod_span_singleton Ideal.prod_span_singleton

/- warning: ideal.multiset_prod_span_singleton -> Ideal.multiset_prod_span_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (m : Multiset.{u1} R), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Multiset.prod.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CommSemiring.toCommMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemCommSemiring.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) (Multiset.map.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (fun (x : R) => Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x)) m)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) (Multiset.prod.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1) m)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (m : Multiset.{u1} R), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Multiset.prod.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CommSemiring.toCommMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) (Multiset.map.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (fun (x : R) => Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x)) m)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) (Multiset.prod.{u1} R (CommSemiring.toCommMonoid.{u1} R _inst_1) m)))
Case conversion may be inaccurate. Consider using '#align ideal.multiset_prod_span_singleton Ideal.multiset_prod_span_singletonₓ'. -/
@[simp]
theorem multiset_prod_span_singleton (m : Multiset R) :
    (m.map fun x => Ideal.span {x}).Prod = Ideal.span ({Multiset.prod m} : Set R) :=
  Multiset.induction_on m (by simp) fun a m ih => by
    simp only [Multiset.map_cons, Multiset.prod_cons, ih, ← Ideal.span_singleton_mul_span_singleton]
#align ideal.multiset_prod_span_singleton Ideal.multiset_prod_span_singleton

/- warning: ideal.finset_inf_span_singleton -> Ideal.finset_inf_span_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {ι : Type.{u2}} (s : Finset.{u2} ι) (I : ι -> R), (Set.Pairwise.{u2} ι ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s) (Function.onFun.{succ u2, succ u1, 1} ι R Prop (IsCoprime.{u1} R _inst_1) I)) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Finset.inf.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) ι (Lattice.toSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (ConditionallyCompleteLattice.toLattice.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (Submodule.orderTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) s (fun (i : ι) => Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) (I i)))) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) (Finset.prod.{u1, u2} R ι (CommSemiring.toCommMonoid.{u1} R _inst_1) s (fun (i : ι) => I i)))))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {ι : Type.{u1}} (s : Finset.{u1} ι) (I : ι -> R), (Set.Pairwise.{u1} ι (Finset.toSet.{u1} ι s) (Function.onFun.{succ u1, succ u2, 1} ι R Prop (IsCoprime.{u2} R _inst_1) I)) -> (Eq.{succ u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Finset.inf.{u2, u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) ι (Lattice.toSemilatticeInf.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (ConditionallyCompleteLattice.toLattice.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))) (Submodule.instOrderTopSubmoduleToLEToPreorderInstPartialOrderSetLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) s (fun (i : ι) => Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (I i)))) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Finset.prod.{u2, u1} R ι (CommSemiring.toCommMonoid.{u2} R _inst_1) s (fun (i : ι) => I i)))))
Case conversion may be inaccurate. Consider using '#align ideal.finset_inf_span_singleton Ideal.finset_inf_span_singletonₓ'. -/
theorem finset_inf_span_singleton {ι : Type _} (s : Finset ι) (I : ι → R)
    (hI : Set.Pairwise (↑s) (IsCoprime on I)) :
    (s.inf fun i => Ideal.span ({I i} : Set R)) = Ideal.span {∏ i in s, I i} :=
  by
  ext x
  simp only [Submodule.mem_finset_inf, Ideal.mem_span_singleton]
  exact ⟨Finset.prod_dvd_of_coprime hI, fun h i hi => (Finset.dvd_prod_of_mem _ hi).trans h⟩
#align ideal.finset_inf_span_singleton Ideal.finset_inf_span_singleton

/- warning: ideal.infi_span_singleton -> Ideal.infᵢ_span_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {ι : Type.{u2}} [_inst_2 : Fintype.{u2} ι] (I : ι -> R), (forall (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (IsCoprime.{u1} R _inst_1 (I i) (I j))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (infᵢ.{u1, succ u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasInf.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) ι (fun (i : ι) => Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) (I i)))) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) (Finset.prod.{u1, u2} R ι (CommSemiring.toCommMonoid.{u1} R _inst_1) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => I i)))))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {ι : Type.{u1}} [_inst_2 : Fintype.{u1} ι] (I : ι -> R), (forall (i : ι) (j : ι), (Ne.{succ u1} ι i j) -> (IsCoprime.{u2} R _inst_1 (I i) (I j))) -> (Eq.{succ u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (infᵢ.{u2, succ u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instInfSetSubmodule.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) ι (fun (i : ι) => Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (I i)))) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Finset.prod.{u2, u1} R ι (CommSemiring.toCommMonoid.{u2} R _inst_1) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => I i)))))
Case conversion may be inaccurate. Consider using '#align ideal.infi_span_singleton Ideal.infᵢ_span_singletonₓ'. -/
theorem infᵢ_span_singleton {ι : Type _} [Fintype ι] (I : ι → R)
    (hI : ∀ (i j) (hij : i ≠ j), IsCoprime (I i) (I j)) :
    (⨅ i, Ideal.span ({I i} : Set R)) = Ideal.span {∏ i, I i} :=
  by
  rw [← Finset.inf_univ_eq_infᵢ, finset_inf_span_singleton]
  rwa [Finset.coe_univ, Set.pairwise_univ]
#align ideal.infi_span_singleton Ideal.infᵢ_span_singleton

/- warning: ideal.sup_eq_top_iff_is_coprime -> Ideal.sup_eq_top_iff_isCoprime is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_2 : CommSemiring.{u1} R] (x : R) (y : R), Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Submodule.idemSemiring.{u1, u1} R _inst_2 R (CommSemiring.toSemiring.{u1} R _inst_2) (Algebra.id.{u1} R _inst_2)))) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) y))) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))) (IsCoprime.{u1} R _inst_2 x y)
but is expected to have type
  forall {R : Type.{u1}} [_inst_2 : CommSemiring.{u1} R] (x : R) (y : R), Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_2 R _inst_2 (Algebra.id.{u1} R _inst_2)))) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) y))) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))) (IsCoprime.{u1} R _inst_2 x y)
Case conversion may be inaccurate. Consider using '#align ideal.sup_eq_top_iff_is_coprime Ideal.sup_eq_top_iff_isCoprimeₓ'. -/
theorem sup_eq_top_iff_isCoprime {R : Type _} [CommSemiring R] (x y : R) :
    span ({x} : Set R) ⊔ span {y} = ⊤ ↔ IsCoprime x y :=
  by
  rw [eq_top_iff_one, Submodule.mem_sup]
  constructor
  · rintro ⟨u, hu, v, hv, h1⟩
    rw [mem_span_singleton'] at hu hv
    rw [← hu.some_spec, ← hv.some_spec] at h1
    exact ⟨_, _, h1⟩
  ·
    exact fun ⟨u, v, h1⟩ =>
      ⟨_, mem_span_singleton'.mpr ⟨_, rfl⟩, _, mem_span_singleton'.mpr ⟨_, rfl⟩, h1⟩
#align ideal.sup_eq_top_iff_is_coprime Ideal.sup_eq_top_iff_isCoprime

#print Ideal.mul_le_inf /-
theorem mul_le_inf : I * J ≤ I ⊓ J :=
  mul_le.2 fun r hri s hsj => ⟨I.mul_mem_right s hri, J.mul_mem_left r hsj⟩
#align ideal.mul_le_inf Ideal.mul_le_inf
-/

/- warning: ideal.multiset_prod_le_inf -> Ideal.multiset_prod_le_inf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {s : Multiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))}, LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (Multiset.prod.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CommSemiring.toCommMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemCommSemiring.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) s) (Multiset.inf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Lattice.toSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (ConditionallyCompleteLattice.toLattice.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (Submodule.orderTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) s)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {s : Multiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))}, LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (Multiset.prod.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CommSemiring.toCommMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) s) (Multiset.inf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Lattice.toSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (ConditionallyCompleteLattice.toLattice.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (Submodule.instOrderTopSubmoduleToLEToPreorderInstPartialOrderSetLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) s)
Case conversion may be inaccurate. Consider using '#align ideal.multiset_prod_le_inf Ideal.multiset_prod_le_infₓ'. -/
theorem multiset_prod_le_inf {s : Multiset (Ideal R)} : s.Prod ≤ s.inf := by
  classical
    refine' s.induction_on _ _
    · rw [Multiset.inf_zero]
      exact le_top
    intro a s ih
    rw [Multiset.prod_cons, Multiset.inf_cons]
    exact le_trans mul_le_inf (inf_le_inf le_rfl ih)
#align ideal.multiset_prod_le_inf Ideal.multiset_prod_le_inf

/- warning: ideal.prod_le_inf -> Ideal.prod_le_inf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {s : Finset.{u2} ι} {f : ι -> (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))}, LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (Finset.prod.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) ι (CommSemiring.toCommMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemCommSemiring.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) s f) (Finset.inf.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) ι (Lattice.toSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (ConditionallyCompleteLattice.toLattice.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (Submodule.orderTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) s f)
but is expected to have type
  forall {R : Type.{u2}} {ι : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {s : Finset.{u1} ι} {f : ι -> (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))}, LE.le.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Preorder.toLE.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))))) (Finset.prod.{u2, u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) ι (CommSemiring.toCommMonoid.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u2, u2} R _inst_1 R _inst_1 (Algebra.id.{u2} R _inst_1)))) s f) (Finset.inf.{u2, u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) ι (Lattice.toSemilatticeInf.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (ConditionallyCompleteLattice.toLattice.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))) (Submodule.instOrderTopSubmoduleToLEToPreorderInstPartialOrderSetLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) s f)
Case conversion may be inaccurate. Consider using '#align ideal.prod_le_inf Ideal.prod_le_infₓ'. -/
theorem prod_le_inf {s : Finset ι} {f : ι → Ideal R} : s.Prod f ≤ s.inf f :=
  multiset_prod_le_inf
#align ideal.prod_le_inf Ideal.prod_le_inf

/- warning: ideal.mul_eq_inf_of_coprime -> Ideal.mul_eq_inf_of_coprime is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I J) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) I J) (Inf.inf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasInf.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) I J))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I J) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) I J) (Inf.inf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instInfSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) I J))
Case conversion may be inaccurate. Consider using '#align ideal.mul_eq_inf_of_coprime Ideal.mul_eq_inf_of_coprimeₓ'. -/
theorem mul_eq_inf_of_coprime (h : I ⊔ J = ⊤) : I * J = I ⊓ J :=
  le_antisymm mul_le_inf fun r ⟨hri, hrj⟩ =>
    let ⟨s, hsi, t, htj, hst⟩ := Submodule.mem_sup.1 ((eq_top_iff_one _).1 h)
    mul_one r ▸
      hst ▸
        (mul_add r s t).symm ▸ Ideal.add_mem (I * J) (mul_mem_mul_rev hsi hrj) (mul_mem_mul hri htj)
#align ideal.mul_eq_inf_of_coprime Ideal.mul_eq_inf_of_coprime

/- warning: ideal.sup_mul_eq_of_coprime_left -> Ideal.sup_mul_eq_of_coprime_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {K : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I J) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) J K)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I K))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {K : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I J) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) J K)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I K))
Case conversion may be inaccurate. Consider using '#align ideal.sup_mul_eq_of_coprime_left Ideal.sup_mul_eq_of_coprime_leftₓ'. -/
theorem sup_mul_eq_of_coprime_left (h : I ⊔ J = ⊤) : I ⊔ J * K = I ⊔ K :=
  le_antisymm (sup_le_sup_left mul_le_left _) fun i hi =>
    by
    rw [eq_top_iff_one] at h; rw [Submodule.mem_sup] at h hi⊢
    obtain ⟨i1, hi1, j, hj, h⟩ := h; obtain ⟨i', hi', k, hk, hi⟩ := hi
    refine' ⟨_, add_mem hi' (mul_mem_right k _ hi1), _, mul_mem_mul hj hk, _⟩
    rw [add_assoc, ← add_mul, h, one_mul, hi]
#align ideal.sup_mul_eq_of_coprime_left Ideal.sup_mul_eq_of_coprime_left

/- warning: ideal.sup_mul_eq_of_coprime_right -> Ideal.sup_mul_eq_of_coprime_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {K : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I K) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) J K)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I J))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {K : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I K) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) J K)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I J))
Case conversion may be inaccurate. Consider using '#align ideal.sup_mul_eq_of_coprime_right Ideal.sup_mul_eq_of_coprime_rightₓ'. -/
theorem sup_mul_eq_of_coprime_right (h : I ⊔ K = ⊤) : I ⊔ J * K = I ⊔ J :=
  by
  rw [mul_comm]
  exact sup_mul_eq_of_coprime_left h
#align ideal.sup_mul_eq_of_coprime_right Ideal.sup_mul_eq_of_coprime_right

/- warning: ideal.mul_sup_eq_of_coprime_left -> Ideal.mul_sup_eq_of_coprime_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {K : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I J) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) I K) J) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) K J))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {K : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I J) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) I K) J) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) K J))
Case conversion may be inaccurate. Consider using '#align ideal.mul_sup_eq_of_coprime_left Ideal.mul_sup_eq_of_coprime_leftₓ'. -/
theorem mul_sup_eq_of_coprime_left (h : I ⊔ J = ⊤) : I * K ⊔ J = K ⊔ J :=
  by
  rw [sup_comm] at h
  rw [sup_comm, sup_mul_eq_of_coprime_left h, sup_comm]
#align ideal.mul_sup_eq_of_coprime_left Ideal.mul_sup_eq_of_coprime_left

/- warning: ideal.mul_sup_eq_of_coprime_right -> Ideal.mul_sup_eq_of_coprime_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {K : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) K J) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) I K) J) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I J))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {K : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) K J) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) I K) J) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I J))
Case conversion may be inaccurate. Consider using '#align ideal.mul_sup_eq_of_coprime_right Ideal.mul_sup_eq_of_coprime_rightₓ'. -/
theorem mul_sup_eq_of_coprime_right (h : K ⊔ J = ⊤) : I * K ⊔ J = I ⊔ J :=
  by
  rw [sup_comm] at h
  rw [sup_comm, sup_mul_eq_of_coprime_right h, sup_comm]
#align ideal.mul_sup_eq_of_coprime_right Ideal.mul_sup_eq_of_coprime_right

/- warning: ideal.sup_prod_eq_top -> Ideal.sup_prod_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {s : Finset.{u2} ι} {J : ι -> (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))}, (forall (i : ι), (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I (J i)) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I (Finset.prod.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) ι (CommSemiring.toCommMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemCommSemiring.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) s (fun (i : ι) => J i))) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u2}} {ι : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)} {s : Finset.{u1} ι} {J : ι -> (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))}, (forall (i : ι), (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) -> (Eq.{succ u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Sup.sup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (SemilatticeSup.toSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u2, u2} R _inst_1 R _inst_1 (Algebra.id.{u2} R _inst_1)))) I (J i)) (Top.top.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instTopSubmodule.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))) -> (Eq.{succ u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Sup.sup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (SemilatticeSup.toSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u2, u2} R _inst_1 R _inst_1 (Algebra.id.{u2} R _inst_1)))) I (Finset.prod.{u2, u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) ι (CommSemiring.toCommMonoid.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u2, u2} R _inst_1 R _inst_1 (Algebra.id.{u2} R _inst_1)))) s (fun (i : ι) => J i))) (Top.top.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instTopSubmodule.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align ideal.sup_prod_eq_top Ideal.sup_prod_eq_topₓ'. -/
theorem sup_prod_eq_top {s : Finset ι} {J : ι → Ideal R} (h : ∀ i, i ∈ s → I ⊔ J i = ⊤) :
    (I ⊔ ∏ i in s, J i) = ⊤ :=
  Finset.prod_induction _ (fun J => I ⊔ J = ⊤)
    (fun J K hJ hK => (sup_mul_eq_of_coprime_left hJ).trans hK) (by rw [one_eq_top, sup_top_eq]) h
#align ideal.sup_prod_eq_top Ideal.sup_prod_eq_top

/- warning: ideal.sup_infi_eq_top -> Ideal.sup_infᵢ_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {s : Finset.{u2} ι} {J : ι -> (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))}, (forall (i : ι), (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I (J i)) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I (infᵢ.{u1, succ u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasInf.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) ι (fun (i : ι) => infᵢ.{u1, 0} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasInf.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) (fun (H : Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) => J i)))) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u2}} {ι : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)} {s : Finset.{u1} ι} {J : ι -> (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))}, (forall (i : ι), (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) -> (Eq.{succ u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Sup.sup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (SemilatticeSup.toSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u2, u2} R _inst_1 R _inst_1 (Algebra.id.{u2} R _inst_1)))) I (J i)) (Top.top.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instTopSubmodule.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))) -> (Eq.{succ u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Sup.sup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (SemilatticeSup.toSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u2, u2} R _inst_1 R _inst_1 (Algebra.id.{u2} R _inst_1)))) I (infᵢ.{u2, succ u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instInfSetSubmodule.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) ι (fun (i : ι) => infᵢ.{u2, 0} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instInfSetSubmodule.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) (fun (H : Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) => J i)))) (Top.top.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instTopSubmodule.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align ideal.sup_infi_eq_top Ideal.sup_infᵢ_eq_topₓ'. -/
theorem sup_infᵢ_eq_top {s : Finset ι} {J : ι → Ideal R} (h : ∀ i, i ∈ s → I ⊔ J i = ⊤) :
    (I ⊔ ⨅ i ∈ s, J i) = ⊤ :=
  eq_top_iff.mpr <|
    le_of_eq_of_le (sup_prod_eq_top h).symm <|
      sup_le_sup_left (le_of_le_of_eq prod_le_inf <| Finset.inf_eq_infᵢ _ _) _
#align ideal.sup_infi_eq_top Ideal.sup_infᵢ_eq_top

/- warning: ideal.prod_sup_eq_top -> Ideal.prod_sup_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {s : Finset.{u2} ι} {J : ι -> (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))}, (forall (i : ι), (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) (J i) I) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) (Finset.prod.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) ι (CommSemiring.toCommMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemCommSemiring.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) s (fun (i : ι) => J i)) I) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u2}} {ι : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)} {s : Finset.{u1} ι} {J : ι -> (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))}, (forall (i : ι), (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) -> (Eq.{succ u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Sup.sup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (SemilatticeSup.toSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u2, u2} R _inst_1 R _inst_1 (Algebra.id.{u2} R _inst_1)))) (J i) I) (Top.top.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instTopSubmodule.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))) -> (Eq.{succ u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Sup.sup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (SemilatticeSup.toSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u2, u2} R _inst_1 R _inst_1 (Algebra.id.{u2} R _inst_1)))) (Finset.prod.{u2, u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) ι (CommSemiring.toCommMonoid.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u2, u2} R _inst_1 R _inst_1 (Algebra.id.{u2} R _inst_1)))) s (fun (i : ι) => J i)) I) (Top.top.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instTopSubmodule.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align ideal.prod_sup_eq_top Ideal.prod_sup_eq_topₓ'. -/
theorem prod_sup_eq_top {s : Finset ι} {J : ι → Ideal R} (h : ∀ i, i ∈ s → J i ⊔ I = ⊤) :
    (∏ i in s, J i) ⊔ I = ⊤ :=
  sup_comm.trans (sup_prod_eq_top fun i hi => sup_comm.trans <| h i hi)
#align ideal.prod_sup_eq_top Ideal.prod_sup_eq_top

/- warning: ideal.infi_sup_eq_top -> Ideal.infᵢ_sup_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {s : Finset.{u2} ι} {J : ι -> (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))}, (forall (i : ι), (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) (J i) I) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) (infᵢ.{u1, succ u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasInf.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) ι (fun (i : ι) => infᵢ.{u1, 0} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasInf.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) (fun (H : Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) => J i))) I) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u2}} {ι : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)} {s : Finset.{u1} ι} {J : ι -> (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))}, (forall (i : ι), (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) -> (Eq.{succ u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Sup.sup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (SemilatticeSup.toSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u2, u2} R _inst_1 R _inst_1 (Algebra.id.{u2} R _inst_1)))) (J i) I) (Top.top.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instTopSubmodule.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))) -> (Eq.{succ u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Sup.sup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (SemilatticeSup.toSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u2, u2} R _inst_1 R _inst_1 (Algebra.id.{u2} R _inst_1)))) (infᵢ.{u2, succ u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instInfSetSubmodule.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) ι (fun (i : ι) => infᵢ.{u2, 0} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instInfSetSubmodule.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) (fun (H : Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) => J i))) I) (Top.top.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.instTopSubmodule.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align ideal.infi_sup_eq_top Ideal.infᵢ_sup_eq_topₓ'. -/
theorem infᵢ_sup_eq_top {s : Finset ι} {J : ι → Ideal R} (h : ∀ i, i ∈ s → J i ⊔ I = ⊤) :
    (⨅ i ∈ s, J i) ⊔ I = ⊤ :=
  sup_comm.trans (sup_infᵢ_eq_top fun i hi => sup_comm.trans <| h i hi)
#align ideal.infi_sup_eq_top Ideal.infᵢ_sup_eq_top

/- warning: ideal.sup_pow_eq_top -> Ideal.sup_pow_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {n : Nat}, (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I J) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I (HPow.hPow.{u1, 0, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHPow.{u1, 0} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Monoid.Pow.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))))) J n)) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {n : Nat}, (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I J) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I (HPow.hPow.{u1, 0, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHPow.{u1, 0} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Monoid.Pow.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))))) J n)) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align ideal.sup_pow_eq_top Ideal.sup_pow_eq_topₓ'. -/
theorem sup_pow_eq_top {n : ℕ} (h : I ⊔ J = ⊤) : I ⊔ J ^ n = ⊤ :=
  by
  rw [← Finset.card_range n, ← Finset.prod_const]
  exact sup_prod_eq_top fun _ _ => h
#align ideal.sup_pow_eq_top Ideal.sup_pow_eq_top

/- warning: ideal.pow_sup_eq_top -> Ideal.pow_sup_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {n : Nat}, (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I J) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) (HPow.hPow.{u1, 0, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHPow.{u1, 0} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Monoid.Pow.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))))) I n) J) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {n : Nat}, (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I J) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) (HPow.hPow.{u1, 0, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHPow.{u1, 0} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Monoid.Pow.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))))) I n) J) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align ideal.pow_sup_eq_top Ideal.pow_sup_eq_topₓ'. -/
theorem pow_sup_eq_top {n : ℕ} (h : I ⊔ J = ⊤) : I ^ n ⊔ J = ⊤ :=
  by
  rw [← Finset.card_range n, ← Finset.prod_const]
  exact prod_sup_eq_top fun _ _ => h
#align ideal.pow_sup_eq_top Ideal.pow_sup_eq_top

/- warning: ideal.pow_sup_pow_eq_top -> Ideal.pow_sup_pow_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {m : Nat} {n : Nat}, (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I J) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) (HPow.hPow.{u1, 0, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHPow.{u1, 0} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Monoid.Pow.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))))) I m) (HPow.hPow.{u1, 0, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHPow.{u1, 0} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Monoid.Pow.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))))) J n)) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {m : Nat} {n : Nat}, (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I J) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) (HPow.hPow.{u1, 0, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHPow.{u1, 0} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Monoid.Pow.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))))) I m) (HPow.hPow.{u1, 0, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHPow.{u1, 0} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Monoid.Pow.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))))) J n)) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align ideal.pow_sup_pow_eq_top Ideal.pow_sup_pow_eq_topₓ'. -/
theorem pow_sup_pow_eq_top {m n : ℕ} (h : I ⊔ J = ⊤) : I ^ m ⊔ J ^ n = ⊤ :=
  sup_pow_eq_top (pow_sup_eq_top h)
#align ideal.pow_sup_pow_eq_top Ideal.pow_sup_pow_eq_top

variable (I)

#print Ideal.mul_bot /-
@[simp]
theorem mul_bot : I * ⊥ = ⊥ :=
  Submodule.smul_bot I
#align ideal.mul_bot Ideal.mul_bot
-/

/- warning: ideal.bot_mul -> Ideal.bot_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasBot.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) I) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasBot.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instBotSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) I) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instBotSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align ideal.bot_mul Ideal.bot_mulₓ'. -/
@[simp]
theorem bot_mul : ⊥ * I = ⊥ :=
  Submodule.bot_smul I
#align ideal.bot_mul Ideal.bot_mul

#print Ideal.mul_top /-
@[simp]
theorem mul_top : I * ⊤ = I :=
  Ideal.mul_comm ⊤ I ▸ Submodule.top_smul I
#align ideal.mul_top Ideal.mul_top
-/

/- warning: ideal.top_mul -> Ideal.top_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) I) I
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) I) I
Case conversion may be inaccurate. Consider using '#align ideal.top_mul Ideal.top_mulₓ'. -/
@[simp]
theorem top_mul : ⊤ * I = I :=
  Submodule.top_smul I
#align ideal.top_mul Ideal.top_mul

variable {I}

#print Ideal.mul_mono /-
theorem mul_mono (hik : I ≤ K) (hjl : J ≤ L) : I * J ≤ K * L :=
  Submodule.smul_mono hik hjl
#align ideal.mul_mono Ideal.mul_mono
-/

#print Ideal.mul_mono_left /-
theorem mul_mono_left (h : I ≤ J) : I * K ≤ J * K :=
  Submodule.smul_mono_left h
#align ideal.mul_mono_left Ideal.mul_mono_left
-/

#print Ideal.mul_mono_right /-
theorem mul_mono_right (h : J ≤ K) : I * J ≤ I * K :=
  Submodule.smul_mono_right h
#align ideal.mul_mono_right Ideal.mul_mono_right
-/

variable (I J K)

#print Ideal.mul_sup /-
theorem mul_sup : I * (J ⊔ K) = I * J ⊔ I * K :=
  Submodule.smul_sup I J K
#align ideal.mul_sup Ideal.mul_sup
-/

/- warning: ideal.sup_mul -> Ideal.sup_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (K : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I J) K) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) I K) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) J K))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (K : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I J) K) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) I K) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) J K))
Case conversion may be inaccurate. Consider using '#align ideal.sup_mul Ideal.sup_mulₓ'. -/
theorem sup_mul : (I ⊔ J) * K = I * K ⊔ J * K :=
  Submodule.sup_smul I J K
#align ideal.sup_mul Ideal.sup_mul

variable {I J K}

#print Ideal.pow_le_pow /-
theorem pow_le_pow {m n : ℕ} (h : m ≤ n) : I ^ n ≤ I ^ m :=
  by
  cases' Nat.exists_eq_add_of_le h with k hk
  rw [hk, pow_add]
  exact le_trans mul_le_inf inf_le_left
#align ideal.pow_le_pow Ideal.pow_le_pow
-/

#print Ideal.pow_le_self /-
theorem pow_le_self {n : ℕ} (hn : n ≠ 0) : I ^ n ≤ I :=
  calc
    I ^ n ≤ I ^ 1 := pow_le_pow (Nat.pos_of_ne_zero hn)
    _ = I := pow_one _
    
#align ideal.pow_le_self Ideal.pow_le_self
-/

#print Ideal.pow_mono /-
theorem pow_mono {I J : Ideal R} (e : I ≤ J) (n : ℕ) : I ^ n ≤ J ^ n :=
  by
  induction n
  · rw [pow_zero, pow_zero]
    exact rfl.le
  · rw [pow_succ, pow_succ]
    exact Ideal.mul_mono e n_ih
#align ideal.pow_mono Ideal.pow_mono
-/

/- warning: ideal.mul_eq_bot -> Ideal.mul_eq_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_2 : CommSemiring.{u1} R] [_inst_3 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))))] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)}, Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Ideal.hasMul.{u1} R _inst_2)) I J) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Submodule.hasBot.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))) (Or (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) I (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Submodule.hasBot.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))) (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) J (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Submodule.hasBot.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_2 : CommSemiring.{u1} R] [_inst_3 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_2))] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)}, Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Ideal.instMulIdealToSemiring.{u1} R _inst_2)) I J) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Submodule.instBotSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))) (Or (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) I (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Submodule.instBotSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))) (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) J (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Submodule.instBotSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))))
Case conversion may be inaccurate. Consider using '#align ideal.mul_eq_bot Ideal.mul_eq_botₓ'. -/
theorem mul_eq_bot {R : Type _} [CommSemiring R] [NoZeroDivisors R] {I J : Ideal R} :
    I * J = ⊥ ↔ I = ⊥ ∨ J = ⊥ :=
  ⟨fun hij =>
    or_iff_not_imp_left.mpr fun I_ne_bot =>
      J.eq_bot_iff.mpr fun j hj =>
        let ⟨i, hi, ne0⟩ := I.ne_bot_iff.mp I_ne_bot
        Or.resolve_left (mul_eq_zero.mp ((I * J).eq_bot_iff.mp hij _ (mul_mem_mul hi hj))) ne0,
    fun h => by cases h <;> rw [← Ideal.mul_bot, h, Ideal.mul_comm]⟩
#align ideal.mul_eq_bot Ideal.mul_eq_bot

instance {R : Type _} [CommSemiring R] [NoZeroDivisors R] : NoZeroDivisors (Ideal R)
    where eq_zero_or_eq_zero_of_mul_eq_zero I J := mul_eq_bot.1

/- warning: ideal.prod_eq_bot -> Ideal.prod_eq_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_2 : CommRing.{u1} R] [_inst_3 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))] {s : Multiset.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)))}, Iff (Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Multiset.prod.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (CommSemiring.toCommMonoid.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Submodule.idemCommSemiring.{u1, u1} R (CommRing.toCommSemiring.{u1} R _inst_2) R (CommRing.toCommSemiring.{u1} R _inst_2) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))))) s) (Bot.bot.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Submodule.hasBot.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)))))) (Exists.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (fun (I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) => Exists.{0} (Membership.Mem.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Multiset.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)))) (Multiset.hasMem.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)))) I s) (fun (H : Membership.Mem.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Multiset.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)))) (Multiset.hasMem.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)))) I s) => Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) I (Bot.bot.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Submodule.hasBot.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_2 : CommRing.{u1} R] [_inst_3 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))] {s : Multiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2)))}, Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))) (Multiset.prod.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))) (CommSemiring.toCommMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R (CommRing.toCommSemiring.{u1} R _inst_2) R (CommRing.toCommSemiring.{u1} R _inst_2) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))))) s) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))) (Submodule.instBotSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2)))))) (Exists.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))) (fun (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))) => And (Membership.mem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))) (Multiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2)))) (Multiset.instMembershipMultiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2)))) I s) (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))) I (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))) (Submodule.instBotSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align ideal.prod_eq_bot Ideal.prod_eq_botₓ'. -/
/-- A product of ideals in an integral domain is zero if and only if one of the terms is zero. -/
theorem prod_eq_bot {R : Type _} [CommRing R] [IsDomain R] {s : Multiset (Ideal R)} :
    s.Prod = ⊥ ↔ ∃ I ∈ s, I = ⊥ :=
  prod_zero_iff_exists_zero
#align ideal.prod_eq_bot Ideal.prod_eq_bot

/- warning: ideal.span_pair_mul_span_pair -> Ideal.span_pair_mul_span_pair is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (w : R) (x : R) (y : R) (z : R), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.hasMul.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Insert.insert.{u1, u1} R (Set.{u1} R) (Set.hasInsert.{u1} R) w (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) x))) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Insert.insert.{u1, u1} R (Set.{u1} R) (Set.hasInsert.{u1} R) y (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) z)))) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Insert.insert.{u1, u1} R (Set.{u1} R) (Set.hasInsert.{u1} R) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) w y) (Insert.insert.{u1, u1} R (Set.{u1} R) (Set.hasInsert.{u1} R) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) w z) (Insert.insert.{u1, u1} R (Set.{u1} R) (Set.hasInsert.{u1} R) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) x y) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) x z))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (w : R) (x : R) (y : R) (z : R), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instMulIdealToSemiring.{u1} R _inst_1)) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Insert.insert.{u1, u1} R (Set.{u1} R) (Set.instInsertSet.{u1} R) w (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) x))) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Insert.insert.{u1, u1} R (Set.{u1} R) (Set.instInsertSet.{u1} R) y (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) z)))) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Insert.insert.{u1, u1} R (Set.{u1} R) (Set.instInsertSet.{u1} R) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) w y) (Insert.insert.{u1, u1} R (Set.{u1} R) (Set.instInsertSet.{u1} R) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) w z) (Insert.insert.{u1, u1} R (Set.{u1} R) (Set.instInsertSet.{u1} R) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) x y) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) x z))))))
Case conversion may be inaccurate. Consider using '#align ideal.span_pair_mul_span_pair Ideal.span_pair_mul_span_pairₓ'. -/
theorem span_pair_mul_span_pair (w x y z : R) :
    (span {w, x} : Ideal R) * span {y, z} = span {w * y, w * z, x * y, x * z} := by
  simp_rw [span_insert, sup_mul, mul_sup, span_singleton_mul_span_singleton, sup_assoc]
#align ideal.span_pair_mul_span_pair Ideal.span_pair_mul_span_pair

#print Ideal.radical /-
/-- The radical of an ideal `I` consists of the elements `r` such that `r^n ∈ I` for some `n`. -/
def radical (I : Ideal R) : Ideal R
    where
  carrier := { r | ∃ n : ℕ, r ^ n ∈ I }
  zero_mem' := ⟨1, (pow_one (0 : R)).symm ▸ I.zero_mem⟩
  add_mem' := fun x y ⟨m, hxmi⟩ ⟨n, hyni⟩ =>
    ⟨m + n,
      (add_pow x y (m + n)).symm ▸ I.sum_mem <|
        show
          ∀ c ∈ Finset.range (Nat.succ (m + n)), x ^ c * y ^ (m + n - c) * Nat.choose (m + n) c ∈ I
          from fun c hc =>
          Or.cases_on (le_total c m)
            (fun hcm =>
              I.mul_mem_right _ <|
                I.mul_mem_left _ <|
                  Nat.add_comm n m ▸
                    (add_tsub_assoc_of_le hcm n).symm ▸
                      (pow_add y n (m - c)).symm ▸ I.mul_mem_right _ hyni)
            fun hmc =>
            I.mul_mem_right _ <|
              I.mul_mem_right _ <|
                add_tsub_cancel_of_le hmc ▸ (pow_add x m (c - m)).symm ▸ I.mul_mem_right _ hxmi⟩
  smul_mem' := fun r s ⟨n, hsni⟩ => ⟨n, (mul_pow r s n).symm ▸ I.mul_mem_left (r ^ n) hsni⟩
#align ideal.radical Ideal.radical
-/

#print Ideal.IsRadical /-
/-- An ideal is radical if it contains its radical. -/
def IsRadical (I : Ideal R) : Prop :=
  I.radical ≤ I
#align ideal.is_radical Ideal.IsRadical
-/

#print Ideal.le_radical /-
theorem le_radical : I ≤ radical I := fun r hri => ⟨1, (pow_one r).symm ▸ hri⟩
#align ideal.le_radical Ideal.le_radical
-/

#print Ideal.radical_eq_iff /-
/-- An ideal is radical iff it is equal to its radical. -/
theorem radical_eq_iff : I.radical = I ↔ I.IsRadical := by
  rw [le_antisymm_iff, and_iff_left le_radical, IsRadical]
#align ideal.radical_eq_iff Ideal.radical_eq_iff
-/

alias radical_eq_iff ↔ _ is_radical.radical
#align ideal.is_radical.radical Ideal.IsRadical.radical

variable (R)

/- warning: ideal.radical_top -> Ideal.radical_top is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R], Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.radical.{u1} R _inst_1 (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R], Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.radical.{u1} R _inst_1 (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align ideal.radical_top Ideal.radical_topₓ'. -/
theorem radical_top : (radical ⊤ : Ideal R) = ⊤ :=
  (eq_top_iff_one _).2 ⟨0, Submodule.mem_top⟩
#align ideal.radical_top Ideal.radical_top

variable {R}

#print Ideal.radical_mono /-
theorem radical_mono (H : I ≤ J) : radical I ≤ radical J := fun r ⟨n, hrni⟩ => ⟨n, H hrni⟩
#align ideal.radical_mono Ideal.radical_mono
-/

variable (I)

#print Ideal.radical_isRadical /-
theorem radical_isRadical : (radical I).IsRadical := fun r ⟨n, k, hrnki⟩ =>
  ⟨n * k, (pow_mul r n k).symm ▸ hrnki⟩
#align ideal.radical_is_radical Ideal.radical_isRadical
-/

#print Ideal.radical_idem /-
@[simp]
theorem radical_idem : radical (radical I) = radical I :=
  (radical_isRadical I).radical
#align ideal.radical_idem Ideal.radical_idem
-/

variable {I}

#print Ideal.IsRadical.radical_le_iff /-
theorem IsRadical.radical_le_iff (hJ : J.IsRadical) : radical I ≤ J ↔ I ≤ J :=
  ⟨le_trans le_radical, fun h => hJ.radical ▸ radical_mono h⟩
#align ideal.is_radical.radical_le_iff Ideal.IsRadical.radical_le_iff
-/

#print Ideal.radical_le_radical_iff /-
theorem radical_le_radical_iff : radical I ≤ radical J ↔ I ≤ radical J :=
  (radical_isRadical J).radical_le_iff
#align ideal.radical_le_radical_iff Ideal.radical_le_radical_iff
-/

/- warning: ideal.radical_eq_top -> Ideal.radical_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.radical.{u1} R _inst_1 I) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) I (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.radical.{u1} R _inst_1 I) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) I (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align ideal.radical_eq_top Ideal.radical_eq_topₓ'. -/
theorem radical_eq_top : radical I = ⊤ ↔ I = ⊤ :=
  ⟨fun h =>
    (eq_top_iff_one _).2 <|
      let ⟨n, hn⟩ := (eq_top_iff_one _).1 h
      @one_pow R _ n ▸ hn,
    fun h => h.symm ▸ radical_top R⟩
#align ideal.radical_eq_top Ideal.radical_eq_top

#print Ideal.IsPrime.isRadical /-
theorem IsPrime.isRadical (H : IsPrime I) : I.IsRadical := fun r ⟨n, hrni⟩ =>
  H.mem_of_pow_mem n hrni
#align ideal.is_prime.is_radical Ideal.IsPrime.isRadical
-/

#print Ideal.IsPrime.radical /-
theorem IsPrime.radical (H : IsPrime I) : radical I = I :=
  H.IsRadical.radical
#align ideal.is_prime.radical Ideal.IsPrime.radical
-/

variable (I J)

/- warning: ideal.radical_sup -> Ideal.radical_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.radical.{u1} R _inst_1 (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) I J)) (Ideal.radical.{u1} R _inst_1 (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))) (Ideal.radical.{u1} R _inst_1 I) (Ideal.radical.{u1} R _inst_1 J)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.radical.{u1} R _inst_1 (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) I J)) (Ideal.radical.{u1} R _inst_1 (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule.{u1, u1} R _inst_1 R _inst_1 (Algebra.id.{u1} R _inst_1)))) (Ideal.radical.{u1} R _inst_1 I) (Ideal.radical.{u1} R _inst_1 J)))
Case conversion may be inaccurate. Consider using '#align ideal.radical_sup Ideal.radical_supₓ'. -/
theorem radical_sup : radical (I ⊔ J) = radical (radical I ⊔ radical J) :=
  le_antisymm (radical_mono <| sup_le_sup le_radical le_radical) <|
    radical_le_radical_iff.2 <| sup_le (radical_mono le_sup_left) (radical_mono le_sup_right)
#align ideal.radical_sup Ideal.radical_sup

#print Ideal.radical_inf /-
theorem radical_inf : radical (I ⊓ J) = radical I ⊓ radical J :=
  le_antisymm (le_inf (radical_mono inf_le_left) (radical_mono inf_le_right))
    fun r ⟨⟨m, hrm⟩, ⟨n, hrn⟩⟩ =>
    ⟨m + n, (pow_add r m n).symm ▸ I.mul_mem_right _ hrm,
      (pow_add r m n).symm ▸ J.mul_mem_left _ hrn⟩
#align ideal.radical_inf Ideal.radical_inf
-/

#print Ideal.radical_mul /-
theorem radical_mul : radical (I * J) = radical I ⊓ radical J :=
  le_antisymm (radical_inf I J ▸ radical_mono <| @mul_le_inf _ _ I J) fun r ⟨⟨m, hrm⟩, ⟨n, hrn⟩⟩ =>
    ⟨m + n, (pow_add r m n).symm ▸ mul_mem_mul hrm hrn⟩
#align ideal.radical_mul Ideal.radical_mul
-/

variable {I J}

#print Ideal.IsPrime.radical_le_iff /-
theorem IsPrime.radical_le_iff (hJ : IsPrime J) : radical I ≤ J ↔ I ≤ J :=
  hJ.IsRadical.radical_le_iff
#align ideal.is_prime.radical_le_iff Ideal.IsPrime.radical_le_iff
-/

/- warning: ideal.radical_eq_Inf -> Ideal.radical_eq_infₛ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.radical.{u1} R _inst_1 I) (InfSet.infₛ.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasInf.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (setOf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (fun (J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) => And (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) I J) (Ideal.IsPrime.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) J))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.radical.{u1} R _inst_1 I) (InfSet.infₛ.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instInfSetSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (setOf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (fun (J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) => And (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) I J) (Ideal.IsPrime.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) J))))
Case conversion may be inaccurate. Consider using '#align ideal.radical_eq_Inf Ideal.radical_eq_infₛₓ'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∉ » m) -/
theorem radical_eq_infₛ (I : Ideal R) : radical I = infₛ { J : Ideal R | I ≤ J ∧ IsPrime J } :=
  le_antisymm (le_infₛ fun J hJ => hJ.2.radical_le_iff.2 hJ.1) fun r hr =>
    by_contradiction fun hri =>
      let ⟨m, (hrm : r ∉ radical m), him, hm⟩ :=
        zorn_nonempty_partialOrder₀ { K : Ideal R | r ∉ radical K }
          (fun c hc hcc y hyc =>
            ⟨supₛ c, fun ⟨n, hrnc⟩ =>
              let ⟨y, hyc, hrny⟩ := (Submodule.mem_supₛ_of_directed ⟨y, hyc⟩ hcc.DirectedOn).1 hrnc
              hc hyc ⟨n, hrny⟩,
              fun z => le_supₛ⟩)
          I hri
      have : ∀ (x) (_ : x ∉ m), r ∈ radical (m ⊔ span {x}) := fun x hxm =>
        by_contradiction fun hrmx =>
          hxm <|
            hm (m ⊔ span {x}) hrmx le_sup_left ▸
              (le_sup_right : _ ≤ m ⊔ span {x}) (subset_span <| Set.mem_singleton _)
      have : IsPrime m :=
        ⟨by rintro rfl <;> rw [radical_top] at hrm <;> exact hrm trivial, fun x y hxym =>
          or_iff_not_imp_left.2 fun hxm =>
            by_contradiction fun hym =>
              let ⟨n, hrn⟩ := this _ hxm
              let ⟨p, hpm, q, hq, hpqrn⟩ := Submodule.mem_sup.1 hrn
              let ⟨c, hcxq⟩ := mem_span_singleton'.1 hq
              let ⟨k, hrk⟩ := this _ hym
              let ⟨f, hfm, g, hg, hfgrk⟩ := Submodule.mem_sup.1 hrk
              let ⟨d, hdyg⟩ := mem_span_singleton'.1 hg
              hrm
                ⟨n + k, by
                  rw [pow_add, ← hpqrn, ← hcxq, ← hfgrk, ← hdyg, add_mul, mul_add (c * x),
                      mul_assoc c x (d * y), mul_left_comm x, ← mul_assoc] <;>
                    refine'
                      m.add_mem (m.mul_mem_right _ hpm)
                        (m.add_mem (m.mul_mem_left _ hfm) (m.mul_mem_left _ hxym))⟩⟩
      hrm <|
        this.radical.symm ▸ (infₛ_le ⟨him, this⟩ : infₛ { J : Ideal R | I ≤ J ∧ IsPrime J } ≤ m) hr
#align ideal.radical_eq_Inf Ideal.radical_eq_infₛ

/- warning: ideal.is_radical_bot_of_no_zero_divisors -> Ideal.isRadical_bot_of_noZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_2 : CommSemiring.{u1} R] [_inst_3 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))))], Ideal.IsRadical.{u1} R _inst_2 (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Submodule.hasBot.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_2 : CommSemiring.{u1} R] [_inst_3 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_2))], Ideal.IsRadical.{u1} R _inst_2 (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Submodule.instBotSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))
Case conversion may be inaccurate. Consider using '#align ideal.is_radical_bot_of_no_zero_divisors Ideal.isRadical_bot_of_noZeroDivisorsₓ'. -/
theorem isRadical_bot_of_noZeroDivisors {R} [CommSemiring R] [NoZeroDivisors R] :
    (⊥ : Ideal R).IsRadical := fun x hx => hx.recOn fun n hn => pow_eq_zero hn
#align ideal.is_radical_bot_of_no_zero_divisors Ideal.isRadical_bot_of_noZeroDivisors

/- warning: ideal.radical_bot_of_no_zero_divisors -> Ideal.radical_bot_of_noZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_2 : CommSemiring.{u1} R] [_inst_3 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))))], Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Ideal.radical.{u1} R _inst_2 (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Submodule.hasBot.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Submodule.hasBot.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_2 : CommSemiring.{u1} R] [_inst_3 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_2))], Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Ideal.radical.{u1} R _inst_2 (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Submodule.instBotSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)) (Submodule.instBotSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_2))))
Case conversion may be inaccurate. Consider using '#align ideal.radical_bot_of_no_zero_divisors Ideal.radical_bot_of_noZeroDivisorsₓ'. -/
@[simp]
theorem radical_bot_of_noZeroDivisors {R : Type u} [CommSemiring R] [NoZeroDivisors R] :
    radical (⊥ : Ideal R) = ⊥ :=
  eq_bot_iff.2 isRadical_bot_of_noZeroDivisors
#align ideal.radical_bot_of_no_zero_divisors Ideal.radical_bot_of_noZeroDivisors

instance : IdemCommSemiring (Ideal R) :=
  Submodule.idemCommSemiring

variable (R)

/- warning: ideal.top_pow -> Ideal.top_pow is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] (n : Nat), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HPow.hPow.{u1, 0, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHPow.{u1, 0} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Monoid.Pow.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))))) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) n) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] (n : Nat), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HPow.hPow.{u1, 0, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHPow.{u1, 0} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) Nat (Monoid.Pow.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))))) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) n) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align ideal.top_pow Ideal.top_powₓ'. -/
theorem top_pow (n : ℕ) : (⊤ ^ n : Ideal R) = ⊤ :=
  Nat.recOn n one_eq_top fun n ih => by rw [pow_succ, ih, top_mul]
#align ideal.top_pow Ideal.top_pow

variable {R}

variable (I)

#print Ideal.radical_pow /-
theorem radical_pow (n : ℕ) (H : n > 0) : radical (I ^ n) = radical I :=
  Nat.recOn n (Not.elim (by decide))
    (fun n ih H =>
      Or.cases_on (lt_or_eq_of_le <| Nat.le_of_lt_succ H)
        (fun H =>
          calc
            radical (I ^ (n + 1)) = radical I ⊓ radical (I ^ n) :=
              by
              rw [pow_succ]
              exact radical_mul _ _
            _ = radical I ⊓ radical I := by rw [ih H]
            _ = radical I := inf_idem
            )
        fun H => H ▸ (pow_one I).symm ▸ rfl)
    H
#align ideal.radical_pow Ideal.radical_pow
-/

#print Ideal.IsPrime.mul_le /-
theorem IsPrime.mul_le {I J P : Ideal R} (hp : IsPrime P) : I * J ≤ P ↔ I ≤ P ∨ J ≤ P :=
  ⟨fun h =>
    or_iff_not_imp_left.2 fun hip j hj =>
      let ⟨i, hi, hip⟩ := Set.not_subset.1 hip
      (hp.mem_or_mem <| h <| mul_mem_mul hi hj).resolve_left hip,
    fun h =>
    Or.cases_on h (le_trans <| le_trans mul_le_inf inf_le_left)
      (le_trans <| le_trans mul_le_inf inf_le_right)⟩
#align ideal.is_prime.mul_le Ideal.IsPrime.mul_le
-/

#print Ideal.IsPrime.inf_le /-
theorem IsPrime.inf_le {I J P : Ideal R} (hp : IsPrime P) : I ⊓ J ≤ P ↔ I ≤ P ∨ J ≤ P :=
  ⟨fun h => hp.mul_le.1 <| le_trans mul_le_inf h, fun h =>
    Or.cases_on h (le_trans inf_le_left) (le_trans inf_le_right)⟩
#align ideal.is_prime.inf_le Ideal.IsPrime.inf_le
-/

/- warning: ideal.is_prime.multiset_prod_le -> Ideal.IsPrime.multiset_prod_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {s : Multiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))} {P : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Ideal.IsPrime.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) P) -> (Ne.{succ u1} (Multiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) s (OfNat.ofNat.{u1} (Multiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) 0 (OfNat.mk.{u1} (Multiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) 0 (Zero.zero.{u1} (Multiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Multiset.hasZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) -> (Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (Multiset.prod.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CommSemiring.toCommMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.idemCommSemiring.{u1} R _inst_1))) s) P) (Exists.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (fun (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) => Exists.{0} (Membership.Mem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Multiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Multiset.hasMem.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) I s) (fun (H : Membership.Mem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Multiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Multiset.hasMem.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) I s) => LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) I P))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {s : Multiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))} {P : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Ideal.IsPrime.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) P) -> (Ne.{succ u1} (Multiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) s (OfNat.ofNat.{u1} (Multiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) 0 (Zero.toOfNat0.{u1} (Multiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Multiset.instZeroMultiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) -> (Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (Multiset.prod.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CommSemiring.toCommMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instIdemCommSemiringIdealToSemiring.{u1} R _inst_1))) s) P) (Exists.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (fun (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) => And (Membership.mem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Multiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Multiset.instMembershipMultiset.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) I s) (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) I P))))
Case conversion may be inaccurate. Consider using '#align ideal.is_prime.multiset_prod_le Ideal.IsPrime.multiset_prod_leₓ'. -/
theorem IsPrime.multiset_prod_le {s : Multiset (Ideal R)} {P : Ideal R} (hp : IsPrime P)
    (hne : s ≠ 0) : s.Prod ≤ P ↔ ∃ I ∈ s, I ≤ P :=
  by
  suffices s.Prod ≤ P → ∃ I ∈ s, I ≤ P from
    ⟨this, fun ⟨i, his, hip⟩ => le_trans multiset_prod_le_inf <| le_trans (Multiset.inf_le his) hip⟩
  classical
    obtain ⟨b, hb⟩ : ∃ b, b ∈ s := Multiset.exists_mem_of_ne_zero hne
    obtain ⟨t, rfl⟩ : ∃ t, s = b ::ₘ t
    exact ⟨s.erase b, (Multiset.cons_erase hb).symm⟩
    refine' t.induction_on _ _
    ·
      simp only [exists_prop, Multiset.cons_zero, Multiset.prod_singleton, Multiset.mem_singleton,
        exists_eq_left, imp_self]
    intro a s ih h
    rw [Multiset.cons_swap, Multiset.prod_cons, hp.mul_le] at h
    rw [Multiset.cons_swap]
    cases h
    · exact ⟨a, Multiset.mem_cons_self a _, h⟩
    obtain ⟨I, hI, ih⟩ : ∃ I ∈ b ::ₘ s, I ≤ P := ih h
    exact ⟨I, Multiset.mem_cons_of_mem hI, ih⟩
#align ideal.is_prime.multiset_prod_le Ideal.IsPrime.multiset_prod_le

/- warning: ideal.is_prime.multiset_prod_map_le -> Ideal.IsPrime.multiset_prod_map_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {s : Multiset.{u2} ι} (f : ι -> (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) {P : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Ideal.IsPrime.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) P) -> (Ne.{succ u2} (Multiset.{u2} ι) s (OfNat.ofNat.{u2} (Multiset.{u2} ι) 0 (OfNat.mk.{u2} (Multiset.{u2} ι) 0 (Zero.zero.{u2} (Multiset.{u2} ι) (Multiset.hasZero.{u2} ι))))) -> (Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (Multiset.prod.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CommSemiring.toCommMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.idemCommSemiring.{u1} R _inst_1))) (Multiset.map.{u2, u1} ι (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) f s)) P) (Exists.{succ u2} ι (fun (i : ι) => Exists.{0} (Membership.Mem.{u2, u2} ι (Multiset.{u2} ι) (Multiset.hasMem.{u2} ι) i s) (fun (H : Membership.Mem.{u2, u2} ι (Multiset.{u2} ι) (Multiset.hasMem.{u2} ι) i s) => LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (f i) P))))
but is expected to have type
  forall {R : Type.{u2}} {ι : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {s : Multiset.{u1} ι} (f : ι -> (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) {P : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)}, (Ideal.IsPrime.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1) P) -> (Ne.{succ u1} (Multiset.{u1} ι) s (OfNat.ofNat.{u1} (Multiset.{u1} ι) 0 (Zero.toOfNat0.{u1} (Multiset.{u1} ι) (Multiset.instZeroMultiset.{u1} ι)))) -> (Iff (LE.le.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Preorder.toLE.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))))) (Multiset.prod.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (CommSemiring.toCommMonoid.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Ideal.instIdemCommSemiringIdealToSemiring.{u2} R _inst_1))) (Multiset.map.{u1, u2} ι (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) f s)) P) (Exists.{succ u1} ι (fun (i : ι) => And (Membership.mem.{u1, u1} ι (Multiset.{u1} ι) (Multiset.instMembershipMultiset.{u1} ι) i s) (LE.le.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Preorder.toLE.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))))) (f i) P))))
Case conversion may be inaccurate. Consider using '#align ideal.is_prime.multiset_prod_map_le Ideal.IsPrime.multiset_prod_map_leₓ'. -/
theorem IsPrime.multiset_prod_map_le {s : Multiset ι} (f : ι → Ideal R) {P : Ideal R}
    (hp : IsPrime P) (hne : s ≠ 0) : (s.map f).Prod ≤ P ↔ ∃ i ∈ s, f i ≤ P :=
  by
  rw [hp.multiset_prod_le (mt multiset.map_eq_zero.mp hne)]
  simp_rw [exists_prop, Multiset.mem_map, exists_exists_and_eq_and]
#align ideal.is_prime.multiset_prod_map_le Ideal.IsPrime.multiset_prod_map_le

/- warning: ideal.is_prime.prod_le -> Ideal.IsPrime.prod_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {s : Finset.{u2} ι} {f : ι -> (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))} {P : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Ideal.IsPrime.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) P) -> (Finset.Nonempty.{u2} ι s) -> (Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (Finset.prod.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) ι (CommSemiring.toCommMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.idemCommSemiring.{u1} R _inst_1))) s f) P) (Exists.{succ u2} ι (fun (i : ι) => Exists.{0} (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) (fun (H : Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) => LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (f i) P))))
but is expected to have type
  forall {R : Type.{u2}} {ι : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {s : Finset.{u1} ι} {f : ι -> (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))} {P : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)}, (Ideal.IsPrime.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1) P) -> (Finset.Nonempty.{u1} ι s) -> (Iff (LE.le.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Preorder.toLE.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))))) (Finset.prod.{u2, u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) ι (CommSemiring.toCommMonoid.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Ideal.instIdemCommSemiringIdealToSemiring.{u2} R _inst_1))) s f) P) (Exists.{succ u1} ι (fun (i : ι) => And (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) (LE.le.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Preorder.toLE.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))))) (f i) P))))
Case conversion may be inaccurate. Consider using '#align ideal.is_prime.prod_le Ideal.IsPrime.prod_leₓ'. -/
theorem IsPrime.prod_le {s : Finset ι} {f : ι → Ideal R} {P : Ideal R} (hp : IsPrime P)
    (hne : s.Nonempty) : s.Prod f ≤ P ↔ ∃ i ∈ s, f i ≤ P :=
  hp.multiset_prod_map_le f (mt Finset.val_eq_zero.mp hne.ne_empty)
#align ideal.is_prime.prod_le Ideal.IsPrime.prod_le

/- warning: ideal.is_prime.inf_le' -> Ideal.IsPrime.inf_le' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] {s : Finset.{u2} ι} {f : ι -> (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))} {P : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Ideal.IsPrime.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) P) -> (Finset.Nonempty.{u2} ι s) -> (Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (Finset.inf.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) ι (Lattice.toSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (ConditionallyCompleteLattice.toLattice.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (Submodule.orderTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) s f) P) (Exists.{succ u2} ι (fun (i : ι) => Exists.{0} (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) (fun (H : Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) => LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) (f i) P))))
but is expected to have type
  forall {R : Type.{u2}} {ι : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] {s : Finset.{u1} ι} {f : ι -> (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))} {P : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)}, (Ideal.IsPrime.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1) P) -> (Finset.Nonempty.{u1} ι s) -> (Iff (LE.le.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Preorder.toLE.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))))) (Finset.inf.{u2, u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) ι (Lattice.toSemilatticeInf.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (ConditionallyCompleteLattice.toLattice.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))) (Submodule.instOrderTopSubmoduleToLEToPreorderInstPartialOrderSetLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) s f) P) (Exists.{succ u1} ι (fun (i : ι) => And (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) (LE.le.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Preorder.toLE.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))))) (f i) P))))
Case conversion may be inaccurate. Consider using '#align ideal.is_prime.inf_le' Ideal.IsPrime.inf_le'ₓ'. -/
theorem IsPrime.inf_le' {s : Finset ι} {f : ι → Ideal R} {P : Ideal R} (hp : IsPrime P)
    (hsne : s.Nonempty) : s.inf f ≤ P ↔ ∃ i ∈ s, f i ≤ P :=
  ⟨fun h => (hp.prod_le hsne).1 <| le_trans prod_le_inf h, fun ⟨i, his, hip⟩ =>
    le_trans (Finset.inf_le his) hip⟩
#align ideal.is_prime.inf_le' Ideal.IsPrime.inf_le'

/- warning: ideal.subset_union -> Ideal.subset_union is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_2 : Ring.{u1} R] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)} {J : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)} {K : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)}, Iff (HasSubset.Subset.{u1} (Set.{u1} R) (Set.hasSubset.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2)))))) I) (Union.union.{u1} (Set.{u1} R) (Set.hasUnion.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2)))))) J) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2)))))) K))) (Or (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2))))))) I J) (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2))))))) I K))
but is expected to have type
  forall {R : Type.{u1}} [_inst_2 : Ring.{u1} R] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)} {J : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)} {K : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)}, Iff (HasSubset.Subset.{u1} (Set.{u1} R) (Set.instHasSubsetSet.{u1} R) (SetLike.coe.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2))) I) (Union.union.{u1} (Set.{u1} R) (Set.instUnionSet.{u1} R) (SetLike.coe.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2))) J) (SetLike.coe.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2))) K))) (Or (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2))))))) I J) (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2))))))) I K))
Case conversion may be inaccurate. Consider using '#align ideal.subset_union Ideal.subset_unionₓ'. -/
theorem subset_union {R : Type u} [Ring R] {I J K : Ideal R} :
    (I : Set R) ⊆ J ∪ K ↔ I ≤ J ∨ I ≤ K :=
  ⟨fun h =>
    or_iff_not_imp_left.2 fun hij s hsi =>
      let ⟨r, hri, hrj⟩ := Set.not_subset.1 hij
      by_contradiction fun hsk =>
        Or.cases_on (h <| I.add_mem hri hsi)
          (fun hj => hrj <| add_sub_cancel r s ▸ J.sub_mem hj ((h hsi).resolve_right hsk)) fun hk =>
          hsk <| add_sub_cancel' r s ▸ K.sub_mem hk ((h hri).resolve_left hrj),
    fun h =>
    Or.cases_on h (fun h => Set.Subset.trans h <| Set.subset_union_left J K) fun h =>
      Set.Subset.trans h <| Set.subset_union_right J K⟩
#align ideal.subset_union Ideal.subset_union

/- warning: ideal.subset_union_prime' -> Ideal.subset_union_prime' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} {R : Type.{u1}} [_inst_2 : CommRing.{u1} R] {s : Finset.{u2} ι} {f : ι -> (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)))} {a : ι} {b : ι}, (forall (i : ι), (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) -> (Ideal.IsPrime.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)) (f i))) -> (forall {I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))}, Iff (HasSubset.Subset.{u1} (Set.{u1} R) (Set.hasSubset.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))))) I) (Union.union.{u1} (Set.{u1} R) (Set.hasUnion.{u1} R) (Union.union.{u1} (Set.{u1} R) (Set.hasUnion.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))))) (f a)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))))) (f b))) (Set.unionᵢ.{u1, succ u2} R ι (fun (i : ι) => Set.unionᵢ.{u1, 0} R (Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) (fun (H : Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))))) (f i)))))) (Or (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)))))))) I (f a)) (Or (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)))))))) I (f b)) (Exists.{succ u2} ι (fun (i : ι) => Exists.{0} (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) (fun (H : Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) => LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)))))))) I (f i)))))))
but is expected to have type
  forall {ι : Type.{u1}} {R : Type.{u2}} [_inst_2 : CommRing.{u2} R] {s : Finset.{u1} ι} {f : ι -> (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))} {a : ι} {b : ι}, (forall (i : ι), (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) -> (Ideal.IsPrime.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (f i))) -> (forall {I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))}, Iff (HasSubset.Subset.{u2} (Set.{u2} R) (Set.instHasSubsetSet.{u2} R) (SetLike.coe.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))) I) (Union.union.{u2} (Set.{u2} R) (Set.instUnionSet.{u2} R) (Union.union.{u2} (Set.{u2} R) (Set.instUnionSet.{u2} R) (SetLike.coe.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))) (f a)) (SetLike.coe.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))) (f b))) (Set.unionᵢ.{u2, succ u1} R ι (fun (i : ι) => Set.unionᵢ.{u2, 0} R (Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) i (Finset.toSet.{u1} ι s)) (fun (H : Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) i (Finset.toSet.{u1} ι s)) => SetLike.coe.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))) (f i)))))) (Or (LE.le.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (Preorder.toLE.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))))))) I (f a)) (Or (LE.le.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (Preorder.toLE.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))))))) I (f b)) (Exists.{succ u1} ι (fun (i : ι) => And (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) (LE.le.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (Preorder.toLE.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))))))) I (f i)))))))
Case conversion may be inaccurate. Consider using '#align ideal.subset_union_prime' Ideal.subset_union_prime'ₓ'. -/
/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:564:6: unsupported: specialize @hyp -/
/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:564:6: unsupported: specialize @hyp -/
/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:564:6: unsupported: specialize @hyp -/
theorem subset_union_prime' {R : Type u} [CommRing R] {s : Finset ι} {f : ι → Ideal R} {a b : ι}
    (hp : ∀ i ∈ s, IsPrime (f i)) {I : Ideal R} :
    ((I : Set R) ⊆ f a ∪ f b ∪ ⋃ i ∈ (↑s : Set ι), f i) ↔ I ≤ f a ∨ I ≤ f b ∨ ∃ i ∈ s, I ≤ f i :=
  by
  suffices
    ((I : Set R) ⊆ f a ∪ f b ∪ ⋃ i ∈ (↑s : Set ι), f i) → I ≤ f a ∨ I ≤ f b ∨ ∃ i ∈ s, I ≤ f i from
    ⟨this, fun h =>
      Or.cases_on h
        (fun h =>
          Set.Subset.trans h <|
            Set.Subset.trans (Set.subset_union_left _ _) (Set.subset_union_left _ _))
        fun h =>
        Or.cases_on h
          (fun h =>
            Set.Subset.trans h <|
              Set.Subset.trans (Set.subset_union_right _ _) (Set.subset_union_left _ _))
          fun ⟨i, his, hi⟩ => by
          refine' Set.Subset.trans hi <| Set.Subset.trans _ <| Set.subset_union_right _ _ <;>
            exact Set.subset_bunionᵢ_of_mem (Finset.mem_coe.2 his)⟩
  generalize hn : s.card = n; intro h
  induction' n with n ih generalizing a b s
  · clear hp
    rw [Finset.card_eq_zero] at hn
    subst hn
    rw [Finset.coe_empty, Set.bunionᵢ_empty, Set.union_empty, subset_union] at h
    simpa only [exists_prop, Finset.not_mem_empty, false_and_iff, exists_false, or_false_iff]
  classical
    replace hn : ∃ (i : ι)(t : Finset ι), i ∉ t ∧ insert i t = s ∧ t.card = n :=
      Finset.card_eq_succ.1 hn
    rcases hn with ⟨i, t, hit, rfl, hn⟩
    replace hp : is_prime (f i) ∧ ∀ x ∈ t, is_prime (f x) := (t.forall_mem_insert _ _).1 hp
    by_cases Ht : ∃ j ∈ t, f j ≤ f i
    · obtain ⟨j, hjt, hfji⟩ : ∃ j ∈ t, f j ≤ f i := Ht
      obtain ⟨u, hju, rfl⟩ : ∃ u, j ∉ u ∧ insert j u = t :=
        ⟨t.erase j, t.not_mem_erase j, Finset.insert_erase hjt⟩
      have hp' : ∀ k ∈ insert i u, is_prime (f k) :=
        by
        rw [Finset.forall_mem_insert] at hp⊢
        exact ⟨hp.1, hp.2.2⟩
      have hiu : i ∉ u := mt Finset.mem_insert_of_mem hit
      have hn' : (insert i u).card = n :=
        by
        rwa [Finset.card_insert_of_not_mem] at hn⊢
        exacts[hiu, hju]
      have h' : (I : Set R) ⊆ f a ∪ f b ∪ ⋃ k ∈ (↑(insert i u) : Set ι), f k :=
        by
        rw [Finset.coe_insert] at h⊢
        rw [Finset.coe_insert] at h
        simp only [Set.bunionᵢ_insert] at h⊢
        rw [← Set.union_assoc ↑(f i)] at h
        erw [Set.union_eq_self_of_subset_right hfji] at h
        exact h
      specialize ih a b (insert i u) hp' hn' h'
      refine' ih.imp id (Or.imp id (Exists.imp fun k => _))
      simp only [exists_prop]
      exact And.imp (fun hk => Finset.insert_subset_insert i (Finset.subset_insert j u) hk) id
    by_cases Ha : f a ≤ f i
    · have h' : (I : Set R) ⊆ f i ∪ f b ∪ ⋃ j ∈ (↑t : Set ι), f j :=
        by
        rw [Finset.coe_insert, Set.bunionᵢ_insert, ← Set.union_assoc,
          Set.union_right_comm ↑(f a)] at h
        erw [Set.union_eq_self_of_subset_left Ha] at h
        exact h
      specialize ih i b t hp.2 hn h'
      right
      rcases ih with (ih | ih | ⟨k, hkt, ih⟩)
      · exact Or.inr ⟨i, Finset.mem_insert_self i t, ih⟩
      · exact Or.inl ih
      · exact Or.inr ⟨k, Finset.mem_insert_of_mem hkt, ih⟩
    by_cases Hb : f b ≤ f i
    · have h' : (I : Set R) ⊆ f a ∪ f i ∪ ⋃ j ∈ (↑t : Set ι), f j :=
        by
        rw [Finset.coe_insert, Set.bunionᵢ_insert, ← Set.union_assoc, Set.union_assoc ↑(f a)] at h
        erw [Set.union_eq_self_of_subset_left Hb] at h
        exact h
      specialize ih a i t hp.2 hn h'
      rcases ih with (ih | ih | ⟨k, hkt, ih⟩)
      · exact Or.inl ih
      · exact Or.inr (Or.inr ⟨i, Finset.mem_insert_self i t, ih⟩)
      · exact Or.inr (Or.inr ⟨k, Finset.mem_insert_of_mem hkt, ih⟩)
    by_cases Hi : I ≤ f i
    · exact Or.inr (Or.inr ⟨i, Finset.mem_insert_self i t, Hi⟩)
    have : ¬I ⊓ f a ⊓ f b ⊓ t.inf f ≤ f i :=
      by
      rcases t.eq_empty_or_nonempty with (rfl | hsne)
      · rw [Finset.inf_empty, inf_top_eq, hp.1.inf_le, hp.1.inf_le, not_or, not_or]
        exact ⟨⟨Hi, Ha⟩, Hb⟩
      simp only [hp.1.inf_le, hp.1.inf_le' hsne, not_or]
      exact ⟨⟨⟨Hi, Ha⟩, Hb⟩, Ht⟩
    rcases Set.not_subset.1 this with ⟨r, ⟨⟨⟨hrI, hra⟩, hrb⟩, hr⟩, hri⟩
    by_cases HI : (I : Set R) ⊆ f a ∪ f b ∪ ⋃ j ∈ (↑t : Set ι), f j
    · specialize ih hp.2 hn HI
      rcases ih with (ih | ih | ⟨k, hkt, ih⟩)
      · left
        exact ih
      · right
        left
        exact ih
      · right
        right
        exact ⟨k, Finset.mem_insert_of_mem hkt, ih⟩
    exfalso
    rcases Set.not_subset.1 HI with ⟨s, hsI, hs⟩
    rw [Finset.coe_insert, Set.bunionᵢ_insert] at h
    have hsi : s ∈ f i := ((h hsI).resolve_left (mt Or.inl hs)).resolve_right (mt Or.inr hs)
    rcases h (I.add_mem hrI hsI) with (⟨ha | hb⟩ | hi | ht)
    · exact hs (Or.inl <| Or.inl <| add_sub_cancel' r s ▸ (f a).sub_mem ha hra)
    · exact hs (Or.inl <| Or.inr <| add_sub_cancel' r s ▸ (f b).sub_mem hb hrb)
    · exact hri (add_sub_cancel r s ▸ (f i).sub_mem hi hsi)
    · rw [Set.mem_unionᵢ₂] at ht
      rcases ht with ⟨j, hjt, hj⟩
      simp only [Finset.inf_eq_infᵢ, SetLike.mem_coe, Submodule.mem_infᵢ] at hr
      exact hs (Or.inr <| Set.mem_bunionᵢ hjt <| add_sub_cancel' r s ▸ (f j).sub_mem hj <| hr j hjt)
#align ideal.subset_union_prime' Ideal.subset_union_prime'

/- warning: ideal.subset_union_prime -> Ideal.subset_union_prime is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} {R : Type.{u1}} [_inst_2 : CommRing.{u1} R] {s : Finset.{u2} ι} {f : ι -> (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)))} (a : ι) (b : ι), (forall (i : ι), (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) -> (Ne.{succ u2} ι i a) -> (Ne.{succ u2} ι i b) -> (Ideal.IsPrime.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)) (f i))) -> (forall {I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))}, Iff (HasSubset.Subset.{u1} (Set.{u1} R) (Set.hasSubset.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))))) I) (Set.unionᵢ.{u1, succ u2} R ι (fun (i : ι) => Set.unionᵢ.{u1, 0} R (Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) (fun (H : Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))))) (f i))))) (Exists.{succ u2} ι (fun (i : ι) => Exists.{0} (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) (fun (H : Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) => LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_2)))))))) I (f i)))))
but is expected to have type
  forall {ι : Type.{u1}} {R : Type.{u2}} [_inst_2 : CommRing.{u2} R] {s : Finset.{u1} ι} {f : ι -> (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))} (a : ι) (b : ι), (forall (i : ι), (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) -> (Ne.{succ u1} ι i a) -> (Ne.{succ u1} ι i b) -> (Ideal.IsPrime.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (f i))) -> (forall {I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))}, Iff (HasSubset.Subset.{u2} (Set.{u2} R) (Set.instHasSubsetSet.{u2} R) (SetLike.coe.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))) I) (Set.unionᵢ.{u2, succ u1} R ι (fun (i : ι) => Set.unionᵢ.{u2, 0} R (Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) i (Finset.toSet.{u1} ι s)) (fun (H : Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) i (Finset.toSet.{u1} ι s)) => SetLike.coe.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))) (f i))))) (Exists.{succ u1} ι (fun (i : ι) => And (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) (LE.le.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (Preorder.toLE.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))))))) I (f i)))))
Case conversion may be inaccurate. Consider using '#align ideal.subset_union_prime Ideal.subset_union_primeₓ'. -/
/-- Prime avoidance. Atiyah-Macdonald 1.11, Eisenbud 3.3, Stacks 00DS, Matsumura Ex.1.6. -/
theorem subset_union_prime {R : Type u} [CommRing R] {s : Finset ι} {f : ι → Ideal R} (a b : ι)
    (hp : ∀ i ∈ s, i ≠ a → i ≠ b → IsPrime (f i)) {I : Ideal R} :
    ((I : Set R) ⊆ ⋃ i ∈ (↑s : Set ι), f i) ↔ ∃ i ∈ s, I ≤ f i :=
  suffices ((I : Set R) ⊆ ⋃ i ∈ (↑s : Set ι), f i) → ∃ i, i ∈ s ∧ I ≤ f i from
    ⟨fun h => bex_def.2 <| this h, fun ⟨i, his, hi⟩ =>
      Set.Subset.trans hi <| Set.subset_bunionᵢ_of_mem <| show i ∈ (↑s : Set ι) from his⟩
  fun h : (I : Set R) ⊆ ⋃ i ∈ (↑s : Set ι), f i => by
  classical
    by_cases has : a ∈ s
    · obtain ⟨t, hat, rfl⟩ : ∃ t, a ∉ t ∧ insert a t = s :=
        ⟨s.erase a, Finset.not_mem_erase a s, Finset.insert_erase has⟩
      by_cases hbt : b ∈ t
      · obtain ⟨u, hbu, rfl⟩ : ∃ u, b ∉ u ∧ insert b u = t :=
          ⟨t.erase b, Finset.not_mem_erase b t, Finset.insert_erase hbt⟩
        have hp' : ∀ i ∈ u, is_prime (f i) := by
          intro i hiu
          refine' hp i (Finset.mem_insert_of_mem (Finset.mem_insert_of_mem hiu)) _ _ <;>
              rintro rfl <;>
            solve_by_elim only [Finset.mem_insert_of_mem, *]
        rw [Finset.coe_insert, Finset.coe_insert, Set.bunionᵢ_insert, Set.bunionᵢ_insert, ←
          Set.union_assoc, subset_union_prime' hp', bex_def] at h
        rwa [Finset.exists_mem_insert, Finset.exists_mem_insert]
      · have hp' : ∀ j ∈ t, is_prime (f j) := by
          intro j hj
          refine' hp j (Finset.mem_insert_of_mem hj) _ _ <;> rintro rfl <;>
            solve_by_elim only [Finset.mem_insert_of_mem, *]
        rw [Finset.coe_insert, Set.bunionᵢ_insert, ← Set.union_self (f a : Set R),
          subset_union_prime' hp', ← or_assoc', or_self_iff, bex_def] at h
        rwa [Finset.exists_mem_insert]
    · by_cases hbs : b ∈ s
      · obtain ⟨t, hbt, rfl⟩ : ∃ t, b ∉ t ∧ insert b t = s :=
          ⟨s.erase b, Finset.not_mem_erase b s, Finset.insert_erase hbs⟩
        have hp' : ∀ j ∈ t, is_prime (f j) := by
          intro j hj
          refine' hp j (Finset.mem_insert_of_mem hj) _ _ <;> rintro rfl <;>
            solve_by_elim only [Finset.mem_insert_of_mem, *]
        rw [Finset.coe_insert, Set.bunionᵢ_insert, ← Set.union_self (f b : Set R),
          subset_union_prime' hp', ← or_assoc', or_self_iff, bex_def] at h
        rwa [Finset.exists_mem_insert]
      cases' s.eq_empty_or_nonempty with hse hsne
      · subst hse
        rw [Finset.coe_empty, Set.bunionᵢ_empty, Set.subset_empty_iff] at h
        have : (I : Set R) ≠ ∅ := Set.Nonempty.ne_empty (Set.nonempty_of_mem I.zero_mem)
        exact absurd h this
      · cases' hsne.bex with i his
        obtain ⟨t, hit, rfl⟩ : ∃ t, i ∉ t ∧ insert i t = s :=
          ⟨s.erase i, Finset.not_mem_erase i s, Finset.insert_erase his⟩
        have hp' : ∀ j ∈ t, is_prime (f j) := by
          intro j hj
          refine' hp j (Finset.mem_insert_of_mem hj) _ _ <;> rintro rfl <;>
            solve_by_elim only [Finset.mem_insert_of_mem, *]
        rw [Finset.coe_insert, Set.bunionᵢ_insert, ← Set.union_self (f i : Set R),
          subset_union_prime' hp', ← or_assoc', or_self_iff, bex_def] at h
        rwa [Finset.exists_mem_insert]
#align ideal.subset_union_prime Ideal.subset_union_prime

section Dvd

/- warning: ideal.le_of_dvd -> Ideal.le_of_dvd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Dvd.Dvd.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (semigroupDvd.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemigroupWithZero.toSemigroup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CommSemiring.toNonUnitalCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.idemCommSemiring.{u1} R _inst_1))))))) I J) -> (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) J I)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Dvd.dvd.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (semigroupDvd.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (SemigroupWithZero.toSemigroup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (NonUnitalCommSemiring.toNonUnitalSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CommSemiring.toNonUnitalCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instIdemCommSemiringIdealToSemiring.{u1} R _inst_1))))))) I J) -> (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))) J I)
Case conversion may be inaccurate. Consider using '#align ideal.le_of_dvd Ideal.le_of_dvdₓ'. -/
/-- If `I` divides `J`, then `I` contains `J`.

In a Dedekind domain, to divide and contain are equivalent, see `ideal.dvd_iff_le`.
-/
theorem le_of_dvd {I J : Ideal R} : I ∣ J → J ≤ I
  | ⟨K, h⟩ => h.symm ▸ le_trans mul_le_inf inf_le_left
#align ideal.le_of_dvd Ideal.le_of_dvd

/- warning: ideal.is_unit_iff -> Ideal.isUnit_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (IsUnit.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))) I) (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) I (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.hasTop.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (IsUnit.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))) I) (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) I (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align ideal.is_unit_iff Ideal.isUnit_iffₓ'. -/
theorem isUnit_iff {I : Ideal R} : IsUnit I ↔ I = ⊤ :=
  isUnit_iff_dvd_one.trans
    ((@one_eq_top R _).symm ▸
      ⟨fun h => eq_top_iff.mpr (Ideal.le_of_dvd h), fun h => ⟨⊤, by rw [mul_top, h]⟩⟩)
#align ideal.is_unit_iff Ideal.isUnit_iff

#print Ideal.uniqueUnits /-
instance uniqueUnits : Unique (Ideal R)ˣ
    where
  default := 1
  uniq u := Units.ext (show (u : Ideal R) = 1 by rw [is_unit_iff.mp u.is_unit, one_eq_top])
#align ideal.unique_units Ideal.uniqueUnits
-/

end Dvd

end MulAndRadical

section MapAndComap

variable {R : Type u} {S : Type v}

section Semiring

variable {F : Type _} [Semiring R] [Semiring S]

variable [rc : RingHomClass F R S]

variable (f : F)

variable {I J : Ideal R} {K L : Ideal S}

include rc

#print Ideal.map /-
/-- `I.map f` is the span of the image of the ideal `I` under `f`, which may be bigger than
  the image itself. -/
def map (I : Ideal R) : Ideal S :=
  span (f '' I)
#align ideal.map Ideal.map
-/

#print Ideal.comap /-
/-- `I.comap f` is the preimage of `I` under `f`. -/
def comap (I : Ideal S) : Ideal R where
  carrier := f ⁻¹' I
  add_mem' x y hx hy := by
    simp only [Set.mem_preimage, SetLike.mem_coe, map_add, add_mem hx hy] at *
  zero_mem' := by simp only [Set.mem_preimage, map_zero, SetLike.mem_coe, Submodule.zero_mem]
  smul_mem' c x hx :=
    by
    simp only [smul_eq_mul, Set.mem_preimage, map_mul, SetLike.mem_coe] at *
    exact mul_mem_left I _ hx
#align ideal.comap Ideal.comap
-/

variable {f}

/- warning: ideal.map_mono -> Ideal.map_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] {f : F} {I : Ideal.{u1} R _inst_1} {J : Ideal.{u1} R _inst_1}, (LE.le.{u1} (Ideal.{u1} R _inst_1) (Preorder.toLE.{u1} (Ideal.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) I J) -> (LE.le.{u2} (Ideal.{u2} S _inst_2) (Preorder.toLE.{u2} (Ideal.{u2} S _inst_2) (PartialOrder.toPreorder.{u2} (Ideal.{u2} S _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))))) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f J))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] {f : F} {I : Ideal.{u2} R _inst_1} {J : Ideal.{u2} R _inst_1}, (LE.le.{u2} (Ideal.{u2} R _inst_1) (Preorder.toLE.{u2} (Ideal.{u2} R _inst_1) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R _inst_1) (Submodule.completeLattice.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))))) I J) -> (LE.le.{u3} (Ideal.{u3} S _inst_2) (Preorder.toLE.{u3} (Ideal.{u3} S _inst_2) (PartialOrder.toPreorder.{u3} (Ideal.{u3} S _inst_2) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} S _inst_2) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} S _inst_2) (Submodule.completeLattice.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))))) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f J))
Case conversion may be inaccurate. Consider using '#align ideal.map_mono Ideal.map_monoₓ'. -/
theorem map_mono (h : I ≤ J) : map f I ≤ map f J :=
  span_mono <| Set.image_subset _ h
#align ideal.map_mono Ideal.map_mono

/- warning: ideal.mem_map_of_mem -> Ideal.mem_map_of_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) {I : Ideal.{u1} R _inst_1} {x : R}, (Membership.Mem.{u1, u1} R (Ideal.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R _inst_1) R (Submodule.setLike.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) x I) -> (Membership.Mem.{u2, u2} S (Ideal.{u2} S _inst_2) (SetLike.hasMem.{u2, u2} (Ideal.{u2} S _inst_2) S (Submodule.setLike.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2))) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f x) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) {I : Ideal.{u2} R _inst_1} {x : R}, (Membership.mem.{u2, u2} R (Ideal.{u2} R _inst_1) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R _inst_1) R (Submodule.setLike.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) x I) -> (Membership.mem.{u3, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) (Ideal.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (Ideal.{u3} S _inst_2) S (Submodule.setLike.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2))) (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f x) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I))
Case conversion may be inaccurate. Consider using '#align ideal.mem_map_of_mem Ideal.mem_map_of_memₓ'. -/
theorem mem_map_of_mem (f : F) {I : Ideal R} {x : R} (h : x ∈ I) : f x ∈ map f I :=
  subset_span ⟨x, h, rfl⟩
#align ideal.mem_map_of_mem Ideal.mem_map_of_mem

/- warning: ideal.apply_coe_mem_map -> Ideal.apply_coe_mem_map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) (I : Ideal.{u1} R _inst_1) (x : coeSort.{succ u1, succ (succ u1)} (Ideal.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Ideal.{u1} R _inst_1) R (Submodule.setLike.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) I), Membership.Mem.{u2, u2} S (Ideal.{u2} S _inst_2) (SetLike.hasMem.{u2, u2} (Ideal.{u2} S _inst_2) S (Submodule.setLike.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2))) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Ideal.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Ideal.{u1} R _inst_1) R (Submodule.setLike.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) I) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Ideal.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Ideal.{u1} R _inst_1) R (Submodule.setLike.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) I) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Ideal.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Ideal.{u1} R _inst_1) R (Submodule.setLike.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) I) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Ideal.{u1} R _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Ideal.{u1} R _inst_1) R (Submodule.setLike.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) I) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Ideal.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R _inst_1) R (Submodule.setLike.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) x I))))) x)) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) (I : Ideal.{u2} R _inst_1) (x : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R _inst_1) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R _inst_1) R (Submodule.setLike.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) x I)), Membership.mem.{u3, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) (Subtype.val.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) x (SetLike.coe.{u2, u2} (Ideal.{u2} R _inst_1) R (Submodule.setLike.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) I)) x)) (Ideal.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (Ideal.{u3} S _inst_2) S (Submodule.setLike.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2))) (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f (Subtype.val.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) x (SetLike.coe.{u2, u2} (Ideal.{u2} R _inst_1) R (Submodule.setLike.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) I)) x)) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I)
Case conversion may be inaccurate. Consider using '#align ideal.apply_coe_mem_map Ideal.apply_coe_mem_mapₓ'. -/
theorem apply_coe_mem_map (f : F) (I : Ideal R) (x : I) : f x ∈ I.map f :=
  mem_map_of_mem f x.Prop
#align ideal.apply_coe_mem_map Ideal.apply_coe_mem_map

/- warning: ideal.map_le_iff_le_comap -> Ideal.map_le_iff_le_comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] {f : F} {I : Ideal.{u1} R _inst_1} {K : Ideal.{u2} S _inst_2}, Iff (LE.le.{u2} (Ideal.{u2} S _inst_2) (Preorder.toLE.{u2} (Ideal.{u2} S _inst_2) (PartialOrder.toPreorder.{u2} (Ideal.{u2} S _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))))) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I) K) (LE.le.{u1} (Ideal.{u1} R _inst_1) (Preorder.toLE.{u1} (Ideal.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) I (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f K))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] {f : F} {I : Ideal.{u2} R _inst_1} {K : Ideal.{u3} S _inst_2}, Iff (LE.le.{u3} (Ideal.{u3} S _inst_2) (Preorder.toLE.{u3} (Ideal.{u3} S _inst_2) (PartialOrder.toPreorder.{u3} (Ideal.{u3} S _inst_2) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} S _inst_2) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} S _inst_2) (Submodule.completeLattice.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))))) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I) K) (LE.le.{u2} (Ideal.{u2} R _inst_1) (Preorder.toLE.{u2} (Ideal.{u2} R _inst_1) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R _inst_1) (Submodule.completeLattice.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))))) I (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f K))
Case conversion may be inaccurate. Consider using '#align ideal.map_le_iff_le_comap Ideal.map_le_iff_le_comapₓ'. -/
theorem map_le_iff_le_comap : map f I ≤ K ↔ I ≤ comap f K :=
  span_le.trans Set.image_subset_iff
#align ideal.map_le_iff_le_comap Ideal.map_le_iff_le_comap

/- warning: ideal.mem_comap -> Ideal.mem_comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] {f : F} {K : Ideal.{u2} S _inst_2} {x : R}, Iff (Membership.Mem.{u1, u1} R (Ideal.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R _inst_1) R (Submodule.setLike.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) x (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f K)) (Membership.Mem.{u2, u2} S (Ideal.{u2} S _inst_2) (SetLike.hasMem.{u2, u2} (Ideal.{u2} S _inst_2) S (Submodule.setLike.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2))) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f x) K)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] {f : F} {K : Ideal.{u3} S _inst_2} {x : R}, Iff (Membership.mem.{u2, u2} R (Ideal.{u2} R _inst_1) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R _inst_1) R (Submodule.setLike.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) x (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f K)) (Membership.mem.{u3, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) (Ideal.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (Ideal.{u3} S _inst_2) S (Submodule.setLike.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2))) (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f x) K)
Case conversion may be inaccurate. Consider using '#align ideal.mem_comap Ideal.mem_comapₓ'. -/
@[simp]
theorem mem_comap {x} : x ∈ comap f K ↔ f x ∈ K :=
  Iff.rfl
#align ideal.mem_comap Ideal.mem_comap

/- warning: ideal.comap_mono -> Ideal.comap_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] {f : F} {K : Ideal.{u2} S _inst_2} {L : Ideal.{u2} S _inst_2}, (LE.le.{u2} (Ideal.{u2} S _inst_2) (Preorder.toLE.{u2} (Ideal.{u2} S _inst_2) (PartialOrder.toPreorder.{u2} (Ideal.{u2} S _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))))) K L) -> (LE.le.{u1} (Ideal.{u1} R _inst_1) (Preorder.toLE.{u1} (Ideal.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f K) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f L))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] {f : F} {K : Ideal.{u3} S _inst_2} {L : Ideal.{u3} S _inst_2}, (LE.le.{u3} (Ideal.{u3} S _inst_2) (Preorder.toLE.{u3} (Ideal.{u3} S _inst_2) (PartialOrder.toPreorder.{u3} (Ideal.{u3} S _inst_2) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} S _inst_2) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} S _inst_2) (Submodule.completeLattice.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))))) K L) -> (LE.le.{u2} (Ideal.{u2} R _inst_1) (Preorder.toLE.{u2} (Ideal.{u2} R _inst_1) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R _inst_1) (Submodule.completeLattice.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))))) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f K) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f L))
Case conversion may be inaccurate. Consider using '#align ideal.comap_mono Ideal.comap_monoₓ'. -/
theorem comap_mono (h : K ≤ L) : comap f K ≤ comap f L :=
  Set.preimage_mono fun x hx => h hx
#align ideal.comap_mono Ideal.comap_mono

variable (f)

/- warning: ideal.comap_ne_top -> Ideal.comap_ne_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) {K : Ideal.{u2} S _inst_2}, (Ne.{succ u2} (Ideal.{u2} S _inst_2) K (Top.top.{u2} (Ideal.{u2} S _inst_2) (Submodule.hasTop.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))) -> (Ne.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f K) (Top.top.{u1} (Ideal.{u1} R _inst_1) (Submodule.hasTop.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) {K : Ideal.{u3} S _inst_2}, (Ne.{succ u3} (Ideal.{u3} S _inst_2) K (Top.top.{u3} (Ideal.{u3} S _inst_2) (Submodule.instTopSubmodule.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))) -> (Ne.{succ u2} (Ideal.{u2} R _inst_1) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f K) (Top.top.{u2} (Ideal.{u2} R _inst_1) (Submodule.instTopSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align ideal.comap_ne_top Ideal.comap_ne_topₓ'. -/
theorem comap_ne_top (hK : K ≠ ⊤) : comap f K ≠ ⊤ :=
  (ne_top_iff_one _).2 <| by rw [mem_comap, map_one] <;> exact (ne_top_iff_one _).1 hK
#align ideal.comap_ne_top Ideal.comap_ne_top

variable {G : Type _} [rcg : RingHomClass G S R]

include rcg

/- warning: ideal.map_le_comap_of_inv_on -> Ideal.map_le_comap_of_inv_on is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) {G : Type.{u4}} [rcg : RingHomClass.{u4, u2, u1} G S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)] (g : G) (I : Ideal.{u1} R _inst_1), (Set.LeftInvOn.{u1, u2} R S (coeFn.{succ u4, max (succ u2) (succ u1)} G (fun (_x : G) => S -> R) (FunLike.hasCoeToFun.{succ u4, succ u2, succ u1} G S (fun (_x : S) => R) (MulHomClass.toFunLike.{u4, u2, u1} G S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u4, u2, u1} G S R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{u4, u2, u1} G S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1) rcg)))) g) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R _inst_1) R (Submodule.setLike.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))))) I)) -> (LE.le.{u2} (Ideal.{u2} S _inst_2) (Preorder.toLE.{u2} (Ideal.{u2} S _inst_2) (PartialOrder.toPreorder.{u2} (Ideal.{u2} S _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))))) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I) (Ideal.comap.{u2, u1, u4} S R G _inst_2 _inst_1 rcg g I))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u4}} {F : Type.{u1}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u4} S] [rc : RingHomClass.{u1, u3, u4} F R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} S _inst_2)] (f : F) {G : Type.{u2}} [rcg : RingHomClass.{u2, u4, u3} G S R (Semiring.toNonAssocSemiring.{u4} S _inst_2) (Semiring.toNonAssocSemiring.{u3} R _inst_1)] (g : G) (I : Ideal.{u3} R _inst_1), (Set.LeftInvOn.{u3, u4} R S (FunLike.coe.{succ u2, succ u4, succ u3} G S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => R) _x) (MulHomClass.toFunLike.{u2, u4, u3} G S R (NonUnitalNonAssocSemiring.toMul.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (NonUnitalRingHomClass.toMulHomClass.{u2, u4, u3} G S R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{u2, u4, u3} G S R (Semiring.toNonAssocSemiring.{u4} S _inst_2) (Semiring.toNonAssocSemiring.{u3} R _inst_1) rcg))) g) (FunLike.coe.{succ u1, succ u3, succ u4} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u3, u4} F R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u3, u4} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u3, u4} F R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} S _inst_2) rc))) f) (SetLike.coe.{u3, u3} (Ideal.{u3} R _inst_1) R (Submodule.setLike.{u3, u3} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) I)) -> (LE.le.{u4} (Ideal.{u4} S _inst_2) (Preorder.toLE.{u4} (Ideal.{u4} S _inst_2) (PartialOrder.toPreorder.{u4} (Ideal.{u4} S _inst_2) (OmegaCompletePartialOrder.toPartialOrder.{u4} (Ideal.{u4} S _inst_2) (CompleteLattice.instOmegaCompletePartialOrder.{u4} (Ideal.{u4} S _inst_2) (Submodule.completeLattice.{u4, u4} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (Semiring.toModule.{u4} S _inst_2)))))) (Ideal.map.{u3, u4, u1} R S F _inst_1 _inst_2 rc f I) (Ideal.comap.{u4, u3, u2} S R G _inst_2 _inst_1 rcg g I))
Case conversion may be inaccurate. Consider using '#align ideal.map_le_comap_of_inv_on Ideal.map_le_comap_of_inv_onₓ'. -/
theorem map_le_comap_of_inv_on (g : G) (I : Ideal R) (hf : Set.LeftInvOn g f I) :
    I.map f ≤ I.comap g := by
  refine' Ideal.span_le.2 _
  rintro x ⟨x, hx, rfl⟩
  rw [SetLike.mem_coe, mem_comap, hf hx]
  exact hx
#align ideal.map_le_comap_of_inv_on Ideal.map_le_comap_of_inv_on

/- warning: ideal.comap_le_map_of_inv_on -> Ideal.comap_le_map_of_inv_on is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) {G : Type.{u4}} [rcg : RingHomClass.{u4, u2, u1} G S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)] (g : G) (I : Ideal.{u2} S _inst_2), (Set.LeftInvOn.{u1, u2} R S (coeFn.{succ u4, max (succ u2) (succ u1)} G (fun (_x : G) => S -> R) (FunLike.hasCoeToFun.{succ u4, succ u2, succ u1} G S (fun (_x : S) => R) (MulHomClass.toFunLike.{u4, u2, u1} G S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u4, u2, u1} G S R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{u4, u2, u1} G S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1) rcg)))) g) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f) (Set.preimage.{u1, u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} S _inst_2) (Set.{u2} S) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} S _inst_2) (Set.{u2} S) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} S _inst_2) (Set.{u2} S) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} S _inst_2) S (Submodule.setLike.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2))))) I))) -> (LE.le.{u1} (Ideal.{u1} R _inst_1) (Preorder.toLE.{u1} (Ideal.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I) (Ideal.map.{u2, u1, u4} S R G _inst_2 _inst_1 rcg g I))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u4}} {F : Type.{u1}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u4} S] [rc : RingHomClass.{u1, u3, u4} F R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} S _inst_2)] (f : F) {G : Type.{u2}} [rcg : RingHomClass.{u2, u4, u3} G S R (Semiring.toNonAssocSemiring.{u4} S _inst_2) (Semiring.toNonAssocSemiring.{u3} R _inst_1)] (g : G) (I : Ideal.{u4} S _inst_2), (Set.LeftInvOn.{u3, u4} R S (FunLike.coe.{succ u2, succ u4, succ u3} G S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => R) _x) (MulHomClass.toFunLike.{u2, u4, u3} G S R (NonUnitalNonAssocSemiring.toMul.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (NonUnitalRingHomClass.toMulHomClass.{u2, u4, u3} G S R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{u2, u4, u3} G S R (Semiring.toNonAssocSemiring.{u4} S _inst_2) (Semiring.toNonAssocSemiring.{u3} R _inst_1) rcg))) g) (FunLike.coe.{succ u1, succ u3, succ u4} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u3, u4} F R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u3, u4} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u3, u4} F R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} S _inst_2) rc))) f) (Set.preimage.{u3, u4} R S (FunLike.coe.{succ u1, succ u3, succ u4} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u3, u4} F R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u3, u4} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u3, u4} F R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} S _inst_2) rc))) f) (SetLike.coe.{u4, u4} (Ideal.{u4} S _inst_2) S (Submodule.setLike.{u4, u4} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (Semiring.toModule.{u4} S _inst_2)) I))) -> (LE.le.{u3} (Ideal.{u3} R _inst_1) (Preorder.toLE.{u3} (Ideal.{u3} R _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} R _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} R _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} R _inst_1) (Submodule.completeLattice.{u3, u3} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)))))) (Ideal.comap.{u3, u4, u1} R S F _inst_1 _inst_2 rc f I) (Ideal.map.{u4, u3, u2} S R G _inst_2 _inst_1 rcg g I))
Case conversion may be inaccurate. Consider using '#align ideal.comap_le_map_of_inv_on Ideal.comap_le_map_of_inv_onₓ'. -/
theorem comap_le_map_of_inv_on (g : G) (I : Ideal S) (hf : Set.LeftInvOn g f (f ⁻¹' I)) :
    I.comap f ≤ I.map g := fun x (hx : f x ∈ I) => hf hx ▸ Ideal.mem_map_of_mem g hx
#align ideal.comap_le_map_of_inv_on Ideal.comap_le_map_of_inv_on

/- warning: ideal.map_le_comap_of_inverse -> Ideal.map_le_comap_of_inverse is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) {G : Type.{u4}} [rcg : RingHomClass.{u4, u2, u1} G S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)] (g : G) (I : Ideal.{u1} R _inst_1), (Function.LeftInverse.{succ u1, succ u2} R S (coeFn.{succ u4, max (succ u2) (succ u1)} G (fun (_x : G) => S -> R) (FunLike.hasCoeToFun.{succ u4, succ u2, succ u1} G S (fun (_x : S) => R) (MulHomClass.toFunLike.{u4, u2, u1} G S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u4, u2, u1} G S R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{u4, u2, u1} G S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1) rcg)))) g) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f)) -> (LE.le.{u2} (Ideal.{u2} S _inst_2) (Preorder.toLE.{u2} (Ideal.{u2} S _inst_2) (PartialOrder.toPreorder.{u2} (Ideal.{u2} S _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))))) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I) (Ideal.comap.{u2, u1, u4} S R G _inst_2 _inst_1 rcg g I))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u4}} {F : Type.{u1}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u4} S] [rc : RingHomClass.{u1, u3, u4} F R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} S _inst_2)] (f : F) {G : Type.{u2}} [rcg : RingHomClass.{u2, u4, u3} G S R (Semiring.toNonAssocSemiring.{u4} S _inst_2) (Semiring.toNonAssocSemiring.{u3} R _inst_1)] (g : G) (I : Ideal.{u3} R _inst_1), (Function.LeftInverse.{succ u3, succ u4} R S (FunLike.coe.{succ u2, succ u4, succ u3} G S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => R) _x) (MulHomClass.toFunLike.{u2, u4, u3} G S R (NonUnitalNonAssocSemiring.toMul.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (NonUnitalRingHomClass.toMulHomClass.{u2, u4, u3} G S R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{u2, u4, u3} G S R (Semiring.toNonAssocSemiring.{u4} S _inst_2) (Semiring.toNonAssocSemiring.{u3} R _inst_1) rcg))) g) (FunLike.coe.{succ u1, succ u3, succ u4} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u3, u4} F R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u3, u4} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u3, u4} F R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} S _inst_2) rc))) f)) -> (LE.le.{u4} (Ideal.{u4} S _inst_2) (Preorder.toLE.{u4} (Ideal.{u4} S _inst_2) (PartialOrder.toPreorder.{u4} (Ideal.{u4} S _inst_2) (OmegaCompletePartialOrder.toPartialOrder.{u4} (Ideal.{u4} S _inst_2) (CompleteLattice.instOmegaCompletePartialOrder.{u4} (Ideal.{u4} S _inst_2) (Submodule.completeLattice.{u4, u4} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (Semiring.toModule.{u4} S _inst_2)))))) (Ideal.map.{u3, u4, u1} R S F _inst_1 _inst_2 rc f I) (Ideal.comap.{u4, u3, u2} S R G _inst_2 _inst_1 rcg g I))
Case conversion may be inaccurate. Consider using '#align ideal.map_le_comap_of_inverse Ideal.map_le_comap_of_inverseₓ'. -/
/-- The `ideal` version of `set.image_subset_preimage_of_inverse`. -/
theorem map_le_comap_of_inverse (g : G) (I : Ideal R) (h : Function.LeftInverse g f) :
    I.map f ≤ I.comap g :=
  map_le_comap_of_inv_on _ _ _ <| h.LeftInvOn _
#align ideal.map_le_comap_of_inverse Ideal.map_le_comap_of_inverse

/- warning: ideal.comap_le_map_of_inverse -> Ideal.comap_le_map_of_inverse is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) {G : Type.{u4}} [rcg : RingHomClass.{u4, u2, u1} G S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)] (g : G) (I : Ideal.{u2} S _inst_2), (Function.LeftInverse.{succ u1, succ u2} R S (coeFn.{succ u4, max (succ u2) (succ u1)} G (fun (_x : G) => S -> R) (FunLike.hasCoeToFun.{succ u4, succ u2, succ u1} G S (fun (_x : S) => R) (MulHomClass.toFunLike.{u4, u2, u1} G S R (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u4, u2, u1} G S R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{u4, u2, u1} G S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1) rcg)))) g) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f)) -> (LE.le.{u1} (Ideal.{u1} R _inst_1) (Preorder.toLE.{u1} (Ideal.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I) (Ideal.map.{u2, u1, u4} S R G _inst_2 _inst_1 rcg g I))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u4}} {F : Type.{u1}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u4} S] [rc : RingHomClass.{u1, u3, u4} F R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} S _inst_2)] (f : F) {G : Type.{u2}} [rcg : RingHomClass.{u2, u4, u3} G S R (Semiring.toNonAssocSemiring.{u4} S _inst_2) (Semiring.toNonAssocSemiring.{u3} R _inst_1)] (g : G) (I : Ideal.{u4} S _inst_2), (Function.LeftInverse.{succ u3, succ u4} R S (FunLike.coe.{succ u2, succ u4, succ u3} G S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => R) _x) (MulHomClass.toFunLike.{u2, u4, u3} G S R (NonUnitalNonAssocSemiring.toMul.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (NonUnitalRingHomClass.toMulHomClass.{u2, u4, u3} G S R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{u2, u4, u3} G S R (Semiring.toNonAssocSemiring.{u4} S _inst_2) (Semiring.toNonAssocSemiring.{u3} R _inst_1) rcg))) g) (FunLike.coe.{succ u1, succ u3, succ u4} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u3, u4} F R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u3, u4} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u3, u4} F R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} S _inst_2) rc))) f)) -> (LE.le.{u3} (Ideal.{u3} R _inst_1) (Preorder.toLE.{u3} (Ideal.{u3} R _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} R _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} R _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} R _inst_1) (Submodule.completeLattice.{u3, u3} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)))))) (Ideal.comap.{u3, u4, u1} R S F _inst_1 _inst_2 rc f I) (Ideal.map.{u4, u3, u2} S R G _inst_2 _inst_1 rcg g I))
Case conversion may be inaccurate. Consider using '#align ideal.comap_le_map_of_inverse Ideal.comap_le_map_of_inverseₓ'. -/
/-- The `ideal` version of `set.preimage_subset_image_of_inverse`. -/
theorem comap_le_map_of_inverse (g : G) (I : Ideal S) (h : Function.LeftInverse g f) :
    I.comap f ≤ I.map g :=
  comap_le_map_of_inv_on _ _ _ <| h.LeftInvOn _
#align ideal.comap_le_map_of_inverse Ideal.comap_le_map_of_inverse

omit rcg

#print Ideal.IsPrime.comap /-
instance IsPrime.comap [hK : K.IsPrime] : (comap f K).IsPrime :=
  ⟨comap_ne_top _ hK.1, fun x y => by simp only [mem_comap, map_mul] <;> apply hK.2⟩
#align ideal.is_prime.comap Ideal.IsPrime.comap
-/

variable (I J K L)

/- warning: ideal.map_top -> Ideal.map_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F), Eq.{succ u2} (Ideal.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Top.top.{u1} (Ideal.{u1} R _inst_1) (Submodule.hasTop.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) (Top.top.{u2} (Ideal.{u2} S _inst_2) (Submodule.hasTop.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F), Eq.{succ u3} (Ideal.{u3} S _inst_2) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Top.top.{u2} (Ideal.{u2} R _inst_1) (Submodule.instTopSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))) (Top.top.{u3} (Ideal.{u3} S _inst_2) (Submodule.instTopSubmodule.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))
Case conversion may be inaccurate. Consider using '#align ideal.map_top Ideal.map_topₓ'. -/
theorem map_top : map f ⊤ = ⊤ :=
  (eq_top_iff_one _).2 <| subset_span ⟨1, trivial, map_one f⟩
#align ideal.map_top Ideal.map_top

variable (f)

/- warning: ideal.gc_map_comap -> Ideal.gc_map_comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F), GaloisConnection.{u1, u2} (Ideal.{u1} R _inst_1) (Ideal.{u2} S _inst_2) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} S _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2))))) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F), GaloisConnection.{u2, u3} (Ideal.{u2} R _inst_1) (Ideal.{u3} S _inst_2) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R _inst_1) (Submodule.completeLattice.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))))) (PartialOrder.toPreorder.{u3} (Ideal.{u3} S _inst_2) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} S _inst_2) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} S _inst_2) (Submodule.completeLattice.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2))))) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f)
Case conversion may be inaccurate. Consider using '#align ideal.gc_map_comap Ideal.gc_map_comapₓ'. -/
theorem gc_map_comap : GaloisConnection (Ideal.map f) (Ideal.comap f) := fun I J =>
  Ideal.map_le_iff_le_comap
#align ideal.gc_map_comap Ideal.gc_map_comap

omit rc

/- warning: ideal.comap_id -> Ideal.comap_id is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (I : Ideal.{u1} R _inst_1), Eq.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.comap.{u1, u1, u1} R R (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_1 _inst_1 (RingHom.ringHomClass.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) I) I
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (I : Ideal.{u1} R _inst_1), Eq.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.comap.{u1, u1, u1} R R (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_1 _inst_1 (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) I) I
Case conversion may be inaccurate. Consider using '#align ideal.comap_id Ideal.comap_idₓ'. -/
@[simp]
theorem comap_id : I.comap (RingHom.id R) = I :=
  Ideal.ext fun _ => Iff.rfl
#align ideal.comap_id Ideal.comap_id

/- warning: ideal.map_id -> Ideal.map_id is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (I : Ideal.{u1} R _inst_1), Eq.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.map.{u1, u1, u1} R R (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_1 _inst_1 (RingHom.ringHomClass.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) I) I
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (I : Ideal.{u1} R _inst_1), Eq.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.map.{u1, u1, u1} R R (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_1 _inst_1 (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) I) I
Case conversion may be inaccurate. Consider using '#align ideal.map_id Ideal.map_idₓ'. -/
@[simp]
theorem map_id : I.map (RingHom.id R) = I :=
  (gc_map_comap (RingHom.id R)).l_unique GaloisConnection.id comap_id
#align ideal.map_id Ideal.map_id

/- warning: ideal.comap_comap -> Ideal.comap_comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] {T : Type.{u3}} [_inst_3 : Semiring.{u3} T] {I : Ideal.{u3} T _inst_3} (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (g : RingHom.{u2, u3} S T (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u3} T _inst_3)), Eq.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.comap.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) _inst_1 _inst_2 (RingHom.ringHomClass.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) f (Ideal.comap.{u2, u3, max u2 u3} S T (RingHom.{u2, u3} S T (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u3} T _inst_3)) _inst_2 _inst_3 (RingHom.ringHomClass.{u2, u3} S T (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u3} T _inst_3)) g I)) (Ideal.comap.{u1, u3, max u1 u3} R T (RingHom.{u1, u3} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u3} T _inst_3)) _inst_1 _inst_3 (RingHom.ringHomClass.{u1, u3} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u3} T _inst_3)) (RingHom.comp.{u1, u2, u3} R S T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u3} T _inst_3) g f) I)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] {T : Type.{u1}} [_inst_3 : Semiring.{u1} T] {I : Ideal.{u1} T _inst_3} (f : RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (g : RingHom.{u3, u1} S T (Semiring.toNonAssocSemiring.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u1} T _inst_3)), Eq.{succ u2} (Ideal.{u2} R _inst_1) (Ideal.comap.{u2, u3, max u2 u3} R S (RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) _inst_1 _inst_2 (RingHom.instRingHomClassRingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) f (Ideal.comap.{u3, u1, max u3 u1} S T (RingHom.{u3, u1} S T (Semiring.toNonAssocSemiring.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) _inst_2 _inst_3 (RingHom.instRingHomClassRingHom.{u3, u1} S T (Semiring.toNonAssocSemiring.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) g I)) (Ideal.comap.{u2, u1, max u1 u2} R T (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) _inst_1 _inst_3 (RingHom.instRingHomClassRingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (RingHom.comp.{u2, u3, u1} R S T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u1} T _inst_3) g f) I)
Case conversion may be inaccurate. Consider using '#align ideal.comap_comap Ideal.comap_comapₓ'. -/
theorem comap_comap {T : Type _} [Semiring T] {I : Ideal T} (f : R →+* S) (g : S →+* T) :
    (I.comap g).comap f = I.comap (g.comp f) :=
  rfl
#align ideal.comap_comap Ideal.comap_comap

/- warning: ideal.map_map -> Ideal.map_map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] {T : Type.{u3}} [_inst_3 : Semiring.{u3} T] {I : Ideal.{u1} R _inst_1} (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (g : RingHom.{u2, u3} S T (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u3} T _inst_3)), Eq.{succ u3} (Ideal.{u3} T _inst_3) (Ideal.map.{u2, u3, max u2 u3} S T (RingHom.{u2, u3} S T (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u3} T _inst_3)) _inst_2 _inst_3 (RingHom.ringHomClass.{u2, u3} S T (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u3} T _inst_3)) g (Ideal.map.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) _inst_1 _inst_2 (RingHom.ringHomClass.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) f I)) (Ideal.map.{u1, u3, max u1 u3} R T (RingHom.{u1, u3} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u3} T _inst_3)) _inst_1 _inst_3 (RingHom.ringHomClass.{u1, u3} R T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u3} T _inst_3)) (RingHom.comp.{u1, u2, u3} R S T (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u3} T _inst_3) g f) I)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] {T : Type.{u1}} [_inst_3 : Semiring.{u1} T] {I : Ideal.{u2} R _inst_1} (f : RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (g : RingHom.{u3, u1} S T (Semiring.toNonAssocSemiring.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u1} T _inst_3)), Eq.{succ u1} (Ideal.{u1} T _inst_3) (Ideal.map.{u3, u1, max u3 u1} S T (RingHom.{u3, u1} S T (Semiring.toNonAssocSemiring.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) _inst_2 _inst_3 (RingHom.instRingHomClassRingHom.{u3, u1} S T (Semiring.toNonAssocSemiring.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) g (Ideal.map.{u2, u3, max u2 u3} R S (RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) _inst_1 _inst_2 (RingHom.instRingHomClassRingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)) f I)) (Ideal.map.{u2, u1, max u1 u2} R T (RingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) _inst_1 _inst_3 (RingHom.instRingHomClassRingHom.{u2, u1} R T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} T _inst_3)) (RingHom.comp.{u2, u3, u1} R S T (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u1} T _inst_3) g f) I)
Case conversion may be inaccurate. Consider using '#align ideal.map_map Ideal.map_mapₓ'. -/
theorem map_map {T : Type _} [Semiring T] {I : Ideal R} (f : R →+* S) (g : S →+* T) :
    (I.map f).map g = I.map (g.comp f) :=
  ((gc_map_comap f).compose (gc_map_comap g)).l_unique (gc_map_comap (g.comp f)) fun _ =>
    comap_comap _ _
#align ideal.map_map Ideal.map_map

include rc

/- warning: ideal.map_span -> Ideal.map_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) (s : Set.{u1} R), Eq.{succ u2} (Ideal.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Ideal.span.{u1} R _inst_1 s)) (Ideal.span.{u2} S _inst_2 (Set.image.{u1, u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f) s))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) (s : Set.{u2} R), Eq.{succ u3} (Ideal.{u3} S _inst_2) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Ideal.span.{u2} R _inst_1 s)) (Ideal.span.{u3} S _inst_2 (Set.image.{u2, u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f) s))
Case conversion may be inaccurate. Consider using '#align ideal.map_span Ideal.map_spanₓ'. -/
theorem map_span (f : F) (s : Set R) : map f (span s) = span (f '' s) :=
  symm <|
    Submodule.span_eq_of_le _ (fun y ⟨x, hy, x_eq⟩ => x_eq ▸ mem_map_of_mem f (subset_span hy))
      (map_le_iff_le_comap.2 <| span_le.2 <| Set.image_subset_iff.1 subset_span)
#align ideal.map_span Ideal.map_span

variable {f I J K L}

/- warning: ideal.map_le_of_le_comap -> Ideal.map_le_of_le_comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] {f : F} {I : Ideal.{u1} R _inst_1} {K : Ideal.{u2} S _inst_2}, (LE.le.{u1} (Ideal.{u1} R _inst_1) (Preorder.toLE.{u1} (Ideal.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) I (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f K)) -> (LE.le.{u2} (Ideal.{u2} S _inst_2) (Preorder.toLE.{u2} (Ideal.{u2} S _inst_2) (PartialOrder.toPreorder.{u2} (Ideal.{u2} S _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))))) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I) K)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] {f : F} {I : Ideal.{u2} R _inst_1} {K : Ideal.{u3} S _inst_2}, (LE.le.{u2} (Ideal.{u2} R _inst_1) (Preorder.toLE.{u2} (Ideal.{u2} R _inst_1) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R _inst_1) (Submodule.completeLattice.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))))) I (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f K)) -> (LE.le.{u3} (Ideal.{u3} S _inst_2) (Preorder.toLE.{u3} (Ideal.{u3} S _inst_2) (PartialOrder.toPreorder.{u3} (Ideal.{u3} S _inst_2) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} S _inst_2) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} S _inst_2) (Submodule.completeLattice.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))))) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I) K)
Case conversion may be inaccurate. Consider using '#align ideal.map_le_of_le_comap Ideal.map_le_of_le_comapₓ'. -/
theorem map_le_of_le_comap : I ≤ K.comap f → I.map f ≤ K :=
  (gc_map_comap f).l_le
#align ideal.map_le_of_le_comap Ideal.map_le_of_le_comap

/- warning: ideal.le_comap_of_map_le -> Ideal.le_comap_of_map_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] {f : F} {I : Ideal.{u1} R _inst_1} {K : Ideal.{u2} S _inst_2}, (LE.le.{u2} (Ideal.{u2} S _inst_2) (Preorder.toLE.{u2} (Ideal.{u2} S _inst_2) (PartialOrder.toPreorder.{u2} (Ideal.{u2} S _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))))) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I) K) -> (LE.le.{u1} (Ideal.{u1} R _inst_1) (Preorder.toLE.{u1} (Ideal.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) I (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f K))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] {f : F} {I : Ideal.{u2} R _inst_1} {K : Ideal.{u3} S _inst_2}, (LE.le.{u3} (Ideal.{u3} S _inst_2) (Preorder.toLE.{u3} (Ideal.{u3} S _inst_2) (PartialOrder.toPreorder.{u3} (Ideal.{u3} S _inst_2) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} S _inst_2) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} S _inst_2) (Submodule.completeLattice.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))))) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I) K) -> (LE.le.{u2} (Ideal.{u2} R _inst_1) (Preorder.toLE.{u2} (Ideal.{u2} R _inst_1) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R _inst_1) (Submodule.completeLattice.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))))) I (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f K))
Case conversion may be inaccurate. Consider using '#align ideal.le_comap_of_map_le Ideal.le_comap_of_map_leₓ'. -/
theorem le_comap_of_map_le : I.map f ≤ K → I ≤ K.comap f :=
  (gc_map_comap f).le_u
#align ideal.le_comap_of_map_le Ideal.le_comap_of_map_le

/- warning: ideal.le_comap_map -> Ideal.le_comap_map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] {f : F} {I : Ideal.{u1} R _inst_1}, LE.le.{u1} (Ideal.{u1} R _inst_1) (Preorder.toLE.{u1} (Ideal.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) I (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] {f : F} {I : Ideal.{u2} R _inst_1}, LE.le.{u2} (Ideal.{u2} R _inst_1) (Preorder.toLE.{u2} (Ideal.{u2} R _inst_1) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R _inst_1) (Submodule.completeLattice.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))))) I (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I))
Case conversion may be inaccurate. Consider using '#align ideal.le_comap_map Ideal.le_comap_mapₓ'. -/
theorem le_comap_map : I ≤ (I.map f).comap f :=
  (gc_map_comap f).le_u_l _
#align ideal.le_comap_map Ideal.le_comap_map

/- warning: ideal.map_comap_le -> Ideal.map_comap_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] {f : F} {K : Ideal.{u2} S _inst_2}, LE.le.{u2} (Ideal.{u2} S _inst_2) (Preorder.toLE.{u2} (Ideal.{u2} S _inst_2) (PartialOrder.toPreorder.{u2} (Ideal.{u2} S _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))))) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f K)) K
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] {f : F} {K : Ideal.{u3} S _inst_2}, LE.le.{u3} (Ideal.{u3} S _inst_2) (Preorder.toLE.{u3} (Ideal.{u3} S _inst_2) (PartialOrder.toPreorder.{u3} (Ideal.{u3} S _inst_2) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} S _inst_2) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} S _inst_2) (Submodule.completeLattice.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))))) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f K)) K
Case conversion may be inaccurate. Consider using '#align ideal.map_comap_le Ideal.map_comap_leₓ'. -/
theorem map_comap_le : (K.comap f).map f ≤ K :=
  (gc_map_comap f).l_u_le _
#align ideal.map_comap_le Ideal.map_comap_le

/- warning: ideal.comap_top -> Ideal.comap_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] {f : F}, Eq.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Top.top.{u2} (Ideal.{u2} S _inst_2) (Submodule.hasTop.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))) (Top.top.{u1} (Ideal.{u1} R _inst_1) (Submodule.hasTop.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] {f : F}, Eq.{succ u2} (Ideal.{u2} R _inst_1) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Top.top.{u3} (Ideal.{u3} S _inst_2) (Submodule.instTopSubmodule.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))) (Top.top.{u2} (Ideal.{u2} R _inst_1) (Submodule.instTopSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align ideal.comap_top Ideal.comap_topₓ'. -/
@[simp]
theorem comap_top : (⊤ : Ideal S).comap f = ⊤ :=
  (gc_map_comap f).u_top
#align ideal.comap_top Ideal.comap_top

/- warning: ideal.comap_eq_top_iff -> Ideal.comap_eq_top_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] {f : F} {I : Ideal.{u2} S _inst_2}, Iff (Eq.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I) (Top.top.{u1} (Ideal.{u1} R _inst_1) (Submodule.hasTop.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) (Eq.{succ u2} (Ideal.{u2} S _inst_2) I (Top.top.{u2} (Ideal.{u2} S _inst_2) (Submodule.hasTop.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] {f : F} {I : Ideal.{u3} S _inst_2}, Iff (Eq.{succ u2} (Ideal.{u2} R _inst_1) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I) (Top.top.{u2} (Ideal.{u2} R _inst_1) (Submodule.instTopSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))) (Eq.{succ u3} (Ideal.{u3} S _inst_2) I (Top.top.{u3} (Ideal.{u3} S _inst_2) (Submodule.instTopSubmodule.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2))))
Case conversion may be inaccurate. Consider using '#align ideal.comap_eq_top_iff Ideal.comap_eq_top_iffₓ'. -/
@[simp]
theorem comap_eq_top_iff {I : Ideal S} : I.comap f = ⊤ ↔ I = ⊤ :=
  ⟨fun h => I.eq_top_iff_one.mpr (map_one f ▸ mem_comap.mp ((I.comap f).eq_top_iff_one.mp h)),
    fun h => by rw [h, comap_top]⟩
#align ideal.comap_eq_top_iff Ideal.comap_eq_top_iff

/- warning: ideal.map_bot -> Ideal.map_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] {f : F}, Eq.{succ u2} (Ideal.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Bot.bot.{u1} (Ideal.{u1} R _inst_1) (Submodule.hasBot.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) (Bot.bot.{u2} (Ideal.{u2} S _inst_2) (Submodule.hasBot.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] {f : F}, Eq.{succ u3} (Ideal.{u3} S _inst_2) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Bot.bot.{u2} (Ideal.{u2} R _inst_1) (Submodule.instBotSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))) (Bot.bot.{u3} (Ideal.{u3} S _inst_2) (Submodule.instBotSubmodule.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))
Case conversion may be inaccurate. Consider using '#align ideal.map_bot Ideal.map_botₓ'. -/
@[simp]
theorem map_bot : (⊥ : Ideal R).map f = ⊥ :=
  (gc_map_comap f).l_bot
#align ideal.map_bot Ideal.map_bot

variable (f I J K L)

/- warning: ideal.map_comap_map -> Ideal.map_comap_map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) (I : Ideal.{u1} R _inst_1), Eq.{succ u2} (Ideal.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I))) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) (I : Ideal.{u2} R _inst_1), Eq.{succ u3} (Ideal.{u3} S _inst_2) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I))) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I)
Case conversion may be inaccurate. Consider using '#align ideal.map_comap_map Ideal.map_comap_mapₓ'. -/
@[simp]
theorem map_comap_map : ((I.map f).comap f).map f = I.map f :=
  (gc_map_comap f).l_u_l_eq_l I
#align ideal.map_comap_map Ideal.map_comap_map

/- warning: ideal.comap_map_comap -> Ideal.comap_map_comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) (K : Ideal.{u2} S _inst_2), Eq.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f K))) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f K)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) (K : Ideal.{u3} S _inst_2), Eq.{succ u2} (Ideal.{u2} R _inst_1) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f K))) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f K)
Case conversion may be inaccurate. Consider using '#align ideal.comap_map_comap Ideal.comap_map_comapₓ'. -/
@[simp]
theorem comap_map_comap : ((K.comap f).map f).comap f = K.comap f :=
  (gc_map_comap f).u_l_u_eq_u K
#align ideal.comap_map_comap Ideal.comap_map_comap

/- warning: ideal.map_sup -> Ideal.map_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) (I : Ideal.{u1} R _inst_1) (J : Ideal.{u1} R _inst_1), Eq.{succ u2} (Ideal.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Sup.sup.{u1} (Ideal.{u1} R _inst_1) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R _inst_1) (Lattice.toSemilatticeSup.{u1} (Ideal.{u1} R _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) I J)) (Sup.sup.{u2} (Ideal.{u2} S _inst_2) (SemilatticeSup.toHasSup.{u2} (Ideal.{u2} S _inst_2) (Lattice.toSemilatticeSup.{u2} (Ideal.{u2} S _inst_2) (ConditionallyCompleteLattice.toLattice.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))))) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f J))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) (I : Ideal.{u2} R _inst_1) (J : Ideal.{u2} R _inst_1), Eq.{succ u3} (Ideal.{u3} S _inst_2) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Sup.sup.{u2} (Ideal.{u2} R _inst_1) (SemilatticeSup.toSup.{u2} (Ideal.{u2} R _inst_1) (Lattice.toSemilatticeSup.{u2} (Ideal.{u2} R _inst_1) (ConditionallyCompleteLattice.toLattice.{u2} (Ideal.{u2} R _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} R _inst_1) (Submodule.completeLattice.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))))) I J)) (Sup.sup.{u3} (Ideal.{u3} S _inst_2) (SemilatticeSup.toSup.{u3} (Ideal.{u3} S _inst_2) (Lattice.toSemilatticeSup.{u3} (Ideal.{u3} S _inst_2) (ConditionallyCompleteLattice.toLattice.{u3} (Ideal.{u3} S _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} S _inst_2) (Submodule.completeLattice.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))))) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f J))
Case conversion may be inaccurate. Consider using '#align ideal.map_sup Ideal.map_supₓ'. -/
theorem map_sup : (I ⊔ J).map f = I.map f ⊔ J.map f :=
  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_sup
#align ideal.map_sup Ideal.map_sup

/- warning: ideal.comap_inf -> Ideal.comap_inf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) (K : Ideal.{u2} S _inst_2) (L : Ideal.{u2} S _inst_2), Eq.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Inf.inf.{u2} (Ideal.{u2} S _inst_2) (Submodule.hasInf.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)) K L)) (Inf.inf.{u1} (Ideal.{u1} R _inst_1) (Submodule.hasInf.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f K) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f L))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) (K : Ideal.{u3} S _inst_2) (L : Ideal.{u3} S _inst_2), Eq.{succ u2} (Ideal.{u2} R _inst_1) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Inf.inf.{u3} (Ideal.{u3} S _inst_2) (Submodule.instInfSubmodule.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)) K L)) (Inf.inf.{u2} (Ideal.{u2} R _inst_1) (Submodule.instInfSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f K) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f L))
Case conversion may be inaccurate. Consider using '#align ideal.comap_inf Ideal.comap_infₓ'. -/
theorem comap_inf : comap f (K ⊓ L) = comap f K ⊓ comap f L :=
  rfl
#align ideal.comap_inf Ideal.comap_inf

variable {ι : Sort _}

/- warning: ideal.map_supr -> Ideal.map_supᵢ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) {ι : Sort.{u4}} (K : ι -> (Ideal.{u1} R _inst_1)), Eq.{succ u2} (Ideal.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (supᵢ.{u1, u4} (Ideal.{u1} R _inst_1) (ConditionallyCompleteLattice.toHasSup.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) ι K)) (supᵢ.{u2, u4} (Ideal.{u2} S _inst_2) (ConditionallyCompleteLattice.toHasSup.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))) ι (fun (i : ι) => Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (K i)))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u4}} {F : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u4} S] [rc : RingHomClass.{u2, u3, u4} F R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} S _inst_2)] (f : F) {ι : Sort.{u1}} (K : ι -> (Ideal.{u3} R _inst_1)), Eq.{succ u4} (Ideal.{u4} S _inst_2) (Ideal.map.{u3, u4, u2} R S F _inst_1 _inst_2 rc f (supᵢ.{u3, u1} (Ideal.{u3} R _inst_1) (ConditionallyCompleteLattice.toSupSet.{u3} (Ideal.{u3} R _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} R _inst_1) (Submodule.completeLattice.{u3, u3} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)))) ι K)) (supᵢ.{u4, u1} (Ideal.{u4} S _inst_2) (ConditionallyCompleteLattice.toSupSet.{u4} (Ideal.{u4} S _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u4} (Ideal.{u4} S _inst_2) (Submodule.completeLattice.{u4, u4} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (Semiring.toModule.{u4} S _inst_2)))) ι (fun (i : ι) => Ideal.map.{u3, u4, u2} R S F _inst_1 _inst_2 rc f (K i)))
Case conversion may be inaccurate. Consider using '#align ideal.map_supr Ideal.map_supᵢₓ'. -/
theorem map_supᵢ (K : ι → Ideal R) : (supᵢ K).map f = ⨆ i, (K i).map f :=
  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_supᵢ
#align ideal.map_supr Ideal.map_supᵢ

/- warning: ideal.comap_infi -> Ideal.comap_infᵢ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) {ι : Sort.{u4}} (K : ι -> (Ideal.{u2} S _inst_2)), Eq.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (infᵢ.{u2, u4} (Ideal.{u2} S _inst_2) (Submodule.hasInf.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)) ι K)) (infᵢ.{u1, u4} (Ideal.{u1} R _inst_1) (Submodule.hasInf.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) ι (fun (i : ι) => Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (K i)))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u4}} {F : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u4} S] [rc : RingHomClass.{u2, u3, u4} F R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} S _inst_2)] (f : F) {ι : Sort.{u1}} (K : ι -> (Ideal.{u4} S _inst_2)), Eq.{succ u3} (Ideal.{u3} R _inst_1) (Ideal.comap.{u3, u4, u2} R S F _inst_1 _inst_2 rc f (infᵢ.{u4, u1} (Ideal.{u4} S _inst_2) (Submodule.instInfSetSubmodule.{u4, u4} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (Semiring.toModule.{u4} S _inst_2)) ι K)) (infᵢ.{u3, u1} (Ideal.{u3} R _inst_1) (Submodule.instInfSetSubmodule.{u3, u3} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) ι (fun (i : ι) => Ideal.comap.{u3, u4, u2} R S F _inst_1 _inst_2 rc f (K i)))
Case conversion may be inaccurate. Consider using '#align ideal.comap_infi Ideal.comap_infᵢₓ'. -/
theorem comap_infᵢ (K : ι → Ideal S) : (infᵢ K).comap f = ⨅ i, (K i).comap f :=
  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_infᵢ
#align ideal.comap_infi Ideal.comap_infᵢ

/- warning: ideal.map_Sup -> Ideal.map_supₛ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) (s : Set.{u1} (Ideal.{u1} R _inst_1)), Eq.{succ u2} (Ideal.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (SupSet.supₛ.{u1} (Ideal.{u1} R _inst_1) (ConditionallyCompleteLattice.toHasSup.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) s)) (supᵢ.{u2, succ u1} (Ideal.{u2} S _inst_2) (ConditionallyCompleteLattice.toHasSup.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))) (Ideal.{u1} R _inst_1) (fun (I : Ideal.{u1} R _inst_1) => supᵢ.{u2, 0} (Ideal.{u2} S _inst_2) (ConditionallyCompleteLattice.toHasSup.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))) (Membership.Mem.{u1, u1} (Ideal.{u1} R _inst_1) (Set.{u1} (Ideal.{u1} R _inst_1)) (Set.hasMem.{u1} (Ideal.{u1} R _inst_1)) I s) (fun (H : Membership.Mem.{u1, u1} (Ideal.{u1} R _inst_1) (Set.{u1} (Ideal.{u1} R _inst_1)) (Set.hasMem.{u1} (Ideal.{u1} R _inst_1)) I s) => Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I)))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) (s : Set.{u2} (Ideal.{u2} R _inst_1)), Eq.{succ u3} (Ideal.{u3} S _inst_2) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (SupSet.supₛ.{u2} (Ideal.{u2} R _inst_1) (ConditionallyCompleteLattice.toSupSet.{u2} (Ideal.{u2} R _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} R _inst_1) (Submodule.completeLattice.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))) s)) (supᵢ.{u3, succ u2} (Ideal.{u3} S _inst_2) (ConditionallyCompleteLattice.toSupSet.{u3} (Ideal.{u3} S _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} S _inst_2) (Submodule.completeLattice.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))) (Ideal.{u2} R _inst_1) (fun (I : Ideal.{u2} R _inst_1) => supᵢ.{u3, 0} (Ideal.{u3} S _inst_2) (ConditionallyCompleteLattice.toSupSet.{u3} (Ideal.{u3} S _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} S _inst_2) (Submodule.completeLattice.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))) (Membership.mem.{u2, u2} (Ideal.{u2} R _inst_1) (Set.{u2} (Ideal.{u2} R _inst_1)) (Set.instMembershipSet.{u2} (Ideal.{u2} R _inst_1)) I s) (fun (H : Membership.mem.{u2, u2} (Ideal.{u2} R _inst_1) (Set.{u2} (Ideal.{u2} R _inst_1)) (Set.instMembershipSet.{u2} (Ideal.{u2} R _inst_1)) I s) => Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I)))
Case conversion may be inaccurate. Consider using '#align ideal.map_Sup Ideal.map_supₛₓ'. -/
theorem map_supₛ (s : Set (Ideal R)) : (supₛ s).map f = ⨆ I ∈ s, (I : Ideal R).map f :=
  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_supₛ
#align ideal.map_Sup Ideal.map_supₛ

/- warning: ideal.comap_Inf -> Ideal.comap_infₛ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) (s : Set.{u2} (Ideal.{u2} S _inst_2)), Eq.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (InfSet.infₛ.{u2} (Ideal.{u2} S _inst_2) (Submodule.hasInf.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)) s)) (infᵢ.{u1, succ u2} (Ideal.{u1} R _inst_1) (Submodule.hasInf.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Ideal.{u2} S _inst_2) (fun (I : Ideal.{u2} S _inst_2) => infᵢ.{u1, 0} (Ideal.{u1} R _inst_1) (Submodule.hasInf.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Membership.Mem.{u2, u2} (Ideal.{u2} S _inst_2) (Set.{u2} (Ideal.{u2} S _inst_2)) (Set.hasMem.{u2} (Ideal.{u2} S _inst_2)) I s) (fun (H : Membership.Mem.{u2, u2} (Ideal.{u2} S _inst_2) (Set.{u2} (Ideal.{u2} S _inst_2)) (Set.hasMem.{u2} (Ideal.{u2} S _inst_2)) I s) => Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I)))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) (s : Set.{u3} (Ideal.{u3} S _inst_2)), Eq.{succ u2} (Ideal.{u2} R _inst_1) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (InfSet.infₛ.{u3} (Ideal.{u3} S _inst_2) (Submodule.instInfSetSubmodule.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)) s)) (infᵢ.{u2, succ u3} (Ideal.{u2} R _inst_1) (Submodule.instInfSetSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (Ideal.{u3} S _inst_2) (fun (I : Ideal.{u3} S _inst_2) => infᵢ.{u2, 0} (Ideal.{u2} R _inst_1) (Submodule.instInfSetSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (Membership.mem.{u3, u3} (Ideal.{u3} S _inst_2) (Set.{u3} (Ideal.{u3} S _inst_2)) (Set.instMembershipSet.{u3} (Ideal.{u3} S _inst_2)) I s) (fun (H : Membership.mem.{u3, u3} (Ideal.{u3} S _inst_2) (Set.{u3} (Ideal.{u3} S _inst_2)) (Set.instMembershipSet.{u3} (Ideal.{u3} S _inst_2)) I s) => Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I)))
Case conversion may be inaccurate. Consider using '#align ideal.comap_Inf Ideal.comap_infₛₓ'. -/
theorem comap_infₛ (s : Set (Ideal S)) : (infₛ s).comap f = ⨅ I ∈ s, (I : Ideal S).comap f :=
  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_infₛ
#align ideal.comap_Inf Ideal.comap_infₛ

/- warning: ideal.comap_Inf' -> Ideal.comap_Inf' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) (s : Set.{u2} (Ideal.{u2} S _inst_2)), Eq.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (InfSet.infₛ.{u2} (Ideal.{u2} S _inst_2) (Submodule.hasInf.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)) s)) (infᵢ.{u1, succ u1} (Ideal.{u1} R _inst_1) (Submodule.hasInf.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Ideal.{u1} R _inst_1) (fun (I : Ideal.{u1} R _inst_1) => infᵢ.{u1, 0} (Ideal.{u1} R _inst_1) (Submodule.hasInf.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Membership.Mem.{u1, u1} (Ideal.{u1} R _inst_1) (Set.{u1} (Ideal.{u1} R _inst_1)) (Set.hasMem.{u1} (Ideal.{u1} R _inst_1)) I (Set.image.{u2, u1} (Ideal.{u2} S _inst_2) (Ideal.{u1} R _inst_1) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f) s)) (fun (H : Membership.Mem.{u1, u1} (Ideal.{u1} R _inst_1) (Set.{u1} (Ideal.{u1} R _inst_1)) (Set.hasMem.{u1} (Ideal.{u1} R _inst_1)) I (Set.image.{u2, u1} (Ideal.{u2} S _inst_2) (Ideal.{u1} R _inst_1) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f) s)) => I)))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) (s : Set.{u3} (Ideal.{u3} S _inst_2)), Eq.{succ u2} (Ideal.{u2} R _inst_1) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (InfSet.infₛ.{u3} (Ideal.{u3} S _inst_2) (Submodule.instInfSetSubmodule.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)) s)) (infᵢ.{u2, succ u2} (Ideal.{u2} R _inst_1) (Submodule.instInfSetSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (Ideal.{u2} R _inst_1) (fun (I : Ideal.{u2} R _inst_1) => infᵢ.{u2, 0} (Ideal.{u2} R _inst_1) (Submodule.instInfSetSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (Membership.mem.{u2, u2} (Ideal.{u2} R _inst_1) (Set.{u2} (Ideal.{u2} R _inst_1)) (Set.instMembershipSet.{u2} (Ideal.{u2} R _inst_1)) I (Set.image.{u3, u2} (Ideal.{u3} S _inst_2) (Ideal.{u2} R _inst_1) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f) s)) (fun (H : Membership.mem.{u2, u2} (Ideal.{u2} R _inst_1) (Set.{u2} (Ideal.{u2} R _inst_1)) (Set.instMembershipSet.{u2} (Ideal.{u2} R _inst_1)) I (Set.image.{u3, u2} (Ideal.{u3} S _inst_2) (Ideal.{u2} R _inst_1) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f) s)) => I)))
Case conversion may be inaccurate. Consider using '#align ideal.comap_Inf' Ideal.comap_Inf'ₓ'. -/
theorem comap_Inf' (s : Set (Ideal S)) : (infₛ s).comap f = ⨅ I ∈ comap f '' s, I :=
  trans (comap_infₛ f s) (by rw [infᵢ_image])
#align ideal.comap_Inf' Ideal.comap_Inf'

/- warning: ideal.comap_is_prime -> Ideal.comap_isPrime is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) (K : Ideal.{u2} S _inst_2) [H : Ideal.IsPrime.{u2} S _inst_2 K], Ideal.IsPrime.{u1} R _inst_1 (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f K)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) (K : Ideal.{u3} S _inst_2) [H : Ideal.IsPrime.{u3} S _inst_2 K], Ideal.IsPrime.{u2} R _inst_1 (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f K)
Case conversion may be inaccurate. Consider using '#align ideal.comap_is_prime Ideal.comap_isPrimeₓ'. -/
theorem comap_isPrime [H : IsPrime K] : IsPrime (comap f K) :=
  ⟨comap_ne_top f H.ne_top, fun x y h => H.mem_or_mem <| by rwa [mem_comap, map_mul] at h⟩
#align ideal.comap_is_prime Ideal.comap_isPrime

variable {I J K L}

/- warning: ideal.map_inf_le -> Ideal.map_inf_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) {I : Ideal.{u1} R _inst_1} {J : Ideal.{u1} R _inst_1}, LE.le.{u2} (Ideal.{u2} S _inst_2) (Preorder.toLE.{u2} (Ideal.{u2} S _inst_2) (PartialOrder.toPreorder.{u2} (Ideal.{u2} S _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))))) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Inf.inf.{u1} (Ideal.{u1} R _inst_1) (Submodule.hasInf.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) I J)) (Inf.inf.{u2} (Ideal.{u2} S _inst_2) (Submodule.hasInf.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f J))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) {I : Ideal.{u2} R _inst_1} {J : Ideal.{u2} R _inst_1}, LE.le.{u3} (Ideal.{u3} S _inst_2) (Preorder.toLE.{u3} (Ideal.{u3} S _inst_2) (PartialOrder.toPreorder.{u3} (Ideal.{u3} S _inst_2) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} S _inst_2) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} S _inst_2) (Submodule.completeLattice.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))))) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Inf.inf.{u2} (Ideal.{u2} R _inst_1) (Submodule.instInfSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) I J)) (Inf.inf.{u3} (Ideal.{u3} S _inst_2) (Submodule.instInfSubmodule.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f J))
Case conversion may be inaccurate. Consider using '#align ideal.map_inf_le Ideal.map_inf_leₓ'. -/
theorem map_inf_le : map f (I ⊓ J) ≤ map f I ⊓ map f J :=
  (gc_map_comap f : GaloisConnection (map f) (comap f)).monotone_l.map_inf_le _ _
#align ideal.map_inf_le Ideal.map_inf_le

/- warning: ideal.le_comap_sup -> Ideal.le_comap_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) {K : Ideal.{u2} S _inst_2} {L : Ideal.{u2} S _inst_2}, LE.le.{u1} (Ideal.{u1} R _inst_1) (Preorder.toLE.{u1} (Ideal.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) (Sup.sup.{u1} (Ideal.{u1} R _inst_1) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R _inst_1) (Lattice.toSemilatticeSup.{u1} (Ideal.{u1} R _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f K) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f L)) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Sup.sup.{u2} (Ideal.{u2} S _inst_2) (SemilatticeSup.toHasSup.{u2} (Ideal.{u2} S _inst_2) (Lattice.toSemilatticeSup.{u2} (Ideal.{u2} S _inst_2) (ConditionallyCompleteLattice.toLattice.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))))) K L))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) {K : Ideal.{u3} S _inst_2} {L : Ideal.{u3} S _inst_2}, LE.le.{u2} (Ideal.{u2} R _inst_1) (Preorder.toLE.{u2} (Ideal.{u2} R _inst_1) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R _inst_1) (Submodule.completeLattice.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))))) (Sup.sup.{u2} (Ideal.{u2} R _inst_1) (SemilatticeSup.toSup.{u2} (Ideal.{u2} R _inst_1) (Lattice.toSemilatticeSup.{u2} (Ideal.{u2} R _inst_1) (ConditionallyCompleteLattice.toLattice.{u2} (Ideal.{u2} R _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} R _inst_1) (Submodule.completeLattice.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))))) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f K) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f L)) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Sup.sup.{u3} (Ideal.{u3} S _inst_2) (SemilatticeSup.toSup.{u3} (Ideal.{u3} S _inst_2) (Lattice.toSemilatticeSup.{u3} (Ideal.{u3} S _inst_2) (ConditionallyCompleteLattice.toLattice.{u3} (Ideal.{u3} S _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} S _inst_2) (Submodule.completeLattice.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))))) K L))
Case conversion may be inaccurate. Consider using '#align ideal.le_comap_sup Ideal.le_comap_supₓ'. -/
theorem le_comap_sup : comap f K ⊔ comap f L ≤ comap f (K ⊔ L) :=
  (gc_map_comap f : GaloisConnection (map f) (comap f)).monotone_u.le_map_sup _ _
#align ideal.le_comap_sup Ideal.le_comap_sup

omit rc

/- warning: ideal.smul_top_eq_map -> Ideal.smul_top_eq_map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_3 : CommSemiring.{u1} R] [_inst_4 : CommSemiring.{u2} S] [_inst_5 : Algebra.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4)] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3)), Eq.{succ u2} (Submodule.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5)) (SMul.smul.{u1, u2} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3)) (Submodule.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5)) (Submodule.hasSmul'.{u1, u2} R S _inst_3 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5)) I (Top.top.{u2} (Submodule.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5)) (Submodule.hasTop.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5)))) (Submodule.restrictScalars.{u1, u2, u2} R S S (CommSemiring.toSemiring.{u2} S _inst_4) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (CommSemiring.toSemiring.{u1} R _inst_3) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5) (Semiring.toModule.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (SMulZeroClass.toHasSmul.{u1, u2} R S (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R S (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3))))) (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R S (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3)) (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))))) (Module.toMulActionWithZero.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5))))) (IsScalarTower.right.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5) (Ideal.map.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))) (CommSemiring.toSemiring.{u1} R _inst_3) (CommSemiring.toSemiring.{u2} S _inst_4) (RingHom.ringHomClass.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))) (algebraMap.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5) I))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_3 : CommSemiring.{u2} R] [_inst_4 : CommSemiring.{u1} S] [_inst_5 : Algebra.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4)] (I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_3)), Eq.{succ u1} (Submodule.{u2, u1} R S (CommSemiring.toSemiring.{u2} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))) (Algebra.toModule.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5)) (HSMul.hSMul.{u2, u1, u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_3)) (Submodule.{u2, u1} R S (CommSemiring.toSemiring.{u2} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))) (Algebra.toModule.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5)) (Submodule.{u2, u1} R S (CommSemiring.toSemiring.{u2} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))) (Algebra.toModule.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5)) (instHSMul.{u2, u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R _inst_3)) (Submodule.{u2, u1} R S (CommSemiring.toSemiring.{u2} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))) (Algebra.toModule.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5)) (Submodule.hasSmul'.{u2, u1} R S _inst_3 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))) (Algebra.toModule.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5))) I (Top.top.{u1} (Submodule.{u2, u1} R S (CommSemiring.toSemiring.{u2} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))) (Algebra.toModule.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5)) (Submodule.instTopSubmodule.{u2, u1} R S (CommSemiring.toSemiring.{u2} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))) (Algebra.toModule.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5)))) (Submodule.restrictScalars.{u2, u1, u1} R S S (CommSemiring.toSemiring.{u1} S _inst_4) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))) (CommSemiring.toSemiring.{u2} R _inst_3) (Algebra.toModule.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Algebra.toSMul.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5) (IsScalarTower.right.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5) (Ideal.map.{u2, u1, max u2 u1} R S (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_3)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))) (CommSemiring.toSemiring.{u2} R _inst_3) (CommSemiring.toSemiring.{u1} S _inst_4) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_3)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4))) (algebraMap.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5) I))
Case conversion may be inaccurate. Consider using '#align ideal.smul_top_eq_map Ideal.smul_top_eq_mapₓ'. -/
@[simp]
theorem smul_top_eq_map {R S : Type _} [CommSemiring R] [CommSemiring S] [Algebra R S]
    (I : Ideal R) : I • (⊤ : Submodule R S) = (I.map (algebraMap R S)).restrictScalars R :=
  by
  refine'
    le_antisymm (submodule.smul_le.mpr fun r hr y _ => _) fun x hx =>
      Submodule.span_induction hx _ _ _ _
  · rw [Algebra.smul_def]
    exact mul_mem_right _ _ (mem_map_of_mem _ hr)
  · rintro _ ⟨x, hx, rfl⟩
    rw [← mul_one (algebraMap R S x), ← Algebra.smul_def]
    exact Submodule.smul_mem_smul hx Submodule.mem_top
  · exact Submodule.zero_mem _
  · intro x y
    exact Submodule.add_mem _
  intro a x hx
  refine' Submodule.smul_induction_on hx _ _
  · intro r hr s hs
    rw [smul_comm]
    exact Submodule.smul_mem_smul hr Submodule.mem_top
  · intro x y hx hy
    rw [smul_add]
    exact Submodule.add_mem _ hx hy
#align ideal.smul_top_eq_map Ideal.smul_top_eq_map

/- warning: ideal.coe_restrict_scalars -> Ideal.coe_restrictScalars is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_3 : CommSemiring.{u1} R] [_inst_4 : Semiring.{u2} S] [_inst_5 : Algebra.{u1, u2} R S _inst_3 _inst_4] (I : Ideal.{u2} S _inst_4), Eq.{succ u2} (Set.{u2} S) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_4))) (Algebra.toModule.{u1, u2} R S _inst_3 _inst_4 _inst_5)) (Set.{u2} S) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_4))) (Algebra.toModule.{u1, u2} R S _inst_3 _inst_4 _inst_5)) (Set.{u2} S) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_4))) (Algebra.toModule.{u1, u2} R S _inst_3 _inst_4 _inst_5)) (Set.{u2} S) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_4))) (Algebra.toModule.{u1, u2} R S _inst_3 _inst_4 _inst_5)) S (Submodule.setLike.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_4))) (Algebra.toModule.{u1, u2} R S _inst_3 _inst_4 _inst_5))))) (Submodule.restrictScalars.{u1, u2, u2} R S S _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_4))) (CommSemiring.toSemiring.{u1} R _inst_3) (Algebra.toModule.{u1, u2} R S _inst_3 _inst_4 _inst_5) (Semiring.toModule.{u2} S _inst_4) (SMulZeroClass.toHasSmul.{u1, u2} R S (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_4)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R S (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3))))) (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_4)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R S (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3)) (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_4)))))) (Module.toMulActionWithZero.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_4))) (Algebra.toModule.{u1, u2} R S _inst_3 _inst_4 _inst_5))))) (IsScalarTower.right.{u1, u2} R S _inst_3 _inst_4 _inst_5) I)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} S _inst_4) (Set.{u2} S) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} S _inst_4) (Set.{u2} S) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} S _inst_4) (Set.{u2} S) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} S _inst_4) S (Submodule.setLike.{u2, u2} S S _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_4))) (Semiring.toModule.{u2} S _inst_4))))) I)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_3 : CommSemiring.{u2} R] [_inst_4 : Semiring.{u1} S] [_inst_5 : Algebra.{u2, u1} R S _inst_3 _inst_4] (I : Ideal.{u1} S _inst_4), Eq.{succ u1} (Set.{u1} S) (SetLike.coe.{u1, u1} (Submodule.{u2, u1} R S (CommSemiring.toSemiring.{u2} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_4))) (Algebra.toModule.{u2, u1} R S _inst_3 _inst_4 _inst_5)) S (Submodule.setLike.{u2, u1} R S (CommSemiring.toSemiring.{u2} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_4))) (Algebra.toModule.{u2, u1} R S _inst_3 _inst_4 _inst_5)) (Submodule.restrictScalars.{u2, u1, u1} R S S _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_4))) (CommSemiring.toSemiring.{u2} R _inst_3) (Algebra.toModule.{u2, u1} R S _inst_3 _inst_4 _inst_5) (Semiring.toModule.{u1} S _inst_4) (Algebra.toSMul.{u2, u1} R S _inst_3 _inst_4 _inst_5) (IsScalarTower.right.{u2, u1} R S _inst_3 _inst_4 _inst_5) I)) (SetLike.coe.{u1, u1} (Ideal.{u1} S _inst_4) S (Submodule.setLike.{u1, u1} S S _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_4))) (Semiring.toModule.{u1} S _inst_4)) I)
Case conversion may be inaccurate. Consider using '#align ideal.coe_restrict_scalars Ideal.coe_restrictScalarsₓ'. -/
@[simp]
theorem coe_restrictScalars {R S : Type _} [CommSemiring R] [Semiring S] [Algebra R S]
    (I : Ideal S) : (I.restrictScalars R : Set S) = ↑I :=
  rfl
#align ideal.coe_restrict_scalars Ideal.coe_restrictScalars

/- warning: ideal.restrict_scalars_mul -> Ideal.restrictScalars_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_3 : CommSemiring.{u1} R] [_inst_4 : CommSemiring.{u2} S] [_inst_5 : Algebra.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4)] (I : Ideal.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (J : Ideal.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)), Eq.{succ u2} (Submodule.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5)) (Submodule.restrictScalars.{u1, u2, u2} R S S (CommSemiring.toSemiring.{u2} S _inst_4) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (CommSemiring.toSemiring.{u1} R _inst_3) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5) (Semiring.toModule.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (SMulZeroClass.toHasSmul.{u1, u2} R S (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R S (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3))))) (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R S (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3)) (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))))) (Module.toMulActionWithZero.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5))))) (IsScalarTower.right.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5) (HMul.hMul.{u2, u2, u2} (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (instHMul.{u2} (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (Ideal.hasMul.{u2} S _inst_4)) I J)) (HMul.hMul.{u2, u2, u2} (Submodule.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5)) (Submodule.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5)) (Submodule.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5)) (instHMul.{u2} (Submodule.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5)) (Submodule.mul.{u1, u2} R _inst_3 S (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5)) (Submodule.restrictScalars.{u1, u2, u2} R S S (CommSemiring.toSemiring.{u2} S _inst_4) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (CommSemiring.toSemiring.{u1} R _inst_3) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5) (Semiring.toModule.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (SMulZeroClass.toHasSmul.{u1, u2} R S (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R S (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3))))) (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R S (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3)) (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))))) (Module.toMulActionWithZero.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5))))) (IsScalarTower.right.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5) I) (Submodule.restrictScalars.{u1, u2, u2} R S S (CommSemiring.toSemiring.{u2} S _inst_4) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (CommSemiring.toSemiring.{u1} R _inst_3) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5) (Semiring.toModule.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)) (SMulZeroClass.toHasSmul.{u1, u2} R S (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R S (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3))))) (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R S (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_3)) (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4))))))) (Module.toMulActionWithZero.{u1, u2} R S (CommSemiring.toSemiring.{u1} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_4)))) (Algebra.toModule.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5))))) (IsScalarTower.right.{u1, u2} R S _inst_3 (CommSemiring.toSemiring.{u2} S _inst_4) _inst_5) J))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_3 : CommSemiring.{u2} R] [_inst_4 : CommSemiring.{u1} S] [_inst_5 : Algebra.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4)] (I : Ideal.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (J : Ideal.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)), Eq.{succ u1} (Submodule.{u2, u1} R S (CommSemiring.toSemiring.{u2} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))) (Algebra.toModule.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5)) (Submodule.restrictScalars.{u2, u1, u1} R S S (CommSemiring.toSemiring.{u1} S _inst_4) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))) (CommSemiring.toSemiring.{u2} R _inst_3) (Algebra.toModule.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Algebra.toSMul.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5) (IsScalarTower.right.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (instHMul.{u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Ideal.instMulIdealToSemiring.{u1} S _inst_4)) I J)) (HMul.hMul.{u1, u1, u1} (Submodule.{u2, u1} R S (CommSemiring.toSemiring.{u2} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))) (Algebra.toModule.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5)) (Submodule.{u2, u1} R S (CommSemiring.toSemiring.{u2} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))) (Algebra.toModule.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5)) (Submodule.{u2, u1} R S (CommSemiring.toSemiring.{u2} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))) (Algebra.toModule.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5)) (instHMul.{u1} (Submodule.{u2, u1} R S (CommSemiring.toSemiring.{u2} R _inst_3) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))) (Algebra.toModule.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5)) (Submodule.mul.{u2, u1} R _inst_3 S (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5)) (Submodule.restrictScalars.{u2, u1, u1} R S S (CommSemiring.toSemiring.{u1} S _inst_4) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))) (CommSemiring.toSemiring.{u2} R _inst_3) (Algebra.toModule.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Algebra.toSMul.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5) (IsScalarTower.right.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5) I) (Submodule.restrictScalars.{u2, u1, u1} R S S (CommSemiring.toSemiring.{u1} S _inst_4) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)))) (CommSemiring.toSemiring.{u2} R _inst_3) (Algebra.toModule.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S _inst_4)) (Algebra.toSMul.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5) (IsScalarTower.right.{u2, u1} R S _inst_3 (CommSemiring.toSemiring.{u1} S _inst_4) _inst_5) J))
Case conversion may be inaccurate. Consider using '#align ideal.restrict_scalars_mul Ideal.restrictScalars_mulₓ'. -/
/-- The smallest `S`-submodule that contains all `x ∈ I * y ∈ J`
is also the smallest `R`-submodule that does so. -/
@[simp]
theorem restrictScalars_mul {R S : Type _} [CommSemiring R] [CommSemiring S] [Algebra R S]
    (I J : Ideal S) : (I * J).restrictScalars R = I.restrictScalars R * J.restrictScalars R :=
  le_antisymm
    (fun x hx =>
      Submodule.mul_induction_on hx (fun x hx y hy => Submodule.mul_mem_mul hx hy) fun x y =>
        Submodule.add_mem _)
    (Submodule.mul_le.mpr fun x hx y hy => Ideal.mul_mem_mul hx hy)
#align ideal.restrict_scalars_mul Ideal.restrictScalars_mul

section Surjective

variable (hf : Function.Surjective f)

include hf

open Function

/- warning: ideal.map_comap_of_surjective -> Ideal.map_comap_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f)) -> (forall (I : Ideal.{u2} S _inst_2), Eq.{succ u2} (Ideal.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I)) I)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F), (Function.Surjective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f)) -> (forall (I : Ideal.{u3} S _inst_2), Eq.{succ u3} (Ideal.{u3} S _inst_2) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I)) I)
Case conversion may be inaccurate. Consider using '#align ideal.map_comap_of_surjective Ideal.map_comap_of_surjectiveₓ'. -/
theorem map_comap_of_surjective (I : Ideal S) : map f (comap f I) = I :=
  le_antisymm (map_le_iff_le_comap.2 le_rfl) fun s hsi =>
    let ⟨r, hfrs⟩ := hf s
    hfrs ▸ (mem_map_of_mem f <| show f r ∈ I from hfrs.symm ▸ hsi)
#align ideal.map_comap_of_surjective Ideal.map_comap_of_surjective

#print Ideal.giMapComap /-
/-- `map` and `comap` are adjoint, and the composition `map f ∘ comap f` is the
  identity -/
def giMapComap : GaloisInsertion (map f) (comap f) :=
  GaloisInsertion.monotoneIntro (gc_map_comap f).monotone_u (gc_map_comap f).monotone_l
    (fun _ => le_comap_map) (map_comap_of_surjective _ hf)
#align ideal.gi_map_comap Ideal.giMapComap
-/

/- warning: ideal.map_surjective_of_surjective -> Ideal.map_surjective_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f)) -> (Function.Surjective.{succ u1, succ u2} (Ideal.{u1} R _inst_1) (Ideal.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F), (Function.Surjective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f)) -> (Function.Surjective.{succ u2, succ u3} (Ideal.{u2} R _inst_1) (Ideal.{u3} S _inst_2) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f))
Case conversion may be inaccurate. Consider using '#align ideal.map_surjective_of_surjective Ideal.map_surjective_of_surjectiveₓ'. -/
theorem map_surjective_of_surjective : Surjective (map f) :=
  (giMapComap f hf).l_surjective
#align ideal.map_surjective_of_surjective Ideal.map_surjective_of_surjective

/- warning: ideal.comap_injective_of_surjective -> Ideal.comap_injective_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f)) -> (Function.Injective.{succ u2, succ u1} (Ideal.{u2} S _inst_2) (Ideal.{u1} R _inst_1) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F), (Function.Surjective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f)) -> (Function.Injective.{succ u3, succ u2} (Ideal.{u3} S _inst_2) (Ideal.{u2} R _inst_1) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f))
Case conversion may be inaccurate. Consider using '#align ideal.comap_injective_of_surjective Ideal.comap_injective_of_surjectiveₓ'. -/
theorem comap_injective_of_surjective : Injective (comap f) :=
  (giMapComap f hf).u_injective
#align ideal.comap_injective_of_surjective Ideal.comap_injective_of_surjective

/- warning: ideal.map_sup_comap_of_surjective -> Ideal.map_sup_comap_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f)) -> (forall (I : Ideal.{u2} S _inst_2) (J : Ideal.{u2} S _inst_2), Eq.{succ u2} (Ideal.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Sup.sup.{u1} (Ideal.{u1} R _inst_1) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R _inst_1) (Lattice.toSemilatticeSup.{u1} (Ideal.{u1} R _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f J))) (Sup.sup.{u2} (Ideal.{u2} S _inst_2) (SemilatticeSup.toHasSup.{u2} (Ideal.{u2} S _inst_2) (Lattice.toSemilatticeSup.{u2} (Ideal.{u2} S _inst_2) (ConditionallyCompleteLattice.toLattice.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))))) I J))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F), (Function.Surjective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f)) -> (forall (I : Ideal.{u3} S _inst_2) (J : Ideal.{u3} S _inst_2), Eq.{succ u3} (Ideal.{u3} S _inst_2) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Sup.sup.{u2} (Ideal.{u2} R _inst_1) (SemilatticeSup.toSup.{u2} (Ideal.{u2} R _inst_1) (Lattice.toSemilatticeSup.{u2} (Ideal.{u2} R _inst_1) (ConditionallyCompleteLattice.toLattice.{u2} (Ideal.{u2} R _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} R _inst_1) (Submodule.completeLattice.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))))) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f J))) (Sup.sup.{u3} (Ideal.{u3} S _inst_2) (SemilatticeSup.toSup.{u3} (Ideal.{u3} S _inst_2) (Lattice.toSemilatticeSup.{u3} (Ideal.{u3} S _inst_2) (ConditionallyCompleteLattice.toLattice.{u3} (Ideal.{u3} S _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} S _inst_2) (Submodule.completeLattice.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))))) I J))
Case conversion may be inaccurate. Consider using '#align ideal.map_sup_comap_of_surjective Ideal.map_sup_comap_of_surjectiveₓ'. -/
theorem map_sup_comap_of_surjective (I J : Ideal S) : (I.comap f ⊔ J.comap f).map f = I ⊔ J :=
  (giMapComap f hf).l_sup_u _ _
#align ideal.map_sup_comap_of_surjective Ideal.map_sup_comap_of_surjective

/- warning: ideal.map_supr_comap_of_surjective -> Ideal.map_supᵢ_comap_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) {ι : Sort.{u4}}, (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f)) -> (forall (K : ι -> (Ideal.{u2} S _inst_2)), Eq.{succ u2} (Ideal.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (supᵢ.{u1, u4} (Ideal.{u1} R _inst_1) (ConditionallyCompleteLattice.toHasSup.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) ι (fun (i : ι) => Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (K i)))) (supᵢ.{u2, u4} (Ideal.{u2} S _inst_2) (ConditionallyCompleteLattice.toHasSup.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))) ι K))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u4}} {F : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u4} S] [rc : RingHomClass.{u2, u3, u4} F R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} S _inst_2)] (f : F) {ι : Sort.{u1}}, (Function.Surjective.{succ u3, succ u4} R S (FunLike.coe.{succ u2, succ u3, succ u4} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u2, u3, u4} F R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u2, u3, u4} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u2, u3, u4} F R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} S _inst_2) rc))) f)) -> (forall (K : ι -> (Ideal.{u4} S _inst_2)), Eq.{succ u4} (Ideal.{u4} S _inst_2) (Ideal.map.{u3, u4, u2} R S F _inst_1 _inst_2 rc f (supᵢ.{u3, u1} (Ideal.{u3} R _inst_1) (ConditionallyCompleteLattice.toSupSet.{u3} (Ideal.{u3} R _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Ideal.{u3} R _inst_1) (Submodule.completeLattice.{u3, u3} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)))) ι (fun (i : ι) => Ideal.comap.{u3, u4, u2} R S F _inst_1 _inst_2 rc f (K i)))) (supᵢ.{u4, u1} (Ideal.{u4} S _inst_2) (ConditionallyCompleteLattice.toSupSet.{u4} (Ideal.{u4} S _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u4} (Ideal.{u4} S _inst_2) (Submodule.completeLattice.{u4, u4} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (Semiring.toModule.{u4} S _inst_2)))) ι K))
Case conversion may be inaccurate. Consider using '#align ideal.map_supr_comap_of_surjective Ideal.map_supᵢ_comap_of_surjectiveₓ'. -/
theorem map_supᵢ_comap_of_surjective (K : ι → Ideal S) : (⨆ i, (K i).comap f).map f = supᵢ K :=
  (giMapComap f hf).l_supᵢ_u _
#align ideal.map_supr_comap_of_surjective Ideal.map_supᵢ_comap_of_surjective

/- warning: ideal.map_inf_comap_of_surjective -> Ideal.map_inf_comap_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f)) -> (forall (I : Ideal.{u2} S _inst_2) (J : Ideal.{u2} S _inst_2), Eq.{succ u2} (Ideal.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Inf.inf.{u1} (Ideal.{u1} R _inst_1) (Submodule.hasInf.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f J))) (Inf.inf.{u2} (Ideal.{u2} S _inst_2) (Submodule.hasInf.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)) I J))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F), (Function.Surjective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f)) -> (forall (I : Ideal.{u3} S _inst_2) (J : Ideal.{u3} S _inst_2), Eq.{succ u3} (Ideal.{u3} S _inst_2) (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Inf.inf.{u2} (Ideal.{u2} R _inst_1) (Submodule.instInfSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f J))) (Inf.inf.{u3} (Ideal.{u3} S _inst_2) (Submodule.instInfSubmodule.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)) I J))
Case conversion may be inaccurate. Consider using '#align ideal.map_inf_comap_of_surjective Ideal.map_inf_comap_of_surjectiveₓ'. -/
theorem map_inf_comap_of_surjective (I J : Ideal S) : (I.comap f ⊓ J.comap f).map f = I ⊓ J :=
  (giMapComap f hf).l_inf_u _ _
#align ideal.map_inf_comap_of_surjective Ideal.map_inf_comap_of_surjective

/- warning: ideal.map_infi_comap_of_surjective -> Ideal.map_infᵢ_comap_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) {ι : Sort.{u4}}, (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f)) -> (forall (K : ι -> (Ideal.{u2} S _inst_2)), Eq.{succ u2} (Ideal.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (infᵢ.{u1, u4} (Ideal.{u1} R _inst_1) (Submodule.hasInf.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) ι (fun (i : ι) => Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (K i)))) (infᵢ.{u2, u4} (Ideal.{u2} S _inst_2) (Submodule.hasInf.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)) ι K))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u4}} {F : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u4} S] [rc : RingHomClass.{u2, u3, u4} F R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} S _inst_2)] (f : F) {ι : Sort.{u1}}, (Function.Surjective.{succ u3, succ u4} R S (FunLike.coe.{succ u2, succ u3, succ u4} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u2, u3, u4} F R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u2, u3, u4} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u2, u3, u4} F R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} S _inst_2) rc))) f)) -> (forall (K : ι -> (Ideal.{u4} S _inst_2)), Eq.{succ u4} (Ideal.{u4} S _inst_2) (Ideal.map.{u3, u4, u2} R S F _inst_1 _inst_2 rc f (infᵢ.{u3, u1} (Ideal.{u3} R _inst_1) (Submodule.instInfSetSubmodule.{u3, u3} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) ι (fun (i : ι) => Ideal.comap.{u3, u4, u2} R S F _inst_1 _inst_2 rc f (K i)))) (infᵢ.{u4, u1} (Ideal.{u4} S _inst_2) (Submodule.instInfSetSubmodule.{u4, u4} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) (Semiring.toModule.{u4} S _inst_2)) ι K))
Case conversion may be inaccurate. Consider using '#align ideal.map_infi_comap_of_surjective Ideal.map_infᵢ_comap_of_surjectiveₓ'. -/
theorem map_infᵢ_comap_of_surjective (K : ι → Ideal S) : (⨅ i, (K i).comap f).map f = infᵢ K :=
  (giMapComap f hf).l_infᵢ_u _
#align ideal.map_infi_comap_of_surjective Ideal.map_infᵢ_comap_of_surjective

/- warning: ideal.mem_image_of_mem_map_of_surjective -> Ideal.mem_image_of_mem_map_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f)) -> (forall {I : Ideal.{u1} R _inst_1} {y : S}, (Membership.Mem.{u2, u2} S (Ideal.{u2} S _inst_2) (SetLike.hasMem.{u2, u2} (Ideal.{u2} S _inst_2) S (Submodule.setLike.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2))) y (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I)) -> (Membership.Mem.{u2, u2} S (Set.{u2} S) (Set.hasMem.{u2} S) y (Set.image.{u1, u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R _inst_1) R (Submodule.setLike.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))))) I))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F), (Function.Surjective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f)) -> (forall {I : Ideal.{u2} R _inst_1} {y : S}, (Membership.mem.{u3, u3} S (Ideal.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (Ideal.{u3} S _inst_2) S (Submodule.setLike.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2))) y (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I)) -> (Membership.mem.{u3, u3} S (Set.{u3} S) (Set.instMembershipSet.{u3} S) y (Set.image.{u2, u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f) (SetLike.coe.{u2, u2} (Ideal.{u2} R _inst_1) R (Submodule.setLike.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) I))))
Case conversion may be inaccurate. Consider using '#align ideal.mem_image_of_mem_map_of_surjective Ideal.mem_image_of_mem_map_of_surjectiveₓ'. -/
theorem mem_image_of_mem_map_of_surjective {I : Ideal R} {y} (H : y ∈ map f I) : y ∈ f '' I :=
  Submodule.span_induction H (fun _ => id) ⟨0, I.zero_mem, map_zero f⟩
    (fun y1 y2 ⟨x1, hx1i, hxy1⟩ ⟨x2, hx2i, hxy2⟩ =>
      ⟨x1 + x2, I.add_mem hx1i hx2i, hxy1 ▸ hxy2 ▸ map_add f _ _⟩)
    fun c y ⟨x, hxi, hxy⟩ =>
    let ⟨d, hdc⟩ := hf c
    ⟨d * x, I.mul_mem_left _ hxi, hdc ▸ hxy ▸ map_mul f _ _⟩
#align ideal.mem_image_of_mem_map_of_surjective Ideal.mem_image_of_mem_map_of_surjective

/- warning: ideal.mem_map_iff_of_surjective -> Ideal.mem_map_iff_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f)) -> (forall {I : Ideal.{u1} R _inst_1} {y : S}, Iff (Membership.Mem.{u2, u2} S (Ideal.{u2} S _inst_2) (SetLike.hasMem.{u2, u2} (Ideal.{u2} S _inst_2) S (Submodule.setLike.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2))) y (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I)) (Exists.{succ u1} R (fun (x : R) => And (Membership.Mem.{u1, u1} R (Ideal.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R _inst_1) R (Submodule.setLike.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) x I) (Eq.{succ u2} S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f x) y))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F), (Function.Surjective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f)) -> (forall {I : Ideal.{u2} R _inst_1} {y : S}, Iff (Membership.mem.{u3, u3} S (Ideal.{u3} S _inst_2) (SetLike.instMembership.{u3, u3} (Ideal.{u3} S _inst_2) S (Submodule.setLike.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2))) y (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I)) (Exists.{succ u2} R (fun (x : R) => And (Membership.mem.{u2, u2} R (Ideal.{u2} R _inst_1) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R _inst_1) R (Submodule.setLike.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) x I) (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f x) y))))
Case conversion may be inaccurate. Consider using '#align ideal.mem_map_iff_of_surjective Ideal.mem_map_iff_of_surjectiveₓ'. -/
theorem mem_map_iff_of_surjective {I : Ideal R} {y} : y ∈ map f I ↔ ∃ x, x ∈ I ∧ f x = y :=
  ⟨fun h => (Set.mem_image _ _ _).2 (mem_image_of_mem_map_of_surjective f hf h), fun ⟨x, hx⟩ =>
    hx.right ▸ mem_map_of_mem f hx.left⟩
#align ideal.mem_map_iff_of_surjective Ideal.mem_map_iff_of_surjective

/- warning: ideal.le_map_of_comap_le_of_surjective -> Ideal.le_map_of_comap_le_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) {I : Ideal.{u1} R _inst_1} {K : Ideal.{u2} S _inst_2}, (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f)) -> (LE.le.{u1} (Ideal.{u1} R _inst_1) (Preorder.toLE.{u1} (Ideal.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f K) I) -> (LE.le.{u2} (Ideal.{u2} S _inst_2) (Preorder.toLE.{u2} (Ideal.{u2} S _inst_2) (PartialOrder.toPreorder.{u2} (Ideal.{u2} S _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u2} (Ideal.{u2} S _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Ideal.{u2} S _inst_2) (Submodule.completeLattice.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))))) K (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) {I : Ideal.{u2} R _inst_1} {K : Ideal.{u3} S _inst_2}, (Function.Surjective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f)) -> (LE.le.{u2} (Ideal.{u2} R _inst_1) (Preorder.toLE.{u2} (Ideal.{u2} R _inst_1) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R _inst_1) (Submodule.completeLattice.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))))) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f K) I) -> (LE.le.{u3} (Ideal.{u3} S _inst_2) (Preorder.toLE.{u3} (Ideal.{u3} S _inst_2) (PartialOrder.toPreorder.{u3} (Ideal.{u3} S _inst_2) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} S _inst_2) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} S _inst_2) (Submodule.completeLattice.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))))) K (Ideal.map.{u2, u3, u1} R S F _inst_1 _inst_2 rc f I))
Case conversion may be inaccurate. Consider using '#align ideal.le_map_of_comap_le_of_surjective Ideal.le_map_of_comap_le_of_surjectiveₓ'. -/
theorem le_map_of_comap_le_of_surjective : comap f K ≤ I → K ≤ map f I := fun h =>
  map_comap_of_surjective f hf K ▸ map_mono h
#align ideal.le_map_of_comap_le_of_surjective Ideal.le_map_of_comap_le_of_surjective

omit hf

/- warning: ideal.map_eq_submodule_map -> Ideal.map_eq_submodule_map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) [h : RingHomSurjective.{u1, u2} R S _inst_1 _inst_2 f] (I : Ideal.{u1} R _inst_1), Eq.{succ u2} (Ideal.{u2} S _inst_2) (Ideal.map.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) _inst_1 _inst_2 (RingHom.ringHomClass.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) f I) (Submodule.map.{u1, u2, u1, u2, max u1 u2} R S R S _inst_1 _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u1} R _inst_1) (Semiring.toModule.{u2} S _inst_2) f h (LinearMap.{u1, u2, u1, u2} R S _inst_1 _inst_2 f R S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u1} R _inst_1) (Semiring.toModule.{u2} S _inst_2)) (LinearMap.semilinearMapClass.{u1, u2, u1, u2} R S R S _inst_1 _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u1} R _inst_1) (Semiring.toModule.{u2} S _inst_2) f) (RingHom.toSemilinearMap.{u1, u2} R S _inst_1 _inst_2 f) I)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) [h : RingHomSurjective.{u1, u2} R S _inst_1 _inst_2 f] (I : Ideal.{u1} R _inst_1), Eq.{succ u2} (Ideal.{u2} S _inst_2) (Ideal.map.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) _inst_1 _inst_2 (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) f I) (Submodule.map.{u1, u2, u1, u2, max u1 u2} R S R S _inst_1 _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u1} R _inst_1) (Semiring.toModule.{u2} S _inst_2) f h (LinearMap.{u1, u2, u1, u2} R S _inst_1 _inst_2 f R S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u1} R _inst_1) (Semiring.toModule.{u2} S _inst_2)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u2, u1, u2} R S R S _inst_1 _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u1} R _inst_1) (Semiring.toModule.{u2} S _inst_2) f) (RingHom.toSemilinearMap.{u1, u2} R S _inst_1 _inst_2 f) I)
Case conversion may be inaccurate. Consider using '#align ideal.map_eq_submodule_map Ideal.map_eq_submodule_mapₓ'. -/
theorem map_eq_submodule_map (f : R →+* S) [h : RingHomSurjective f] (I : Ideal R) :
    I.map f = Submodule.map f.toSemilinearMap I :=
  Submodule.ext fun x => mem_map_iff_of_surjective f h.1
#align ideal.map_eq_submodule_map Ideal.map_eq_submodule_map

end Surjective

section Injective

variable (hf : Function.Injective f)

include hf

/- warning: ideal.comap_bot_le_of_injective -> Ideal.comap_bot_le_of_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) {I : Ideal.{u1} R _inst_1}, (Function.Injective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f)) -> (LE.le.{u1} (Ideal.{u1} R _inst_1) (Preorder.toLE.{u1} (Ideal.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Bot.bot.{u2} (Ideal.{u2} S _inst_2) (Submodule.hasBot.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))) I)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) {I : Ideal.{u2} R _inst_1}, (Function.Injective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f)) -> (LE.le.{u2} (Ideal.{u2} R _inst_1) (Preorder.toLE.{u2} (Ideal.{u2} R _inst_1) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R _inst_1) (Submodule.completeLattice.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))))) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Bot.bot.{u3} (Ideal.{u3} S _inst_2) (Submodule.instBotSubmodule.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))) I)
Case conversion may be inaccurate. Consider using '#align ideal.comap_bot_le_of_injective Ideal.comap_bot_le_of_injectiveₓ'. -/
theorem comap_bot_le_of_injective : comap f ⊥ ≤ I :=
  by
  refine' le_trans (fun x hx => _) bot_le
  rw [mem_comap, Submodule.mem_bot, ← map_zero f] at hx
  exact Eq.symm (hf hx) ▸ Submodule.zero_mem ⊥
#align ideal.comap_bot_le_of_injective Ideal.comap_bot_le_of_injective

/- warning: ideal.comap_bot_of_injective -> Ideal.comap_bot_of_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F), (Function.Injective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f)) -> (Eq.{succ u1} (Ideal.{u1} R _inst_1) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f (Bot.bot.{u2} (Ideal.{u2} S _inst_2) (Submodule.hasBot.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))) (Bot.bot.{u1} (Ideal.{u1} R _inst_1) (Submodule.hasBot.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F), (Function.Injective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f)) -> (Eq.{succ u2} (Ideal.{u2} R _inst_1) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f (Bot.bot.{u3} (Ideal.{u3} S _inst_2) (Submodule.instBotSubmodule.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2)))) (Bot.bot.{u2} (Ideal.{u2} R _inst_1) (Submodule.instBotSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align ideal.comap_bot_of_injective Ideal.comap_bot_of_injectiveₓ'. -/
theorem comap_bot_of_injective : Ideal.comap f ⊥ = ⊥ :=
  le_bot_iff.mp (Ideal.comap_bot_le_of_injective f hf)
#align ideal.comap_bot_of_injective Ideal.comap_bot_of_injective

end Injective

end Semiring

section Ring

variable {F : Type _} [Ring R] [Ring S]

variable [RingHomClass F R S] (f : F) {I : Ideal R}

section Surjective

variable (hf : Function.Surjective f)

include hf

/- warning: ideal.comap_map_of_surjective -> Ideal.comap_map_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] [_inst_3 : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))] (f : F), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) _inst_3)))) f)) -> (forall (I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)), Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.comap.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) _inst_3 f (Ideal.map.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) _inst_3 f I)) (Sup.sup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Lattice.toSemilatticeSup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (ConditionallyCompleteLattice.toLattice.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) I (Ideal.comap.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) _inst_3 f (Bot.bot.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.hasBot.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2)))))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : Ring.{u3} S] [_inst_3 : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))] (f : F), (Function.Surjective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)) _inst_3))) f)) -> (forall (I : Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)), Eq.{succ u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Ideal.comap.{u2, u3, u1} R S F (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S _inst_2) _inst_3 f (Ideal.map.{u2, u3, u1} R S F (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S _inst_2) _inst_3 f I)) (Sup.sup.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (SemilatticeSup.toSup.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Lattice.toSemilatticeSup.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (ConditionallyCompleteLattice.toLattice.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Submodule.completeLattice.{u2, u2} R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))))))) I (Ideal.comap.{u2, u3, u1} R S F (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S _inst_2) _inst_3 f (Bot.bot.{u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)) (Submodule.instBotSubmodule.{u3, u3} S S (Ring.toSemiring.{u3} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S _inst_2)))))))
Case conversion may be inaccurate. Consider using '#align ideal.comap_map_of_surjective Ideal.comap_map_of_surjectiveₓ'. -/
theorem comap_map_of_surjective (I : Ideal R) : comap f (map f I) = I ⊔ comap f ⊥ :=
  le_antisymm
    (fun r h =>
      let ⟨s, hsi, hfsr⟩ := mem_image_of_mem_map_of_surjective f hf h
      Submodule.mem_sup.2
        ⟨s, hsi, r - s, (Submodule.mem_bot S).2 <| by rw [map_sub, hfsr, sub_self],
          add_sub_cancel'_right s r⟩)
    (sup_le (map_le_iff_le_comap.1 le_rfl) (comap_mono bot_le))
#align ideal.comap_map_of_surjective Ideal.comap_map_of_surjective

/- warning: ideal.rel_iso_of_surjective -> Ideal.relIsoOfSurjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] [_inst_3 : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))] (f : F), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) _inst_3)))) f)) -> (OrderIso.{u2, u1} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Subtype.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (fun (p : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) => LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) (Ideal.comap.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) _inst_3 f (Bot.bot.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.hasBot.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))) p)) (Preorder.toLE.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (PartialOrder.toPreorder.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.completeLattice.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))))) (Subtype.hasLe.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) (fun (p : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) => LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) (Ideal.comap.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) _inst_3 f (Bot.bot.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.hasBot.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))) p)))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] [_inst_3 : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))] (f : F), (Function.Surjective.{succ u1, succ u2} R S (FunLike.coe.{succ u3, succ u1, succ u2} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u3, u1, u2} F R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) _inst_3))) f)) -> (OrderIso.{u2, u1} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Subtype.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (fun (p : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) => LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) (Ideal.comap.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) _inst_3 f (Bot.bot.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.instBotSubmodule.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))) p)) (Preorder.toLE.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (PartialOrder.toPreorder.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.completeLattice.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))))) (Subtype.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) (fun (p : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) => LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) (Ideal.comap.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) _inst_3 f (Bot.bot.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.instBotSubmodule.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))) p)))
Case conversion may be inaccurate. Consider using '#align ideal.rel_iso_of_surjective Ideal.relIsoOfSurjectiveₓ'. -/
/-- Correspondence theorem -/
def relIsoOfSurjective : Ideal S ≃o { p : Ideal R // comap f ⊥ ≤ p }
    where
  toFun J := ⟨comap f J, comap_mono bot_le⟩
  invFun I := map f I.1
  left_inv J := map_comap_of_surjective f hf J
  right_inv I :=
    Subtype.eq <|
      show comap f (map f I.1) = I.1 from
        (comap_map_of_surjective f hf I).symm ▸ le_antisymm (sup_le le_rfl I.2) le_sup_left
  map_rel_iff' I1 I2 :=
    ⟨fun H => map_comap_of_surjective f hf I1 ▸ map_comap_of_surjective f hf I2 ▸ map_mono H,
      comap_mono⟩
#align ideal.rel_iso_of_surjective Ideal.relIsoOfSurjective

#print Ideal.orderEmbeddingOfSurjective /-
/-- The map on ideals induced by a surjective map preserves inclusion. -/
def orderEmbeddingOfSurjective : Ideal S ↪o Ideal R :=
  (relIsoOfSurjective f hf).toRelEmbedding.trans (Subtype.relEmbedding _ _)
#align ideal.order_embedding_of_surjective Ideal.orderEmbeddingOfSurjective
-/

/- warning: ideal.map_eq_top_or_is_maximal_of_surjective -> Ideal.map_eq_top_or_isMaximal_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] [_inst_3 : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))] (f : F), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) _inst_3)))) f)) -> (forall {I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)}, (Ideal.IsMaximal.{u1} R (Ring.toSemiring.{u1} R _inst_1) I) -> (Or (Eq.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Ideal.map.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) _inst_3 f I) (Top.top.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.hasTop.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))) (Ideal.IsMaximal.{u2} S (Ring.toSemiring.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) _inst_3 f I))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : Ring.{u3} S] [_inst_3 : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))] (f : F), (Function.Surjective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)) _inst_3))) f)) -> (forall {I : Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)}, (Ideal.IsMaximal.{u2} R (Ring.toSemiring.{u2} R _inst_1) I) -> (Or (Eq.{succ u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)) (Ideal.map.{u2, u3, u1} R S F (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S _inst_2) _inst_3 f I) (Top.top.{u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)) (Submodule.instTopSubmodule.{u3, u3} S S (Ring.toSemiring.{u3} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S _inst_2))))) (Ideal.IsMaximal.{u3} S (Ring.toSemiring.{u3} S _inst_2) (Ideal.map.{u2, u3, u1} R S F (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S _inst_2) _inst_3 f I))))
Case conversion may be inaccurate. Consider using '#align ideal.map_eq_top_or_is_maximal_of_surjective Ideal.map_eq_top_or_isMaximal_of_surjectiveₓ'. -/
theorem map_eq_top_or_isMaximal_of_surjective {I : Ideal R} (H : IsMaximal I) :
    map f I = ⊤ ∨ IsMaximal (map f I) :=
  by
  refine' or_iff_not_imp_left.2 fun ne_top => ⟨⟨fun h => ne_top h, fun J hJ => _⟩⟩
  · refine'
      (rel_iso_of_surjective f hf).Injective
        (Subtype.ext_iff.2 (Eq.trans (H.1.2 (comap f J) (lt_of_le_of_ne _ _)) comap_top.symm))
    · exact map_le_iff_le_comap.1 (le_of_lt hJ)
    · exact fun h => hJ.right (le_map_of_comap_le_of_surjective f hf (le_of_eq h.symm))
#align ideal.map_eq_top_or_is_maximal_of_surjective Ideal.map_eq_top_or_isMaximal_of_surjective

/- warning: ideal.comap_is_maximal_of_surjective -> Ideal.comap_isMaximal_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] [_inst_3 : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))] (f : F), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) _inst_3)))) f)) -> (forall {K : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)} [H : Ideal.IsMaximal.{u2} S (Ring.toSemiring.{u2} S _inst_2) K], Ideal.IsMaximal.{u1} R (Ring.toSemiring.{u1} R _inst_1) (Ideal.comap.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) _inst_3 f K))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : Ring.{u3} S] [_inst_3 : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))] (f : F), (Function.Surjective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)) _inst_3))) f)) -> (forall {K : Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)} [H : Ideal.IsMaximal.{u3} S (Ring.toSemiring.{u3} S _inst_2) K], Ideal.IsMaximal.{u2} R (Ring.toSemiring.{u2} R _inst_1) (Ideal.comap.{u2, u3, u1} R S F (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S _inst_2) _inst_3 f K))
Case conversion may be inaccurate. Consider using '#align ideal.comap_is_maximal_of_surjective Ideal.comap_isMaximal_of_surjectiveₓ'. -/
theorem comap_isMaximal_of_surjective {K : Ideal S} [H : IsMaximal K] : IsMaximal (comap f K) :=
  by
  refine' ⟨⟨comap_ne_top _ H.1.1, fun J hJ => _⟩⟩
  suffices map f J = ⊤ by
    replace this := congr_arg (comap f) this
    rw [comap_top, comap_map_of_surjective _ hf, eq_top_iff] at this
    rw [eq_top_iff]
    exact le_trans this (sup_le (le_of_eq rfl) (le_trans (comap_mono bot_le) (le_of_lt hJ)))
  refine'
    H.1.2 (map f J)
      (lt_of_le_of_ne (le_map_of_comap_le_of_surjective _ hf (le_of_lt hJ)) fun h =>
        ne_of_lt hJ (trans (congr_arg (comap f) h) _))
  rw [comap_map_of_surjective _ hf, sup_eq_left]
  exact le_trans (comap_mono bot_le) (le_of_lt hJ)
#align ideal.comap_is_maximal_of_surjective Ideal.comap_isMaximal_of_surjective

/- warning: ideal.comap_le_comap_iff_of_surjective -> Ideal.comap_le_comap_iff_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] [_inst_3 : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))] (f : F), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) _inst_3)))) f)) -> (forall (I : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (J : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)), Iff (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) (Ideal.comap.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) _inst_3 f I) (Ideal.comap.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) _inst_3 f J)) (LE.le.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Preorder.toLE.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (PartialOrder.toPreorder.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.completeLattice.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))))) I J))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : Ring.{u3} S] [_inst_3 : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))] (f : F), (Function.Surjective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)) _inst_3))) f)) -> (forall (I : Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)) (J : Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)), Iff (LE.le.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Preorder.toLE.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Submodule.completeLattice.{u2, u2} R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))))))) (Ideal.comap.{u2, u3, u1} R S F (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S _inst_2) _inst_3 f I) (Ideal.comap.{u2, u3, u1} R S F (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S _inst_2) _inst_3 f J)) (LE.le.{u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)) (Preorder.toLE.{u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)) (Submodule.completeLattice.{u3, u3} S S (Ring.toSemiring.{u3} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S _inst_2))))))) I J))
Case conversion may be inaccurate. Consider using '#align ideal.comap_le_comap_iff_of_surjective Ideal.comap_le_comap_iff_of_surjectiveₓ'. -/
theorem comap_le_comap_iff_of_surjective (I J : Ideal S) : comap f I ≤ comap f J ↔ I ≤ J :=
  ⟨fun h => (map_comap_of_surjective f hf I).symm.le.trans (map_le_of_le_comap h), fun h =>
    le_comap_of_map_le ((map_comap_of_surjective f hf I).le.trans h)⟩
#align ideal.comap_le_comap_iff_of_surjective Ideal.comap_le_comap_iff_of_surjective

end Surjective

/- warning: ideal.map_of_equiv -> Ideal.map_of_equiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))), Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.map.{u2, u1, max u2 u1} S R (RingHom.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Ring.toSemiring.{u2} S _inst_2) (Ring.toSemiring.{u1} R _inst_1) (RingHom.ringHomClass.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u2) (succ u1), max (succ u2) (succ u1)} a b] => self.0) (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1))) (RingHom.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (HasLiftT.mk.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1))) (RingHom.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (CoeTCₓ.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1))) (RingHom.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (RingHom.hasCoeT.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1))) S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1))) S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (RingEquiv.ringEquivClass.{u2, u1} S R (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1))))))) (RingEquiv.symm.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) f)) (Ideal.map.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) (RingHom.ringHomClass.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))) (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))) (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))) (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))) R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))) R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))))))) f) I)) I
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (f : RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2)))))), Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.map.{u2, u1, max u1 u2} S R (RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Ring.toSemiring.{u2} S _inst_2) (Ring.toSemiring.{u1} R _inst_1) (RingHom.instRingHomClassRingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHomClass.toRingHom.{max u1 u2, u2, u1} (RingEquiv.{u2, u1} S R (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)))))) S R (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (RingEquivClass.toRingHomClass.{max u1 u2, u2, u1} (RingEquiv.{u2, u1} S R (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)))))) S R (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} S R (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))))) (RingEquiv.symm.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))))) f)) (Ideal.map.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (RingHomClass.toRingHom.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2)))))) R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2)))))) R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))))))) f) I)) I
Case conversion may be inaccurate. Consider using '#align ideal.map_of_equiv Ideal.map_of_equivₓ'. -/
/-- If `f : R ≃+* S` is a ring isomorphism and `I : ideal R`, then `map f (map f.symm) = I`. -/
@[simp]
theorem map_of_equiv (I : Ideal R) (f : R ≃+* S) :
    (I.map (f : R →+* S)).map (f.symm : S →+* R) = I := by
  simp [← RingEquiv.toRingHom_eq_coe, map_map]
#align ideal.map_of_equiv Ideal.map_of_equiv

/- warning: ideal.comap_of_equiv -> Ideal.comap_of_equiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))), Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.comap.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) (RingHom.ringHomClass.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))) (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))) (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))) (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))) R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))) R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))))))) f) (Ideal.comap.{u2, u1, max u2 u1} S R (RingHom.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Ring.toSemiring.{u2} S _inst_2) (Ring.toSemiring.{u1} R _inst_1) (RingHom.ringHomClass.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u2) (succ u1), max (succ u2) (succ u1)} a b] => self.0) (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1))) (RingHom.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (HasLiftT.mk.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1))) (RingHom.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (CoeTCₓ.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1))) (RingHom.{u2, u1} S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (RingHom.hasCoeT.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1))) S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1))) S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (RingEquiv.ringEquivClass.{u2, u1} S R (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1))))))) (RingEquiv.symm.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) f)) I)) I
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (f : RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2)))))), Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.comap.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (RingHomClass.toRingHom.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2)))))) R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2)))))) R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))))))) f) (Ideal.comap.{u2, u1, max u1 u2} S R (RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Ring.toSemiring.{u2} S _inst_2) (Ring.toSemiring.{u1} R _inst_1) (RingHom.instRingHomClassRingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHomClass.toRingHom.{max u1 u2, u2, u1} (RingEquiv.{u2, u1} S R (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)))))) S R (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (RingEquivClass.toRingHomClass.{max u1 u2, u2, u1} (RingEquiv.{u2, u1} S R (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)))))) S R (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} S R (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))))) (RingEquiv.symm.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))))) f)) I)) I
Case conversion may be inaccurate. Consider using '#align ideal.comap_of_equiv Ideal.comap_of_equivₓ'. -/
/-- If `f : R ≃+* S` is a ring isomorphism and `I : ideal R`, then `comap f.symm (comap f) = I`. -/
@[simp]
theorem comap_of_equiv (I : Ideal R) (f : R ≃+* S) :
    (I.comap (f.symm : S →+* R)).comap (f : R →+* S) = I := by
  simp [← RingEquiv.toRingHom_eq_coe, comap_comap]
#align ideal.comap_of_equiv Ideal.comap_of_equiv

/- warning: ideal.map_comap_of_equiv -> Ideal.map_comap_of_equiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))), Eq.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Ideal.map.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) (RingHom.ringHomClass.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))) (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))) (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))) (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))) R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))) R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))))))) f) I) (Ideal.comap.{u2, u1, max u2 u1} S R (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1))) (Ring.toSemiring.{u2} S _inst_2) (Ring.toSemiring.{u1} R _inst_1) (RingEquivClass.toRingHomClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} S R (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1))) S R (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (RingEquiv.ringEquivClass.{u2, u1} S R (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)))) (RingEquiv.symm.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2)) f) I)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (f : RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2)))))), Eq.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Ideal.map.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (RingHomClass.toRingHom.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2)))))) R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2)))))) R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))))))) f) I) (Ideal.comap.{u2, u1, max u1 u2} S R (RingEquiv.{u2, u1} S R (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)))))) (Ring.toSemiring.{u2} S _inst_2) (Ring.toSemiring.{u1} R _inst_1) (RingEquivClass.toRingHomClass.{max u1 u2, u2, u1} (RingEquiv.{u2, u1} S R (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)))))) S R (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} S R (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))))) (RingEquiv.symm.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))))) f) I)
Case conversion may be inaccurate. Consider using '#align ideal.map_comap_of_equiv Ideal.map_comap_of_equivₓ'. -/
/-- If `f : R ≃+* S` is a ring isomorphism and `I : ideal R`, then `map f I = comap f.symm I`. -/
theorem map_comap_of_equiv (I : Ideal R) (f : R ≃+* S) : I.map (f : R →+* S) = I.comap f.symm :=
  le_antisymm (le_comap_of_map_le (map_of_equiv I f).le)
    (le_map_of_comap_le_of_surjective _ f.Surjective (comap_of_equiv I f).le)
#align ideal.map_comap_of_equiv Ideal.map_comap_of_equiv

section Bijective

variable (hf : Function.Bijective f)

include hf

#print Ideal.relIsoOfBijective /-
/-- Special case of the correspondence theorem for isomorphic rings -/
def relIsoOfBijective : Ideal S ≃o Ideal R
    where
  toFun := comap f
  invFun := map f
  left_inv := (relIsoOfSurjective f hf.right).left_inv
  right_inv J :=
    Subtype.ext_iff.1
      ((relIsoOfSurjective f hf.right).right_inv ⟨J, comap_bot_le_of_injective f hf.left⟩)
  map_rel_iff' _ _ := (relIsoOfSurjective f hf.right).map_rel_iff'
#align ideal.rel_iso_of_bijective Ideal.relIsoOfBijective
-/

/- warning: ideal.comap_le_iff_le_map -> Ideal.comap_le_iff_le_map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] [_inst_3 : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))] (f : F), (Function.Bijective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) _inst_3)))) f)) -> (forall {I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)} {K : Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)}, Iff (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) (Ideal.comap.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) _inst_3 f K) I) (LE.le.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Preorder.toLE.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (PartialOrder.toPreorder.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.completeLattice.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))))) K (Ideal.map.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) _inst_3 f I)))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : Ring.{u3} S] [_inst_3 : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))] (f : F), (Function.Bijective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)) _inst_3))) f)) -> (forall {I : Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)} {K : Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)}, Iff (LE.le.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Preorder.toLE.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Submodule.completeLattice.{u2, u2} R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))))))) (Ideal.comap.{u2, u3, u1} R S F (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S _inst_2) _inst_3 f K) I) (LE.le.{u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)) (Preorder.toLE.{u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S _inst_2)) (Submodule.completeLattice.{u3, u3} S S (Ring.toSemiring.{u3} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S _inst_2))))))) K (Ideal.map.{u2, u3, u1} R S F (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S _inst_2) _inst_3 f I)))
Case conversion may be inaccurate. Consider using '#align ideal.comap_le_iff_le_map Ideal.comap_le_iff_le_mapₓ'. -/
theorem comap_le_iff_le_map {I : Ideal R} {K : Ideal S} : comap f K ≤ I ↔ K ≤ map f I :=
  ⟨fun h => le_map_of_comap_le_of_surjective f hf.right h, fun h =>
    (relIsoOfBijective f hf).right_inv I ▸ comap_mono h⟩
#align ideal.comap_le_iff_le_map Ideal.comap_le_iff_le_map

/- warning: ideal.map.is_maximal -> Ideal.map.isMaximal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] [_inst_3 : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))] (f : F), (Function.Bijective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) _inst_3)))) f)) -> (forall {I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)}, (Ideal.IsMaximal.{u1} R (Ring.toSemiring.{u1} R _inst_1) I) -> (Ideal.IsMaximal.{u2} S (Ring.toSemiring.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) _inst_3 f I)))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : Ring.{u3} S] [_inst_3 : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))] (f : F), (Function.Bijective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)) _inst_3))) f)) -> (forall {I : Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)}, (Ideal.IsMaximal.{u2} R (Ring.toSemiring.{u2} R _inst_1) I) -> (Ideal.IsMaximal.{u3} S (Ring.toSemiring.{u3} S _inst_2) (Ideal.map.{u2, u3, u1} R S F (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S _inst_2) _inst_3 f I)))
Case conversion may be inaccurate. Consider using '#align ideal.map.is_maximal Ideal.map.isMaximalₓ'. -/
theorem map.isMaximal {I : Ideal R} (H : IsMaximal I) : IsMaximal (map f I) := by
  refine'
      or_iff_not_imp_left.1 (map_eq_top_or_is_maximal_of_surjective f hf.right H) fun h =>
        H.1.1 _ <;>
    calc
      I = comap f (map f I) := ((rel_iso_of_bijective f hf).right_inv I).symm
      _ = comap f ⊤ := by rw [h]
      _ = ⊤ := by rw [comap_top]
      
#align ideal.map.is_maximal Ideal.map.isMaximal

end Bijective

/- warning: ideal.ring_equiv.bot_maximal_iff -> Ideal.RingEquiv.bot_maximal_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S], (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))) -> (Iff (Ideal.IsMaximal.{u1} R (Ring.toSemiring.{u1} R _inst_1) (Bot.bot.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.hasBot.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Ideal.IsMaximal.{u2} S (Ring.toSemiring.{u2} S _inst_2) (Bot.bot.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.hasBot.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S], (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocRing.toMul.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonUnitalRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonUnitalRing.{u2} S _inst_2)))))) -> (Iff (Ideal.IsMaximal.{u1} R (Ring.toSemiring.{u1} R _inst_1) (Bot.bot.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.instBotSubmodule.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Ideal.IsMaximal.{u2} S (Ring.toSemiring.{u2} S _inst_2) (Bot.bot.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.instBotSubmodule.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))))
Case conversion may be inaccurate. Consider using '#align ideal.ring_equiv.bot_maximal_iff Ideal.RingEquiv.bot_maximal_iffₓ'. -/
theorem RingEquiv.bot_maximal_iff (e : R ≃+* S) :
    (⊥ : Ideal R).IsMaximal ↔ (⊥ : Ideal S).IsMaximal :=
  ⟨fun h => @map_bot _ _ _ _ _ _ e.toRingHom ▸ map.isMaximal e.toRingHom e.Bijective h, fun h =>
    @map_bot _ _ _ _ _ _ e.symm.toRingHom ▸ map.isMaximal e.symm.toRingHom e.symm.Bijective h⟩
#align ideal.ring_equiv.bot_maximal_iff Ideal.RingEquiv.bot_maximal_iff

end Ring

section CommRing

variable {F : Type _} [CommRing R] [CommRing S]

variable [rc : RingHomClass F R S]

variable (f : F)

variable {I J : Ideal R} {K L : Ideal S}

variable (I J K L)

include rc

/- warning: ideal.map_mul -> Ideal.map_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))] (f : F) (I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (J : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), Eq.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Ideal.map.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) rc f (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHMul.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ideal.hasMul.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) I J)) (HMul.hMul.{u2, u2, u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (instHMul.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Ideal.hasMul.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (Ideal.map.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) rc f I) (Ideal.map.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) rc f J))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))] (f : F) (I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (J : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))), Eq.{succ u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.map.{u2, u3, u1} R S F (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) rc f (HMul.hMul.{u2, u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (instHMul.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instMulIdealToSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) I J)) (HMul.hMul.{u3, u3, u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (instHMul.{u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.instMulIdealToSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.map.{u2, u3, u1} R S F (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) rc f I) (Ideal.map.{u2, u3, u1} R S F (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) rc f J))
Case conversion may be inaccurate. Consider using '#align ideal.map_mul Ideal.map_mulₓ'. -/
theorem map_mul : map f (I * J) = map f I * map f J :=
  le_antisymm
    (map_le_iff_le_comap.2 <|
      mul_le.2 fun r hri s hsj =>
        show f (r * s) ∈ _ by
          rw [map_mul] <;> exact mul_mem_mul (mem_map_of_mem f hri) (mem_map_of_mem f hsj))
    (trans_rel_right _ (span_mul_span _ _) <|
      span_le.2 <|
        Set.unionᵢ₂_subset fun i ⟨r, hri, hfri⟩ =>
          Set.unionᵢ₂_subset fun j ⟨s, hsj, hfsj⟩ =>
            Set.singleton_subset_iff.2 <|
              hfri ▸ hfsj ▸ by rw [← map_mul] <;> exact mem_map_of_mem f (mul_mem_mul hri hsj))
#align ideal.map_mul Ideal.map_mul

#print Ideal.mapHom /-
/-- The pushforward `ideal.map` as a monoid-with-zero homomorphism. -/
@[simps]
def mapHom : Ideal R →*₀ Ideal S where
  toFun := map f
  map_mul' I J := Ideal.map_mul f I J
  map_one' := by convert Ideal.map_top f <;> exact one_eq_top
  map_zero' := Ideal.map_bot
#align ideal.map_hom Ideal.mapHom
-/

/- warning: ideal.map_pow -> Ideal.map_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))] (f : F) (I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (n : Nat), Eq.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Ideal.map.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) rc f (HPow.hPow.{u1, 0, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.idemSemiring.{u1, u1} R (CommRing.toCommSemiring.{u1} R _inst_1) R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) I n)) (HPow.hPow.{u2, 0, u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) Nat (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (instHPow.{u2, 0} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) Nat (Monoid.Pow.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (MonoidWithZero.toMonoid.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Semiring.toMonoidWithZero.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (IdemSemiring.toSemiring.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Submodule.idemSemiring.{u2, u2} S (CommRing.toCommSemiring.{u2} S _inst_2) S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Algebra.id.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))))))) (Ideal.map.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) rc f I) n)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))] (f : F) (I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (n : Nat), Eq.{succ u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.map.{u2, u3, u1} R S F (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) rc f (HPow.hPow.{u2, 0, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) Nat (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (instHPow.{u2, 0} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) Nat (Monoid.Pow.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (MonoidWithZero.toMonoid.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toMonoidWithZero.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (IdemSemiring.toSemiring.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Submodule.idemSemiring.{u2, u2} R (CommRing.toCommSemiring.{u2} R _inst_1) R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))))) I n)) (HPow.hPow.{u3, 0, u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) Nat (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (instHPow.{u3, 0} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) Nat (Monoid.Pow.{u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (MonoidWithZero.toMonoid.{u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Semiring.toMonoidWithZero.{u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (IdemSemiring.toSemiring.{u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Submodule.idemSemiring.{u3, u3} S (CommRing.toCommSemiring.{u3} S _inst_2) S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Algebra.id.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))))))) (Ideal.map.{u2, u3, u1} R S F (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) rc f I) n)
Case conversion may be inaccurate. Consider using '#align ideal.map_pow Ideal.map_powₓ'. -/
protected theorem map_pow (n : ℕ) : map f (I ^ n) = map f I ^ n :=
  map_pow (mapHom f) I n
#align ideal.map_pow Ideal.map_pow

/- warning: ideal.comap_radical -> Ideal.comap_radical is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))] (f : F) (K : Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Ideal.comap.{u1, u2, u3} R S F (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)) rc f (Ideal.radical.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2) K)) (Ideal.radical.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (Ideal.comap.{u1, u2, u3} R S F (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) rc f K))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))] (f : F) (K : Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))), Eq.{succ u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.comap.{u2, u3, u1} R S F (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) rc f (Ideal.radical.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2) K)) (Ideal.radical.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1) (Ideal.comap.{u2, u3, u1} R S F (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) rc f K))
Case conversion may be inaccurate. Consider using '#align ideal.comap_radical Ideal.comap_radicalₓ'. -/
theorem comap_radical : comap f (radical K) = radical (comap f K) :=
  by
  ext
  simpa only [radical, mem_comap, map_pow]
#align ideal.comap_radical Ideal.comap_radical

variable {K}

/- warning: ideal.is_radical.comap -> Ideal.IsRadical.comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))] (f : F) {K : Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))}, (Ideal.IsRadical.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2) K) -> (Ideal.IsRadical.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (Ideal.comap.{u1, u2, u3} R S F (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) rc f K))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))] (f : F) {K : Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))}, (Ideal.IsRadical.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2) K) -> (Ideal.IsRadical.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1) (Ideal.comap.{u2, u3, u1} R S F (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) rc f K))
Case conversion may be inaccurate. Consider using '#align ideal.is_radical.comap Ideal.IsRadical.comapₓ'. -/
theorem IsRadical.comap (hK : K.IsRadical) : (comap f K).IsRadical :=
  by
  rw [← hK.radical, comap_radical]
  apply radical_is_radical
#align ideal.is_radical.comap Ideal.IsRadical.comap

variable {I J L}

/- warning: ideal.map_radical_le -> Ideal.map_radical_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))] (f : F) {I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, LE.le.{u2} (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (Preorder.toLE.{u2} (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (CompleteSemilatticeInf.toPartialOrder.{u2} (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (Submodule.completeLattice.{u2, u2} S S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))) (Semiring.toModule.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))))))) (Ideal.map.{u1, u2, u3} R S F (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)) rc f (Ideal.radical.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) I)) (Ideal.radical.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)) rc f I))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))] (f : F) {I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))}, LE.le.{u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Preorder.toLE.{u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (PartialOrder.toPreorder.{u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Submodule.completeLattice.{u3, u3} S S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))))))) (Ideal.map.{u2, u3, u1} R S F (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) rc f (Ideal.radical.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1) I)) (Ideal.radical.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2) (Ideal.map.{u2, u3, u1} R S F (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) rc f I))
Case conversion may be inaccurate. Consider using '#align ideal.map_radical_le Ideal.map_radical_leₓ'. -/
theorem map_radical_le : map f (radical I) ≤ radical (map f I) :=
  map_le_iff_le_comap.2 fun r ⟨n, hrni⟩ => ⟨n, map_pow f r n ▸ mem_map_of_mem f hrni⟩
#align ideal.map_radical_le Ideal.map_radical_le

/- warning: ideal.le_comap_mul -> Ideal.le_comap_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))] (f : F) {K : Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))} {L : Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))}, LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHMul.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ideal.hasMul.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Ideal.comap.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) rc f K) (Ideal.comap.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) rc f L)) (Ideal.comap.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) rc f (HMul.hMul.{u2, u2, u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (instHMul.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Ideal.hasMul.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) K L))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))] (f : F) {K : Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))} {L : Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))}, LE.le.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Preorder.toLE.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))))) (HMul.hMul.{u2, u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (instHMul.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instMulIdealToSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.comap.{u2, u3, u1} R S F (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) rc f K) (Ideal.comap.{u2, u3, u1} R S F (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) rc f L)) (Ideal.comap.{u2, u3, u1} R S F (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) rc f (HMul.hMul.{u3, u3, u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (instHMul.{u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.instMulIdealToSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) K L))
Case conversion may be inaccurate. Consider using '#align ideal.le_comap_mul Ideal.le_comap_mulₓ'. -/
theorem le_comap_mul : comap f K * comap f L ≤ comap f (K * L) :=
  map_le_iff_le_comap.1 <|
    (map_mul f (comap f K) (comap f L)).symm ▸
      mul_mono (map_le_iff_le_comap.2 <| le_rfl) (map_le_iff_le_comap.2 <| le_rfl)
#align ideal.le_comap_mul Ideal.le_comap_mul

/- warning: ideal.le_comap_pow -> Ideal.le_comap_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))] (f : F) {K : Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))} (n : Nat), LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (HPow.hPow.{u1, 0, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.idemSemiring.{u1, u1} R (CommRing.toCommSemiring.{u1} R _inst_1) R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) (Ideal.comap.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) rc f K) n) (Ideal.comap.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) rc f (HPow.hPow.{u2, 0, u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) Nat (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (instHPow.{u2, 0} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) Nat (Monoid.Pow.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (MonoidWithZero.toMonoid.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Semiring.toMonoidWithZero.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (IdemSemiring.toSemiring.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Submodule.idemSemiring.{u2, u2} S (CommRing.toCommSemiring.{u2} S _inst_2) S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Algebra.id.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))))))) K n))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))] (f : F) {K : Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))} (n : Nat), LE.le.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Preorder.toLE.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))))) (HPow.hPow.{u2, 0, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) Nat (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (instHPow.{u2, 0} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) Nat (Monoid.Pow.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (MonoidWithZero.toMonoid.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toMonoidWithZero.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (IdemSemiring.toSemiring.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Submodule.idemSemiring.{u2, u2} R (CommRing.toCommSemiring.{u2} R _inst_1) R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))))) (Ideal.comap.{u2, u3, u1} R S F (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) rc f K) n) (Ideal.comap.{u2, u3, u1} R S F (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) rc f (HPow.hPow.{u3, 0, u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) Nat (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (instHPow.{u3, 0} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) Nat (Monoid.Pow.{u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (MonoidWithZero.toMonoid.{u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Semiring.toMonoidWithZero.{u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (IdemSemiring.toSemiring.{u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Submodule.idemSemiring.{u3, u3} S (CommRing.toCommSemiring.{u3} S _inst_2) S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Algebra.id.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))))))) K n))
Case conversion may be inaccurate. Consider using '#align ideal.le_comap_pow Ideal.le_comap_powₓ'. -/
theorem le_comap_pow (n : ℕ) : K.comap f ^ n ≤ (K ^ n).comap f :=
  by
  induction n
  · rw [pow_zero, pow_zero, Ideal.one_eq_top, Ideal.one_eq_top]
    exact rfl.le
  · rw [pow_succ, pow_succ]
    exact (Ideal.mul_mono_right n_ih).trans (Ideal.le_comap_mul f)
#align ideal.le_comap_pow Ideal.le_comap_pow

omit rc

end CommRing

end MapAndComap

section IsPrimary

variable {R : Type u} [CommSemiring R]

#print Ideal.IsPrimary /-
/-- A proper ideal `I` is primary iff `xy ∈ I` implies `x ∈ I` or `y ∈ radical I`. -/
def IsPrimary (I : Ideal R) : Prop :=
  I ≠ ⊤ ∧ ∀ {x y : R}, x * y ∈ I → x ∈ I ∨ y ∈ radical I
#align ideal.is_primary Ideal.IsPrimary
-/

#print Ideal.IsPrime.isPrimary /-
theorem IsPrime.isPrimary {I : Ideal R} (hi : IsPrime I) : IsPrimary I :=
  ⟨hi.1, fun x y hxy => (hi.mem_or_mem hxy).imp id fun hyi => le_radical hyi⟩
#align ideal.is_prime.is_primary Ideal.IsPrime.isPrimary
-/

#print Ideal.mem_radical_of_pow_mem /-
theorem mem_radical_of_pow_mem {I : Ideal R} {x : R} {m : ℕ} (hx : x ^ m ∈ radical I) :
    x ∈ radical I :=
  radical_idem I ▸ ⟨m, hx⟩
#align ideal.mem_radical_of_pow_mem Ideal.mem_radical_of_pow_mem
-/

#print Ideal.isPrime_radical /-
theorem isPrime_radical {I : Ideal R} (hi : IsPrimary I) : IsPrime (radical I) :=
  ⟨mt radical_eq_top.1 hi.1, fun x y ⟨m, hxy⟩ =>
    by
    rw [mul_pow] at hxy; cases hi.2 hxy
    · exact Or.inl ⟨m, h⟩
    · exact Or.inr (mem_radical_of_pow_mem h)⟩
#align ideal.is_prime_radical Ideal.isPrime_radical
-/

#print Ideal.isPrimary_inf /-
theorem isPrimary_inf {I J : Ideal R} (hi : IsPrimary I) (hj : IsPrimary J)
    (hij : radical I = radical J) : IsPrimary (I ⊓ J) :=
  ⟨ne_of_lt <| lt_of_le_of_lt inf_le_left (lt_top_iff_ne_top.2 hi.1), fun x y ⟨hxyi, hxyj⟩ =>
    by
    rw [radical_inf, hij, inf_idem]
    cases' hi.2 hxyi with hxi hyi; cases' hj.2 hxyj with hxj hyj
    · exact Or.inl ⟨hxi, hxj⟩
    · exact Or.inr hyj
    · rw [hij] at hyi
      exact Or.inr hyi⟩
#align ideal.is_primary_inf Ideal.isPrimary_inf
-/

end IsPrimary

section Total

variable (ι : Type _)

variable (M : Type _) [AddCommGroup M] {R : Type _} [CommRing R] [Module R M] (I : Ideal R)

variable (v : ι → M) (hv : Submodule.span R (Set.range v) = ⊤)

open BigOperators

#print Ideal.finsuppTotal /-
/-- A variant of `finsupp.total` that takes in vectors valued in `I`. -/
noncomputable def finsuppTotal : (ι →₀ I) →ₗ[R] M :=
  (Finsupp.total ι M R v).comp (Finsupp.mapRange.linearMap I.Subtype)
#align ideal.finsupp_total Ideal.finsuppTotal
-/

variable {ι M v}

/- warning: ideal.finsupp_total_apply -> Ideal.finsuppTotal_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommGroup.{u2} M] {R : Type.{u3}} [_inst_2 : CommRing.{u3} R] [_inst_3 : Module.{u3, u2} R M (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1)] (I : Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) {v : ι -> M} (f : Finsupp.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)), Eq.{succ u2} M (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)))) (Finsupp.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) M (Finsupp.addCommMonoid.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (Finsupp.module.{u1, u3, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I) (Submodule.module.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) _inst_3) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)))) (Finsupp.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) M (Finsupp.addCommMonoid.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (Finsupp.module.{u1, u3, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I) (Submodule.module.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) _inst_3) => (Finsupp.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) M (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Finsupp.addCommMonoid.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (Finsupp.module.{u1, u3, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I) (Submodule.module.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Ideal.finsuppTotal.{u1, u2, u3} ι M _inst_1 R _inst_2 _inst_3 I v) f) (Finsupp.sum.{u1, u3, u2} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) M (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) f (fun (i : ι) (x : coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) => SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_1)))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_1)))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_1)))) (Module.toMulActionWithZero.{u3, u2} R M (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) _inst_3)))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (coeSubtype.{succ u3} R (fun (x : R) => Membership.Mem.{u3, u3} R (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) (SetLike.hasMem.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) x I))))) x) (v i)))
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M] {R : Type.{u2}} [_inst_2 : CommRing.{u2} R] [_inst_3 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)] (I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) {v : ι -> M} (f : Finsupp.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) => M) f) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u2), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))) (Finsupp.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) M (Finsupp.addCommMonoid.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.addCommMonoid.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (Finsupp.module.{u3, u2, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Submodule.addCommMonoid.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I) (Submodule.module.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) _inst_3) (Finsupp.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) (fun (_x : Finsupp.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Finsupp.addCommMonoid.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.addCommMonoid.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (Finsupp.module.{u3, u2, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Submodule.addCommMonoid.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I) (Submodule.module.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) _inst_3 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Ideal.finsuppTotal.{u3, u1, u2} ι M _inst_1 R _inst_2 _inst_3 I v) f) (Finsupp.sum.{u3, u2, u1} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) M (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) f (fun (i : ι) (x : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) => HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_1))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_1))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_1))))) (Module.toMulActionWithZero.{u2, u1} R M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) _inst_3))))) (Subtype.val.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) x (SetLike.coe.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))) I)) x) (v i)))
Case conversion may be inaccurate. Consider using '#align ideal.finsupp_total_apply Ideal.finsuppTotal_applyₓ'. -/
theorem finsuppTotal_apply (f : ι →₀ I) : finsuppTotal ι M I v f = f.Sum fun i x => (x : R) • v i :=
  by
  dsimp [finsupp_total]
  rw [Finsupp.total_apply, Finsupp.sum_mapRange_index]
  exact fun _ => zero_smul _ _
#align ideal.finsupp_total_apply Ideal.finsuppTotal_apply

/- warning: ideal.finsupp_total_apply_eq_of_fintype -> Ideal.finsuppTotal_apply_eq_of_fintype is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommGroup.{u2} M] {R : Type.{u3}} [_inst_2 : CommRing.{u3} R] [_inst_3 : Module.{u3, u2} R M (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1)] (I : Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) {v : ι -> M} [_inst_4 : Fintype.{u1} ι] (f : Finsupp.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)), Eq.{succ u2} M (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)))) (Finsupp.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) M (Finsupp.addCommMonoid.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (Finsupp.module.{u1, u3, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I) (Submodule.module.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) _inst_3) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)))) (Finsupp.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) M (Finsupp.addCommMonoid.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (Finsupp.module.{u1, u3, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I) (Submodule.module.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) _inst_3) => (Finsupp.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) M (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Finsupp.addCommMonoid.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (Finsupp.module.{u1, u3, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I) (Submodule.module.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Ideal.finsuppTotal.{u1, u2, u3} ι M _inst_1 R _inst_2 _inst_3 I v) f) (Finset.sum.{u2, u1} M ι (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (Finset.univ.{u1} ι _inst_4) (fun (i : ι) => SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_1)))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_1)))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_1)))) (Module.toMulActionWithZero.{u3, u2} R M (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) _inst_3)))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (coeSubtype.{succ u3} R (fun (x : R) => Membership.Mem.{u3, u3} R (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) (SetLike.hasMem.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) x I))))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) (fun (_x : Finsupp.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) => ι -> (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I)) (Finsupp.coeFun.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) f i)) (v i)))
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u1}} [_inst_1 : AddCommGroup.{u1} M] {R : Type.{u2}} [_inst_2 : CommRing.{u2} R] [_inst_3 : Module.{u2, u1} R M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1)] (I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) {v : ι -> M} [_inst_4 : Fintype.{u3} ι] (f : Finsupp.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) => M) f) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u2), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))) (Finsupp.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) M (Finsupp.addCommMonoid.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.addCommMonoid.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (Finsupp.module.{u3, u2, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Submodule.addCommMonoid.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I) (Submodule.module.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) _inst_3) (Finsupp.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) (fun (_x : Finsupp.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Finsupp.addCommMonoid.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.addCommMonoid.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (Finsupp.module.{u3, u2, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Submodule.addCommMonoid.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I) (Submodule.module.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) _inst_3 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Ideal.finsuppTotal.{u3, u1, u2} ι M _inst_1 R _inst_2 _inst_3 I v) f) (Finset.sum.{u1, u3} M ι (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) (Finset.univ.{u3} ι _inst_4) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_1))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_1))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_1))))) (Module.toMulActionWithZero.{u2, u1} R M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_1) _inst_3))))) (Subtype.val.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) x (SetLike.coe.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))) I)) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) _x) (Finsupp.funLike.{u3, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) f i)) (v i)))
Case conversion may be inaccurate. Consider using '#align ideal.finsupp_total_apply_eq_of_fintype Ideal.finsuppTotal_apply_eq_of_fintypeₓ'. -/
theorem finsuppTotal_apply_eq_of_fintype [Fintype ι] (f : ι →₀ I) :
    finsuppTotal ι M I v f = ∑ i, (f i : R) • v i :=
  by
  rw [finsupp_total_apply, Finsupp.sum_fintype]
  exact fun _ => zero_smul _ _
#align ideal.finsupp_total_apply_eq_of_fintype Ideal.finsuppTotal_apply_eq_of_fintype

/- warning: ideal.range_finsupp_total -> Ideal.range_finsuppTotal is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommGroup.{u2} M] {R : Type.{u3}} [_inst_2 : CommRing.{u3} R] [_inst_3 : Module.{u3, u2} R M (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1)] (I : Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) {v : ι -> M}, Eq.{succ u2} (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) _inst_3) (LinearMap.range.{u3, u3, max u1 u3, u2, max (max u1 u3) u2} R R (Finsupp.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) M (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Finsupp.addCommMonoid.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (Finsupp.module.{u1, u3, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I) (Submodule.module.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)))) (LinearMap.{u3, u3, max u1 u3, u2} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)))) (Finsupp.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) M (Finsupp.addCommMonoid.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (Finsupp.module.{u1, u3, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I) (Submodule.module.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) _inst_3) (LinearMap.semilinearMapClass.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.zero.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) M (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Finsupp.addCommMonoid.{u1, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) (Finsupp.module.{u1, u3, u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) R (Submodule.setLike.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) I) R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Submodule.addCommMonoid.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I) (Submodule.module.{u3, u3} R R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) I)) _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))))) (RingHomSurjective.ids.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) (Ideal.finsuppTotal.{u1, u2, u3} ι M _inst_1 R _inst_2 _inst_3 I v)) (SMul.smul.{u3, u2} (Ideal.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2))) (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) _inst_3) (Submodule.hasSmul'.{u3, u2} R M (CommRing.toCommSemiring.{u3} R _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) _inst_3) I (Submodule.span.{u3, u2} R M (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_1) _inst_3 (Set.range.{u2, succ u1} M ι v)))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u3}} [_inst_1 : AddCommGroup.{u3} M] {R : Type.{u2}} [_inst_2 : CommRing.{u2} R] [_inst_3 : Module.{u2, u3} R M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_1)] (I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) {v : ι -> M}, Eq.{succ u3} (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_1) _inst_3) (LinearMap.range.{u2, u2, max u1 u2, u3, max (max u1 u3) u2} R R (Finsupp.{u1, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Finsupp.addCommMonoid.{u1, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.addCommMonoid.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_1) (Finsupp.module.{u1, u2, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Submodule.addCommMonoid.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I) (Submodule.module.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) _inst_3 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))) (LinearMap.{u2, u2, max u2 u1, u3} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))) (Finsupp.{u1, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) M (Finsupp.addCommMonoid.{u1, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.addCommMonoid.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_1) (Finsupp.module.{u1, u2, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Submodule.addCommMonoid.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I) (Submodule.module.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) _inst_3) (LinearMap.instSemilinearMapClassLinearMap.{u2, u2, max u1 u2, u3} R R (Finsupp.{u1, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.zero.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Finsupp.addCommMonoid.{u1, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) (Submodule.addCommMonoid.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_1) (Finsupp.module.{u1, u2, u2} ι (Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) x I)) R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Submodule.addCommMonoid.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I) (Submodule.module.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) I)) _inst_3 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))))) (RingHomSurjective.ids.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (Ideal.finsuppTotal.{u1, u3, u2} ι M _inst_1 R _inst_2 _inst_3 I v)) (HSMul.hSMul.{u2, u3, u3} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_1) _inst_3) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_1) _inst_3) (instHSMul.{u2, u3} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (Submodule.{u2, u3} R M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_1) _inst_3) (Submodule.hasSmul'.{u2, u3} R M (CommRing.toCommSemiring.{u2} R _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M _inst_1) _inst_3)) I (Submodule.span.{u2, u3} R M (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_1) _inst_3 (Set.range.{u3, succ u1} M ι v)))
Case conversion may be inaccurate. Consider using '#align ideal.range_finsupp_total Ideal.range_finsuppTotalₓ'. -/
theorem range_finsuppTotal : (finsuppTotal ι M I v).range = I • Submodule.span R (Set.range v) :=
  by
  ext
  rw [Submodule.mem_ideal_smul_span_iff_exists_sum]
  refine' ⟨fun ⟨f, h⟩ => ⟨Finsupp.mapRange.linearMap I.subtype f, fun i => (f i).2, h⟩, _⟩
  rintro ⟨a, ha, rfl⟩
  classical
    refine' ⟨a.map_range (fun r => if h : r ∈ I then ⟨r, h⟩ else 0) (by split_ifs <;> rfl), _⟩
    rw [finsupp_total_apply, Finsupp.sum_mapRange_index]
    · apply Finsupp.sum_congr
      intro i _
      rw [dif_pos (ha i)]
      rfl
    · exact fun _ => zero_smul _ _
#align ideal.range_finsupp_total Ideal.range_finsuppTotal

end Total

section Basis

variable {ι R S : Type _} [CommSemiring R] [CommRing S] [IsDomain S] [Algebra R S]

/- warning: ideal.basis_span_singleton -> Ideal.basisSpanSingleton is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u3} S] [_inst_3 : IsDomain.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))] [_inst_4 : Algebra.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))], (Basis.{u1, u2, u3} ι R S (CommSemiring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4)) -> (forall {x : S}, (Ne.{succ u3} S x (OfNat.ofNat.{u3} S 0 (OfNat.mk.{u3} S 0 (Zero.zero.{u3} S (MulZeroClass.toHasZero.{u3} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))))) -> (Basis.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (CommSemiring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x)) (CommSemiring.toSemiring.{u2} R _inst_1) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Ideal.basisSpanSingleton._proof_1.{u2, u3} R S _inst_1 _inst_2 _inst_4))))
but is expected to have type
  forall {ι : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u3} S] [_inst_3 : IsDomain.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))] [_inst_4 : Algebra.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))], (Basis.{u1, u2, u3} ι R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) -> (forall {x : S}, (Ne.{succ u3} S x (OfNat.ofNat.{u3} S 0 (Zero.toOfNat0.{u3} S (CommMonoidWithZero.toZero.{u3} S (CancelCommMonoidWithZero.toCommMonoidWithZero.{u3} S (IsDomain.toCancelCommMonoidWithZero.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2) _inst_3)))))) -> (Basis.{u1, u2, u3} ι R (Subtype.{succ u3} S (fun (x_1 : S) => Membership.mem.{u3, u3} S (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (SetLike.instMembership.{u3, u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) x_1 (Ideal.span.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.instSingletonSet.{u3} S) x)))) (CommSemiring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u3, u3} S S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.span.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.instSingletonSet.{u3} S) x))) (Submodule.module'.{u2, u3, u3} R S S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.span.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.instSingletonSet.{u3} S) x)) (CommSemiring.toSemiring.{u2} R _inst_1) (Algebra.toSMul.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (IsScalarTower.right.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4))))
Case conversion may be inaccurate. Consider using '#align ideal.basis_span_singleton Ideal.basisSpanSingletonₓ'. -/
/-- A basis on `S` gives a basis on `ideal.span {x}`, by multiplying everything by `x`. -/
noncomputable def basisSpanSingleton (b : Basis ι R S) {x : S} (hx : x ≠ 0) :
    Basis ι R (span ({x} : Set S)) :=
  b.map <|
    LinearEquiv.ofInjective (Algebra.lmul R S x) (LinearMap.mul_injective hx) ≪≫ₗ
        LinearEquiv.ofEq _ _
          (by
            ext
            simp [mem_span_singleton', mul_comm]) ≪≫ₗ
      (Submodule.restrictScalarsEquiv R S S (Ideal.span ({x} : Set S))).restrictScalars R
#align ideal.basis_span_singleton Ideal.basisSpanSingleton

/- warning: ideal.basis_span_singleton_apply -> Ideal.basisSpanSingleton_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u3} S] [_inst_3 : IsDomain.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))] [_inst_4 : Algebra.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))] (b : Basis.{u1, u2, u3} ι R S (CommSemiring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4)) {x : S} (hx : Ne.{succ u3} S x (OfNat.ofNat.{u3} S 0 (OfNat.mk.{u3} S 0 (Zero.zero.{u3} S (MulZeroClass.toHasZero.{u3} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))))) (i : ι), Eq.{succ u3} S ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) S (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) S (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) S (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) S (coeSubtype.{succ u3} S (fun (x_1 : S) => Membership.Mem.{u3, u3} S (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (SetLike.hasMem.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) x_1 (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))))))) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (Basis.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (CommSemiring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x)) (CommSemiring.toSemiring.{u2} R _inst_1) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Ideal.basisSpanSingleton._proof_1.{u2, u3} R S _inst_1 _inst_2 _inst_4))) (fun (_x : Basis.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (CommSemiring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x)) (CommSemiring.toSemiring.{u2} R _inst_1) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Ideal.basisSpanSingleton._proof_1.{u2, u3} R S _inst_1 _inst_2 _inst_4))) => ι -> (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x)))) (FunLike.hasCoeToFun.{max (succ u1) (succ u2) (succ u3), succ u1, succ u3} (Basis.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (CommSemiring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x)) (CommSemiring.toSemiring.{u2} R _inst_1) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Ideal.basisSpanSingleton._proof_1.{u2, u3} R S _inst_1 _inst_2 _inst_4))) ι (fun (_x : ι) => coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (Basis.funLike.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (CommSemiring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x)) (CommSemiring.toSemiring.{u2} R _inst_1) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Ideal.basisSpanSingleton._proof_1.{u2, u3} R S _inst_1 _inst_2 _inst_4)))) (Ideal.basisSpanSingleton.{u1, u2, u3} ι R S _inst_1 _inst_2 _inst_3 _inst_4 b x hx) i)) (HMul.hMul.{u3, u3, u3} S S S (instHMul.{u3} S (Distrib.toHasMul.{u3} S (Ring.toDistrib.{u3} S (CommRing.toRing.{u3} S _inst_2)))) x (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (Basis.{u1, u2, u3} ι R S (CommSemiring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4)) (fun (_x : Basis.{u1, u2, u3} ι R S (CommSemiring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4)) => ι -> S) (FunLike.hasCoeToFun.{max (succ u1) (succ u2) (succ u3), succ u1, succ u3} (Basis.{u1, u2, u3} ι R S (CommSemiring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4)) ι (fun (_x : ι) => S) (Basis.funLike.{u1, u2, u3} ι R S (CommSemiring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4))) b i))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u1} S] [_inst_3 : IsDomain.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))] [_inst_4 : Algebra.{u2, u1} R S _inst_1 (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))] (b : Basis.{u3, u2, u1} ι R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonUnitalRing.toNonUnitalNonAssocRing.{u1} S (NonUnitalCommRing.toNonUnitalRing.{u1} S (CommRing.toNonUnitalCommRing.{u1} S _inst_2))))) (Algebra.toModule.{u2, u1} R S _inst_1 (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_4)) {x : S} (hx : Ne.{succ u1} S x (OfNat.ofNat.{u1} S 0 (Zero.toOfNat0.{u1} S (CommMonoidWithZero.toZero.{u1} S (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} S (IsDomain.toCancelCommMonoidWithZero.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2) _inst_3)))))) (i : ι), Eq.{succ u1} S (Subtype.val.{succ u1} S (fun (x_1 : S) => Membership.mem.{u1, u1} S (Set.{u1} S) (Set.instMembershipSet.{u1} S) x_1 (SetLike.coe.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (Ideal.span.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (Singleton.singleton.{u1, u1} S (Set.{u1} S) (Set.instSingletonSet.{u1} S) x)))) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (Basis.{u3, u2, u1} ι R (Subtype.{succ u1} S (fun (x_1 : S) => Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) x_1 (Ideal.span.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (Singleton.singleton.{u1, u1} S (Set.{u1} S) (Set.instSingletonSet.{u1} S) x)))) (CommSemiring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Ideal.span.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (Singleton.singleton.{u1, u1} S (Set.{u1} S) (Set.instSingletonSet.{u1} S) x))) (Submodule.module'.{u2, u1, u1} R S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Ideal.span.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (Singleton.singleton.{u1, u1} S (Set.{u1} S) (Set.instSingletonSet.{u1} S) x)) (CommSemiring.toSemiring.{u2} R _inst_1) (Algebra.toSMul.{u2, u1} R S _inst_1 (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u1} R S _inst_1 (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_4) (IsScalarTower.right.{u2, u1} R S _inst_1 (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_4))) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => Subtype.{succ u1} S (fun (x_1 : S) => Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) x_1 (Ideal.span.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (Singleton.singleton.{u1, u1} S (Set.{u1} S) (Set.instSingletonSet.{u1} S) x)))) _x) (Basis.funLike.{u3, u2, u1} ι R (Subtype.{succ u1} S (fun (x_1 : S) => Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) x_1 (Ideal.span.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (Singleton.singleton.{u1, u1} S (Set.{u1} S) (Set.instSingletonSet.{u1} S) x)))) (CommSemiring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Ideal.span.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (Singleton.singleton.{u1, u1} S (Set.{u1} S) (Set.instSingletonSet.{u1} S) x))) (Submodule.module'.{u2, u1, u1} R S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Ideal.span.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (Singleton.singleton.{u1, u1} S (Set.{u1} S) (Set.instSingletonSet.{u1} S) x)) (CommSemiring.toSemiring.{u2} R _inst_1) (Algebra.toSMul.{u2, u1} R S _inst_1 (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u1} R S _inst_1 (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_4) (IsScalarTower.right.{u2, u1} R S _inst_1 (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_4))) (Ideal.basisSpanSingleton.{u3, u2, u1} ι R S _inst_1 _inst_2 _inst_3 _inst_4 b x hx) i)) (HMul.hMul.{u1, u1, u1} S ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => S) i) S (instHMul.{u1} S (NonUnitalNonAssocRing.toMul.{u1} S (NonUnitalRing.toNonUnitalNonAssocRing.{u1} S (NonUnitalCommRing.toNonUnitalRing.{u1} S (CommRing.toNonUnitalCommRing.{u1} S _inst_2))))) x (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (Basis.{u3, u2, u1} ι R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonUnitalRing.toNonUnitalNonAssocRing.{u1} S (NonUnitalCommRing.toNonUnitalRing.{u1} S (CommRing.toNonUnitalCommRing.{u1} S _inst_2))))) (Algebra.toModule.{u2, u1} R S _inst_1 (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_4)) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => S) _x) (Basis.funLike.{u3, u2, u1} ι R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonUnitalRing.toNonUnitalNonAssocRing.{u1} S (NonUnitalCommRing.toNonUnitalRing.{u1} S (CommRing.toNonUnitalCommRing.{u1} S _inst_2))))) (Algebra.toModule.{u2, u1} R S _inst_1 (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_4)) b i))
Case conversion may be inaccurate. Consider using '#align ideal.basis_span_singleton_apply Ideal.basisSpanSingleton_applyₓ'. -/
@[simp]
theorem basisSpanSingleton_apply (b : Basis ι R S) {x : S} (hx : x ≠ 0) (i : ι) :
    (basisSpanSingleton b hx i : S) = x * b i := by
  simp only [basis_span_singleton, Basis.map_apply, LinearEquiv.trans_apply,
    Submodule.restrictScalarsEquiv_apply, LinearEquiv.ofInjective_apply, LinearEquiv.coe_ofEq_apply,
    LinearEquiv.restrictScalars_apply, Algebra.coe_lmul_eq_mul, LinearMap.mul_apply']
#align ideal.basis_span_singleton_apply Ideal.basisSpanSingleton_apply

/- warning: ideal.constr_basis_span_singleton -> Ideal.constr_basisSpanSingleton is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u3} S] [_inst_3 : IsDomain.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))] [_inst_4 : Algebra.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))] {N : Type.{u4}} [_inst_5 : Semiring.{u4} N] [_inst_6 : Module.{u4, u3} N S _inst_5 (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2)))))] [_inst_7 : SMulCommClass.{u2, u4, u3} R N S (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4))))) (SMulZeroClass.toHasSmul.{u4, u3} N S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u4, u3} N S (MulZeroClass.toHasZero.{u4} N (MulZeroOneClass.toMulZeroClass.{u4} N (MonoidWithZero.toMulZeroOneClass.{u4} N (Semiring.toMonoidWithZero.{u4} N _inst_5)))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u4, u3} N S (Semiring.toMonoidWithZero.{u4} N _inst_5) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u4, u3} N S _inst_5 (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) _inst_6))))] (b : Basis.{u1, u2, u3} ι R S (CommSemiring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4)) {x : S} (hx : Ne.{succ u3} S x (OfNat.ofNat.{u3} S 0 (OfNat.mk.{u3} S 0 (Zero.zero.{u3} S (MulZeroClass.toHasZero.{u3} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))))), Eq.{succ u3} (LinearMap.{u2, u2, u3, u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) S S (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4)) (coeFn.{max (succ (max u1 u3)) (succ u3), max (succ (max u1 u3)) (succ u3)} (LinearEquiv.{u4, u4, max u1 u3, u3} N N _inst_5 _inst_5 (RingHom.id.{u4} N (Semiring.toNonAssocSemiring.{u4} N _inst_5)) (RingHom.id.{u4} N (Semiring.toNonAssocSemiring.{u4} N _inst_5)) (RingHomInvPair.ids.{u4} N _inst_5) (RingHomInvPair.ids.{u4} N _inst_5) (ι -> S) (LinearMap.{u2, u2, u3, u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) S S (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4)) (Pi.addCommMonoid.{u1, u3} ι (fun (ᾰ : ι) => S) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))) (LinearMap.addCommMonoid.{u2, u2, u3, u3} R R S S (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Pi.Function.module.{u1, u4, u3} ι N S _inst_5 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) _inst_6) (LinearMap.module.{u2, u2, u4, u3, u3} R R N S S (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) _inst_5 _inst_6 _inst_7)) (fun (_x : LinearEquiv.{u4, u4, max u1 u3, u3} N N _inst_5 _inst_5 (RingHom.id.{u4} N (Semiring.toNonAssocSemiring.{u4} N _inst_5)) (RingHom.id.{u4} N (Semiring.toNonAssocSemiring.{u4} N _inst_5)) (RingHomInvPair.ids.{u4} N _inst_5) (RingHomInvPair.ids.{u4} N _inst_5) (ι -> S) (LinearMap.{u2, u2, u3, u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) S S (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4)) (Pi.addCommMonoid.{u1, u3} ι (fun (ᾰ : ι) => S) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))) (LinearMap.addCommMonoid.{u2, u2, u3, u3} R R S S (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Pi.Function.module.{u1, u4, u3} ι N S _inst_5 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) _inst_6) (LinearMap.module.{u2, u2, u4, u3, u3} R R N S S (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) _inst_5 _inst_6 _inst_7)) => (ι -> S) -> (LinearMap.{u2, u2, u3, u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) S S (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4))) (LinearEquiv.hasCoeToFun.{u4, u4, max u1 u3, u3} N N (ι -> S) (LinearMap.{u2, u2, u3, u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) S S (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4)) _inst_5 _inst_5 (Pi.addCommMonoid.{u1, u3} ι (fun (ᾰ : ι) => S) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))) (LinearMap.addCommMonoid.{u2, u2, u3, u3} R R S S (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Pi.Function.module.{u1, u4, u3} ι N S _inst_5 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) _inst_6) (LinearMap.module.{u2, u2, u4, u3, u3} R R N S S (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) _inst_5 _inst_6 _inst_7) (RingHom.id.{u4} N (Semiring.toNonAssocSemiring.{u4} N _inst_5)) (RingHom.id.{u4} N (Semiring.toNonAssocSemiring.{u4} N _inst_5)) (RingHomInvPair.ids.{u4} N _inst_5) (RingHomInvPair.ids.{u4} N _inst_5)) (Basis.constr.{u1, u2, u3, u3, u4} ι R S S (CommSemiring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) b N _inst_5 _inst_6 _inst_7) (Function.comp.{succ u1, succ u3, succ u3} ι (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) S ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) S (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) S (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) S (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) S (coeSubtype.{succ u3} S (fun (x_1 : S) => Membership.Mem.{u3, u3} S (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (SetLike.hasMem.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) x_1 (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x)))))))) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (Basis.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (CommSemiring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x)) (CommSemiring.toSemiring.{u2} R _inst_1) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Ideal.basisSpanSingleton._proof_1.{u2, u3} R S _inst_1 _inst_2 _inst_4))) (fun (_x : Basis.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (CommSemiring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x)) (CommSemiring.toSemiring.{u2} R _inst_1) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Ideal.basisSpanSingleton._proof_1.{u2, u3} R S _inst_1 _inst_2 _inst_4))) => ι -> (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x)))) (FunLike.hasCoeToFun.{max (succ u1) (succ u2) (succ u3), succ u1, succ u3} (Basis.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (CommSemiring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x)) (CommSemiring.toSemiring.{u2} R _inst_1) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Ideal.basisSpanSingleton._proof_1.{u2, u3} R S _inst_1 _inst_2 _inst_4))) ι (fun (_x : ι) => coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (Basis.funLike.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (CommSemiring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x))) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.span.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.hasSingleton.{u3} S) x)) (CommSemiring.toSemiring.{u2} R _inst_1) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) (Ideal.basisSpanSingleton._proof_1.{u2, u3} R S _inst_1 _inst_2 _inst_4)))) (Ideal.basisSpanSingleton.{u1, u2, u3} ι R S _inst_1 _inst_2 _inst_3 _inst_4 b x hx)))) (coeFn.{succ u3, succ u3} (AlgHom.{u2, u3, u3} R S (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4)) _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4)) _inst_4 (Module.End.algebra.{u2, u3} R S _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4))) (fun (_x : AlgHom.{u2, u3, u3} R S (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4)) _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4)) _inst_4 (Module.End.algebra.{u2, u3} R S _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4))) => S -> (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4))) ([anonymous].{u2, u3, u3} R S (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4)) _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4)) _inst_4 (Module.End.algebra.{u2, u3} R S _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4))) (Algebra.lmul.{u2, u3} R S _inst_1 (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_4) x)
but is expected to have type
  forall {ι : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u3} S] [_inst_3 : IsDomain.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))] [_inst_4 : Algebra.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))] {N : Type.{u4}} [_inst_5 : Semiring.{u4} N] [_inst_6 : Module.{u4, u3} N S _inst_5 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2)))))] [_inst_7 : SMulCommClass.{u2, u4, u3} R N S (Algebra.toSMul.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (SMulZeroClass.toSMul.{u4, u3} N S (CommMonoidWithZero.toZero.{u3} S (CancelCommMonoidWithZero.toCommMonoidWithZero.{u3} S (IsDomain.toCancelCommMonoidWithZero.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2) _inst_3))) (SMulWithZero.toSMulZeroClass.{u4, u3} N S (MonoidWithZero.toZero.{u4} N (Semiring.toMonoidWithZero.{u4} N _inst_5)) (CommMonoidWithZero.toZero.{u3} S (CancelCommMonoidWithZero.toCommMonoidWithZero.{u3} S (IsDomain.toCancelCommMonoidWithZero.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2) _inst_3))) (MulActionWithZero.toSMulWithZero.{u4, u3} N S (Semiring.toMonoidWithZero.{u4} N _inst_5) (CommMonoidWithZero.toZero.{u3} S (CancelCommMonoidWithZero.toCommMonoidWithZero.{u3} S (IsDomain.toCancelCommMonoidWithZero.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2) _inst_3))) (Module.toMulActionWithZero.{u4, u3} N S _inst_5 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) _inst_6))))] (b : Basis.{u1, u2, u3} ι R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) {x : S} (hx : Ne.{succ u3} S x (OfNat.ofNat.{u3} S 0 (Zero.toOfNat0.{u3} S (CommMonoidWithZero.toZero.{u3} S (CancelCommMonoidWithZero.toCommMonoidWithZero.{u3} S (IsDomain.toCancelCommMonoidWithZero.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2) _inst_3)))))), Eq.{succ u3} (LinearMap.{u2, u2, u3, u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) S S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (AddHom.toFun.{max u1 u3, u3} (ι -> S) (LinearMap.{u2, u2, u3, u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) S S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (AddZeroClass.toAdd.{max u1 u3} (ι -> S) (AddMonoid.toAddZeroClass.{max u1 u3} (ι -> S) (AddCommMonoid.toAddMonoid.{max u1 u3} (ι -> S) (Pi.addCommMonoid.{u1, u3} ι (fun (a._@.Mathlib.LinearAlgebra.Basis._hyg.7822 : ι) => S) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))))))) (AddZeroClass.toAdd.{u3} (LinearMap.{u2, u2, u3, u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) S S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (AddMonoid.toAddZeroClass.{u3} (LinearMap.{u2, u2, u3, u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) S S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (AddCommMonoid.toAddMonoid.{u3} (LinearMap.{u2, u2, u3, u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) S S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (LinearMap.addCommMonoid.{u2, u2, u3, u3} R R S S (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))))) (LinearMap.toAddHom.{u4, u4, max u1 u3, u3} N N _inst_5 _inst_5 (RingHom.id.{u4} N (Semiring.toNonAssocSemiring.{u4} N _inst_5)) (ι -> S) (LinearMap.{u2, u2, u3, u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) S S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Pi.addCommMonoid.{u1, u3} ι (fun (a._@.Mathlib.LinearAlgebra.Basis._hyg.7822 : ι) => S) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2)))))) (LinearMap.addCommMonoid.{u2, u2, u3, u3} R R S S (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Pi.module.{u1, u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.Basis._hyg.7822 : ι) => S) N _inst_5 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (fun (i : ι) => _inst_6)) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, u4, u3, u3} R R N S S (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) _inst_5 _inst_6 _inst_7) (LinearEquiv.toLinearMap.{u4, u4, max u1 u3, u3} N N _inst_5 _inst_5 (RingHom.id.{u4} N (Semiring.toNonAssocSemiring.{u4} N _inst_5)) (RingHom.id.{u4} N (Semiring.toNonAssocSemiring.{u4} N _inst_5)) (RingHomInvPair.ids.{u4} N _inst_5) (RingHomInvPair.ids.{u4} N _inst_5) (ι -> S) (LinearMap.{u2, u2, u3, u3} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) S S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Pi.addCommMonoid.{u1, u3} ι (fun (a._@.Mathlib.LinearAlgebra.Basis._hyg.7822 : ι) => S) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2)))))) (LinearMap.addCommMonoid.{u2, u2, u3, u3} R R S S (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Pi.module.{u1, u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.Basis._hyg.7822 : ι) => S) N _inst_5 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (fun (i : ι) => _inst_6)) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, u4, u3, u3} R R N S S (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) _inst_5 _inst_6 _inst_7) (Basis.constr.{u1, u2, u3, u3, u4} ι R S S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonUnitalRing.toNonUnitalNonAssocRing.{u3} S (NonUnitalCommRing.toNonUnitalRing.{u3} S (CommRing.toNonUnitalCommRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) b N _inst_5 _inst_6 _inst_7))) (Function.comp.{succ u1, succ u3, succ u3} ι (Subtype.{succ u3} S (fun (x_1 : S) => Membership.mem.{u3, u3} S (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (SetLike.instMembership.{u3, u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) x_1 (Ideal.span.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.instSingletonSet.{u3} S) x)))) S (Subtype.val.{succ u3} S (fun (x_1 : S) => Membership.mem.{u3, u3} S (Set.{u3} S) (Set.instMembershipSet.{u3} S) x_1 (SetLike.coe.{u3, u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))) (Ideal.span.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.instSingletonSet.{u3} S) x))))) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), succ u1, succ u3} (Basis.{u1, u2, u3} ι R (Subtype.{succ u3} S (fun (x_1 : S) => Membership.mem.{u3, u3} S (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (SetLike.instMembership.{u3, u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) x_1 (Ideal.span.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.instSingletonSet.{u3} S) x)))) (CommSemiring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u3, u3} S S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.span.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.instSingletonSet.{u3} S) x))) (Submodule.module'.{u2, u3, u3} R S S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.span.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.instSingletonSet.{u3} S) x)) (CommSemiring.toSemiring.{u2} R _inst_1) (Algebra.toSMul.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (IsScalarTower.right.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4))) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => Subtype.{succ u3} S (fun (x_1 : S) => Membership.mem.{u3, u3} S (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (SetLike.instMembership.{u3, u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) x_1 (Ideal.span.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.instSingletonSet.{u3} S) x)))) _x) (Basis.funLike.{u1, u2, u3} ι R (Subtype.{succ u3} S (fun (x_1 : S) => Membership.mem.{u3, u3} S (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (SetLike.instMembership.{u3, u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) x_1 (Ideal.span.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.instSingletonSet.{u3} S) x)))) (CommSemiring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u3, u3} S S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.span.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.instSingletonSet.{u3} S) x))) (Submodule.module'.{u2, u3, u3} R S S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.span.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.instSingletonSet.{u3} S) x)) (CommSemiring.toSemiring.{u2} R _inst_1) (Algebra.toSMul.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) (IsScalarTower.right.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4))) (Ideal.basisSpanSingleton.{u1, u2, u3} ι R S _inst_1 _inst_2 _inst_3 _inst_4 b x hx)))) (FunLike.coe.{succ u3, succ u3, succ u3} (AlgHom.{u2, u3, u3} R S (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_4 (Module.instAlgebraEndToSemiringSemiring.{u2, u3} R S _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4))) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : S) => Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _x) (SMulHomClass.toFunLike.{u3, u2, u3, u3} (AlgHom.{u2, u3, u3} R S (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_4 (Module.instAlgebraEndToSemiringSemiring.{u2, u3} R S _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4))) R S (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (SMulZeroClass.toSMul.{u2, u3} R S (AddMonoid.toZero.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))))) (DistribSMul.toSMulZeroClass.{u2, u3} R S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))))) (DistribMulAction.toDistribSMul.{u2, u3} R S (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))))) (Module.toDistribMulAction.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4))))) (SMulZeroClass.toSMul.{u2, u3} R (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (AddMonoid.toZero.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (AddCommMonoid.toAddMonoid.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Semiring.toNonAssocSemiring.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4))))))) (DistribSMul.toSMulZeroClass.{u2, u3} R (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (AddMonoid.toAddZeroClass.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (AddCommMonoid.toAddMonoid.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Semiring.toNonAssocSemiring.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4))))))) (DistribMulAction.toDistribSMul.{u2, u3} R (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (AddCommMonoid.toAddMonoid.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Semiring.toNonAssocSemiring.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)))))) (Module.toDistribMulAction.{u2, u3} R (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Semiring.toNonAssocSemiring.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4))))) (Algebra.toModule.{u2, u3} R (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_1 (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Module.instAlgebraEndToSemiringSemiring.{u2, u3} R S _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4))))))) (DistribMulActionHomClass.toSMulHomClass.{u3, u2, u3, u3} (AlgHom.{u2, u3, u3} R S (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_4 (Module.instAlgebraEndToSemiringSemiring.{u2, u3} R S _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4))) R S (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))))) (AddCommMonoid.toAddMonoid.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Semiring.toNonAssocSemiring.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)))))) (Module.toDistribMulAction.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Module.toDistribMulAction.{u2, u3} R (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Semiring.toNonAssocSemiring.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4))))) (Algebra.toModule.{u2, u3} R (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_1 (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Module.instAlgebraEndToSemiringSemiring.{u2, u3} R S _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)))) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{u3, u2, u3, u3} (AlgHom.{u2, u3, u3} R S (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_4 (Module.instAlgebraEndToSemiringSemiring.{u2, u3} R S _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4))) R S (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Semiring.toNonAssocSemiring.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)))) (Module.toDistribMulAction.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Module.toDistribMulAction.{u2, u3} R (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Semiring.toNonAssocSemiring.{u3} (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4))))) (Algebra.toModule.{u2, u3} R (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_1 (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (Module.instAlgebraEndToSemiringSemiring.{u2, u3} R S _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)))) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u2, u3, u3, u3} R S (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_4 (Module.instAlgebraEndToSemiringSemiring.{u2, u3} R S _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) (AlgHom.{u2, u3, u3} R S (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_4 (Module.instAlgebraEndToSemiringSemiring.{u2, u3} R S _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4))) (AlgHom.algHomClass.{u2, u3, u3} R S (Module.End.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (Module.End.semiring.{u2, u3} R S (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4)) _inst_4 (Module.instAlgebraEndToSemiringSemiring.{u2, u3} R S _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4))))))) (Algebra.lmul.{u2, u3} R S _inst_1 (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_4) x)
Case conversion may be inaccurate. Consider using '#align ideal.constr_basis_span_singleton Ideal.constr_basisSpanSingletonₓ'. -/
@[simp]
theorem constr_basisSpanSingleton {N : Type _} [Semiring N] [Module N S] [SMulCommClass R N S]
    (b : Basis ι R S) {x : S} (hx : x ≠ 0) :
    b.constr N (coe ∘ basisSpanSingleton b hx) = Algebra.lmul R S x :=
  b.ext fun i => by
    erw [Basis.constr_basis, Function.comp_apply, basis_span_singleton_apply, LinearMap.mul_apply']
#align ideal.constr_basis_span_singleton Ideal.constr_basisSpanSingleton

end Basis

end Ideal

/- warning: associates.mk_ne_zero' -> Associates.mk_ne_zero' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {r : R}, Iff (Ne.{succ u1} (Associates.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))))) (Associates.mk.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) r))) (OfNat.ofNat.{u1} (Associates.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))))) 0 (OfNat.mk.{u1} (Associates.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))))) 0 (Zero.zero.{u1} (Associates.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))))) (Associates.hasZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MulZeroClass.toHasZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))))) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))))))))) (Ne.{succ u1} R r (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {r : R}, Iff (Ne.{succ u1} (Associates.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))))) (Associates.mk.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) r))) (OfNat.ofNat.{u1} (Associates.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))))) 0 (Zero.toOfNat0.{u1} (Associates.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)))))) (Associates.instZeroAssociates.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CommMonoidWithZero.toZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (CommSemiring.toCommMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemCommSemiring.toCommSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.instIdemCommSemiringIdealToSemiring.{u1} R _inst_1)))) (MonoidWithZero.toMonoid.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (IdemSemiring.toSemiring.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.idemSemiring.{u1, u1} R _inst_1 R (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))))))))) (Ne.{succ u1} R r (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align associates.mk_ne_zero' Associates.mk_ne_zero'ₓ'. -/
theorem Associates.mk_ne_zero' {R : Type _} [CommSemiring R] {r : R} :
    Associates.mk (Ideal.span {r} : Ideal R) ≠ 0 ↔ r ≠ 0 := by
  rw [Associates.mk_ne_zero, Ideal.zero_eq_bot, Ne.def, Ideal.span_singleton_eq_bot]
#align associates.mk_ne_zero' Associates.mk_ne_zero'

/- warning: basis.mem_ideal_iff -> Basis.mem_ideal_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} S] [_inst_3 : Algebra.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))] {I : Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))} (b : Basis.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) I) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) I) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) I (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3) (IsScalarTower.right.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3))) {x : S}, Iff (Membership.Mem.{u3, u3} S (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (SetLike.hasMem.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) x I) (Exists.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))))))) (fun (c : Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))))))) => Eq.{succ u3} S x (Finsupp.sum.{u1, u2, u3} ι R S (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) c (fun (i : ι) (x : R) => SMul.smul.{u2, u3} R S (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3))))) x ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) I) S (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) I) S (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) I) S (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) I) S (coeSubtype.{succ u3} S (fun (x : S) => Membership.Mem.{u3, u3} S (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (SetLike.hasMem.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) x I))))) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (Basis.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) I) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) I) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) I (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3) (IsScalarTower.right.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3))) (fun (_x : Basis.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) I) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) I) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) I (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3) (IsScalarTower.right.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3))) => ι -> (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) I)) (FunLike.hasCoeToFun.{max (succ u1) (succ u2) (succ u3), succ u1, succ u3} (Basis.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) I) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) I) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) I (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3) (IsScalarTower.right.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3))) ι (fun (_x : ι) => coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) I) (Basis.funLike.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) I) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) I) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) I (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3) (IsScalarTower.right.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3)))) b i))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} S] [_inst_3 : Algebra.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))] {I : Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))} (b : Basis.{u3, u2, u1} ι R (Subtype.{succ u1} S (fun (x : S) => Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) x I)) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Submodule.addCommMonoid.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) I) (Submodule.module'.{u2, u1, u1} R S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) I (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Algebra.toSMul.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_3) (Algebra.toModule.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_3) (IsScalarTower.right.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_3))) {x : S}, Iff (Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) x I) (Exists.{max (succ u3) (succ u2)} (Finsupp.{u3, u2} ι R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (fun (c : Finsupp.{u3, u2} ι R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) => Eq.{succ u1} S x (Finsupp.sum.{u3, u2, u1} ι R S (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonUnitalRing.toNonUnitalNonAssocRing.{u1} S (NonUnitalCommRing.toNonUnitalRing.{u1} S (CommRing.toNonUnitalCommRing.{u1} S _inst_2))))) c (fun (i : ι) (x : R) => HSMul.hSMul.{u2, u1, u1} R S S (instHSMul.{u2, u1} R S (Algebra.toSMul.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_3)) x (Subtype.val.{succ u1} S (fun (x : S) => Membership.mem.{u1, u1} S (Set.{u1} S) (Set.instMembershipSet.{u1} S) x (SetLike.coe.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) I)) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (Basis.{u3, u2, u1} ι R (Subtype.{succ u1} S (fun (x : S) => Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) x I)) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Submodule.addCommMonoid.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) I) (Submodule.module'.{u2, u1, u1} R S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) I (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Algebra.toSMul.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_3) (Algebra.toModule.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_3) (IsScalarTower.right.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_3))) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => Subtype.{succ u1} S (fun (x : S) => Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) x I)) _x) (Basis.funLike.{u3, u2, u1} ι R (Subtype.{succ u1} S (fun (x : S) => Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) x I)) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Submodule.addCommMonoid.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) I) (Submodule.module'.{u2, u1, u1} R S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) I (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Algebra.toSMul.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_3) (Algebra.toModule.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_3) (IsScalarTower.right.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) _inst_3))) b i))))))
Case conversion may be inaccurate. Consider using '#align basis.mem_ideal_iff Basis.mem_ideal_iffₓ'. -/
/-- If `I : ideal S` has a basis over `R`,
`x ∈ I` iff it is a linear combination of basis vectors. -/
theorem Basis.mem_ideal_iff {ι R S : Type _} [CommRing R] [CommRing S] [Algebra R S] {I : Ideal S}
    (b : Basis ι R I) {x : S} : x ∈ I ↔ ∃ c : ι →₀ R, x = Finsupp.sum c fun i x => x • b i :=
  (b.map ((I.restrictScalarsEquiv R _ _).restrictScalars R).symm).mem_submodule_iff
#align basis.mem_ideal_iff Basis.mem_ideal_iff

/- warning: basis.mem_ideal_iff' -> Basis.mem_ideal_iff' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : Fintype.{u1} ι] [_inst_2 : CommRing.{u2} R] [_inst_3 : CommRing.{u3} S] [_inst_4 : Algebra.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))] {I : Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))} (b : Basis.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) I) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_2)) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) I) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) I (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_2)) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) _inst_4))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) _inst_4) (IsScalarTower.right.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) _inst_4))) {x : S}, Iff (Membership.Mem.{u3, u3} S (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) (SetLike.hasMem.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) x I) (Exists.{max (succ u1) (succ u2)} (ι -> R) (fun (c : ι -> R) => Eq.{succ u3} S x (Finset.sum.{u3, u1} S ι (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Finset.univ.{u1} ι _inst_1) (fun (i : ι) => SMul.smul.{u2, u3} R S (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) _inst_4))))) (c i) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) I) S (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) I) S (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) I) S (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) I) S (coeSubtype.{succ u3} S (fun (x : S) => Membership.Mem.{u3, u3} S (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) (SetLike.hasMem.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) x I))))) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (Basis.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) I) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_2)) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) I) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) I (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_2)) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) _inst_4))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) _inst_4) (IsScalarTower.right.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) _inst_4))) (fun (_x : Basis.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) I) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_2)) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) I) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) I (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_2)) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) _inst_4))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) _inst_4) (IsScalarTower.right.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) _inst_4))) => ι -> (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) I)) (FunLike.hasCoeToFun.{max (succ u1) (succ u2) (succ u3), succ u1, succ u3} (Basis.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) I) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_2)) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) I) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) I (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_2)) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) _inst_4))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) _inst_4) (IsScalarTower.right.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) _inst_4))) ι (fun (_x : ι) => coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) I) (Basis.funLike.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) S (Submodule.setLike.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) I) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_2)) (Submodule.addCommMonoid.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) I) (Submodule.module'.{u2, u3, u3} R S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))) I (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_2)) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) _inst_4))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) _inst_4) (IsScalarTower.right.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_2) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_3)) _inst_4)))) b i))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Fintype.{u3} ι] [_inst_2 : CommRing.{u2} R] [_inst_3 : CommRing.{u1} S] [_inst_4 : Algebra.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_2) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))] {I : Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))} (b : Basis.{u3, u2, u1} ι R (Subtype.{succ u1} S (fun (x : S) => Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) x I)) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Submodule.addCommMonoid.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) I) (Submodule.module'.{u2, u1, u1} R S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) I (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Algebra.toSMul.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_2) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) _inst_4) (Algebra.toModule.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_2) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) _inst_4) (IsScalarTower.right.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_2) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) _inst_4))) {x : S}, Iff (Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) x I) (Exists.{max (succ u3) (succ u2)} (ι -> R) (fun (c : ι -> R) => Eq.{succ u1} S x (Subtype.val.{succ u1} S (fun (x : S) => Membership.mem.{u1, u1} S (Set.{u1} S) (Set.instMembershipSet.{u1} S) x (SetLike.coe.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)))) I)) (Finset.sum.{u1, u3} (Subtype.{succ u1} S (fun (x : S) => Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) x I)) ι (Submodule.addCommMonoid.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) I) (Finset.univ.{u3} ι _inst_1) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} R ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => Subtype.{succ u1} S (fun (x : S) => Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) x I)) i) ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => Subtype.{succ u1} S (fun (x : S) => Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) x I)) i) (instHSMul.{u2, u1} R ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => Subtype.{succ u1} S (fun (x : S) => Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) x I)) i) (Submodule.smul.{u2, u1, u1} R S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) I (Algebra.toSMul.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_2) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) _inst_4) (Algebra.toSMul.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_2) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) _inst_4) (IsScalarTower.right.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_2) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) _inst_4))) (c i) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (Basis.{u3, u2, u1} ι R (Subtype.{succ u1} S (fun (x : S) => Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) x I)) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Submodule.addCommMonoid.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) I) (Submodule.module'.{u2, u1, u1} R S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) I (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Algebra.toSMul.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_2) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) _inst_4) (Algebra.toModule.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_2) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) _inst_4) (IsScalarTower.right.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_2) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) _inst_4))) ι (fun (a : ι) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => Subtype.{succ u1} S (fun (x : S) => Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) x I)) a) (Basis.funLike.{u3, u2, u1} ι R (Subtype.{succ u1} S (fun (x : S) => Membership.mem.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) S (Submodule.setLike.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) x I)) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Submodule.addCommMonoid.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) I) (Submodule.module'.{u2, u1, u1} R S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3))) I (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_2)) (Algebra.toSMul.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_2) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) _inst_4) (Algebra.toModule.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_2) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) _inst_4) (IsScalarTower.right.{u2, u1} R S (CommRing.toCommSemiring.{u2} R _inst_2) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_3)) _inst_4))) b i))))))
Case conversion may be inaccurate. Consider using '#align basis.mem_ideal_iff' Basis.mem_ideal_iff'ₓ'. -/
/-- If `I : ideal S` has a finite basis over `R`,
`x ∈ I` iff it is a linear combination of basis vectors. -/
theorem Basis.mem_ideal_iff' {ι R S : Type _} [Fintype ι] [CommRing R] [CommRing S] [Algebra R S]
    {I : Ideal S} (b : Basis ι R I) {x : S} : x ∈ I ↔ ∃ c : ι → R, x = ∑ i, c i • b i :=
  (b.map ((I.restrictScalarsEquiv R _ _).restrictScalars R).symm).mem_submodule_iff'
#align basis.mem_ideal_iff' Basis.mem_ideal_iff'

namespace RingHom

variable {R : Type u} {S : Type v} {T : Type w}

section Semiring

variable {F : Type _} {G : Type _} [Semiring R] [Semiring S] [Semiring T]

variable [rcf : RingHomClass F R S] [rcg : RingHomClass G T S] (f : F) (g : G)

include rcf

#print RingHom.ker /-
/-- Kernel of a ring homomorphism as an ideal of the domain. -/
def ker : Ideal R :=
  Ideal.comap f ⊥
#align ring_hom.ker RingHom.ker
-/

/- warning: ring_hom.mem_ker -> RingHom.mem_ker is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rcf : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F) {r : R}, Iff (Membership.Mem.{u1, u1} R (Ideal.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R _inst_1) R (Submodule.setLike.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) r (RingHom.ker.{u1, u2, u3} R S F _inst_1 _inst_2 rcf f)) (Eq.{succ u2} S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rcf)))) f r) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rcf : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F) {r : R}, Iff (Membership.mem.{u2, u2} R (Ideal.{u2} R _inst_1) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R _inst_1) R (Submodule.setLike.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) r (RingHom.ker.{u2, u3, u1} R S F _inst_1 _inst_2 rcf f)) (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) r) (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rcf))) f r) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) r) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) r) (MonoidWithZero.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) r) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) r) _inst_2)))))
Case conversion may be inaccurate. Consider using '#align ring_hom.mem_ker RingHom.mem_kerₓ'. -/
/-- An element is in the kernel if and only if it maps to zero.-/
theorem mem_ker {r} : r ∈ ker f ↔ f r = 0 := by rw [ker, Ideal.mem_comap, Submodule.mem_bot]
#align ring_hom.mem_ker RingHom.mem_ker

/- warning: ring_hom.ker_eq -> RingHom.ker_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rcf : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F), Eq.{succ u1} (Set.{u1} R) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R _inst_1) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R _inst_1) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R _inst_1) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R _inst_1) R (Submodule.setLike.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))))) (RingHom.ker.{u1, u2, u3} R S F _inst_1 _inst_2 rcf f)) (Set.preimage.{u1, u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rcf)))) f) (Singleton.singleton.{u2, u2} S (Set.{u2} S) (Set.hasSingleton.{u2} S) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))))))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rcf : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F), Eq.{succ u2} (Set.{u2} R) (SetLike.coe.{u2, u2} (Ideal.{u2} R _inst_1) R (Submodule.setLike.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (RingHom.ker.{u2, u3, u1} R S F _inst_1 _inst_2 rcf f)) (Set.preimage.{u2, u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rcf))) f) (Singleton.singleton.{u3, u3} S (Set.{u3} S) (Set.instSingletonSet.{u3} S) (OfNat.ofNat.{u3} S 0 (Zero.toOfNat0.{u3} S (MonoidWithZero.toZero.{u3} S (Semiring.toMonoidWithZero.{u3} S _inst_2))))))
Case conversion may be inaccurate. Consider using '#align ring_hom.ker_eq RingHom.ker_eqₓ'. -/
theorem ker_eq : (ker f : Set R) = Set.preimage f {0} :=
  rfl
#align ring_hom.ker_eq RingHom.ker_eq

/- warning: ring_hom.ker_eq_comap_bot -> RingHom.ker_eq_comap_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rcf : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F), Eq.{succ u1} (Ideal.{u1} R _inst_1) (RingHom.ker.{u1, u2, u3} R S F _inst_1 _inst_2 rcf f) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rcf f (Bot.bot.{u2} (Ideal.{u2} S _inst_2) (Submodule.hasBot.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rcf : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F), Eq.{succ u2} (Ideal.{u2} R _inst_1) (RingHom.ker.{u2, u3, u1} R S F _inst_1 _inst_2 rcf f) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rcf f (Bot.bot.{u3} (Ideal.{u3} S _inst_2) (Submodule.instBotSubmodule.{u3, u3} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Semiring.toModule.{u3} S _inst_2))))
Case conversion may be inaccurate. Consider using '#align ring_hom.ker_eq_comap_bot RingHom.ker_eq_comap_botₓ'. -/
theorem ker_eq_comap_bot (f : F) : ker f = Ideal.comap f ⊥ :=
  rfl
#align ring_hom.ker_eq_comap_bot RingHom.ker_eq_comap_bot

omit rcf

/- warning: ring_hom.comap_ker -> RingHom.comap_ker is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : Semiring.{u3} T] (f : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (g : RingHom.{u3, u2} T S (Semiring.toNonAssocSemiring.{u3} T _inst_3) (Semiring.toNonAssocSemiring.{u2} S _inst_2)), Eq.{succ u3} (Ideal.{u3} T _inst_3) (Ideal.comap.{u3, u2, max u3 u2} T S (RingHom.{u3, u2} T S (Semiring.toNonAssocSemiring.{u3} T _inst_3) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) _inst_3 _inst_2 (RingHom.ringHomClass.{u3, u2} T S (Semiring.toNonAssocSemiring.{u3} T _inst_3) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) g (RingHom.ker.{u2, u1, max u2 u1} S R (RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 _inst_1 (RingHom.ringHomClass.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) f)) (RingHom.ker.{u3, u1, max u3 u1} T R (RingHom.{u3, u1} T R (Semiring.toNonAssocSemiring.{u3} T _inst_3) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_3 _inst_1 (RingHom.ringHomClass.{u3, u1} T R (Semiring.toNonAssocSemiring.{u3} T _inst_3) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.comp.{u3, u2, u1} T S R (Semiring.toNonAssocSemiring.{u3} T _inst_3) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1) f g))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} {T : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : Semiring.{u3} T] (f : RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (g : RingHom.{u3, u2} T S (Semiring.toNonAssocSemiring.{u3} T _inst_3) (Semiring.toNonAssocSemiring.{u2} S _inst_2)), Eq.{succ u3} (Ideal.{u3} T _inst_3) (Ideal.comap.{u3, u2, max u2 u3} T S (RingHom.{u3, u2} T S (Semiring.toNonAssocSemiring.{u3} T _inst_3) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) _inst_3 _inst_2 (RingHom.instRingHomClassRingHom.{u3, u2} T S (Semiring.toNonAssocSemiring.{u3} T _inst_3) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) g (RingHom.ker.{u2, u1, max u1 u2} S R (RingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 _inst_1 (RingHom.instRingHomClassRingHom.{u2, u1} S R (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) f)) (RingHom.ker.{u3, u1, max u1 u3} T R (RingHom.{u3, u1} T R (Semiring.toNonAssocSemiring.{u3} T _inst_3) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_3 _inst_1 (RingHom.instRingHomClassRingHom.{u3, u1} T R (Semiring.toNonAssocSemiring.{u3} T _inst_3) (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.comp.{u3, u2, u1} T S R (Semiring.toNonAssocSemiring.{u3} T _inst_3) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u1} R _inst_1) f g))
Case conversion may be inaccurate. Consider using '#align ring_hom.comap_ker RingHom.comap_kerₓ'. -/
theorem comap_ker (f : S →+* R) (g : T →+* S) : f.ker.comap g = (f.comp g).ker := by
  rw [RingHom.ker_eq_comap_bot, Ideal.comap_comap, RingHom.ker_eq_comap_bot]
#align ring_hom.comap_ker RingHom.comap_ker

include rcf

/- warning: ring_hom.not_one_mem_ker -> RingHom.not_one_mem_ker is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rcf : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] [_inst_4 : Nontrivial.{u2} S] (f : F), Not (Membership.Mem.{u1, u1} R (Ideal.{u1} R _inst_1) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R _inst_1) R (Submodule.setLike.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (RingHom.ker.{u1, u2, u3} R S F _inst_1 _inst_2 rcf f))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rcf : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] [_inst_4 : Nontrivial.{u3} S] (f : F), Not (Membership.mem.{u2, u2} R (Ideal.{u2} R _inst_1) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R _inst_1) R (Submodule.setLike.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (Semiring.toOne.{u2} R _inst_1))) (RingHom.ker.{u2, u3, u1} R S F _inst_1 _inst_2 rcf f))
Case conversion may be inaccurate. Consider using '#align ring_hom.not_one_mem_ker RingHom.not_one_mem_kerₓ'. -/
/-- If the target is not the zero ring, then one is not in the kernel.-/
theorem not_one_mem_ker [Nontrivial S] (f : F) : (1 : R) ∉ ker f :=
  by
  rw [mem_ker, map_one]
  exact one_ne_zero
#align ring_hom.not_one_mem_ker RingHom.not_one_mem_ker

/- warning: ring_hom.ker_ne_top -> RingHom.ker_ne_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rcf : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] [_inst_4 : Nontrivial.{u2} S] (f : F), Ne.{succ u1} (Ideal.{u1} R _inst_1) (RingHom.ker.{u1, u2, u3} R S F _inst_1 _inst_2 rcf f) (Top.top.{u1} (Ideal.{u1} R _inst_1) (Submodule.hasTop.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rcf : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] [_inst_4 : Nontrivial.{u3} S] (f : F), Ne.{succ u2} (Ideal.{u2} R _inst_1) (RingHom.ker.{u2, u3, u1} R S F _inst_1 _inst_2 rcf f) (Top.top.{u2} (Ideal.{u2} R _inst_1) (Submodule.instTopSubmodule.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align ring_hom.ker_ne_top RingHom.ker_ne_topₓ'. -/
theorem ker_ne_top [Nontrivial S] (f : F) : ker f ≠ ⊤ :=
  (Ideal.ne_top_iff_one _).mpr <| not_one_mem_ker f
#align ring_hom.ker_ne_top RingHom.ker_ne_top

omit rcf

end Semiring

section Ring

variable {F : Type _} [Ring R] [Semiring S] [rc : RingHomClass F R S] (f : F)

include rc

/- warning: ring_hom.injective_iff_ker_eq_bot -> RingHom.injective_iff_ker_eq_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F), Iff (Function.Injective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f)) (Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (RingHom.ker.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) _inst_2 rc f) (Bot.bot.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.hasBot.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F), Iff (Function.Injective.{succ u2, succ u3} R S (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f)) (Eq.{succ u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (RingHom.ker.{u2, u3, u1} R S F (Ring.toSemiring.{u2} R _inst_1) _inst_2 rc f) (Bot.bot.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Submodule.instBotSubmodule.{u2, u2} R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align ring_hom.injective_iff_ker_eq_bot RingHom.injective_iff_ker_eq_botₓ'. -/
theorem injective_iff_ker_eq_bot : Function.Injective f ↔ ker f = ⊥ :=
  by
  rw [SetLike.ext'_iff, ker_eq, Set.ext_iff]
  exact injective_iff_map_eq_zero' f
#align ring_hom.injective_iff_ker_eq_bot RingHom.injective_iff_ker_eq_bot

/- warning: ring_hom.ker_eq_bot_iff_eq_zero -> RingHom.ker_eq_bot_iff_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] (f : F), Iff (Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (RingHom.ker.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) _inst_2 rc f) (Bot.bot.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.hasBot.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (forall (x : R), (Eq.{succ u2} S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2) rc)))) f x) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))))))) -> (Eq.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))))))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] (f : F), Iff (Eq.{succ u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (RingHom.ker.{u2, u3, u1} R S F (Ring.toSemiring.{u2} R _inst_1) _inst_2 rc f) (Bot.bot.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Submodule.instBotSubmodule.{u2, u2} R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (forall (x : R), (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S _inst_2) rc))) f x) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) (MonoidWithZero.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) _inst_2))))) -> (Eq.{succ u2} R x (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align ring_hom.ker_eq_bot_iff_eq_zero RingHom.ker_eq_bot_iff_eq_zeroₓ'. -/
theorem ker_eq_bot_iff_eq_zero : ker f = ⊥ ↔ ∀ x, f x = 0 → x = 0 := by
  rw [← injective_iff_map_eq_zero f, injective_iff_ker_eq_bot]
#align ring_hom.ker_eq_bot_iff_eq_zero RingHom.ker_eq_bot_iff_eq_zero

omit rc

/- warning: ring_hom.ker_coe_equiv -> RingHom.ker_coe_equiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Semiring.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))), Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (RingHom.ker.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (Ring.toSemiring.{u1} R _inst_1) _inst_2 (RingHom.ringHomClass.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHom.hasCoeT.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (RingEquiv.ringEquivClass.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))))))) f)) (Bot.bot.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.hasBot.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Semiring.{u2} S] (f : RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))), Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (RingHom.ker.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (Ring.toSemiring.{u1} R _inst_1) _inst_2 (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toRingHom.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (RingEquivClass.toRingHomClass.{max u1 u2, u1, u2} (RingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) R S (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (RingEquiv.instRingEquivClassRingEquiv.{u1, u2} R S (NonUnitalNonAssocRing.toMul.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))))) f)) (Bot.bot.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.instBotSubmodule.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align ring_hom.ker_coe_equiv RingHom.ker_coe_equivₓ'. -/
@[simp]
theorem ker_coe_equiv (f : R ≃+* S) : ker (f : R →+* S) = ⊥ := by
  simpa only [← injective_iff_ker_eq_bot] using EquivLike.injective f
#align ring_hom.ker_coe_equiv RingHom.ker_coe_equiv

/- warning: ring_hom.ker_equiv -> RingHom.ker_equiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Semiring.{u2} S] {F' : Type.{u3}} [_inst_3 : RingEquivClass.{u3, u1, u2} F' R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))] (f : F'), Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (RingHom.ker.{u1, u2, u3} R S F' (Ring.toSemiring.{u1} R _inst_1) _inst_2 (RingEquivClass.toRingHomClass.{u3, u1, u2} F' R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2) _inst_3) f) (Bot.bot.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.hasBot.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : Ring.{u2} R] [_inst_2 : Semiring.{u3} S] {F' : Type.{u1}} [_inst_3 : RingEquivClass.{u1, u2, u3} F' R S (NonUnitalNonAssocRing.toMul.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))) (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_2))))] (f : F'), Eq.{succ u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (RingHom.ker.{u2, u3, u1} R S F' (Ring.toSemiring.{u2} R _inst_1) _inst_2 (RingEquivClass.toRingHomClass.{u1, u2, u3} F' R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S _inst_2) _inst_3) f) (Bot.bot.{u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Submodule.instBotSubmodule.{u2, u2} R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align ring_hom.ker_equiv RingHom.ker_equivₓ'. -/
@[simp]
theorem ker_equiv {F' : Type _} [RingEquivClass F' R S] (f : F') : ker f = ⊥ := by
  simpa only [← injective_iff_ker_eq_bot] using EquivLike.injective f
#align ring_hom.ker_equiv RingHom.ker_equiv

end Ring

section RingRing

variable {F : Type _} [Ring R] [Ring S] [rc : RingHomClass F R S] (f : F)

include rc

/- warning: ring_hom.sub_mem_ker_iff -> RingHom.sub_mem_ker_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))] (f : F) {x : R} {y : R}, Iff (Membership.Mem.{u1, u1} R (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))) x y) (RingHom.ker.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) rc f)) (Eq.{succ u2} S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) rc)))) f x) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) rc)))) f y))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : Ring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))] (f : F) {x : R} {y : R}, Iff (Membership.mem.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (SetLike.instMembership.{u2, u2} (Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)) R (Submodule.setLike.{u2, u2} R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R _inst_1)) x y) (RingHom.ker.{u2, u3, u1} R S F (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S _inst_2) rc f)) (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) x) (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)) rc))) f x) (FunLike.coe.{succ u1, succ u2, succ u3} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u2, u3} F R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u2, u3} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)) rc))) f y))
Case conversion may be inaccurate. Consider using '#align ring_hom.sub_mem_ker_iff RingHom.sub_mem_ker_iffₓ'. -/
theorem sub_mem_ker_iff {x y} : x - y ∈ ker f ↔ f x = f y := by rw [mem_ker, map_sub, sub_eq_zero]
#align ring_hom.sub_mem_ker_iff RingHom.sub_mem_ker_iff

end RingRing

/- warning: ring_hom.ker_is_prime -> RingHom.ker_isPrime is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] [_inst_3 : IsDomain.{u2} S (Ring.toSemiring.{u2} S _inst_2)] [_inst_4 : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))] (f : F), Ideal.IsPrime.{u1} R (Ring.toSemiring.{u1} R _inst_1) (RingHom.ker.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) _inst_4 f)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : Ring.{u3} S] [_inst_3 : IsDomain.{u3} S (Ring.toSemiring.{u3} S _inst_2)] [_inst_4 : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))] (f : F), Ideal.IsPrime.{u2} R (Ring.toSemiring.{u2} R _inst_1) (RingHom.ker.{u2, u3, u1} R S F (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S _inst_2) _inst_4 f)
Case conversion may be inaccurate. Consider using '#align ring_hom.ker_is_prime RingHom.ker_isPrimeₓ'. -/
/-- The kernel of a homomorphism to a domain is a prime ideal. -/
theorem ker_isPrime {F : Type _} [Ring R] [Ring S] [IsDomain S] [RingHomClass F R S] (f : F) :
    (ker f).IsPrime :=
  ⟨by
    rw [Ne.def, Ideal.eq_top_iff_one]
    exact not_one_mem_ker f, fun x y => by
    simpa only [mem_ker, map_mul] using @eq_zero_or_eq_zero_of_mul_eq_zero S _ _ _ _ _⟩
#align ring_hom.ker_is_prime RingHom.ker_isPrime

/- warning: ring_hom.ker_is_maximal_of_surjective -> RingHom.ker_isMaximal_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {K : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Field.{u2} K] [_inst_3 : RingHomClass.{u3, u1, u2} F R K (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))] (f : F), (Function.Surjective.{succ u1, succ u2} R K (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> K) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => K) (MulHomClass.toFunLike.{u3, u1, u2} F R K (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} K (NonUnitalNonAssocSemiring.toDistrib.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R K (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2)))) _inst_3)))) f)) -> (Ideal.IsMaximal.{u1} R (Ring.toSemiring.{u1} R _inst_1) (RingHom.ker.{u1, u2, u3} R K F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_2))) _inst_3 f))
but is expected to have type
  forall {R : Type.{u3}} {K : Type.{u2}} {F : Type.{u1}} [_inst_1 : Ring.{u3} R] [_inst_2 : Field.{u2} K] [_inst_3 : RingHomClass.{u1, u3, u2} F R K (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_2))))] (f : F), (Function.Surjective.{succ u3, succ u2} R K (FunLike.coe.{succ u1, succ u3, succ u2} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => K) _x) (MulHomClass.toFunLike.{u1, u3, u2} F R K (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u3, u2} F R K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u3, u2} F R K (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_2)))) _inst_3))) f)) -> (Ideal.IsMaximal.{u3} R (Ring.toSemiring.{u3} R _inst_1) (RingHom.ker.{u3, u2, u1} R K F (Ring.toSemiring.{u3} R _inst_1) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_2))) _inst_3 f))
Case conversion may be inaccurate. Consider using '#align ring_hom.ker_is_maximal_of_surjective RingHom.ker_isMaximal_of_surjectiveₓ'. -/
/-- The kernel of a homomorphism to a field is a maximal ideal. -/
theorem ker_isMaximal_of_surjective {R K F : Type _} [Ring R] [Field K] [RingHomClass F R K] (f : F)
    (hf : Function.Surjective f) : (ker f).IsMaximal :=
  by
  refine'
    ideal.is_maximal_iff.mpr
      ⟨fun h1 => one_ne_zero' K <| map_one f ▸ (mem_ker f).mp h1, fun J x hJ hxf hxJ => _⟩
  obtain ⟨y, hy⟩ := hf (f x)⁻¹
  have H : 1 = y * x - (y * x - 1) := (sub_sub_cancel _ _).symm
  rw [H]
  refine' J.sub_mem (J.mul_mem_left _ hxJ) (hJ _)
  rw [mem_ker]
  simp only [hy, map_sub, map_one, map_mul, inv_mul_cancel (mt (mem_ker f).mpr hxf), sub_self]
#align ring_hom.ker_is_maximal_of_surjective RingHom.ker_isMaximal_of_surjective

end RingHom

namespace Ideal

variable {R : Type _} {S : Type _} {F : Type _}

section Semiring

variable [Semiring R] [Semiring S] [rc : RingHomClass F R S]

include rc

/- warning: ideal.map_eq_bot_iff_le_ker -> Ideal.map_eq_bot_iff_le_ker is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] {I : Ideal.{u1} R _inst_1} (f : F), Iff (Eq.{succ u2} (Ideal.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F _inst_1 _inst_2 rc f I) (Bot.bot.{u2} (Ideal.{u2} S _inst_2) (Submodule.hasBot.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))) (LE.le.{u1} (Ideal.{u1} R _inst_1) (Preorder.toLE.{u1} (Ideal.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) I (RingHom.ker.{u1, u2, u3} R S F _inst_1 _inst_2 rc f))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u2}} {F : Type.{u1}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u1, u3, u2} F R S (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] {I : Ideal.{u3} R _inst_1} (f : F), Iff (Eq.{succ u2} (Ideal.{u2} S _inst_2) (Ideal.map.{u3, u2, u1} R S F _inst_1 _inst_2 rc f I) (Bot.bot.{u2} (Ideal.{u2} S _inst_2) (Submodule.instBotSubmodule.{u2, u2} S S _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (Semiring.toModule.{u2} S _inst_2)))) (LE.le.{u3} (Ideal.{u3} R _inst_1) (Preorder.toLE.{u3} (Ideal.{u3} R _inst_1) (PartialOrder.toPreorder.{u3} (Ideal.{u3} R _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} R _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} R _inst_1) (Submodule.completeLattice.{u3, u3} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)))))) I (RingHom.ker.{u3, u2, u1} R S F _inst_1 _inst_2 rc f))
Case conversion may be inaccurate. Consider using '#align ideal.map_eq_bot_iff_le_ker Ideal.map_eq_bot_iff_le_kerₓ'. -/
theorem map_eq_bot_iff_le_ker {I : Ideal R} (f : F) : I.map f = ⊥ ↔ I ≤ RingHom.ker f := by
  rw [RingHom.ker, eq_bot_iff, map_le_iff_le_comap]
#align ideal.map_eq_bot_iff_le_ker Ideal.map_eq_bot_iff_le_ker

/- warning: ideal.ker_le_comap -> Ideal.ker_le_comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} S _inst_2)] {K : Ideal.{u2} S _inst_2} (f : F), LE.le.{u1} (Ideal.{u1} R _inst_1) (Preorder.toLE.{u1} (Ideal.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R _inst_1) (Submodule.completeLattice.{u1, u1} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))))) (RingHom.ker.{u1, u2, u3} R S F _inst_1 _inst_2 rc f) (Ideal.comap.{u1, u2, u3} R S F _inst_1 _inst_2 rc f K)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {F : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u3} S] [rc : RingHomClass.{u1, u2, u3} F R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S _inst_2)] {K : Ideal.{u3} S _inst_2} (f : F), LE.le.{u2} (Ideal.{u2} R _inst_1) (Preorder.toLE.{u2} (Ideal.{u2} R _inst_1) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R _inst_1) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R _inst_1) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R _inst_1) (Submodule.completeLattice.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))))) (RingHom.ker.{u2, u3, u1} R S F _inst_1 _inst_2 rc f) (Ideal.comap.{u2, u3, u1} R S F _inst_1 _inst_2 rc f K)
Case conversion may be inaccurate. Consider using '#align ideal.ker_le_comap Ideal.ker_le_comapₓ'. -/
theorem ker_le_comap {K : Ideal S} (f : F) : RingHom.ker f ≤ comap f K := fun x hx =>
  mem_comap.2 (((RingHom.mem_ker f).1 hx).symm ▸ K.zero_mem)
#align ideal.ker_le_comap Ideal.ker_le_comap

end Semiring

section Ring

variable [Ring R] [Ring S] [rc : RingHomClass F R S]

include rc

/- warning: ideal.map_Inf -> Ideal.map_infₛ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))] {A : Set.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1))} {f : F}, (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) rc)))) f)) -> (forall (J : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)), (Membership.Mem.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Set.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Set.hasMem.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1))) J A) -> (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) (RingHom.ker.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) rc f) J)) -> (Eq.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Ideal.map.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) rc f (InfSet.infₛ.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.hasInf.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))) A)) (InfSet.infₛ.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.hasInf.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Set.image.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Ideal.map.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) rc f) A)))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u2}} {F : Type.{u1}} [_inst_1 : Ring.{u3} R] [_inst_2 : Ring.{u2} S] [rc : RingHomClass.{u1, u3, u2} F R S (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))] {A : Set.{u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1))} {f : F}, (Function.Surjective.{succ u3, succ u2} R S (FunLike.coe.{succ u1, succ u3, succ u2} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u3, u2} F R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u3, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u1, u3, u2} F R S (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) rc))) f)) -> (forall (J : Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)), (Membership.mem.{u3, u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (Set.{u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (Set.instMembershipSet.{u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1))) J A) -> (LE.le.{u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (Submodule.completeLattice.{u3, u3} R R (Ring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R _inst_1))))))) (RingHom.ker.{u3, u2, u1} R S F (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) rc f) J)) -> (Eq.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Ideal.map.{u3, u2, u1} R S F (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) rc f (InfSet.infₛ.{u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (Submodule.instInfSetSubmodule.{u3, u3} R R (Ring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R _inst_1))) A)) (InfSet.infₛ.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.instInfSetSubmodule.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (Set.image.{u3, u2} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Ideal.map.{u3, u2, u1} R S F (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) rc f) A)))
Case conversion may be inaccurate. Consider using '#align ideal.map_Inf Ideal.map_infₛₓ'. -/
theorem map_infₛ {A : Set (Ideal R)} {f : F} (hf : Function.Surjective f) :
    (∀ J ∈ A, RingHom.ker f ≤ J) → map f (infₛ A) = infₛ (map f '' A) :=
  by
  refine' fun h => le_antisymm (le_infₛ _) _
  · intro j hj y hy
    cases' (mem_map_iff_of_surjective f hf).1 hy with x hx
    cases' (Set.mem_image _ _ _).mp hj with J hJ
    rw [← hJ.right, ← hx.right]
    exact mem_map_of_mem f (infₛ_le_of_le hJ.left (le_of_eq rfl) hx.left)
  · intro y hy
    cases' hf y with x hx
    refine' hx ▸ mem_map_of_mem f _
    have : ∀ I ∈ A, y ∈ map f I := by simpa using hy
    rw [Submodule.mem_infₛ]
    intro J hJ
    rcases(mem_map_iff_of_surjective f hf).1 (this J hJ) with ⟨x', hx', rfl⟩
    have : x - x' ∈ J := by
      apply h J hJ
      rw [RingHom.mem_ker, map_sub, hx, sub_self]
    simpa only [sub_add_cancel] using J.add_mem this hx'
#align ideal.map_Inf Ideal.map_infₛ

/- warning: ideal.map_is_prime_of_surjective -> Ideal.map_isPrime_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))] {f : F}, (Function.Surjective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) rc)))) f)) -> (forall {I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)} [H : Ideal.IsPrime.{u1} R (Ring.toSemiring.{u1} R _inst_1) I], (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))) (RingHom.ker.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) rc f) I) -> (Ideal.IsPrime.{u2} S (Ring.toSemiring.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) rc f I)))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u2}} {F : Type.{u1}} [_inst_1 : Ring.{u3} R] [_inst_2 : Ring.{u2} S] [rc : RingHomClass.{u1, u3, u2} F R S (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))] {f : F}, (Function.Surjective.{succ u3, succ u2} R S (FunLike.coe.{succ u1, succ u3, succ u2} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u3, u2} F R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u3, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u1, u3, u2} F R S (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) rc))) f)) -> (forall {I : Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)} [H : Ideal.IsPrime.{u3} R (Ring.toSemiring.{u3} R _inst_1) I], (LE.le.{u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (Submodule.completeLattice.{u3, u3} R R (Ring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R _inst_1))))))) (RingHom.ker.{u3, u2, u1} R S F (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) rc f) I) -> (Ideal.IsPrime.{u2} S (Ring.toSemiring.{u2} S _inst_2) (Ideal.map.{u3, u2, u1} R S F (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) rc f I)))
Case conversion may be inaccurate. Consider using '#align ideal.map_is_prime_of_surjective Ideal.map_isPrime_of_surjectiveₓ'. -/
theorem map_isPrime_of_surjective {f : F} (hf : Function.Surjective f) {I : Ideal R} [H : IsPrime I]
    (hk : RingHom.ker f ≤ I) : IsPrime (map f I) :=
  by
  refine' ⟨fun h => H.ne_top (eq_top_iff.2 _), fun x y => _⟩
  · replace h := congr_arg (comap f) h
    rw [comap_map_of_surjective _ hf, comap_top] at h
    exact h ▸ sup_le (le_of_eq rfl) hk
  · refine' fun hxy => (hf x).recOn fun a ha => (hf y).recOn fun b hb => _
    rw [← ha, ← hb, ← _root_.map_mul f, mem_map_iff_of_surjective _ hf] at hxy
    rcases hxy with ⟨c, hc, hc'⟩
    rw [← sub_eq_zero, ← map_sub] at hc'
    have : a * b ∈ I :=
      by
      convert I.sub_mem hc (hk (hc' : c - a * b ∈ RingHom.ker f))
      abel
    exact
      (H.mem_or_mem this).imp (fun h => ha ▸ mem_map_of_mem f h) fun h => hb ▸ mem_map_of_mem f h
#align ideal.map_is_prime_of_surjective Ideal.map_isPrime_of_surjective

/- warning: ideal.map_eq_bot_iff_of_injective -> Ideal.map_eq_bot_iff_of_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] [rc : RingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)} {f : F}, (Function.Injective.{succ u1, succ u2} R S (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => R -> S) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F R (fun (_x : R) => S) (MulHomClass.toFunLike.{u3, u1, u2} F R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) rc)))) f)) -> (Iff (Eq.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Ideal.map.{u1, u2, u3} R S F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) rc f I) (Bot.bot.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.hasBot.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))) (Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) I (Bot.bot.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (Submodule.hasBot.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))
but is expected to have type
  forall {R : Type.{u3}} {S : Type.{u2}} {F : Type.{u1}} [_inst_1 : Ring.{u3} R] [_inst_2 : Ring.{u2} S] [rc : RingHomClass.{u1, u3, u2} F R S (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))] {I : Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)} {f : F}, (Function.Injective.{succ u3, succ u2} R S (FunLike.coe.{succ u1, succ u3, succ u2} F R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{u1, u3, u2} F R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u3, u2} F R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u1, u3, u2} F R S (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)) rc))) f)) -> (Iff (Eq.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Ideal.map.{u3, u2, u1} R S F (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) rc f I) (Bot.bot.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S _inst_2)) (Submodule.instBotSubmodule.{u2, u2} S S (Ring.toSemiring.{u2} S _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2)))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S _inst_2))))) (Eq.{succ u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)) I (Bot.bot.{u3} (Ideal.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (Submodule.instBotSubmodule.{u3, u3} R R (Ring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (Semiring.toModule.{u3} R (Ring.toSemiring.{u3} R _inst_1))))))
Case conversion may be inaccurate. Consider using '#align ideal.map_eq_bot_iff_of_injective Ideal.map_eq_bot_iff_of_injectiveₓ'. -/
theorem map_eq_bot_iff_of_injective {I : Ideal R} {f : F} (hf : Function.Injective f) :
    I.map f = ⊥ ↔ I = ⊥ := by
  rw [map_eq_bot_iff_le_ker, (RingHom.injective_iff_ker_eq_bot f).mp hf, le_bot_iff]
#align ideal.map_eq_bot_iff_of_injective Ideal.map_eq_bot_iff_of_injective

omit rc

/- warning: ideal.map_is_prime_of_equiv -> Ideal.map_isPrime_of_equiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] {F' : Type.{u3}} [_inst_3 : RingEquivClass.{u3, u1, u2} F' R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S _inst_2)) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S _inst_2))] (f : F') {I : Ideal.{u1} R (Ring.toSemiring.{u1} R _inst_1)} [_inst_4 : Ideal.IsPrime.{u1} R (Ring.toSemiring.{u1} R _inst_1) I], Ideal.IsPrime.{u2} S (Ring.toSemiring.{u2} S _inst_2) (Ideal.map.{u1, u2, u3} R S F' (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S _inst_2) (RingEquivClass.toRingHomClass.{u3, u1, u2} F' R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2)) _inst_3) f I)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : Ring.{u1} S] {F' : Type.{u3}} [_inst_3 : RingEquivClass.{u3, u2, u1} F' R S (NonUnitalNonAssocRing.toMul.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1))))) (NonUnitalNonAssocRing.toMul.{u1} S (NonUnitalRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonUnitalRing.{u1} S _inst_2))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonUnitalRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonUnitalRing.{u1} S _inst_2)))))] (f : F') {I : Ideal.{u2} R (Ring.toSemiring.{u2} R _inst_1)} [_inst_4 : Ideal.IsPrime.{u2} R (Ring.toSemiring.{u2} R _inst_1) I], Ideal.IsPrime.{u1} S (Ring.toSemiring.{u1} S _inst_2) (Ideal.map.{u2, u1, u3} R S F' (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} S _inst_2) (RingEquivClass.toRingHomClass.{u3, u2, u1} F' R S (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S _inst_2)) _inst_3) f I)
Case conversion may be inaccurate. Consider using '#align ideal.map_is_prime_of_equiv Ideal.map_isPrime_of_equivₓ'. -/
theorem map_isPrime_of_equiv {F' : Type _} [RingEquivClass F' R S] (f : F') {I : Ideal R}
    [IsPrime I] : IsPrime (map f I) :=
  map_isPrime_of_surjective (EquivLike.surjective f) <| by simp only [RingHom.ker_equiv, bot_le]
#align ideal.map_is_prime_of_equiv Ideal.map_isPrime_of_equiv

end Ring

section CommRing

variable [CommRing R] [CommRing S]

/- warning: ideal.map_eq_iff_sup_ker_eq_of_surjective -> Ideal.map_eq_iff_sup_ker_eq_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {J : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f)) -> (Iff (Eq.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Ideal.map.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (RingHom.ringHomClass.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f I) (Ideal.map.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (RingHom.ringHomClass.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f J)) (Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Sup.sup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.idemSemiring.{u1, u1} R (CommRing.toCommSemiring.{u1} R _inst_1) R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) I (RingHom.ker.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (RingHom.ringHomClass.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f)) (Sup.sup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.idemSemiring.{u1, u1} R (CommRing.toCommSemiring.{u1} R _inst_1) R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) J (RingHom.ker.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (RingHom.ringHomClass.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} S] {I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))} {J : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))} (f : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))), (Function.Surjective.{succ u2, succ u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))))) f)) -> (Iff (Eq.{succ u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Ideal.map.{u2, u1, max u2 u1} R S (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) f I) (Ideal.map.{u2, u1, max u2 u1} R S (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) f J)) (Eq.{succ u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Sup.sup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (SemilatticeSup.toSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (IdemCommSemiring.toSemilatticeSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instIdemCommSemiringIdealToSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) I (RingHom.ker.{u2, u1, max u2 u1} R S (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) f)) (Sup.sup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (SemilatticeSup.toSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (IdemCommSemiring.toSemilatticeSup.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instIdemCommSemiringIdealToSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) J (RingHom.ker.{u2, u1, max u2 u1} R S (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) f))))
Case conversion may be inaccurate. Consider using '#align ideal.map_eq_iff_sup_ker_eq_of_surjective Ideal.map_eq_iff_sup_ker_eq_of_surjectiveₓ'. -/
theorem map_eq_iff_sup_ker_eq_of_surjective {I J : Ideal R} (f : R →+* S)
    (hf : Function.Surjective f) : map f I = map f J ↔ I ⊔ f.ker = J ⊔ f.ker := by
  rw [← (comap_injective_of_surjective f hf).eq_iff, comap_map_of_surjective f hf,
    comap_map_of_surjective f hf, RingHom.ker_eq_comap_bot]
#align ideal.map_eq_iff_sup_ker_eq_of_surjective Ideal.map_eq_iff_sup_ker_eq_of_surjective

/- warning: ideal.map_radical_of_surjective -> Ideal.map_radical_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] {f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))}, (Function.Surjective.{succ u1, succ u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f)) -> (forall {I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Preorder.toLE.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (RingHom.ker.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (RingHom.ringHomClass.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f) I) -> (Eq.{succ u2} (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (Ideal.map.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)) (RingHom.ringHomClass.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f (Ideal.radical.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) I)) (Ideal.radical.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2) (Ideal.map.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)) (RingHom.ringHomClass.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f I))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u1} S] {f : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))}, (Function.Surjective.{succ u2, succ u1} R S (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))))) f)) -> (forall {I : Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))}, (LE.le.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Preorder.toLE.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))))) (RingHom.ker.{u2, u1, max u2 u1} R S (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) f) I) -> (Eq.{succ u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Ideal.map.{u2, u1, max u2 u1} R S (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) f (Ideal.radical.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1) I)) (Ideal.radical.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2) (Ideal.map.{u2, u1, max u2 u1} R S (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))) f I))))
Case conversion may be inaccurate. Consider using '#align ideal.map_radical_of_surjective Ideal.map_radical_of_surjectiveₓ'. -/
theorem map_radical_of_surjective {f : R →+* S} (hf : Function.Surjective f) {I : Ideal R}
    (h : RingHom.ker f ≤ I) : map f I.radical = (map f I).radical :=
  by
  rw [radical_eq_Inf, radical_eq_Inf]
  have : ∀ J ∈ { J : Ideal R | I ≤ J ∧ J.IsPrime }, f.ker ≤ J := fun J hJ => le_trans h hJ.left
  convert map_Inf hf this
  refine' funext fun j => propext ⟨_, _⟩
  · rintro ⟨hj, hj'⟩
    haveI : j.is_prime := hj'
    exact
      ⟨comap f j, ⟨⟨map_le_iff_le_comap.1 hj, comap_is_prime f j⟩, map_comap_of_surjective f hf j⟩⟩
  · rintro ⟨J, ⟨hJ, hJ'⟩⟩
    haveI : J.is_prime := hJ.right
    refine' ⟨hJ' ▸ map_mono hJ.left, hJ' ▸ map_is_prime_of_surjective hf (le_trans h hJ.left)⟩
#align ideal.map_radical_of_surjective Ideal.map_radical_of_surjective

end CommRing

end Ideal

namespace Submodule

variable {R : Type u} {M : Type v}

variable [CommSemiring R] [AddCommMonoid M] [Module R M]

#print Submodule.moduleSubmodule /-
-- TODO: show `[algebra R A] : algebra (ideal R) A` too
instance moduleSubmodule : Module (Ideal R) (Submodule R M)
    where
  smul_add := smul_sup
  add_smul := sup_smul
  mul_smul := Submodule.smul_assoc
  one_smul := by simp
  zero_smul := bot_smul
  smul_zero := smul_bot
#align submodule.module_submodule Submodule.moduleSubmodule
-/

end Submodule

namespace RingHom

variable {A B C : Type _} [Ring A] [Ring B] [Ring C]

variable (f : A →+* B) (f_inv : B → A)

/- warning: ring_hom.lift_of_right_inverse_aux -> RingHom.liftOfRightInverseAux is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} {C : Type.{u3}} [_inst_1 : Ring.{u1} A] [_inst_2 : Ring.{u2} B] [_inst_3 : Ring.{u3} C] (f : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (f_inv : B -> A), (Function.RightInverse.{succ u1, succ u2} A B f_inv (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f)) -> (forall (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))), (LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g)) -> (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))))
but is expected to have type
  forall {A : Type.{u1}} {B : Type.{u2}} {C : Type.{u3}} [_inst_1 : Ring.{u1} A] [_inst_2 : Ring.{u2} B] [_inst_3 : Ring.{u3} C] (f : RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (f_inv : B -> A), (Function.RightInverse.{succ u1, succ u2} A B f_inv (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))))) f)) -> (forall (g : RingHom.{u1, u3} A C (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u3} C (Ring.toSemiring.{u3} C _inst_3))), (LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u3} C (Ring.toSemiring.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.instRingHomClassRingHom.{u1, u3} A C (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u3} C (Ring.toSemiring.{u3} C _inst_3))) g)) -> (RingHom.{u2, u3} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u3} C (Ring.toSemiring.{u3} C _inst_3))))
Case conversion may be inaccurate. Consider using '#align ring_hom.lift_of_right_inverse_aux RingHom.liftOfRightInverseAuxₓ'. -/
/-- Auxiliary definition used to define `lift_of_right_inverse` -/
def liftOfRightInverseAux (hf : Function.RightInverse f_inv f) (g : A →+* C) (hg : f.ker ≤ g.ker) :
    B →+* C :=
  {
    AddMonoidHom.liftOfRightInverse f.toAddMonoidHom f_inv hf
      ⟨g.toAddMonoidHom, hg⟩ with
    toFun := fun b => g (f_inv b)
    map_one' := by
      rw [← g.map_one, ← sub_eq_zero, ← g.map_sub, ← g.mem_ker]
      apply hg
      rw [f.mem_ker, f.map_sub, sub_eq_zero, f.map_one]
      exact hf 1
    map_mul' := by
      intro x y
      rw [← g.map_mul, ← sub_eq_zero, ← g.map_sub, ← g.mem_ker]
      apply hg
      rw [f.mem_ker, f.map_sub, sub_eq_zero, f.map_mul]
      simp only [hf _] }
#align ring_hom.lift_of_right_inverse_aux RingHom.liftOfRightInverseAux

/- warning: ring_hom.lift_of_right_inverse_aux_comp_apply -> RingHom.liftOfRightInverseAux_comp_apply is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} {C : Type.{u3}} [_inst_1 : Ring.{u1} A] [_inst_2 : Ring.{u2} B] [_inst_3 : Ring.{u3} C] (f : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (f_inv : B -> A) (hf : Function.RightInverse.{succ u1, succ u2} A B f_inv (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f)) (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (hg : LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g)) (a : A), Eq.{succ u3} C (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (_x : RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => B -> C) (RingHom.hasCoeToFun.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (RingHom.liftOfRightInverseAux.{u1, u2, u3} A B C _inst_1 _inst_2 _inst_3 f f_inv hf g hg) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f a)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (_x : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => A -> C) (RingHom.hasCoeToFun.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g a)
but is expected to have type
  forall {A : Type.{u3}} {B : Type.{u2}} {C : Type.{u1}} [_inst_1 : Ring.{u3} A] [_inst_2 : Ring.{u2} B] [_inst_3 : Ring.{u1} C] (f : RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (f_inv : B -> A) (hf : Function.RightInverse.{succ u3, succ u2} A B f_inv (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))))) f)) (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (hg : LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g)) (a : A), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : B) => C) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A (fun (a : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) a) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))))) f a)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) B (fun (_x : B) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : B) => C) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) B C (NonUnitalNonAssocSemiring.toMul.{u2} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u1} C (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} C (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) B C (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} C (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)) (RingHom.instRingHomClassRingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)))))) (RingHom.liftOfRightInverseAux.{u3, u2, u1} A B C _inst_1 _inst_2 _inst_3 f f_inv hf g hg) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))))) f a)) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => C) _x) (MulHomClass.toFunLike.{max u3 u1, u3, u1} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) A C (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} C (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} C (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u1, u3, u1} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) A C (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} C (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u1, u3, u1} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)))))) g a)
Case conversion may be inaccurate. Consider using '#align ring_hom.lift_of_right_inverse_aux_comp_apply RingHom.liftOfRightInverseAux_comp_applyₓ'. -/
@[simp]
theorem liftOfRightInverseAux_comp_apply (hf : Function.RightInverse f_inv f) (g : A →+* C)
    (hg : f.ker ≤ g.ker) (a : A) : (f.liftOfRightInverseAux f_inv hf g hg) (f a) = g a :=
  f.toAddMonoidHom.liftOfRightInverse_comp_apply f_inv hf ⟨g.toAddMonoidHom, hg⟩ a
#align ring_hom.lift_of_right_inverse_aux_comp_apply RingHom.liftOfRightInverseAux_comp_apply

/- warning: ring_hom.lift_of_right_inverse -> RingHom.liftOfRightInverse is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} {C : Type.{u3}} [_inst_1 : Ring.{u1} A] [_inst_2 : Ring.{u2} B] [_inst_3 : Ring.{u3} C] (f : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (f_inv : B -> A), (Function.RightInverse.{succ u1, succ u2} A B f_inv (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f)) -> (Equiv.{max 1 (succ u1) (succ u3), max (succ u2) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))))
but is expected to have type
  forall {A : Type.{u1}} {B : Type.{u2}} {C : Type.{u3}} [_inst_1 : Ring.{u1} A] [_inst_2 : Ring.{u2} B] [_inst_3 : Ring.{u3} C] (f : RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (f_inv : B -> A), (Function.RightInverse.{succ u1, succ u2} A B f_inv (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))))) f)) -> (Equiv.{max 1 (succ u1) (succ u3), max (succ u3) (succ u2)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u3} C (Ring.toSemiring.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u3} C (Ring.toSemiring.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u3} C (Ring.toSemiring.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.instRingHomClassRingHom.{u1, u3} A C (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u3} C (Ring.toSemiring.{u3} C _inst_3))) g))) (RingHom.{u2, u3} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u3} C (Ring.toSemiring.{u3} C _inst_3))))
Case conversion may be inaccurate. Consider using '#align ring_hom.lift_of_right_inverse RingHom.liftOfRightInverseₓ'. -/
/-- `lift_of_right_inverse f hf g hg` is the unique ring homomorphism `φ`

* such that `φ.comp f = g` (`ring_hom.lift_of_right_inverse_comp`),
* where `f : A →+* B` is has a right_inverse `f_inv` (`hf`),
* and `g : B →+* C` satisfies `hg : f.ker ≤ g.ker`.

See `ring_hom.eq_lift_of_right_inverse` for the uniqueness lemma.

```
   A .
   |  \
 f |   \ g
   |    \
   v     \⌟
   B ----> C
      ∃!φ
```
-/
def liftOfRightInverse (hf : Function.RightInverse f_inv f) :
    { g : A →+* C // f.ker ≤ g.ker } ≃ (B →+* C)
    where
  toFun g := f.liftOfRightInverseAux f_inv hf g.1 g.2
  invFun φ := ⟨φ.comp f, fun x hx => (mem_ker _).mpr <| by simp [(mem_ker _).mp hx]⟩
  left_inv g := by
    ext
    simp only [comp_apply, lift_of_right_inverse_aux_comp_apply, Subtype.coe_mk, Subtype.val_eq_coe]
  right_inv φ := by
    ext b
    simp [lift_of_right_inverse_aux, hf b]
#align ring_hom.lift_of_right_inverse RingHom.liftOfRightInverse

/- warning: ring_hom.lift_of_surjective -> RingHom.liftOfSurjective is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} {C : Type.{u3}} [_inst_1 : Ring.{u1} A] [_inst_2 : Ring.{u2} B] [_inst_3 : Ring.{u3} C] (f : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))), (Function.Surjective.{succ u1, succ u2} A B (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f)) -> (Equiv.{max 1 (succ u1) (succ u3), max (succ u2) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))))
but is expected to have type
  forall {A : Type.{u1}} {B : Type.{u2}} {C : Type.{u3}} [_inst_1 : Ring.{u1} A] [_inst_2 : Ring.{u2} B] [_inst_3 : Ring.{u3} C] (f : RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))), (Function.Surjective.{succ u1, succ u2} A B (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))))) f)) -> (Equiv.{max 1 (succ u1) (succ u3), max (succ u3) (succ u2)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u3} C (Ring.toSemiring.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u3} C (Ring.toSemiring.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u1, u2} A B (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u3} C (Ring.toSemiring.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.instRingHomClassRingHom.{u1, u3} A C (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Semiring.toNonAssocSemiring.{u3} C (Ring.toSemiring.{u3} C _inst_3))) g))) (RingHom.{u2, u3} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u3} C (Ring.toSemiring.{u3} C _inst_3))))
Case conversion may be inaccurate. Consider using '#align ring_hom.lift_of_surjective RingHom.liftOfSurjectiveₓ'. -/
/-- A non-computable version of `ring_hom.lift_of_right_inverse` for when no computable right
inverse is available, that uses `function.surj_inv`. -/
@[simp]
noncomputable abbrev liftOfSurjective (hf : Function.Surjective f) :
    { g : A →+* C // f.ker ≤ g.ker } ≃ (B →+* C) :=
  f.liftOfRightInverse (Function.surjInv hf) (Function.rightInverse_surjInv hf)
#align ring_hom.lift_of_surjective RingHom.liftOfSurjective

/- warning: ring_hom.lift_of_right_inverse_comp_apply -> RingHom.liftOfRightInverse_comp_apply is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} {C : Type.{u3}} [_inst_1 : Ring.{u1} A] [_inst_2 : Ring.{u2} B] [_inst_3 : Ring.{u3} C] (f : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (f_inv : B -> A) (hf : Function.RightInverse.{succ u1, succ u2} A B f_inv (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f)) (g : Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (x : A), Eq.{succ u3} C (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (_x : RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => B -> C) (RingHom.hasCoeToFun.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (coeFn.{max 1 (max (max 1 (succ u1) (succ u3)) (succ u2) (succ u3)) (max (succ u2) (succ u3)) 1 (succ u1) (succ u3), max (max 1 (succ u1) (succ u3)) (succ u2) (succ u3)} (Equiv.{max 1 (succ u1) (succ u3), max (succ u2) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3)))) (fun (_x : Equiv.{max 1 (succ u1) (succ u3), max (succ u2) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3)))) => (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) -> (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3)))) (Equiv.hasCoeToFun.{max 1 (succ u1) (succ u3), max (succ u2) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3)))) (RingHom.liftOfRightInverse.{u1, u2, u3} A B C _inst_1 _inst_2 _inst_3 f f_inv hf) g) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f x)) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (fun (x : Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) => A -> C) (coeFnTrans.{max (succ u1) (succ u3), max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (_x : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => A -> C) (RingHom.hasCoeToFun.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (coeBaseAux.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (coeSubtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))))) g x)
but is expected to have type
  forall {A : Type.{u3}} {B : Type.{u2}} {C : Type.{u1}} [_inst_1 : Ring.{u3} A] [_inst_2 : Ring.{u2} B] [_inst_3 : Ring.{u1} C] (f : RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (f_inv : B -> A) (hf : Function.RightInverse.{succ u3, succ u2} A B f_inv (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))))) f)) (g : Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) (x : A), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : B) => C) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A (fun (a : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) a) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))))) f x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) => RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g) B (fun (_x : B) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : B) => C) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) => RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g) B C (NonUnitalNonAssocSemiring.toMul.{u2} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u1} C (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} C (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) => RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g) B C (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} C (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) => RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g) B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)) (RingHom.instRingHomClassRingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)))))) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u1), max (succ u2) (succ u1)} (Equiv.{max 1 (succ u3) (succ u1), max (succ u1) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) (RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)))) (Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) (fun (_x : Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) => RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u2) (succ u1)} (Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) (RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)))) (RingHom.liftOfRightInverse.{u3, u2, u1} A B C _inst_1 _inst_2 _inst_3 f f_inv hf) g) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))))) f x)) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) A (fun (x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => C) x) (MulHomClass.toFunLike.{max u3 u1, u3, u1} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) A C (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} C (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} C (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u1, u3, u1} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) A C (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} C (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u1, u3, u1} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)))))) (Subtype.val.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g)) g) x)
Case conversion may be inaccurate. Consider using '#align ring_hom.lift_of_right_inverse_comp_apply RingHom.liftOfRightInverse_comp_applyₓ'. -/
theorem liftOfRightInverse_comp_apply (hf : Function.RightInverse f_inv f)
    (g : { g : A →+* C // f.ker ≤ g.ker }) (x : A) :
    (f.liftOfRightInverse f_inv hf g) (f x) = g x :=
  f.liftOfRightInverseAux_comp_apply f_inv hf g.1 g.2 x
#align ring_hom.lift_of_right_inverse_comp_apply RingHom.liftOfRightInverse_comp_apply

/- warning: ring_hom.lift_of_right_inverse_comp -> RingHom.liftOfRightInverse_comp is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} {C : Type.{u3}} [_inst_1 : Ring.{u1} A] [_inst_2 : Ring.{u2} B] [_inst_3 : Ring.{u3} C] (f : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (f_inv : B -> A) (hf : Function.RightInverse.{succ u1, succ u2} A B f_inv (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f)) (g : Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))), Eq.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (RingHom.comp.{u1, u2, u3} A B C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3)) (coeFn.{max 1 (max (max 1 (succ u1) (succ u3)) (succ u2) (succ u3)) (max (succ u2) (succ u3)) 1 (succ u1) (succ u3), max (max 1 (succ u1) (succ u3)) (succ u2) (succ u3)} (Equiv.{max 1 (succ u1) (succ u3), max (succ u2) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3)))) (fun (_x : Equiv.{max 1 (succ u1) (succ u3), max (succ u2) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3)))) => (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) -> (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3)))) (Equiv.hasCoeToFun.{max 1 (succ u1) (succ u3), max (succ u2) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3)))) (RingHom.liftOfRightInverse.{u1, u2, u3} A B C _inst_1 _inst_2 _inst_3 f f_inv hf) g) f) ((fun (a : Sort.{max 1 (succ u1) (succ u3)}) (b : Sort.{max (succ u1) (succ u3)}) [self : HasLiftT.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} a b] => self.0) (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (HasLiftT.mk.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (CoeTCₓ.coe.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (coeBase.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (coeSubtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g)))))) g)
but is expected to have type
  forall {A : Type.{u3}} {B : Type.{u2}} {C : Type.{u1}} [_inst_1 : Ring.{u3} A] [_inst_2 : Ring.{u2} B] [_inst_3 : Ring.{u1} C] (f : RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (f_inv : B -> A) (hf : Function.RightInverse.{succ u3, succ u2} A B f_inv (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))))) f)) (g : Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))), Eq.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (RingHom.comp.{u3, u2, u1} A B C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u1), max (succ u2) (succ u1)} (Equiv.{max 1 (succ u3) (succ u1), max (succ u1) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) (RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)))) (Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) (fun (_x : Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) => RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u2) (succ u1)} (Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) (RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)))) (RingHom.liftOfRightInverse.{u3, u2, u1} A B C _inst_1 _inst_2 _inst_3 f f_inv hf) g) f) (Subtype.val.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g)) g)
Case conversion may be inaccurate. Consider using '#align ring_hom.lift_of_right_inverse_comp RingHom.liftOfRightInverse_compₓ'. -/
theorem liftOfRightInverse_comp (hf : Function.RightInverse f_inv f)
    (g : { g : A →+* C // f.ker ≤ g.ker }) : (f.liftOfRightInverse f_inv hf g).comp f = g :=
  RingHom.ext <| f.liftOfRightInverse_comp_apply f_inv hf g
#align ring_hom.lift_of_right_inverse_comp RingHom.liftOfRightInverse_comp

/- warning: ring_hom.eq_lift_of_right_inverse -> RingHom.eq_liftOfRightInverse is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} {C : Type.{u3}} [_inst_1 : Ring.{u1} A] [_inst_2 : Ring.{u2} B] [_inst_3 : Ring.{u3} C] (f : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (f_inv : B -> A) (hf : Function.RightInverse.{succ u1, succ u2} A B f_inv (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f)) (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (hg : LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g)) (h : RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))), (Eq.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (RingHom.comp.{u1, u2, u3} A B C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3)) h f) g) -> (Eq.{max (succ u2) (succ u3)} (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) h (coeFn.{max 1 (max (max 1 (succ u1) (succ u3)) (succ u2) (succ u3)) (max (succ u2) (succ u3)) 1 (succ u1) (succ u3), max (max 1 (succ u1) (succ u3)) (succ u2) (succ u3)} (Equiv.{max 1 (succ u1) (succ u3), max (succ u2) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3)))) (fun (_x : Equiv.{max 1 (succ u1) (succ u3), max (succ u2) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3)))) => (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) -> (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3)))) (Equiv.hasCoeToFun.{max 1 (succ u1) (succ u3), max (succ u2) (succ u3)} (Subtype.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g))) (RingHom.{u2, u3} B C (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3)))) (RingHom.liftOfRightInverse.{u1, u2, u3} A B C _inst_1 _inst_2 _inst_3 f f_inv hf) (Subtype.mk.{max (succ u1) (succ u3)} (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (fun (g : RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) => LE.le.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Preorder.toLE.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (PartialOrder.toPreorder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Ideal.{u1} A (Ring.toSemiring.{u1} A _inst_1)) (Submodule.completeLattice.{u1, u1} A A (Ring.toSemiring.{u1} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_1)))) (Semiring.toModule.{u1} A (Ring.toSemiring.{u1} A _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} A B (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.ringHomClass.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B _inst_2))) f) (RingHom.ker.{u1, u3, max u1 u3} A C (RingHom.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) (Ring.toSemiring.{u1} A _inst_1) (Ring.toSemiring.{u3} C _inst_3) (RingHom.ringHomClass.{u1, u3} A C (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A _inst_1)) (NonAssocRing.toNonAssocSemiring.{u3} C (Ring.toNonAssocRing.{u3} C _inst_3))) g)) g hg)))
but is expected to have type
  forall {A : Type.{u3}} {B : Type.{u2}} {C : Type.{u1}} [_inst_1 : Ring.{u3} A] [_inst_2 : Ring.{u2} B] [_inst_3 : Ring.{u1} C] (f : RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (f_inv : B -> A) (hf : Function.RightInverse.{succ u3, succ u2} A B f_inv (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} B (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)))))) f)) (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (hg : LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g)) (h : RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))), (Eq.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (RingHom.comp.{u3, u2, u1} A B C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)) h f) g) -> (Eq.{max (succ u2) (succ u1)} (RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) h (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u1), max (succ u2) (succ u1)} (Equiv.{max 1 (succ u3) (succ u1), max (succ u1) (succ u2)} (Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) (RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)))) (Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) (fun (_x : Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) => RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u2) (succ u1)} (Subtype.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g))) (RingHom.{u2, u1} B C (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3)))) (RingHom.liftOfRightInverse.{u3, u2, u1} A B C _inst_1 _inst_2 _inst_3 f f_inv hf) (Subtype.mk.{max (succ u3) (succ u1)} (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (fun (g : RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) => LE.le.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Preorder.toLE.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (PartialOrder.toPreorder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Ideal.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Submodule.completeLattice.{u3, u3} A A (Ring.toSemiring.{u3} A _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A _inst_1))))))) (RingHom.ker.{u3, u2, max u3 u2} A B (RingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u2} B _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} A B (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u2} B (Ring.toSemiring.{u2} B _inst_2))) f) (RingHom.ker.{u3, u1, max u3 u1} A C (RingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) (Ring.toSemiring.{u3} A _inst_1) (Ring.toSemiring.{u1} C _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} A C (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_1)) (Semiring.toNonAssocSemiring.{u1} C (Ring.toSemiring.{u1} C _inst_3))) g)) g hg)))
Case conversion may be inaccurate. Consider using '#align ring_hom.eq_lift_of_right_inverse RingHom.eq_liftOfRightInverseₓ'. -/
theorem eq_liftOfRightInverse (hf : Function.RightInverse f_inv f) (g : A →+* C)
    (hg : f.ker ≤ g.ker) (h : B →+* C) (hh : h.comp f = g) :
    h = f.liftOfRightInverse f_inv hf ⟨g, hg⟩ :=
  by
  simp_rw [← hh]
  exact ((f.lift_of_right_inverse f_inv hf).apply_symm_apply _).symm
#align ring_hom.eq_lift_of_right_inverse RingHom.eq_liftOfRightInverse

end RingHom

