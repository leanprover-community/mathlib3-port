import Mathbin.MeasureTheory.MeasurableSpaceDef 
import Mathbin.Data.Equiv.Encodable.Lattice

/-!
# Induction principles for measurable sets, related to π-systems and λ-systems.

## Main statements

* The main theorem of this file is Dynkin's π-λ theorem, which appears
  here as an induction principle `induction_on_inter`. Suppose `s` is a
  collection of subsets of `α` such that the intersection of two members
  of `s` belongs to `s` whenever it is nonempty. Let `m` be the σ-algebra
  generated by `s`. In order to check that a predicate `C` holds on every
  member of `m`, it suffices to check that `C` holds on the members of `s` and
  that `C` is preserved by complementation and *disjoint* countable
  unions.

* The proof of this theorem relies on the notion of `is_pi_system`, i.e., a collection of sets
  which is closed under binary non-empty intersections. Note that this is a small variation around
  the usual notion in the literature, which often requires that a π-system is non-empty, and closed
  also under disjoint intersections. This variation turns out to be convenient for the
  formalization.

* The proof of Dynkin's π-λ theorem also requires the notion of `dynkin_system`, i.e., a collection
  of sets which contains the empty set, is closed under complementation and under countable union
  of pairwise disjoint sets. The disjointness condition is the only difference with `σ`-algebras.

* `generate_pi_system g` gives the minimal π-system containing `g`.
  This can be considered a Galois insertion into both measurable spaces and sets.

* `generate_from_generate_pi_system_eq` proves that if you start from a collection of sets `g`,
  take the generated π-system, and then the generated σ-algebra, you get the same result as
  the σ-algebra generated from `g`. This is useful because there are connections between
  independent sets that are π-systems and the generated independent spaces.

* `mem_generate_pi_system_Union_elim` and `mem_generate_pi_system_Union_elim'` show that any
  element of the π-system generated from the union of a set of π-systems can be
  represented as the intersection of a finite number of elements from these sets.

## Implementation details

* `is_pi_system` is a predicate, not a type. Thus, we don't explicitly define the galois
  insertion, nor do we define a complete lattice. In theory, we could define a complete
  lattice and galois insertion on the subtype corresponding to `is_pi_system`.
-/


open MeasurableSpace Set

open_locale Classical

/-- A π-system is a collection of subsets of `α` that is closed under binary intersection of
  non-disjoint sets. Usually it is also required that the collection is nonempty, but we don't do
  that here. -/
def IsPiSystem {α} (C : Set (Set α)) : Prop :=
  ∀ s t (_ : s ∈ C) (_ : t ∈ C), (s ∩ t : Set α).Nonempty → s ∩ t ∈ C

namespace MeasurableSpace

theorem is_pi_system_measurable_set {α : Type _} [MeasurableSpace α] : IsPiSystem { s:Set α | MeasurableSet s } :=
  fun s t hs ht _ => hs.inter ht

end MeasurableSpace

theorem IsPiSystem.singleton {α} (S : Set α) : IsPiSystem ({S} : Set (Set α)) :=
  by 
    intro s t h_s h_t h_ne 
    rw [Set.mem_singleton_iff.1 h_s, Set.mem_singleton_iff.1 h_t, Set.inter_self, Set.mem_singleton_iff]

section Order

variable{α : Type _}{ι ι' : Sort _}[LinearOrderₓ α]

theorem is_pi_system_image_Iio (s : Set α) : IsPiSystem (Iio '' s) :=
  by 
    rintro _ _ ⟨a, ha, rfl⟩ ⟨b, hb, rfl⟩ -
    exact ⟨a⊓b, inf_ind a b ha hb, Iio_inter_Iio.symm⟩

theorem is_pi_system_Iio : IsPiSystem (range Iio : Set (Set α)) :=
  @image_univ α _ Iio ▸ is_pi_system_image_Iio univ

theorem is_pi_system_image_Ioi (s : Set α) : IsPiSystem (Ioi '' s) :=
  @is_pi_system_image_Iio (OrderDual α) _ s

theorem is_pi_system_Ioi : IsPiSystem (range Ioi : Set (Set α)) :=
  @image_univ α _ Ioi ▸ is_pi_system_image_Ioi univ

theorem is_pi_system_Ixx_mem {Ixx : α → α → Set α} {p : α → α → Prop} (Hne : ∀ {a b}, (Ixx a b).Nonempty → p a b)
  (Hi : ∀ {a₁ b₁ a₂ b₂}, Ixx a₁ b₁ ∩ Ixx a₂ b₂ = Ixx (max a₁ a₂) (min b₁ b₂)) (s t : Set α) :
  IsPiSystem { S | ∃ (l : _)(_ : l ∈ s)(u : _)(_ : u ∈ t)(hlu : p l u), Ixx l u = S } :=
  by 
    rintro _ _ ⟨l₁, hls₁, u₁, hut₁, hlu₁, rfl⟩ ⟨l₂, hls₂, u₂, hut₂, hlu₂, rfl⟩
    simp only [Hi, ←sup_eq_max, ←inf_eq_min]
    exact fun H => ⟨l₁⊔l₂, sup_ind l₁ l₂ hls₁ hls₂, u₁⊓u₂, inf_ind u₁ u₂ hut₁ hut₂, Hne H, rfl⟩

theorem is_pi_system_Ixx {Ixx : α → α → Set α} {p : α → α → Prop} (Hne : ∀ {a b}, (Ixx a b).Nonempty → p a b)
  (Hi : ∀ {a₁ b₁ a₂ b₂}, Ixx a₁ b₁ ∩ Ixx a₂ b₂ = Ixx (max a₁ a₂) (min b₁ b₂)) (f : ι → α) (g : ι' → α) :
  @IsPiSystem α { S | ∃ (i j : _)(h : p (f i) (g j)), Ixx (f i) (g j) = S } :=
  by 
    simpa only [exists_range_iff] using is_pi_system_Ixx_mem (@Hne) (@Hi) (range f) (range g)

theorem is_pi_system_Ioo_mem (s t : Set α) :
  IsPiSystem { S | ∃ (l : _)(_ : l ∈ s)(u : _)(_ : u ∈ t)(h : l < u), Ioo l u = S } :=
  is_pi_system_Ixx_mem (fun a b ⟨x, hax, hxb⟩ => hax.trans hxb) (fun _ _ _ _ => Ioo_inter_Ioo) s t

theorem is_pi_system_Ioo (f : ι → α) (g : ι' → α) :
  @IsPiSystem α { S | ∃ (l u : _)(h : f l < g u), Ioo (f l) (g u) = S } :=
  is_pi_system_Ixx (fun a b ⟨x, hax, hxb⟩ => hax.trans hxb) (fun _ _ _ _ => Ioo_inter_Ioo) f g

theorem is_pi_system_Ioc_mem (s t : Set α) :
  IsPiSystem { S | ∃ (l : _)(_ : l ∈ s)(u : _)(_ : u ∈ t)(h : l < u), Ioc l u = S } :=
  is_pi_system_Ixx_mem (fun a b ⟨x, hax, hxb⟩ => hax.trans_le hxb) (fun _ _ _ _ => Ioc_inter_Ioc) s t

theorem is_pi_system_Ioc (f : ι → α) (g : ι' → α) :
  @IsPiSystem α { S | ∃ (i j : _)(h : f i < g j), Ioc (f i) (g j) = S } :=
  is_pi_system_Ixx (fun a b ⟨x, hax, hxb⟩ => hax.trans_le hxb) (fun _ _ _ _ => Ioc_inter_Ioc) f g

theorem is_pi_system_Ico_mem (s t : Set α) :
  IsPiSystem { S | ∃ (l : _)(_ : l ∈ s)(u : _)(_ : u ∈ t)(h : l < u), Ico l u = S } :=
  is_pi_system_Ixx_mem (fun a b ⟨x, hax, hxb⟩ => hax.trans_lt hxb) (fun _ _ _ _ => Ico_inter_Ico) s t

theorem is_pi_system_Ico (f : ι → α) (g : ι' → α) :
  @IsPiSystem α { S | ∃ (i j : _)(h : f i < g j), Ico (f i) (g j) = S } :=
  is_pi_system_Ixx (fun a b ⟨x, hax, hxb⟩ => hax.trans_lt hxb) (fun _ _ _ _ => Ico_inter_Ico) f g

theorem is_pi_system_Icc_mem (s t : Set α) :
  IsPiSystem { S | ∃ (l : _)(_ : l ∈ s)(u : _)(_ : u ∈ t)(h : l ≤ u), Icc l u = S } :=
  is_pi_system_Ixx_mem (fun a b => nonempty_Icc.1) (fun _ _ _ _ => Icc_inter_Icc) s t

theorem is_pi_system_Icc (f : ι → α) (g : ι' → α) :
  @IsPiSystem α { S | ∃ (i j : _)(h : f i ≤ g j), Icc (f i) (g j) = S } :=
  is_pi_system_Ixx (fun a b => nonempty_Icc.1) (fun _ _ _ _ => Icc_inter_Icc) f g

end Order

/-- Given a collection `S` of subsets of `α`, then `generate_pi_system S` is the smallest
π-system containing `S`. -/
inductive GeneratePiSystem {α} (S : Set (Set α)) : Set (Set α)
  | base {s : Set α} (h_s : s ∈ S) : GeneratePiSystem s
  | inter {s t : Set α} (h_s : GeneratePiSystem s) (h_t : GeneratePiSystem t) (h_nonempty : (s ∩ t).Nonempty) :
  GeneratePiSystem (s ∩ t)

theorem is_pi_system_generate_pi_system {α} (S : Set (Set α)) : IsPiSystem (GeneratePiSystem S) :=
  fun s t h_s h_t h_nonempty => GeneratePiSystem.inter h_s h_t h_nonempty

theorem subset_generate_pi_system_self {α} (S : Set (Set α)) : S ⊆ GeneratePiSystem S :=
  fun s => GeneratePiSystem.base

theorem generate_pi_system_subset_self {α} {S : Set (Set α)} (h_S : IsPiSystem S) : GeneratePiSystem S ⊆ S :=
  by 
    intro x h 
    induction' h with s h_s s u h_gen_s h_gen_u h_nonempty h_s h_u
    ·
      exact h_s
    ·
      exact h_S _ _ h_s h_u h_nonempty

theorem generate_pi_system_eq {α} {S : Set (Set α)} (h_pi : IsPiSystem S) : GeneratePiSystem S = S :=
  Set.Subset.antisymm (generate_pi_system_subset_self h_pi) (subset_generate_pi_system_self S)

theorem generate_pi_system_mono {α} {S T : Set (Set α)} (hST : S ⊆ T) : GeneratePiSystem S ⊆ GeneratePiSystem T :=
  by 
    intro t ht 
    induction' ht with s h_s s u h_gen_s h_gen_u h_nonempty h_s h_u
    ·
      exact GeneratePiSystem.base (Set.mem_of_subset_of_mem hST h_s)
    ·
      exact is_pi_system_generate_pi_system T _ _ h_s h_u h_nonempty

theorem generate_pi_system_measurable_set {α} [M : MeasurableSpace α] {S : Set (Set α)}
  (h_meas_S : ∀ s (_ : s ∈ S), MeasurableSet s) (t : Set α) (h_in_pi : t ∈ GeneratePiSystem S) : MeasurableSet t :=
  by 
    induction' h_in_pi with s h_s s u h_gen_s h_gen_u h_nonempty h_s h_u
    ·
      apply h_meas_S _ h_s
    ·
      apply MeasurableSet.inter h_s h_u

theorem generate_from_measurable_set_of_generate_pi_system {α} {g : Set (Set α)} (t : Set α)
  (ht : t ∈ GeneratePiSystem g) : (generate_from g).MeasurableSet' t :=
  @generate_pi_system_measurable_set α (generate_from g) g (fun s h_s_in_g => measurable_set_generate_from h_s_in_g) t
    ht

theorem generate_from_generate_pi_system_eq {α} {g : Set (Set α)} :
  generate_from (GeneratePiSystem g) = generate_from g :=
  by 
    apply le_antisymmₓ <;> apply generate_from_le
    ·
      exact fun t h_t => generate_from_measurable_set_of_generate_pi_system t h_t
    ·
      exact fun t h_t => measurable_set_generate_from (GeneratePiSystem.base h_t)

-- error in MeasureTheory.PiSystem: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem mem_generate_pi_system_Union_elim
{α β}
{g : β → set (set α)}
(h_pi : ∀ b, is_pi_system (g b))
(t : set α)
(h_t : «expr ∈ »(t, generate_pi_system «expr⋃ , »((b), g b))) : «expr∃ , »((T : finset β)
 (f : β → set α), «expr ∧ »(«expr = »(t, «expr⋂ , »((b «expr ∈ » T), f b)), ∀ b «expr ∈ » T, «expr ∈ »(f b, g b))) :=
begin
  induction [expr h_t] [] ["with", ident s, ident h_s, ident s, ident t', ident h_gen_s, ident h_gen_t', ident h_nonempty, ident h_s, ident h_t'] [],
  { rcases [expr h_s, "with", "⟨", ident t', ",", "⟨", "⟨", ident b, ",", ident rfl, "⟩", ",", ident h_s_in_t', "⟩", "⟩"],
    refine [expr ⟨{b}, λ _, s, _⟩],
    simpa [] [] [] [] [] ["using", expr h_s_in_t'] },
  { rcases [expr h_t', "with", "⟨", ident T_t', ",", "⟨", ident f_t', ",", "⟨", ident rfl, ",", ident h_t', "⟩", "⟩", "⟩"],
    rcases [expr h_s, "with", "⟨", ident T_s, ",", "⟨", ident f_s, ",", "⟨", ident rfl, ",", ident h_s, "⟩", "⟩", "⟩"],
    use ["[", expr «expr ∪ »(T_s, T_t'), ",", expr λ
     b : β, if «expr ∈ »(b, T_s) then if «expr ∈ »(b, T_t') then «expr ∩ »(f_s b, f_t' b) else f_s b else if «expr ∈ »(b, T_t') then f_t' b else («expr∅»() : set α), "]"],
    split,
    { ext [] [ident a] [],
      simp_rw ["[", expr set.mem_inter_iff, ",", expr set.mem_Inter, ",", expr finset.mem_union, ",", expr or_imp_distrib, "]"] [],
      rw ["<-", expr forall_and_distrib] [],
      split; intros [ident h1, ident b]; by_cases [expr hbs, ":", expr «expr ∈ »(b, T_s)]; by_cases [expr hbt, ":", expr «expr ∈ »(b, T_t')]; specialize [expr h1 b]; simp [] [] ["only"] ["[", expr hbs, ",", expr hbt, ",", expr if_true, ",", expr if_false, ",", expr true_implies_iff, ",", expr and_self, ",", expr false_implies_iff, ",", expr and_true, ",", expr true_and, "]"] [] ["at", ident h1, "⊢"],
      all_goals { exact [expr h1] } },
    intros [ident b, ident h_b],
    split_ifs [] ["with", ident hbs, ident hbt, ident hbt],
    { refine [expr h_pi b (f_s b) (f_t' b) (h_s b hbs) (h_t' b hbt) (set.nonempty.mono _ h_nonempty)],
      exact [expr set.inter_subset_inter (set.bInter_subset_of_mem hbs) (set.bInter_subset_of_mem hbt)] },
    { exact [expr h_s b hbs] },
    { exact [expr h_t' b hbt] },
    { rw [expr finset.mem_union] ["at", ident h_b],
      apply [expr false.elim (h_b.elim hbs hbt)] } }
end

-- error in MeasureTheory.PiSystem: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem mem_generate_pi_system_Union_elim'
{α β}
{g : β → set (set α)}
{s : set β}
(h_pi : ∀ b «expr ∈ » s, is_pi_system (g b))
(t : set α)
(h_t : «expr ∈ »(t, generate_pi_system «expr⋃ , »((b «expr ∈ » s), g b))) : «expr∃ , »((T : finset β)
 (f : β → set α), «expr ∧ »(«expr ⊆ »(«expr↑ »(T), s), «expr ∧ »(«expr = »(t, «expr⋂ , »((b «expr ∈ » T), f b)), ∀
   b «expr ∈ » T, «expr ∈ »(f b, g b)))) :=
begin
  have [] [":", expr «expr ∈ »(t, generate_pi_system «expr⋃ , »((b : subtype s), «expr ∘ »(g, subtype.val) b))] [],
  { suffices [ident h1] [":", expr «expr = »(«expr⋃ , »((b : subtype s), «expr ∘ »(g, subtype.val) b), «expr⋃ , »((b)
       (H : «expr ∈ »(b, s)), g b))],
    by rwa [expr h1] [],
    ext [] [ident x] [],
    simp [] [] ["only"] ["[", expr exists_prop, ",", expr set.mem_Union, ",", expr function.comp_app, ",", expr subtype.exists, ",", expr subtype.coe_mk, "]"] [] [],
    refl },
  rcases [expr @mem_generate_pi_system_Union_elim α (subtype s) «expr ∘ »(g, subtype.val) (λ
    b, h_pi b.val b.property) t this, "with", "⟨", ident T, ",", "⟨", ident f, ",", "⟨", ident rfl, ",", ident h_t', "⟩", "⟩", "⟩"],
  refine [expr ⟨T.image subtype.val, function.extend subtype.val f (λ
     b : β, («expr∅»() : set α)), by simp [] [] [] [] [] [], _, _⟩],
  { ext [] [ident a] [],
    split; { simp [] [] ["only"] ["[", expr set.mem_Inter, ",", expr subtype.forall, ",", expr finset.set_bInter_finset_image, "]"] [] [],
      intros [ident h1, ident b, ident h_b, ident h_b_in_T],
      have [ident h2] [] [":=", expr h1 b h_b h_b_in_T],
      revert [ident h2],
      rw [expr function.extend_apply subtype.val_injective] [],
      apply [expr id] } },
  { intros [ident b, ident h_b],
    simp_rw ["[", expr finset.mem_image, ",", expr exists_prop, ",", expr subtype.exists, ",", expr exists_and_distrib_right, ",", expr exists_eq_right, "]"] ["at", ident h_b],
    cases [expr h_b] [],
    have [ident h_b_alt] [":", expr «expr = »(b, (subtype.mk b h_b_w).val)] [":=", expr rfl],
    rw ["[", expr h_b_alt, ",", expr function.extend_apply subtype.val_injective, "]"] [],
    apply [expr h_t'],
    apply [expr h_b_h] }
end

namespace MeasurableSpace

variable{α : Type _}

/-- A Dynkin system is a collection of subsets of a type `α` that contains the empty set,
  is closed under complementation and under countable union of pairwise disjoint sets.
  The disjointness condition is the only difference with `σ`-algebras.

  The main purpose of Dynkin systems is to provide a powerful induction rule for σ-algebras
  generated by a collection of sets which is stable under intersection.

  A Dynkin system is also known as a "λ-system" or a "d-system".
-/
structure dynkin_system(α : Type _) where 
  Has : Set α → Prop 
  has_empty : has ∅
  HasCompl : ∀ {a}, has a → has («expr ᶜ» a)
  has_Union_nat : ∀ {f : ℕ → Set α}, Pairwise (Disjoint on f) → (∀ i, has (f i)) → has (⋃i, f i)

namespace DynkinSystem

@[ext]
theorem ext : ∀ {d₁ d₂ : dynkin_system α}, (∀ (s : Set α), d₁.has s ↔ d₂.has s) → d₁ = d₂
| ⟨s₁, _, _, _⟩, ⟨s₂, _, _, _⟩, h =>
  have  : s₁ = s₂ := funext$ fun x => propext$ h x 
  by 
    subst this

variable(d : dynkin_system α)

theorem has_compl_iff {a} : d.has («expr ᶜ» a) ↔ d.has a :=
  ⟨fun h =>
      by 
        simpa using d.has_compl h,
    fun h => d.has_compl h⟩

theorem has_univ : d.has univ :=
  by 
    simpa using d.has_compl d.has_empty

theorem has_Union {β} [Encodable β] {f : β → Set α} (hd : Pairwise (Disjoint on f)) (h : ∀ i, d.has (f i)) :
  d.has (⋃i, f i) :=
  by 
    rw [←Encodable.Union_decode₂]
    exact d.has_Union_nat (Encodable.Union_decode₂_disjoint_on hd) fun n => Encodable.Union_decode₂_cases d.has_empty h

theorem HasUnion {s₁ s₂ : Set α} (h₁ : d.has s₁) (h₂ : d.has s₂) (h : s₁ ∩ s₂ ⊆ ∅) : d.has (s₁ ∪ s₂) :=
  by 
    rw [union_eq_Union]
    exact d.has_Union (pairwise_disjoint_on_bool.2 h) (Bool.forall_bool.2 ⟨h₂, h₁⟩)

theorem has_diff {s₁ s₂ : Set α} (h₁ : d.has s₁) (h₂ : d.has s₂) (h : s₂ ⊆ s₁) : d.has (s₁ \ s₂) :=
  by 
    apply d.has_compl_iff.1
    simp [diff_eq, compl_inter]
    exact d.has_union (d.has_compl h₁) h₂ fun x ⟨h₁, h₂⟩ => h₁ (h h₂)

instance  : LE (dynkin_system α) :=
  { le := fun m₁ m₂ => m₁.has ≤ m₂.has }

theorem le_def {α} {a b : dynkin_system α} : a ≤ b ↔ a.has ≤ b.has :=
  Iff.rfl

instance  : PartialOrderₓ (dynkin_system α) :=
  { dynkin_system.has_le with le_refl := fun a b => le_reflₓ _,
    le_trans := fun a b c hab hbc => le_def.mpr (le_transₓ hab hbc),
    le_antisymm := fun a b h₁ h₂ => ext$ fun s => ⟨h₁ s, h₂ s⟩ }

/-- Every measurable space (σ-algebra) forms a Dynkin system -/
def of_measurable_space (m : MeasurableSpace α) : dynkin_system α :=
  { Has := m.measurable_set', has_empty := m.measurable_set_empty, HasCompl := m.measurable_set_compl,
    has_Union_nat := fun f _ hf => m.measurable_set_Union f hf }

theorem of_measurable_space_le_of_measurable_space_iff {m₁ m₂ : MeasurableSpace α} :
  of_measurable_space m₁ ≤ of_measurable_space m₂ ↔ m₁ ≤ m₂ :=
  Iff.rfl

/-- The least Dynkin system containing a collection of basic sets.
  This inductive type gives the underlying collection of sets. -/
inductive generate_has (s : Set (Set α)) : Set α → Prop
  | basic : ∀ t (_ : t ∈ s), generate_has t
  | Empty : generate_has ∅
  | compl : ∀ {a}, generate_has a → generate_has («expr ᶜ» a)
  | Union : ∀ {f : ℕ → Set α}, Pairwise (Disjoint on f) → (∀ i, generate_has (f i)) → generate_has (⋃i, f i)

theorem generate_has_compl {C : Set (Set α)} {s : Set α} : generate_has C («expr ᶜ» s) ↔ generate_has C s :=
  by 
    refine' ⟨_, generate_has.compl⟩
    intro h 
    convert generate_has.compl h 
    simp 

/-- The least Dynkin system containing a collection of basic sets. -/
def generate (s : Set (Set α)) : dynkin_system α :=
  { Has := generate_has s, has_empty := generate_has.empty, HasCompl := fun a => generate_has.compl,
    has_Union_nat := fun f => generate_has.Union }

theorem generate_has_def {C : Set (Set α)} : (generate C).Has = generate_has C :=
  rfl

instance  : Inhabited (dynkin_system α) :=
  ⟨generate univ⟩

/-- If a Dynkin system is closed under binary intersection, then it forms a `σ`-algebra. -/
def to_measurable_space (h_inter : ∀ s₁ s₂, d.has s₁ → d.has s₂ → d.has (s₁ ∩ s₂)) :=
  { MeasurableSet' := d.has, measurable_set_empty := d.has_empty, measurable_set_compl := fun s h => d.has_compl h,
    measurable_set_Union :=
      fun f hf =>
        by 
          rw [←Union_disjointed]
          exact
            d.has_Union (disjoint_disjointed _)
              fun n => disjointedRecₓ (fun t i h => h_inter _ _ h$ d.has_compl$ hf i) (hf n) }

theorem of_measurable_space_to_measurable_space (h_inter : ∀ s₁ s₂, d.has s₁ → d.has s₂ → d.has (s₁ ∩ s₂)) :
  of_measurable_space (d.to_measurable_space h_inter) = d :=
  ext$ fun s => Iff.rfl

/-- If `s` is in a Dynkin system `d`, we can form the new Dynkin system `{s ∩ t | t ∈ d}`. -/
def restrict_on {s : Set α} (h : d.has s) : dynkin_system α :=
  { Has := fun t => d.has (t ∩ s),
    has_empty :=
      by 
        simp [d.has_empty],
    HasCompl :=
      fun t hts =>
        have  : «expr ᶜ» t ∩ s = «expr ᶜ» (t ∩ s) \ «expr ᶜ» s :=
          Set.ext$
            fun x =>
              by 
                byCases' x ∈ s <;> simp [h]
        by 
          rw [this]
          exact d.has_diff (d.has_compl hts) (d.has_compl h) (compl_subset_compl.mpr$ inter_subset_right _ _),
    has_Union_nat :=
      fun f hd hf =>
        by 
          rw [inter_comm, inter_Union]
          apply d.has_Union_nat
          ·
            exact fun i j h x ⟨⟨_, h₁⟩, _, h₂⟩ => hd i j h ⟨h₁, h₂⟩
          ·
            simpa [inter_comm] using hf }

theorem generate_le {s : Set (Set α)} (h : ∀ t (_ : t ∈ s), d.has t) : generate s ≤ d :=
  fun t ht => ht.rec_on h d.has_empty (fun a _ h => d.has_compl h) fun f hd _ hf => d.has_Union hd hf

theorem generate_has_subset_generate_measurable {C : Set (Set α)} {s : Set α} (hs : (generate C).Has s) :
  (generate_from C).MeasurableSet' s :=
  generate_le (of_measurable_space (generate_from C)) (fun t => measurable_set_generate_from) s hs

theorem generate_inter {s : Set (Set α)} (hs : IsPiSystem s) {t₁ t₂ : Set α} (ht₁ : (generate s).Has t₁)
  (ht₂ : (generate s).Has t₂) : (generate s).Has (t₁ ∩ t₂) :=
  have  : generate s ≤ (generate s).restrictOn ht₂ :=
    generate_le _$
      fun s₁ hs₁ =>
        have  : (generate s).Has s₁ := generate_has.basic s₁ hs₁ 
        have  : generate s ≤ (generate s).restrictOn this :=
          generate_le _$
            fun s₂ hs₂ =>
              show (generate s).Has (s₂ ∩ s₁) from
                (s₂ ∩ s₁).eq_empty_or_nonempty.elim (fun h => h.symm ▸ generate_has.empty)
                  fun h => generate_has.basic _ (hs _ _ hs₂ hs₁ h)
        have  : (generate s).Has (t₂ ∩ s₁) := this _ ht₂ 
        show (generate s).Has (s₁ ∩ t₂)by 
          rwa [inter_comm]
  this _ ht₁

/--
  **Dynkin's π-λ theorem**:
  Given a collection of sets closed under binary intersections, then the Dynkin system it
  generates is equal to the σ-algebra it generates.
  This result is known as the π-λ theorem.
  A collection of sets closed under binary intersection is called a π-system (often requiring
  additionnally that is is non-empty, but we drop this condition in the formalization).
-/
theorem generate_from_eq {s : Set (Set α)} (hs : IsPiSystem s) :
  generate_from s = (generate s).toMeasurableSpace fun t₁ t₂ => generate_inter hs :=
  le_antisymmₓ (generate_from_le$ fun t ht => generate_has.basic t ht)
    (of_measurable_space_le_of_measurable_space_iff.mp$
      by 
        rw [of_measurable_space_to_measurable_space]
        exact generate_le _$ fun t ht => measurable_set_generate_from ht)

end DynkinSystem

theorem induction_on_inter {C : Set α → Prop} {s : Set (Set α)} [m : MeasurableSpace α] (h_eq : m = generate_from s)
  (h_inter : IsPiSystem s) (h_empty : C ∅) (h_basic : ∀ t (_ : t ∈ s), C t)
  (h_compl : ∀ t, MeasurableSet t → C t → C («expr ᶜ» t))
  (h_union : ∀ (f : ℕ → Set α), Pairwise (Disjoint on f) → (∀ i, MeasurableSet (f i)) → (∀ i, C (f i)) → C (⋃i, f i)) :
  ∀ ⦃t⦄, MeasurableSet t → C t :=
  have eq : MeasurableSet = dynkin_system.generate_has s :=
    by 
      rw [h_eq, dynkin_system.generate_from_eq h_inter]
      rfl 
  fun t ht =>
    have  : dynkin_system.generate_has s t :=
      by 
        rwa [Eq] at ht 
    this.rec_on h_basic h_empty
      (fun t ht =>
        h_compl t$
          by 
            rw [Eq]
            exact ht)
      fun f hf ht =>
        h_union f hf$
          fun i =>
            by 
              rw [Eq]
              exact ht _

end MeasurableSpace

