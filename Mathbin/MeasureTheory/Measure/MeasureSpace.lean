/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro

! This file was ported from Lean 3 source module measure_theory.measure.measure_space
! leanprover-community/mathlib commit 343e80208d29d2d15f8050b929aa50fe4ce71b55
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.MeasureTheory.Measure.NullMeasurable
import Mathbin.MeasureTheory.MeasurableSpace
import Mathbin.Topology.Algebra.Order.LiminfLimsup

/-!
# Measure spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

The definition of a measure and a measure space are in `measure_theory.measure_space_def`, with
only a few basic properties. This file provides many more properties of these objects.
This separation allows the measurability tactic to import only the file `measure_space_def`, and to
be available in `measure_space` (through `measurable_space`).

Given a measurable space `Œ±`, a measure on `Œ±` is a function that sends measurable sets to the
extended nonnegative reals that satisfies the following conditions:
1. `Œº ‚àÖ = 0`;
2. `Œº` is countably additive. This means that the measure of a countable union of pairwise disjoint
   sets is equal to the measure of the individual sets.

Every measure can be canonically extended to an outer measure, so that it assigns values to
all subsets, not just the measurable subsets. On the other hand, a measure that is countably
additive on measurable sets can be restricted to measurable sets to obtain a measure.
In this file a measure is defined to be an outer measure that is countably additive on
measurable sets, with the additional assumption that the outer measure is the canonical
extension of the restricted measure.

Measures on `Œ±` form a complete lattice, and are closed under scalar multiplication with `‚Ñù‚â•0‚àû`.

We introduce the following typeclasses for measures:

* `is_probability_measure Œº`: `Œº univ = 1`;
* `is_finite_measure Œº`: `Œº univ < ‚àû`;
* `sigma_finite Œº`: there exists a countable collection of sets that cover `univ`
  where `Œº` is finite;
* `is_locally_finite_measure Œº` : `‚àÄ x, ‚àÉ s ‚àà ùìù x, Œº s < ‚àû`;
* `has_no_atoms Œº` : `‚àÄ x, Œº {x} = 0`; possibly should be redefined as
  `‚àÄ s, 0 < Œº s ‚Üí ‚àÉ t ‚äÜ s, 0 < Œº t ‚àß Œº t < Œº s`.

Given a measure, the null sets are the sets where `Œº s = 0`, where `Œº` denotes the corresponding
outer measure (so `s` might not be measurable). We can then define the completion of `Œº` as the
measure on the least `œÉ`-algebra that also contains all null sets, by defining the measure to be `0`
on the null sets.

## Main statements

* `completion` is the completion of a measure to all null measurable sets.
* `measure.of_measurable` and `outer_measure.to_measure` are two important ways to define a measure.

## Implementation notes

Given `Œº : measure Œ±`, `Œº s` is the value of the *outer measure* applied to `s`.
This conveniently allows us to apply the measure to sets without proving that they are measurable.
We get countable subadditivity for all sets, but only countable additivity for measurable sets.

You often don't want to define a measure via its constructor.
Two ways that are sometimes more convenient:
* `measure.of_measurable` is a way to define a measure by only giving its value on measurable sets
  and proving the properties (1) and (2) mentioned above.
* `outer_measure.to_measure` is a way of obtaining a measure from an outer measure by showing that
  all measurable sets in the measurable space are Carath√©odory measurable.

To prove that two measures are equal, there are multiple options:
* `ext`: two measures are equal if they are equal on all measurable sets.
* `ext_of_generate_from_of_Union`: two measures are equal if they are equal on a œÄ-system generating
  the measurable sets, if the œÄ-system contains a spanning increasing sequence of sets where the
  measures take finite value (in particular the measures are œÉ-finite). This is a special case of
  the more general `ext_of_generate_from_of_cover`
* `ext_of_generate_finite`: two finite measures are equal if they are equal on a œÄ-system
  generating the measurable sets. This is a special case of `ext_of_generate_from_of_Union` using
  `C ‚à™ {univ}`, but is easier to work with.

A `measure_space` is a class that is a measurable space with a canonical measure.
The measure is denoted `volume`.

## References

* <https://en.wikipedia.org/wiki/Measure_(mathematics)>
* <https://en.wikipedia.org/wiki/Complete_measure>
* <https://en.wikipedia.org/wiki/Almost_everywhere>

## Tags

measure, almost everywhere, measure space, completion, null set, null measurable set
-/


noncomputable section

open Set

open Filter hiding map

open Function MeasurableSpace

open TopologicalSpace (SecondCountableTopology)

open Classical Topology BigOperators Filter ENNReal NNReal Interval MeasureTheory

variable {Œ± Œ≤ Œ≥ Œ¥ Œπ R R' : Type _}

namespace MeasureTheory

section

variable {m : MeasurableSpace Œ±} {Œº Œº‚ÇÅ Œº‚ÇÇ : Measure Œ±} {s s‚ÇÅ s‚ÇÇ t : Set Œ±}

#print MeasureTheory.ae_isMeasurablyGenerated /-
instance ae_isMeasurablyGenerated : IsMeasurablyGenerated Œº.ae :=
  ‚ü®fun s hs =>
    let ‚ü®t, hst, htm, htŒº‚ü© := exists_measurable_superset_of_null hs
    ‚ü®t·∂ú, compl_mem_ae_iff.2 htŒº, htm.compl, compl_subset_comm.1 hst‚ü©‚ü©
#align measure_theory.ae_is_measurably_generated MeasureTheory.ae_isMeasurablyGenerated
-/

#print MeasureTheory.ae_uIoc_iff /-
/-- See also `measure_theory.ae_restrict_uIoc_iff`. -/
theorem ae_uIoc_iff [LinearOrder Œ±] {a b : Œ±} {P : Œ± ‚Üí Prop} :
    (‚àÄ·µê x ‚àÇŒº, x ‚àà Œô a b ‚Üí P x) ‚Üî (‚àÄ·µê x ‚àÇŒº, x ‚àà Ioc a b ‚Üí P x) ‚àß ‚àÄ·µê x ‚àÇŒº, x ‚àà Ioc b a ‚Üí P x := by
  simp only [uIoc_eq_union, mem_union, or_imp, eventually_and]
#align measure_theory.ae_uIoc_iff MeasureTheory.ae_uIoc_iff
-/

/- warning: measure_theory.measure_union -> MeasureTheory.measure_union is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±}, (Disjoint.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±))) s‚ÇÅ s‚ÇÇ) -> (MeasurableSet.{u1} Œ± m s‚ÇÇ) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) s‚ÇÅ s‚ÇÇ)) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÅ) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÇ)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±}, (Disjoint.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) s‚ÇÅ s‚ÇÇ) -> (MeasurableSet.{u1} Œ± m s‚ÇÇ) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) s‚ÇÅ s‚ÇÇ)) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÅ) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÇ)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_union MeasureTheory.measure_union‚Çì'. -/
theorem measure_union (hd : Disjoint s‚ÇÅ s‚ÇÇ) (h : MeasurableSet s‚ÇÇ) : Œº (s‚ÇÅ ‚à™ s‚ÇÇ) = Œº s‚ÇÅ + Œº s‚ÇÇ :=
  measure_union‚ÇÄ h.NullMeasurableSet hd.AEDisjoint
#align measure_theory.measure_union MeasureTheory.measure_union

/- warning: measure_theory.measure_union' -> MeasureTheory.measure_union' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±}, (Disjoint.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±))) s‚ÇÅ s‚ÇÇ) -> (MeasurableSet.{u1} Œ± m s‚ÇÅ) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) s‚ÇÅ s‚ÇÇ)) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÅ) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÇ)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±}, (Disjoint.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) s‚ÇÅ s‚ÇÇ) -> (MeasurableSet.{u1} Œ± m s‚ÇÅ) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) s‚ÇÅ s‚ÇÇ)) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÅ) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÇ)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_union' MeasureTheory.measure_union'‚Çì'. -/
theorem measure_union' (hd : Disjoint s‚ÇÅ s‚ÇÇ) (h : MeasurableSet s‚ÇÅ) : Œº (s‚ÇÅ ‚à™ s‚ÇÇ) = Œº s‚ÇÅ + Œº s‚ÇÇ :=
  measure_union‚ÇÄ' h.NullMeasurableSet hd.AEDisjoint
#align measure_theory.measure_union' MeasureTheory.measure_union'

/- warning: measure_theory.measure_inter_add_diff -> MeasureTheory.measure_inter_add_diff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {t : Set.{u1} Œ±} (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m t) -> (Eq.{1} ENNReal (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s t)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (SDiff.sdiff.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasSdiff.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s t))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {t : Set.{u1} Œ±} (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m t) -> (Eq.{1} ENNReal (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s t)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (SDiff.sdiff.{u1} (Set.{u1} Œ±) (Set.instSDiffSet.{u1} Œ±) s t))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_inter_add_diff MeasureTheory.measure_inter_add_diff‚Çì'. -/
theorem measure_inter_add_diff (s : Set Œ±) (ht : MeasurableSet t) : Œº (s ‚à© t) + Œº (s \ t) = Œº s :=
  measure_inter_add_diff‚ÇÄ _ ht.NullMeasurableSet
#align measure_theory.measure_inter_add_diff MeasureTheory.measure_inter_add_diff

/- warning: measure_theory.measure_diff_add_inter -> MeasureTheory.measure_diff_add_inter is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {t : Set.{u1} Œ±} (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m t) -> (Eq.{1} ENNReal (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (SDiff.sdiff.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasSdiff.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s t)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s t))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {t : Set.{u1} Œ±} (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m t) -> (Eq.{1} ENNReal (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (SDiff.sdiff.{u1} (Set.{u1} Œ±) (Set.instSDiffSet.{u1} Œ±) s t)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s t))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_diff_add_inter MeasureTheory.measure_diff_add_inter‚Çì'. -/
theorem measure_diff_add_inter (s : Set Œ±) (ht : MeasurableSet t) : Œº (s \ t) + Œº (s ‚à© t) = Œº s :=
  (add_comm _ _).trans (measure_inter_add_diff s ht)
#align measure_theory.measure_diff_add_inter MeasureTheory.measure_diff_add_inter

/- warning: measure_theory.measure_union_add_inter -> MeasureTheory.measure_union_add_inter is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {t : Set.{u1} Œ±} (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m t) -> (Eq.{1} ENNReal (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) s t)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s t))) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº t)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {t : Set.{u1} Œ±} (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m t) -> (Eq.{1} ENNReal (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) s t)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s t))) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) t)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_union_add_inter MeasureTheory.measure_union_add_inter‚Çì'. -/
theorem measure_union_add_inter (s : Set Œ±) (ht : MeasurableSet t) :
    Œº (s ‚à™ t) + Œº (s ‚à© t) = Œº s + Œº t :=
  by
  rw [‚Üê measure_inter_add_diff (s ‚à™ t) ht, Set.union_inter_cancel_right, union_diff_right, ‚Üê
    measure_inter_add_diff s ht]
  ac_rfl
#align measure_theory.measure_union_add_inter MeasureTheory.measure_union_add_inter

/- warning: measure_theory.measure_union_add_inter' -> MeasureTheory.measure_union_add_inter' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m s) -> (forall (t : Set.{u1} Œ±), Eq.{1} ENNReal (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) s t)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s t))) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº t)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m s) -> (forall (t : Set.{u1} Œ±), Eq.{1} ENNReal (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) s t)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s t))) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) t)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_union_add_inter' MeasureTheory.measure_union_add_inter'‚Çì'. -/
theorem measure_union_add_inter' (hs : MeasurableSet s) (t : Set Œ±) :
    Œº (s ‚à™ t) + Œº (s ‚à© t) = Œº s + Œº t := by
  rw [union_comm, inter_comm, measure_union_add_inter t hs, add_comm]
#align measure_theory.measure_union_add_inter' MeasureTheory.measure_union_add_inter'

/- warning: measure_theory.measure_add_measure_compl -> MeasureTheory.measure_add_measure_compl is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m s) -> (Eq.{1} ENNReal (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.univ.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m s) -> (Eq.{1} ENNReal (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) s))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.univ.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_add_measure_compl MeasureTheory.measure_add_measure_compl‚Çì'. -/
theorem measure_add_measure_compl (h : MeasurableSet s) : Œº s + Œº (s·∂ú) = Œº univ :=
  measure_add_measure_compl‚ÇÄ h.NullMeasurableSet
#align measure_theory.measure_add_measure_compl MeasureTheory.measure_add_measure_compl

/- warning: measure_theory.measure_bUnion‚ÇÄ -> MeasureTheory.measure_bunion·µ¢‚ÇÄ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u2} Œ≤} {f : Œ≤ -> (Set.{u1} Œ±)}, (Set.Countable.{u2} Œ≤ s) -> (Set.Pairwise.{u2} Œ≤ s (Function.onFun.{succ u2, succ u1, 1} Œ≤ (Set.{u1} Œ±) Prop (MeasureTheory.AEDisjoint.{u1} Œ± m Œº) f)) -> (forall (b : Œ≤), (Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) b s) -> (MeasureTheory.NullMeasurableSet.{u1} Œ± m (f b) Œº)) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.union·µ¢.{u1, succ u2} Œ± Œ≤ (fun (b : Œ≤) => Set.union·µ¢.{u1, 0} Œ± (Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) b s) (fun (H : Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) b s) => f b)))) (tsum.{0, u2} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace (coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) (fun (p : coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) Œ≤ (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) Œ≤ (CoeTC‚Çì.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) Œ≤ (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) Œ≤ (coeSubtype.{succ u2} Œ≤ (fun (x : Œ≤) => Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) x s))))) p)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u2} Œ≤} {f : Œ≤ -> (Set.{u1} Œ±)}, (Set.Countable.{u2} Œ≤ s) -> (Set.Pairwise.{u2} Œ≤ s (Function.onFun.{succ u2, succ u1, 1} Œ≤ (Set.{u1} Œ±) Prop (MeasureTheory.AEDisjoint.{u1} Œ± m Œº) f)) -> (forall (b : Œ≤), (Membership.mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instMembershipSet.{u2} Œ≤) b s) -> (MeasureTheory.NullMeasurableSet.{u1} Œ± m (f b) Œº)) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.union·µ¢.{u1, succ u2} Œ± Œ≤ (fun (b : Œ≤) => Set.union·µ¢.{u1, 0} Œ± (Membership.mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instMembershipSet.{u2} Œ≤) b s) (fun (H : Membership.mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instMembershipSet.{u2} Œ≤) b s) => f b)))) (tsum.{0, u2} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal (Set.Elem.{u2} Œ≤ s) (fun (p : Set.Elem.{u2} Œ≤ s) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (f (Subtype.val.{succ u2} Œ≤ (fun (x : Œ≤) => Membership.mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instMembershipSet.{u2} Œ≤) x s) p)))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_bUnion‚ÇÄ MeasureTheory.measure_bunion·µ¢‚ÇÄ‚Çì'. -/
theorem measure_bunion·µ¢‚ÇÄ {s : Set Œ≤} {f : Œ≤ ‚Üí Set Œ±} (hs : s.Countable)
    (hd : s.Pairwise (AEDisjoint Œº on f)) (h : ‚àÄ b ‚àà s, NullMeasurableSet (f b) Œº) :
    Œº (‚ãÉ b ‚àà s, f b) = ‚àë' p : s, Œº (f p) :=
  by
  haveI := hs.to_encodable
  rw [bUnion_eq_Union]
  exact measure_Union‚ÇÄ (hd.on_injective Subtype.coe_injective fun x => x.2) fun x => h x x.2
#align measure_theory.measure_bUnion‚ÇÄ MeasureTheory.measure_bunion·µ¢‚ÇÄ

/- warning: measure_theory.measure_bUnion -> MeasureTheory.measure_bunion·µ¢ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u2} Œ≤} {f : Œ≤ -> (Set.{u1} Œ±)}, (Set.Countable.{u2} Œ≤ s) -> (Set.PairwiseDisjoint.{u1, u2} (Set.{u1} Œ±) Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±))) s f) -> (forall (b : Œ≤), (Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) b s) -> (MeasurableSet.{u1} Œ± m (f b))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.union·µ¢.{u1, succ u2} Œ± Œ≤ (fun (b : Œ≤) => Set.union·µ¢.{u1, 0} Œ± (Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) b s) (fun (H : Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) b s) => f b)))) (tsum.{0, u2} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace (coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) (fun (p : coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) Œ≤ (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) Œ≤ (CoeTC‚Çì.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) Œ≤ (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) Œ≤ (coeSubtype.{succ u2} Œ≤ (fun (x : Œ≤) => Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) x s))))) p)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u2} Œ≤} {f : Œ≤ -> (Set.{u1} Œ±)}, (Set.Countable.{u2} Œ≤ s) -> (Set.PairwiseDisjoint.{u1, u2} (Set.{u1} Œ±) Œ≤ (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) s f) -> (forall (b : Œ≤), (Membership.mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instMembershipSet.{u2} Œ≤) b s) -> (MeasurableSet.{u1} Œ± m (f b))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.union·µ¢.{u1, succ u2} Œ± Œ≤ (fun (b : Œ≤) => Set.union·µ¢.{u1, 0} Œ± (Membership.mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instMembershipSet.{u2} Œ≤) b s) (fun (H : Membership.mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instMembershipSet.{u2} Œ≤) b s) => f b)))) (tsum.{0, u2} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal (Set.Elem.{u2} Œ≤ s) (fun (p : Set.Elem.{u2} Œ≤ s) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (f (Subtype.val.{succ u2} Œ≤ (fun (x : Œ≤) => Membership.mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instMembershipSet.{u2} Œ≤) x s) p)))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_bUnion MeasureTheory.measure_bunion·µ¢‚Çì'. -/
theorem measure_bunion·µ¢ {s : Set Œ≤} {f : Œ≤ ‚Üí Set Œ±} (hs : s.Countable) (hd : s.PairwiseDisjoint f)
    (h : ‚àÄ b ‚àà s, MeasurableSet (f b)) : Œº (‚ãÉ b ‚àà s, f b) = ‚àë' p : s, Œº (f p) :=
  measure_bunion·µ¢‚ÇÄ hs hd.AEDisjoint fun b hb => (h b hb).NullMeasurableSet
#align measure_theory.measure_bUnion MeasureTheory.measure_bunion·µ¢

/- warning: measure_theory.measure_sUnion‚ÇÄ -> MeasureTheory.measure_union‚Çõ‚ÇÄ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {S : Set.{u1} (Set.{u1} Œ±)}, (Set.Countable.{u1} (Set.{u1} Œ±) S) -> (Set.Pairwise.{u1} (Set.{u1} Œ±) S (MeasureTheory.AEDisjoint.{u1} Œ± m Œº)) -> (forall (s : Set.{u1} Œ±), (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasMem.{u1} (Set.{u1} Œ±)) s S) -> (MeasureTheory.NullMeasurableSet.{u1} Œ± m s Œº)) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.union‚Çõ.{u1} Œ± S)) (tsum.{0, u1} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} Œ±)) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} Œ±)) S) (fun (s : coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} Œ±)) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} Œ±)) S) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} Œ±)) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} Œ±)) S) (Set.{u1} Œ±) (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} Œ±)) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} Œ±)) S) (Set.{u1} Œ±) (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} Œ±)) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} Œ±)) S) (Set.{u1} Œ±) (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} Œ±)) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} Œ±)) S) (Set.{u1} Œ±) (coeSubtype.{succ u1} (Set.{u1} Œ±) (fun (x : Set.{u1} Œ±) => Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasMem.{u1} (Set.{u1} Œ±)) x S))))) s))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {S : Set.{u1} (Set.{u1} Œ±)}, (Set.Countable.{u1} (Set.{u1} Œ±) S) -> (Set.Pairwise.{u1} (Set.{u1} Œ±) S (MeasureTheory.AEDisjoint.{u1} Œ± m Œº)) -> (forall (s : Set.{u1} Œ±), (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instMembershipSet.{u1} (Set.{u1} Œ±)) s S) -> (MeasureTheory.NullMeasurableSet.{u1} Œ± m s Œº)) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.union‚Çõ.{u1} Œ± S)) (tsum.{0, u1} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal (Set.Elem.{u1} (Set.{u1} Œ±) S) (fun (s : Set.Elem.{u1} (Set.{u1} Œ±) S) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Subtype.val.{succ u1} (Set.{u1} Œ±) (fun (x : Set.{u1} Œ±) => Membership.mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instMembershipSet.{u1} (Set.{u1} Œ±)) x S) s))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_sUnion‚ÇÄ MeasureTheory.measure_union‚Çõ‚ÇÄ‚Çì'. -/
theorem measure_union‚Çõ‚ÇÄ {S : Set (Set Œ±)} (hs : S.Countable) (hd : S.Pairwise (AEDisjoint Œº))
    (h : ‚àÄ s ‚àà S, NullMeasurableSet s Œº) : Œº (‚ãÉ‚ÇÄ S) = ‚àë' s : S, Œº s := by
  rw [sUnion_eq_bUnion, measure_bUnion‚ÇÄ hs hd h]
#align measure_theory.measure_sUnion‚ÇÄ MeasureTheory.measure_union‚Çõ‚ÇÄ

/- warning: measure_theory.measure_sUnion -> MeasureTheory.measure_union‚Çõ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {S : Set.{u1} (Set.{u1} Œ±)}, (Set.Countable.{u1} (Set.{u1} Œ±) S) -> (Set.Pairwise.{u1} (Set.{u1} Œ±) S (Disjoint.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±))))) -> (forall (s : Set.{u1} Œ±), (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasMem.{u1} (Set.{u1} Œ±)) s S) -> (MeasurableSet.{u1} Œ± m s)) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.union‚Çõ.{u1} Œ± S)) (tsum.{0, u1} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} Œ±)) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} Œ±)) S) (fun (s : coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} Œ±)) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} Œ±)) S) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} Œ±)) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} Œ±)) S) (Set.{u1} Œ±) (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} Œ±)) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} Œ±)) S) (Set.{u1} Œ±) (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} Œ±)) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} Œ±)) S) (Set.{u1} Œ±) (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} Œ±)) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} Œ±)) S) (Set.{u1} Œ±) (coeSubtype.{succ u1} (Set.{u1} Œ±) (fun (x : Set.{u1} Œ±) => Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasMem.{u1} (Set.{u1} Œ±)) x S))))) s))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {S : Set.{u1} (Set.{u1} Œ±)}, (Set.Countable.{u1} (Set.{u1} Œ±) S) -> (Set.Pairwise.{u1} (Set.{u1} Œ±) S (Disjoint.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) -> (forall (s : Set.{u1} Œ±), (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instMembershipSet.{u1} (Set.{u1} Œ±)) s S) -> (MeasurableSet.{u1} Œ± m s)) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.union‚Çõ.{u1} Œ± S)) (tsum.{0, u1} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal (Set.Elem.{u1} (Set.{u1} Œ±) S) (fun (s : Set.Elem.{u1} (Set.{u1} Œ±) S) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Subtype.val.{succ u1} (Set.{u1} Œ±) (fun (x : Set.{u1} Œ±) => Membership.mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instMembershipSet.{u1} (Set.{u1} Œ±)) x S) s))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_sUnion MeasureTheory.measure_union‚Çõ‚Çì'. -/
theorem measure_union‚Çõ {S : Set (Set Œ±)} (hs : S.Countable) (hd : S.Pairwise Disjoint)
    (h : ‚àÄ s ‚àà S, MeasurableSet s) : Œº (‚ãÉ‚ÇÄ S) = ‚àë' s : S, Œº s := by
  rw [sUnion_eq_bUnion, measure_bUnion hs hd h]
#align measure_theory.measure_sUnion MeasureTheory.measure_union‚Çõ

/- warning: measure_theory.measure_bUnion_finset‚ÇÄ -> MeasureTheory.measure_bunion·µ¢_finset‚ÇÄ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Finset.{u2} Œπ} {f : Œπ -> (Set.{u1} Œ±)}, (Set.Pairwise.{u2} Œπ ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} Œπ) (Set.{u2} Œπ) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} Œπ) (Set.{u2} Œπ) (CoeTC‚Çì.coe.{succ u2, succ u2} (Finset.{u2} Œπ) (Set.{u2} Œπ) (Finset.Set.hasCoeT.{u2} Œπ))) s) (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (MeasureTheory.AEDisjoint.{u1} Œ± m Œº) f)) -> (forall (b : Œπ), (Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) b s) -> (MeasureTheory.NullMeasurableSet.{u1} Œ± m (f b) Œº)) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (b : Œπ) => Set.union·µ¢.{u1, 0} Œ± (Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) b s) (fun (H : Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) b s) => f b)))) (Finset.sum.{0, u2} ENNReal Œπ (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) s (fun (p : Œπ) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (f p))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Finset.{u2} Œπ} {f : Œπ -> (Set.{u1} Œ±)}, (Set.Pairwise.{u2} Œπ (Finset.toSet.{u2} Œπ s) (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (MeasureTheory.AEDisjoint.{u1} Œ± m Œº) f)) -> (forall (b : Œπ), (Membership.mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.instMembershipFinset.{u2} Œπ) b s) -> (MeasureTheory.NullMeasurableSet.{u1} Œ± m (f b) Œº)) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (b : Œπ) => Set.union·µ¢.{u1, 0} Œ± (Membership.mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.instMembershipFinset.{u2} Œπ) b s) (fun (H : Membership.mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.instMembershipFinset.{u2} Œπ) b s) => f b)))) (Finset.sum.{0, u2} ENNReal Œπ (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) s (fun (p : Œπ) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (f p))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_bUnion_finset‚ÇÄ MeasureTheory.measure_bunion·µ¢_finset‚ÇÄ‚Çì'. -/
theorem measure_bunion·µ¢_finset‚ÇÄ {s : Finset Œπ} {f : Œπ ‚Üí Set Œ±}
    (hd : Set.Pairwise (‚Üës) (AEDisjoint Œº on f)) (hm : ‚àÄ b ‚àà s, NullMeasurableSet (f b) Œº) :
    Œº (‚ãÉ b ‚àà s, f b) = ‚àë p in s, Œº (f p) :=
  by
  rw [‚Üê Finset.sum_attach, Finset.attach_eq_univ, ‚Üê tsum_fintype]
  exact measure_bUnion‚ÇÄ s.countable_to_set hd hm
#align measure_theory.measure_bUnion_finset‚ÇÄ MeasureTheory.measure_bunion·µ¢_finset‚ÇÄ

/- warning: measure_theory.measure_bUnion_finset -> MeasureTheory.measure_bunion·µ¢_finset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Finset.{u2} Œπ} {f : Œπ -> (Set.{u1} Œ±)}, (Set.PairwiseDisjoint.{u1, u2} (Set.{u1} Œ±) Œπ (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} Œπ) (Set.{u2} Œπ) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} Œπ) (Set.{u2} Œπ) (CoeTC‚Çì.coe.{succ u2, succ u2} (Finset.{u2} Œπ) (Set.{u2} Œπ) (Finset.Set.hasCoeT.{u2} Œπ))) s) f) -> (forall (b : Œπ), (Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) b s) -> (MeasurableSet.{u1} Œ± m (f b))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (b : Œπ) => Set.union·µ¢.{u1, 0} Œ± (Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) b s) (fun (H : Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) b s) => f b)))) (Finset.sum.{0, u2} ENNReal Œπ (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) s (fun (p : Œπ) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (f p))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Finset.{u2} Œπ} {f : Œπ -> (Set.{u1} Œ±)}, (Set.PairwiseDisjoint.{u1, u2} (Set.{u1} Œ±) Œπ (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (Finset.toSet.{u2} Œπ s) f) -> (forall (b : Œπ), (Membership.mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.instMembershipFinset.{u2} Œπ) b s) -> (MeasurableSet.{u1} Œ± m (f b))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (b : Œπ) => Set.union·µ¢.{u1, 0} Œ± (Membership.mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.instMembershipFinset.{u2} Œπ) b s) (fun (H : Membership.mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.instMembershipFinset.{u2} Œπ) b s) => f b)))) (Finset.sum.{0, u2} ENNReal Œπ (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) s (fun (p : Œπ) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (f p))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_bUnion_finset MeasureTheory.measure_bunion·µ¢_finset‚Çì'. -/
theorem measure_bunion·µ¢_finset {s : Finset Œπ} {f : Œπ ‚Üí Set Œ±} (hd : PairwiseDisjoint (‚Üës) f)
    (hm : ‚àÄ b ‚àà s, MeasurableSet (f b)) : Œº (‚ãÉ b ‚àà s, f b) = ‚àë p in s, Œº (f p) :=
  measure_bunion·µ¢_finset‚ÇÄ hd.AEDisjoint fun b hb => (hm b hb).NullMeasurableSet
#align measure_theory.measure_bUnion_finset MeasureTheory.measure_bunion·µ¢_finset

/- warning: measure_theory.tsum_meas_le_meas_Union_of_disjoint -> MeasureTheory.tsum_meas_le_meas_union·µ¢_of_disjoint is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± _inst_1) {As : Œπ -> (Set.{u1} Œ±)}, (forall (i : Œπ), MeasurableSet.{u1} Œ± _inst_1 (As i)) -> (Pairwise.{u2} Œπ (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)))) As)) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (tsum.{0, u2} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Œπ (fun (i : Œπ) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_1) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_1) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_1) Œº (As i))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_1) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_1) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_1) Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => As i))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± _inst_1) {As : Œπ -> (Set.{u1} Œ±)}, (forall (i : Œπ), MeasurableSet.{u1} Œ± _inst_1 (As i)) -> (Pairwise.{u2} Œπ (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))))) As)) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (tsum.{0, u2} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Œπ (fun (i : Œπ) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_1 Œº) (As i))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_1 Œº) (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => As i))))
Case conversion may be inaccurate. Consider using '#align measure_theory.tsum_meas_le_meas_Union_of_disjoint MeasureTheory.tsum_meas_le_meas_union·µ¢_of_disjoint‚Çì'. -/
/-- The measure of a disjoint union (even uncountable) of measurable sets is at least the sum of
the measures of the sets. -/
theorem tsum_meas_le_meas_union·µ¢_of_disjoint {Œπ : Type _} [MeasurableSpace Œ±] (Œº : Measure Œ±)
    {As : Œπ ‚Üí Set Œ±} (As_mble : ‚àÄ i : Œπ, MeasurableSet (As i))
    (As_disj : Pairwise (Disjoint on As)) : (‚àë' i, Œº (As i)) ‚â§ Œº (‚ãÉ i, As i) :=
  by
  rcases show Summable fun i => Œº (As i) from ENNReal.summable with ‚ü®S, hS‚ü©
  rw [hS.tsum_eq]
  refine' tendsto_le_of_eventuallyLE hS tendsto_const_nhds (eventually_of_forall _)
  intro s
  rw [‚Üê measure_bUnion_finset (fun i hi j hj hij => As_disj hij) fun i _ => As_mble i]
  exact measure_mono (Union‚ÇÇ_subset_Union (fun i : Œπ => i ‚àà s) fun i : Œπ => As i)
#align measure_theory.tsum_meas_le_meas_Union_of_disjoint MeasureTheory.tsum_meas_le_meas_union·µ¢_of_disjoint

/- warning: measure_theory.tsum_measure_preimage_singleton -> MeasureTheory.tsum_measure_preimage_singleton is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u2} Œ≤}, (Set.Countable.{u2} Œ≤ s) -> (forall {f : Œ± -> Œ≤}, (forall (y : Œ≤), (Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) y s) -> (MeasurableSet.{u1} Œ± m (Set.preimage.{u1, u2} Œ± Œ≤ f (Singleton.singleton.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasSingleton.{u2} Œ≤) y)))) -> (Eq.{1} ENNReal (tsum.{0, u2} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace (coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) (fun (b : coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.preimage.{u1, u2} Œ± Œ≤ f (Singleton.singleton.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasSingleton.{u2} Œ≤) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) Œ≤ (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) Œ≤ (CoeTC‚Çì.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) Œ≤ (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} Œ≤) Type.{u2} (Set.hasCoeToSort.{u2} Œ≤) s) Œ≤ (coeSubtype.{succ u2} Œ≤ (fun (x : Œ≤) => Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) x s))))) b))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.preimage.{u1, u2} Œ± Œ≤ f s))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u2} Œ≤}, (Set.Countable.{u2} Œ≤ s) -> (forall {f : Œ± -> Œ≤}, (forall (y : Œ≤), (Membership.mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instMembershipSet.{u2} Œ≤) y s) -> (MeasurableSet.{u1} Œ± m (Set.preimage.{u1, u2} Œ± Œ≤ f (Singleton.singleton.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instSingletonSet.{u2} Œ≤) y)))) -> (Eq.{1} ENNReal (tsum.{0, u2} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal (Set.Elem.{u2} Œ≤ s) (fun (b : Set.Elem.{u2} Œ≤ s) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.preimage.{u1, u2} Œ± Œ≤ f (Singleton.singleton.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instSingletonSet.{u2} Œ≤) (Subtype.val.{succ u2} Œ≤ (fun (x : Œ≤) => Membership.mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instMembershipSet.{u2} Œ≤) x s) b))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.preimage.{u1, u2} Œ± Œ≤ f s))))
Case conversion may be inaccurate. Consider using '#align measure_theory.tsum_measure_preimage_singleton MeasureTheory.tsum_measure_preimage_singleton‚Çì'. -/
/-- If `s` is a countable set, then the measure of its preimage can be found as the sum of measures
of the fibers `f ‚Åª¬π' {y}`. -/
theorem tsum_measure_preimage_singleton {s : Set Œ≤} (hs : s.Countable) {f : Œ± ‚Üí Œ≤}
    (hf : ‚àÄ y ‚àà s, MeasurableSet (f ‚Åª¬π' {y})) : (‚àë' b : s, Œº (f ‚Åª¬π' {‚Üëb})) = Œº (f ‚Åª¬π' s) := by
  rw [‚Üê Set.bunion·µ¢_preimage_singleton, measure_bUnion hs (pairwise_disjoint_fiber _ _) hf]
#align measure_theory.tsum_measure_preimage_singleton MeasureTheory.tsum_measure_preimage_singleton

/- warning: measure_theory.sum_measure_preimage_singleton -> MeasureTheory.sum_measure_preimage_singleton is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} (s : Finset.{u2} Œ≤) {f : Œ± -> Œ≤}, (forall (y : Œ≤), (Membership.Mem.{u2, u2} Œ≤ (Finset.{u2} Œ≤) (Finset.hasMem.{u2} Œ≤) y s) -> (MeasurableSet.{u1} Œ± m (Set.preimage.{u1, u2} Œ± Œ≤ f (Singleton.singleton.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasSingleton.{u2} Œ≤) y)))) -> (Eq.{1} ENNReal (Finset.sum.{0, u2} ENNReal Œ≤ (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) s (fun (b : Œ≤) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.preimage.{u1, u2} Œ± Œ≤ f (Singleton.singleton.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasSingleton.{u2} Œ≤) b)))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.preimage.{u1, u2} Œ± Œ≤ f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} Œ≤) (Set.{u2} Œ≤) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} Œ≤) (Set.{u2} Œ≤) (CoeTC‚Çì.coe.{succ u2, succ u2} (Finset.{u2} Œ≤) (Set.{u2} Œ≤) (Finset.Set.hasCoeT.{u2} Œ≤))) s))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} (s : Finset.{u2} Œ≤) {f : Œ± -> Œ≤}, (forall (y : Œ≤), (Membership.mem.{u2, u2} Œ≤ (Finset.{u2} Œ≤) (Finset.instMembershipFinset.{u2} Œ≤) y s) -> (MeasurableSet.{u1} Œ± m (Set.preimage.{u1, u2} Œ± Œ≤ f (Singleton.singleton.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instSingletonSet.{u2} Œ≤) y)))) -> (Eq.{1} ENNReal (Finset.sum.{0, u2} ENNReal Œ≤ (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) s (fun (b : Œ≤) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.preimage.{u1, u2} Œ± Œ≤ f (Singleton.singleton.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instSingletonSet.{u2} Œ≤) b)))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.preimage.{u1, u2} Œ± Œ≤ f (Finset.toSet.{u2} Œ≤ s))))
Case conversion may be inaccurate. Consider using '#align measure_theory.sum_measure_preimage_singleton MeasureTheory.sum_measure_preimage_singleton‚Çì'. -/
/-- If `s` is a `finset`, then the measure of its preimage can be found as the sum of measures
of the fibers `f ‚Åª¬π' {y}`. -/
theorem sum_measure_preimage_singleton (s : Finset Œ≤) {f : Œ± ‚Üí Œ≤}
    (hf : ‚àÄ y ‚àà s, MeasurableSet (f ‚Åª¬π' {y})) : (‚àë b in s, Œº (f ‚Åª¬π' {b})) = Œº (f ‚Åª¬π' ‚Üës) := by
  simp only [‚Üê measure_bUnion_finset (pairwise_disjoint_fiber _ _) hf,
    Finset.set_bunion·µ¢_preimage_singleton]
#align measure_theory.sum_measure_preimage_singleton MeasureTheory.sum_measure_preimage_singleton

/- warning: measure_theory.measure_diff_null' -> MeasureTheory.measure_diff_null' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s‚ÇÅ s‚ÇÇ)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (SDiff.sdiff.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasSdiff.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s‚ÇÅ s‚ÇÇ)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÅ))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s‚ÇÅ s‚ÇÇ)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (SDiff.sdiff.{u1} (Set.{u1} Œ±) (Set.instSDiffSet.{u1} Œ±) s‚ÇÅ s‚ÇÇ)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÅ))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_diff_null' MeasureTheory.measure_diff_null'‚Çì'. -/
theorem measure_diff_null' (h : Œº (s‚ÇÅ ‚à© s‚ÇÇ) = 0) : Œº (s‚ÇÅ \ s‚ÇÇ) = Œº s‚ÇÅ :=
  measure_congr <| diff_ae_eq_self.2 h
#align measure_theory.measure_diff_null' MeasureTheory.measure_diff_null'

/- warning: measure_theory.measure_diff_null -> MeasureTheory.measure_diff_null is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÇ) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (SDiff.sdiff.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasSdiff.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s‚ÇÅ s‚ÇÇ)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÅ))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÇ) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (SDiff.sdiff.{u1} (Set.{u1} Œ±) (Set.instSDiffSet.{u1} Œ±) s‚ÇÅ s‚ÇÇ)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÅ))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_diff_null MeasureTheory.measure_diff_null‚Çì'. -/
theorem measure_diff_null (h : Œº s‚ÇÇ = 0) : Œº (s‚ÇÅ \ s‚ÇÇ) = Œº s‚ÇÅ :=
  measure_diff_null' <| measure_mono_null (inter_subset_right _ _) h
#align measure_theory.measure_diff_null MeasureTheory.measure_diff_null

/- warning: measure_theory.measure_add_diff -> MeasureTheory.measure_add_diff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m s) -> (forall (t : Set.{u1} Œ±), Eq.{1} ENNReal (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (SDiff.sdiff.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasSdiff.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) t s))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) s t)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m s) -> (forall (t : Set.{u1} Œ±), Eq.{1} ENNReal (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (SDiff.sdiff.{u1} (Set.{u1} Œ±) (Set.instSDiffSet.{u1} Œ±) t s))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) s t)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_add_diff MeasureTheory.measure_add_diff‚Çì'. -/
theorem measure_add_diff (hs : MeasurableSet s) (t : Set Œ±) : Œº s + Œº (t \ s) = Œº (s ‚à™ t) := by
  rw [‚Üê measure_union' disjoint_sdiff_right hs, union_diff_self]
#align measure_theory.measure_add_diff MeasureTheory.measure_add_diff

/- warning: measure_theory.measure_diff' -> MeasureTheory.measure_diff' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {t : Set.{u1} Œ±} (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m t) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº t) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (SDiff.sdiff.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasSdiff.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s t)) (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.hasSub) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) s t)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº t)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {t : Set.{u1} Œ±} (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m t) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) t) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (SDiff.sdiff.{u1} (Set.{u1} Œ±) (Set.instSDiffSet.{u1} Œ±) s t)) (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.instSubENNReal) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) s t)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) t)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_diff' MeasureTheory.measure_diff'‚Çì'. -/
theorem measure_diff' (s : Set Œ±) (hm : MeasurableSet t) (h_fin : Œº t ‚â† ‚àû) :
    Œº (s \ t) = Œº (s ‚à™ t) - Œº t :=
  Eq.symm <| ENNReal.sub_eq_of_add_eq h_fin <| by rw [add_comm, measure_add_diff hm, union_comm]
#align measure_theory.measure_diff' MeasureTheory.measure_diff'

/- warning: measure_theory.measure_diff -> MeasureTheory.measure_diff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s‚ÇÇ s‚ÇÅ) -> (MeasurableSet.{u1} Œ± m s‚ÇÇ) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÇ) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (SDiff.sdiff.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasSdiff.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s‚ÇÅ s‚ÇÇ)) (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.hasSub) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÅ) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÇ)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s‚ÇÇ s‚ÇÅ) -> (MeasurableSet.{u1} Œ± m s‚ÇÇ) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÇ) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (SDiff.sdiff.{u1} (Set.{u1} Œ±) (Set.instSDiffSet.{u1} Œ±) s‚ÇÅ s‚ÇÇ)) (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.instSubENNReal) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÅ) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÇ)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_diff MeasureTheory.measure_diff‚Çì'. -/
theorem measure_diff (h : s‚ÇÇ ‚äÜ s‚ÇÅ) (h‚ÇÇ : MeasurableSet s‚ÇÇ) (h_fin : Œº s‚ÇÇ ‚â† ‚àû) :
    Œº (s‚ÇÅ \ s‚ÇÇ) = Œº s‚ÇÅ - Œº s‚ÇÇ := by rw [measure_diff' _ h‚ÇÇ h_fin, union_eq_self_of_subset_right h]
#align measure_theory.measure_diff MeasureTheory.measure_diff

/- warning: measure_theory.le_measure_diff -> MeasureTheory.le_measure_diff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±}, LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.hasSub) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÅ) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÇ)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (SDiff.sdiff.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasSdiff.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s‚ÇÅ s‚ÇÇ))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±}, LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.instSubENNReal) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÅ) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÇ)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (SDiff.sdiff.{u1} (Set.{u1} Œ±) (Set.instSDiffSet.{u1} Œ±) s‚ÇÅ s‚ÇÇ))
Case conversion may be inaccurate. Consider using '#align measure_theory.le_measure_diff MeasureTheory.le_measure_diff‚Çì'. -/
theorem le_measure_diff : Œº s‚ÇÅ - Œº s‚ÇÇ ‚â§ Œº (s‚ÇÅ \ s‚ÇÇ) :=
  tsub_le_iff_left.2 <|
    calc
      Œº s‚ÇÅ ‚â§ Œº (s‚ÇÇ ‚à™ s‚ÇÅ) := measure_mono (subset_union_right _ _)
      _ = Œº (s‚ÇÇ ‚à™ s‚ÇÅ \ s‚ÇÇ) := (congr_arg Œº union_diff_self.symm)
      _ ‚â§ Œº s‚ÇÇ + Œº (s‚ÇÅ \ s‚ÇÇ) := measure_union_le _ _
      
#align measure_theory.le_measure_diff MeasureTheory.le_measure_diff

/- warning: measure_theory.measure_diff_lt_of_lt_add -> MeasureTheory.measure_diff_lt_of_lt_add is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m s) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s t) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (forall {Œµ : ENNReal}, (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº t) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s) Œµ)) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (SDiff.sdiff.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasSdiff.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) t s)) Œµ))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m s) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s t) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (forall {Œµ : ENNReal}, (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) t) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s) Œµ)) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (SDiff.sdiff.{u1} (Set.{u1} Œ±) (Set.instSDiffSet.{u1} Œ±) t s)) Œµ))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_diff_lt_of_lt_add MeasureTheory.measure_diff_lt_of_lt_add‚Çì'. -/
theorem measure_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ‚äÜ t) (hs' : Œº s ‚â† ‚àû) {Œµ : ‚Ñù‚â•0‚àû}
    (h : Œº t < Œº s + Œµ) : Œº (t \ s) < Œµ :=
  by
  rw [measure_diff hst hs hs']; rw [add_comm] at h
  exact ENNReal.sub_lt_of_lt_add (measure_mono hst) h
#align measure_theory.measure_diff_lt_of_lt_add MeasureTheory.measure_diff_lt_of_lt_add

/- warning: measure_theory.measure_diff_le_iff_le_add -> MeasureTheory.measure_diff_le_iff_le_add is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m s) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s t) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (forall {Œµ : ENNReal}, Iff (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (SDiff.sdiff.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasSdiff.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) t s)) Œµ) (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº t) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s) Œµ)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m s) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s t) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (forall {Œµ : ENNReal}, Iff (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (SDiff.sdiff.{u1} (Set.{u1} Œ±) (Set.instSDiffSet.{u1} Œ±) t s)) Œµ) (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) t) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s) Œµ)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_diff_le_iff_le_add MeasureTheory.measure_diff_le_iff_le_add‚Çì'. -/
theorem measure_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ‚äÜ t) (hs' : Œº s ‚â† ‚àû) {Œµ : ‚Ñù‚â•0‚àû} :
    Œº (t \ s) ‚â§ Œµ ‚Üî Œº t ‚â§ Œº s + Œµ := by rwa [measure_diff hst hs hs', tsub_le_iff_left]
#align measure_theory.measure_diff_le_iff_le_add MeasureTheory.measure_diff_le_iff_le_add

/- warning: measure_theory.measure_eq_measure_of_null_diff -> MeasureTheory.measure_eq_measure_of_null_diff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s t) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (SDiff.sdiff.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasSdiff.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) t s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº t))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s t) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (SDiff.sdiff.{u1} (Set.{u1} Œ±) (Set.instSDiffSet.{u1} Œ±) t s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) t))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_eq_measure_of_null_diff MeasureTheory.measure_eq_measure_of_null_diff‚Çì'. -/
theorem measure_eq_measure_of_null_diff {s t : Set Œ±} (hst : s ‚äÜ t) (h_nulldiff : Œº (t \ s) = 0) :
    Œº s = Œº t :=
  measure_congr (hst.EventuallyLE.antisymm <| ae_le_set.mpr h_nulldiff)
#align measure_theory.measure_eq_measure_of_null_diff MeasureTheory.measure_eq_measure_of_null_diff

/- warning: measure_theory.measure_eq_measure_of_between_null_diff -> MeasureTheory.measure_eq_measure_of_between_null_diff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±} {s‚ÇÉ : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s‚ÇÅ s‚ÇÇ) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s‚ÇÇ s‚ÇÉ) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (SDiff.sdiff.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasSdiff.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s‚ÇÉ s‚ÇÅ)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (And (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÅ) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÇ)) (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÇ) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÉ)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±} {s‚ÇÉ : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s‚ÇÅ s‚ÇÇ) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s‚ÇÇ s‚ÇÉ) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (SDiff.sdiff.{u1} (Set.{u1} Œ±) (Set.instSDiffSet.{u1} Œ±) s‚ÇÉ s‚ÇÅ)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (And (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÅ) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÇ)) (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÇ) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÉ)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_eq_measure_of_between_null_diff MeasureTheory.measure_eq_measure_of_between_null_diff‚Çì'. -/
theorem measure_eq_measure_of_between_null_diff {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Set Œ±} (h12 : s‚ÇÅ ‚äÜ s‚ÇÇ) (h23 : s‚ÇÇ ‚äÜ s‚ÇÉ)
    (h_nulldiff : Œº (s‚ÇÉ \ s‚ÇÅ) = 0) : Œº s‚ÇÅ = Œº s‚ÇÇ ‚àß Œº s‚ÇÇ = Œº s‚ÇÉ :=
  by
  have le12 : Œº s‚ÇÅ ‚â§ Œº s‚ÇÇ := measure_mono h12
  have le23 : Œº s‚ÇÇ ‚â§ Œº s‚ÇÉ := measure_mono h23
  have key : Œº s‚ÇÉ ‚â§ Œº s‚ÇÅ :=
    calc
      Œº s‚ÇÉ = Œº (s‚ÇÉ \ s‚ÇÅ ‚à™ s‚ÇÅ) := by rw [diff_union_of_subset (h12.trans h23)]
      _ ‚â§ Œº (s‚ÇÉ \ s‚ÇÅ) + Œº s‚ÇÅ := (measure_union_le _ _)
      _ = Œº s‚ÇÅ := by simp only [h_nulldiff, zero_add]
      
  exact ‚ü®le12.antisymm (le23.trans key), le23.antisymm (key.trans le12)‚ü©
#align measure_theory.measure_eq_measure_of_between_null_diff MeasureTheory.measure_eq_measure_of_between_null_diff

/- warning: measure_theory.measure_eq_measure_smaller_of_between_null_diff -> MeasureTheory.measure_eq_measure_smaller_of_between_null_diff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±} {s‚ÇÉ : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s‚ÇÅ s‚ÇÇ) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s‚ÇÇ s‚ÇÉ) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (SDiff.sdiff.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasSdiff.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s‚ÇÉ s‚ÇÅ)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÅ) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÇ))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±} {s‚ÇÉ : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s‚ÇÅ s‚ÇÇ) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s‚ÇÇ s‚ÇÉ) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (SDiff.sdiff.{u1} (Set.{u1} Œ±) (Set.instSDiffSet.{u1} Œ±) s‚ÇÉ s‚ÇÅ)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÅ) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÇ))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_eq_measure_smaller_of_between_null_diff MeasureTheory.measure_eq_measure_smaller_of_between_null_diff‚Çì'. -/
theorem measure_eq_measure_smaller_of_between_null_diff {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Set Œ±} (h12 : s‚ÇÅ ‚äÜ s‚ÇÇ)
    (h23 : s‚ÇÇ ‚äÜ s‚ÇÉ) (h_nulldiff : Œº (s‚ÇÉ \ s‚ÇÅ) = 0) : Œº s‚ÇÅ = Œº s‚ÇÇ :=
  (measure_eq_measure_of_between_null_diff h12 h23 h_nulldiff).1
#align measure_theory.measure_eq_measure_smaller_of_between_null_diff MeasureTheory.measure_eq_measure_smaller_of_between_null_diff

/- warning: measure_theory.measure_eq_measure_larger_of_between_null_diff -> MeasureTheory.measure_eq_measure_larger_of_between_null_diff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±} {s‚ÇÉ : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s‚ÇÅ s‚ÇÇ) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s‚ÇÇ s‚ÇÉ) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (SDiff.sdiff.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasSdiff.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s‚ÇÉ s‚ÇÅ)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÇ) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÉ))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±} {s‚ÇÉ : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s‚ÇÅ s‚ÇÇ) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s‚ÇÇ s‚ÇÉ) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (SDiff.sdiff.{u1} (Set.{u1} Œ±) (Set.instSDiffSet.{u1} Œ±) s‚ÇÉ s‚ÇÅ)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÇ) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÉ))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_eq_measure_larger_of_between_null_diff MeasureTheory.measure_eq_measure_larger_of_between_null_diff‚Çì'. -/
theorem measure_eq_measure_larger_of_between_null_diff {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Set Œ±} (h12 : s‚ÇÅ ‚äÜ s‚ÇÇ)
    (h23 : s‚ÇÇ ‚äÜ s‚ÇÉ) (h_nulldiff : Œº (s‚ÇÉ \ s‚ÇÅ) = 0) : Œº s‚ÇÇ = Œº s‚ÇÉ :=
  (measure_eq_measure_of_between_null_diff h12 h23 h_nulldiff).2
#align measure_theory.measure_eq_measure_larger_of_between_null_diff MeasureTheory.measure_eq_measure_larger_of_between_null_diff

/- warning: measure_theory.measure_compl -> MeasureTheory.measure_compl is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m s) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s)) (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.hasSub) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.univ.{u1} Œ±)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m s) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) s)) (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.instSubENNReal) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.univ.{u1} Œ±)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_compl MeasureTheory.measure_compl‚Çì'. -/
theorem measure_compl (h‚ÇÅ : MeasurableSet s) (h_fin : Œº s ‚â† ‚àû) : Œº (s·∂ú) = Œº univ - Œº s :=
  by
  rw [compl_eq_univ_diff]
  exact measure_diff (subset_univ s) h‚ÇÅ h_fin
#align measure_theory.measure_compl MeasureTheory.measure_compl

/- warning: measure_theory.union_ae_eq_left_iff_ae_subset -> MeasureTheory.union_ae_eq_left_iff_ae_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, Iff (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) s t) s) (Filter.EventuallyLE.{u1, 0} Œ± Prop Prop.le (MeasureTheory.Measure.ae.{u1} Œ± m Œº) t s)
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, Iff (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) s t) s) (Filter.EventuallyLE.{u1, 0} Œ± Prop Prop.le (MeasureTheory.Measure.ae.{u1} Œ± m Œº) t s)
Case conversion may be inaccurate. Consider using '#align measure_theory.union_ae_eq_left_iff_ae_subset MeasureTheory.union_ae_eq_left_iff_ae_subset‚Çì'. -/
@[simp]
theorem union_ae_eq_left_iff_ae_subset : (s ‚à™ t : Set Œ±) =·µê[Œº] s ‚Üî t ‚â§·µê[Œº] s :=
  by
  rw [ae_le_set]
  refine'
    ‚ü®fun h => by simpa only [union_diff_left] using (ae_eq_set.mp h).1, fun h =>
      eventually_le_antisymm_iff.mpr
        ‚ü®by rwa [ae_le_set, union_diff_left],
          HasSubset.Subset.eventuallyLE <| subset_union_left s t‚ü©‚ü©
#align measure_theory.union_ae_eq_left_iff_ae_subset MeasureTheory.union_ae_eq_left_iff_ae_subset

/- warning: measure_theory.union_ae_eq_right_iff_ae_subset -> MeasureTheory.union_ae_eq_right_iff_ae_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, Iff (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) s t) t) (Filter.EventuallyLE.{u1, 0} Œ± Prop Prop.le (MeasureTheory.Measure.ae.{u1} Œ± m Œº) s t)
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, Iff (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) s t) t) (Filter.EventuallyLE.{u1, 0} Œ± Prop Prop.le (MeasureTheory.Measure.ae.{u1} Œ± m Œº) s t)
Case conversion may be inaccurate. Consider using '#align measure_theory.union_ae_eq_right_iff_ae_subset MeasureTheory.union_ae_eq_right_iff_ae_subset‚Çì'. -/
@[simp]
theorem union_ae_eq_right_iff_ae_subset : (s ‚à™ t : Set Œ±) =·µê[Œº] t ‚Üî s ‚â§·µê[Œº] t := by
  rw [union_comm, union_ae_eq_left_iff_ae_subset]
#align measure_theory.union_ae_eq_right_iff_ae_subset MeasureTheory.union_ae_eq_right_iff_ae_subset

/- warning: measure_theory.ae_eq_of_ae_subset_of_measure_ge -> MeasureTheory.ae_eq_of_ae_subset_of_measure_ge is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (Filter.EventuallyLE.{u1, 0} Œ± Prop Prop.le (MeasureTheory.Measure.ae.{u1} Œ± m Œº) s t) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº t) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s)) -> (MeasurableSet.{u1} Œ± m s) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº t) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m Œº) s t)
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (Filter.EventuallyLE.{u1, 0} Œ± Prop Prop.le (MeasureTheory.Measure.ae.{u1} Œ± m Œº) s t) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) t) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s)) -> (MeasurableSet.{u1} Œ± m s) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) t) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m Œº) s t)
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_eq_of_ae_subset_of_measure_ge MeasureTheory.ae_eq_of_ae_subset_of_measure_ge‚Çì'. -/
theorem ae_eq_of_ae_subset_of_measure_ge (h‚ÇÅ : s ‚â§·µê[Œº] t) (h‚ÇÇ : Œº t ‚â§ Œº s) (hsm : MeasurableSet s)
    (ht : Œº t ‚â† ‚àû) : s =·µê[Œº] t :=
  by
  refine' eventually_le_antisymm_iff.mpr ‚ü®h‚ÇÅ, ae_le_set.mpr _‚ü©
  replace h‚ÇÇ : Œº t = Œº s; exact h‚ÇÇ.antisymm (measure_mono_ae h‚ÇÅ)
  replace ht : Œº s ‚â† ‚àû; exact h‚ÇÇ ‚ñ∏ ht
  rw [measure_diff' t hsm ht, measure_congr (union_ae_eq_left_iff_ae_subset.mpr h‚ÇÅ), h‚ÇÇ, tsub_self]
#align measure_theory.ae_eq_of_ae_subset_of_measure_ge MeasureTheory.ae_eq_of_ae_subset_of_measure_ge

/- warning: measure_theory.ae_eq_of_subset_of_measure_ge -> MeasureTheory.ae_eq_of_subset_of_measure_ge is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s t) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº t) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s)) -> (MeasurableSet.{u1} Œ± m s) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº t) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m Œº) s t)
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s t) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) t) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s)) -> (MeasurableSet.{u1} Œ± m s) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) t) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m Œº) s t)
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_eq_of_subset_of_measure_ge MeasureTheory.ae_eq_of_subset_of_measure_ge‚Çì'. -/
/-- If `s ‚äÜ t`, `Œº t ‚â§ Œº s`, `Œº t ‚â† ‚àû`, and `s` is measurable, then `s =·µê[Œº] t`. -/
theorem ae_eq_of_subset_of_measure_ge (h‚ÇÅ : s ‚äÜ t) (h‚ÇÇ : Œº t ‚â§ Œº s) (hsm : MeasurableSet s)
    (ht : Œº t ‚â† ‚àû) : s =·µê[Œº] t :=
  ae_eq_of_ae_subset_of_measure_ge (HasSubset.Subset.eventuallyLE h‚ÇÅ) h‚ÇÇ hsm ht
#align measure_theory.ae_eq_of_subset_of_measure_ge MeasureTheory.ae_eq_of_subset_of_measure_ge

/- warning: measure_theory.measure_Union_congr_of_subset -> MeasureTheory.measure_union·µ¢_congr_of_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_1 : Countable.{succ u2} Œ≤] {s : Œ≤ -> (Set.{u1} Œ±)} {t : Œ≤ -> (Set.{u1} Œ±)}, (forall (b : Œ≤), HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (s b) (t b)) -> (forall (b : Œ≤), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (t b)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (s b))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.union·µ¢.{u1, succ u2} Œ± Œ≤ (fun (b : Œ≤) => s b))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.union·µ¢.{u1, succ u2} Œ± Œ≤ (fun (b : Œ≤) => t b))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_1 : Countable.{succ u2} Œ≤] {s : Œ≤ -> (Set.{u1} Œ±)} {t : Œ≤ -> (Set.{u1} Œ±)}, (forall (b : Œ≤), HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (s b) (t b)) -> (forall (b : Œ≤), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (t b)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (s b))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.union·µ¢.{u1, succ u2} Œ± Œ≤ (fun (b : Œ≤) => s b))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.union·µ¢.{u1, succ u2} Œ± Œ≤ (fun (b : Œ≤) => t b))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_Union_congr_of_subset MeasureTheory.measure_union·µ¢_congr_of_subset‚Çì'. -/
theorem measure_union·µ¢_congr_of_subset [Countable Œ≤] {s : Œ≤ ‚Üí Set Œ±} {t : Œ≤ ‚Üí Set Œ±}
    (hsub : ‚àÄ b, s b ‚äÜ t b) (h_le : ‚àÄ b, Œº (t b) ‚â§ Œº (s b)) : Œº (‚ãÉ b, s b) = Œº (‚ãÉ b, t b) :=
  by
  rcases em (‚àÉ b, Œº (t b) = ‚àû) with (‚ü®b, hb‚ü© | htop)
  ¬∑
    calc
      Œº (‚ãÉ b, s b) = ‚àû := top_unique (hb ‚ñ∏ (h_le b).trans <| measure_mono <| subset_Union _ _)
      _ = Œº (‚ãÉ b, t b) := Eq.symm <| top_unique <| hb ‚ñ∏ measure_mono <| subset_Union _ _
      
  push_neg  at htop
  refine' le_antisymm (measure_mono (Union_mono hsub)) _
  set M := to_measurable Œº
  have H : ‚àÄ b, (M (t b) ‚à© M (‚ãÉ b, s b) : Set Œ±) =·µê[Œº] M (t b) :=
    by
    refine' fun b => ae_eq_of_subset_of_measure_ge (inter_subset_left _ _) _ _ _
    ¬∑
      calc
        Œº (M (t b)) = Œº (t b) := measure_to_measurable _
        _ ‚â§ Œº (s b) := (h_le b)
        _ ‚â§ Œº (M (t b) ‚à© M (‚ãÉ b, s b)) :=
          measure_mono <|
            subset_inter ((hsub b).trans <| subset_to_measurable _ _)
              ((subset_Union _ _).trans <| subset_to_measurable _ _)
        
    ¬∑ exact (measurable_set_to_measurable _ _).inter (measurable_set_to_measurable _ _)
    ¬∑ rw [measure_to_measurable]
      exact htop b
  calc
    Œº (‚ãÉ b, t b) ‚â§ Œº (‚ãÉ b, M (t b)) := measure_mono (Union_mono fun b => subset_to_measurable _ _)
    _ = Œº (‚ãÉ b, M (t b) ‚à© M (‚ãÉ b, s b)) := (measure_congr (EventuallyEq.countable_union·µ¢ H).symm)
    _ ‚â§ Œº (M (‚ãÉ b, s b)) := (measure_mono (Union_subset fun b => inter_subset_right _ _))
    _ = Œº (‚ãÉ b, s b) := measure_to_measurable _
    
#align measure_theory.measure_Union_congr_of_subset MeasureTheory.measure_union·µ¢_congr_of_subset

/- warning: measure_theory.measure_union_congr_of_subset -> MeasureTheory.measure_union_congr_of_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±} {t‚ÇÅ : Set.{u1} Œ±} {t‚ÇÇ : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s‚ÇÅ s‚ÇÇ) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÇ) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s‚ÇÅ)) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) t‚ÇÅ t‚ÇÇ) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº t‚ÇÇ) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº t‚ÇÅ)) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) s‚ÇÅ t‚ÇÅ)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) s‚ÇÇ t‚ÇÇ)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s‚ÇÅ : Set.{u1} Œ±} {s‚ÇÇ : Set.{u1} Œ±} {t‚ÇÅ : Set.{u1} Œ±} {t‚ÇÇ : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s‚ÇÅ s‚ÇÇ) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÇ) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s‚ÇÅ)) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) t‚ÇÅ t‚ÇÇ) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) t‚ÇÇ) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) t‚ÇÅ)) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) s‚ÇÅ t‚ÇÅ)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) s‚ÇÇ t‚ÇÇ)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_union_congr_of_subset MeasureTheory.measure_union_congr_of_subset‚Çì'. -/
theorem measure_union_congr_of_subset {t‚ÇÅ t‚ÇÇ : Set Œ±} (hs : s‚ÇÅ ‚äÜ s‚ÇÇ) (hsŒº : Œº s‚ÇÇ ‚â§ Œº s‚ÇÅ)
    (ht : t‚ÇÅ ‚äÜ t‚ÇÇ) (htŒº : Œº t‚ÇÇ ‚â§ Œº t‚ÇÅ) : Œº (s‚ÇÅ ‚à™ t‚ÇÅ) = Œº (s‚ÇÇ ‚à™ t‚ÇÇ) :=
  by
  rw [union_eq_Union, union_eq_Union]
  exact measure_Union_congr_of_subset (Bool.forall_bool.2 ‚ü®ht, hs‚ü©) (Bool.forall_bool.2 ‚ü®htŒº, hsŒº‚ü©)
#align measure_theory.measure_union_congr_of_subset MeasureTheory.measure_union_congr_of_subset

#print MeasureTheory.measure_union·µ¢_toMeasurable /-
@[simp]
theorem measure_union·µ¢_toMeasurable [Countable Œ≤] (s : Œ≤ ‚Üí Set Œ±) :
    Œº (‚ãÉ b, toMeasurable Œº (s b)) = Œº (‚ãÉ b, s b) :=
  Eq.symm <|
    measure_union·µ¢_congr_of_subset (fun b => subset_toMeasurable _ _) fun b =>
      (measure_toMeasurable _).le
#align measure_theory.measure_Union_to_measurable MeasureTheory.measure_union·µ¢_toMeasurable
-/

#print MeasureTheory.measure_bunion·µ¢_toMeasurable /-
theorem measure_bunion·µ¢_toMeasurable {I : Set Œ≤} (hc : I.Countable) (s : Œ≤ ‚Üí Set Œ±) :
    Œº (‚ãÉ b ‚àà I, toMeasurable Œº (s b)) = Œº (‚ãÉ b ‚àà I, s b) :=
  by
  haveI := hc.to_encodable
  simp only [bUnion_eq_Union, measure_Union_to_measurable]
#align measure_theory.measure_bUnion_to_measurable MeasureTheory.measure_bunion·µ¢_toMeasurable
-/

/- warning: measure_theory.measure_to_measurable_union -> MeasureTheory.measure_toMeasurable_union is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) (MeasureTheory.toMeasurable.{u1} Œ± m Œº s) t)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) s t))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) (MeasureTheory.toMeasurable.{u1} Œ± m Œº s) t)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) s t))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_to_measurable_union MeasureTheory.measure_toMeasurable_union‚Çì'. -/
@[simp]
theorem measure_toMeasurable_union : Œº (toMeasurable Œº s ‚à™ t) = Œº (s ‚à™ t) :=
  Eq.symm <|
    measure_union_congr_of_subset (subset_toMeasurable _ _) (measure_toMeasurable _).le Subset.rfl
      le_rfl
#align measure_theory.measure_to_measurable_union MeasureTheory.measure_toMeasurable_union

/- warning: measure_theory.measure_union_to_measurable -> MeasureTheory.measure_union_toMeasurable is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) s (MeasureTheory.toMeasurable.{u1} Œ± m Œº t))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) s t))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) s (MeasureTheory.toMeasurable.{u1} Œ± m Œº t))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) s t))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_union_to_measurable MeasureTheory.measure_union_toMeasurable‚Çì'. -/
@[simp]
theorem measure_union_toMeasurable : Œº (s ‚à™ toMeasurable Œº t) = Œº (s ‚à™ t) :=
  Eq.symm <|
    measure_union_congr_of_subset Subset.rfl le_rfl (subset_toMeasurable _ _)
      (measure_toMeasurable _).le
#align measure_theory.measure_union_to_measurable MeasureTheory.measure_union_toMeasurable

/- warning: measure_theory.sum_measure_le_measure_univ -> MeasureTheory.sum_measure_le_measure_univ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Finset.{u2} Œπ} {t : Œπ -> (Set.{u1} Œ±)}, (forall (i : Œπ), (Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) i s) -> (MeasurableSet.{u1} Œ± m (t i))) -> (Set.PairwiseDisjoint.{u1, u2} (Set.{u1} Œ±) Œπ (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} Œπ) (Set.{u2} Œπ) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} Œπ) (Set.{u2} Œπ) (CoeTC‚Çì.coe.{succ u2, succ u2} (Finset.{u2} Œπ) (Set.{u2} Œπ) (Finset.Set.hasCoeT.{u2} Œπ))) s) t) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (Finset.sum.{0, u2} ENNReal Œπ (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) s (fun (i : Œπ) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (t i))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.univ.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Finset.{u2} Œπ} {t : Œπ -> (Set.{u1} Œ±)}, (forall (i : Œπ), (Membership.mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.instMembershipFinset.{u2} Œπ) i s) -> (MeasurableSet.{u1} Œ± m (t i))) -> (Set.PairwiseDisjoint.{u1, u2} (Set.{u1} Œ±) Œπ (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (Finset.toSet.{u2} Œπ s) t) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (Finset.sum.{0, u2} ENNReal Œπ (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) s (fun (i : Œπ) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (t i))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.univ.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align measure_theory.sum_measure_le_measure_univ MeasureTheory.sum_measure_le_measure_univ‚Çì'. -/
theorem sum_measure_le_measure_univ {s : Finset Œπ} {t : Œπ ‚Üí Set Œ±}
    (h : ‚àÄ i ‚àà s, MeasurableSet (t i)) (H : Set.PairwiseDisjoint (‚Üës) t) :
    (‚àë i in s, Œº (t i)) ‚â§ Œº (univ : Set Œ±) :=
  by
  rw [‚Üê measure_bUnion_finset H h]
  exact measure_mono (subset_univ _)
#align measure_theory.sum_measure_le_measure_univ MeasureTheory.sum_measure_le_measure_univ

/- warning: measure_theory.tsum_measure_le_measure_univ -> MeasureTheory.tsum_measure_le_measure_univ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Œπ -> (Set.{u1} Œ±)}, (forall (i : Œπ), MeasurableSet.{u1} Œ± m (s i)) -> (Pairwise.{u2} Œπ (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)))) s)) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (tsum.{0, u2} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Œπ (fun (i : Œπ) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (s i))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.univ.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m : MeasurableSpace.{u2} Œ±} {Œº : MeasureTheory.Measure.{u2} Œ± m} {s : Œπ -> (Set.{u2} Œ±)}, (forall (i : Œπ), MeasurableSet.{u2} Œ± m (s i)) -> (Pairwise.{u1} Œπ (Function.onFun.{succ u1, succ u2, 1} Œπ (Set.{u2} Œ±) Prop (Disjoint.{u2} (Set.{u2} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} Œ±) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} Œ±) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} Œ±) (Set.instCompleteBooleanAlgebraSet.{u2} Œ±)))))) (BoundedOrder.toOrderBot.{u2} (Set.{u2} Œ±) (Preorder.toLE.{u2} (Set.{u2} Œ±) (PartialOrder.toPreorder.{u2} (Set.{u2} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} Œ±) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} Œ±) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} Œ±) (Set.instCompleteBooleanAlgebraSet.{u2} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u2} (Set.{u2} Œ±) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} Œ±) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} Œ±) (Set.instCompleteBooleanAlgebraSet.{u2} Œ±))))))) s)) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (tsum.{0, u1} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Œπ (fun (i : Œπ) => MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m Œº) (s i))) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m Œº) (Set.univ.{u2} Œ±)))
Case conversion may be inaccurate. Consider using '#align measure_theory.tsum_measure_le_measure_univ MeasureTheory.tsum_measure_le_measure_univ‚Çì'. -/
theorem tsum_measure_le_measure_univ {s : Œπ ‚Üí Set Œ±} (hs : ‚àÄ i, MeasurableSet (s i))
    (H : Pairwise (Disjoint on s)) : (‚àë' i, Œº (s i)) ‚â§ Œº (univ : Set Œ±) :=
  by
  rw [ENNReal.tsum_eq_sup·µ¢_sum]
  exact sup·µ¢_le fun s => sum_measure_le_measure_univ (fun i hi => hs i) fun i hi j hj hij => H hij
#align measure_theory.tsum_measure_le_measure_univ MeasureTheory.tsum_measure_le_measure_univ

/- warning: measure_theory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure -> MeasureTheory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m) {s : Œπ -> (Set.{u1} Œ±)}, (forall (i : Œπ), MeasurableSet.{u1} Œ± m (s i)) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.univ.{u1} Œ±)) (tsum.{0, u2} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Œπ (fun (i : Œπ) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (s i)))) -> (Exists.{succ u2} Œπ (fun (i : Œπ) => Exists.{succ u2} Œπ (fun (j : Œπ) => Exists.{0} (Ne.{succ u2} Œπ i j) (fun (h : Ne.{succ u2} Œπ i j) => Set.Nonempty.{u1} Œ± (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) (s i) (s j))))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m : MeasurableSpace.{u2} Œ±} (Œº : MeasureTheory.Measure.{u2} Œ± m) {s : Œπ -> (Set.{u2} Œ±)}, (forall (i : Œπ), MeasurableSet.{u2} Œ± m (s i)) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m Œº) (Set.univ.{u2} Œ±)) (tsum.{0, u1} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Œπ (fun (i : Œπ) => MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m Œº) (s i)))) -> (Exists.{succ u1} Œπ (fun (i : Œπ) => Exists.{succ u1} Œπ (fun (j : Œπ) => Exists.{0} (Ne.{succ u1} Œπ i j) (fun (h : Ne.{succ u1} Œπ i j) => Set.Nonempty.{u2} Œ± (Inter.inter.{u2} (Set.{u2} Œ±) (Set.instInterSet.{u2} Œ±) (s i) (s j))))))
Case conversion may be inaccurate. Consider using '#align measure_theory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure MeasureTheory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure‚Çì'. -/
/-- Pigeonhole principle for measure spaces: if `‚àë' i, Œº (s i) > Œº univ`, then
one of the intersections `s i ‚à© s j` is not empty. -/
theorem exists_nonempty_inter_of_measure_univ_lt_tsum_measure {m : MeasurableSpace Œ±}
    (Œº : Measure Œ±) {s : Œπ ‚Üí Set Œ±} (hs : ‚àÄ i, MeasurableSet (s i))
    (H : Œº (univ : Set Œ±) < ‚àë' i, Œº (s i)) : ‚àÉ (i j : _)(h : i ‚â† j), (s i ‚à© s j).Nonempty :=
  by
  contrapose! H
  apply tsum_measure_le_measure_univ hs
  intro i j hij
  rw [Function.onFun, disjoint_iff_inf_le]
  exact fun x hx => H i j hij ‚ü®x, hx‚ü©
#align measure_theory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure MeasureTheory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure

/- warning: measure_theory.exists_nonempty_inter_of_measure_univ_lt_sum_measure -> MeasureTheory.exists_nonempty_inter_of_measure_univ_lt_sum_measure is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m) {s : Finset.{u2} Œπ} {t : Œπ -> (Set.{u1} Œ±)}, (forall (i : Œπ), (Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) i s) -> (MeasurableSet.{u1} Œ± m (t i))) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.univ.{u1} Œ±)) (Finset.sum.{0, u2} ENNReal Œπ (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) s (fun (i : Œπ) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (t i)))) -> (Exists.{succ u2} Œπ (fun (i : Œπ) => Exists.{0} (Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) i s) (fun (H : Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) i s) => Exists.{succ u2} Œπ (fun (j : Œπ) => Exists.{0} (Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) j s) (fun (H : Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) j s) => Exists.{0} (Ne.{succ u2} Œπ i j) (fun (h : Ne.{succ u2} Œπ i j) => Set.Nonempty.{u1} Œ± (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) (t i) (t j))))))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m : MeasurableSpace.{u2} Œ±} (Œº : MeasureTheory.Measure.{u2} Œ± m) {s : Finset.{u1} Œπ} {t : Œπ -> (Set.{u2} Œ±)}, (forall (i : Œπ), (Membership.mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.instMembershipFinset.{u1} Œπ) i s) -> (MeasurableSet.{u2} Œ± m (t i))) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m Œº) (Set.univ.{u2} Œ±)) (Finset.sum.{0, u1} ENNReal Œπ (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) s (fun (i : Œπ) => MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m Œº) (t i)))) -> (Exists.{succ u1} Œπ (fun (i : Œπ) => And (Membership.mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.instMembershipFinset.{u1} Œπ) i s) (Exists.{succ u1} Œπ (fun (j : Œπ) => And (Membership.mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.instMembershipFinset.{u1} Œπ) j s) (Exists.{0} (Ne.{succ u1} Œπ i j) (fun (_h : Ne.{succ u1} Œπ i j) => Set.Nonempty.{u2} Œ± (Inter.inter.{u2} (Set.{u2} Œ±) (Set.instInterSet.{u2} Œ±) (t i) (t j))))))))
Case conversion may be inaccurate. Consider using '#align measure_theory.exists_nonempty_inter_of_measure_univ_lt_sum_measure MeasureTheory.exists_nonempty_inter_of_measure_univ_lt_sum_measure‚Çì'. -/
/-- Pigeonhole principle for measure spaces: if `s` is a `finset` and
`‚àë i in s, Œº (t i) > Œº univ`, then one of the intersections `t i ‚à© t j` is not empty. -/
theorem exists_nonempty_inter_of_measure_univ_lt_sum_measure {m : MeasurableSpace Œ±} (Œº : Measure Œ±)
    {s : Finset Œπ} {t : Œπ ‚Üí Set Œ±} (h : ‚àÄ i ‚àà s, MeasurableSet (t i))
    (H : Œº (univ : Set Œ±) < ‚àë i in s, Œº (t i)) :
    ‚àÉ i ‚àà s, ‚àÉ j ‚àà s, ‚àÉ h : i ‚â† j, (t i ‚à© t j).Nonempty :=
  by
  contrapose! H
  apply sum_measure_le_measure_univ h
  intro i hi j hj hij
  rw [Function.onFun, disjoint_iff_inf_le]
  exact fun x hx => H i hi j hj hij ‚ü®x, hx‚ü©
#align measure_theory.exists_nonempty_inter_of_measure_univ_lt_sum_measure MeasureTheory.exists_nonempty_inter_of_measure_univ_lt_sum_measure

/- warning: measure_theory.nonempty_inter_of_measure_lt_add -> MeasureTheory.nonempty_inter_of_measure_lt_add is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m) {s : Set.{u1} Œ±} {t : Set.{u1} Œ±} {u : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m t) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s u) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) t u) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº u) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº t))) -> (Set.Nonempty.{u1} Œ± (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s t))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m) {s : Set.{u1} Œ±} {t : Set.{u1} Œ±} {u : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m t) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s u) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) t u) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) u) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) t))) -> (Set.Nonempty.{u1} Œ± (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s t))
Case conversion may be inaccurate. Consider using '#align measure_theory.nonempty_inter_of_measure_lt_add MeasureTheory.nonempty_inter_of_measure_lt_add‚Çì'. -/
/-- If two sets `s` and `t` are included in a set `u`, and `Œº s + Œº t > Œº u`,
then `s` intersects `t`. Version assuming that `t` is measurable. -/
theorem nonempty_inter_of_measure_lt_add {m : MeasurableSpace Œ±} (Œº : Measure Œ±) {s t u : Set Œ±}
    (ht : MeasurableSet t) (h's : s ‚äÜ u) (h't : t ‚äÜ u) (h : Œº u < Œº s + Œº t) : (s ‚à© t).Nonempty :=
  by
  rw [‚Üê Set.not_disjoint_iff_nonempty_inter]
  contrapose! h
  calc
    Œº s + Œº t = Œº (s ‚à™ t) := (measure_union h ht).symm
    _ ‚â§ Œº u := measure_mono (union_subset h's h't)
    
#align measure_theory.nonempty_inter_of_measure_lt_add MeasureTheory.nonempty_inter_of_measure_lt_add

/- warning: measure_theory.nonempty_inter_of_measure_lt_add' -> MeasureTheory.nonempty_inter_of_measure_lt_add' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m) {s : Set.{u1} Œ±} {t : Set.{u1} Œ±} {u : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m s) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s u) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) t u) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº u) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº t))) -> (Set.Nonempty.{u1} Œ± (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s t))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m) {s : Set.{u1} Œ±} {t : Set.{u1} Œ±} {u : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m s) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s u) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) t u) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) u) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) t))) -> (Set.Nonempty.{u1} Œ± (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s t))
Case conversion may be inaccurate. Consider using '#align measure_theory.nonempty_inter_of_measure_lt_add' MeasureTheory.nonempty_inter_of_measure_lt_add'‚Çì'. -/
/-- If two sets `s` and `t` are included in a set `u`, and `Œº s + Œº t > Œº u`,
then `s` intersects `t`. Version assuming that `s` is measurable. -/
theorem nonempty_inter_of_measure_lt_add' {m : MeasurableSpace Œ±} (Œº : Measure Œ±) {s t u : Set Œ±}
    (hs : MeasurableSet s) (h's : s ‚äÜ u) (h't : t ‚äÜ u) (h : Œº u < Œº s + Œº t) : (s ‚à© t).Nonempty :=
  by
  rw [add_comm] at h
  rw [inter_comm]
  exact nonempty_inter_of_measure_lt_add Œº hs h't h's h
#align measure_theory.nonempty_inter_of_measure_lt_add' MeasureTheory.nonempty_inter_of_measure_lt_add'

/- warning: measure_theory.measure_Union_eq_supr -> MeasureTheory.measure_union·µ¢_eq_sup·µ¢ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_1 : Countable.{succ u2} Œπ] {s : Œπ -> (Set.{u1} Œ±)}, (Directed.{u1, succ u2} (Set.{u1} Œ±) Œπ (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±)) s) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => s i))) (sup·µ¢.{0, succ u2} ENNReal (ConditionallyCompleteLattice.toHasSup.{0} ENNReal (CompleteLattice.toConditionallyCompleteLattice.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ (fun (i : Œπ) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (s i))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_1 : Countable.{succ u2} Œπ] {s : Œπ -> (Set.{u1} Œ±)}, (Directed.{u1, succ u2} (Set.{u1} Œ±) Œπ (fun (x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.6293 : Set.{u1} Œ±) (x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.6295 : Set.{u1} Œ±) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.6293 x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.6295) s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => s i))) (sup·µ¢.{0, succ u2} ENNReal (ConditionallyCompleteLattice.toSupSet.{0} ENNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} ENNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} ENNReal (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) Œπ (fun (i : Œπ) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (s i))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_Union_eq_supr MeasureTheory.measure_union·µ¢_eq_sup·µ¢‚Çì'. -/
/-- Continuity from below: the measure of the union of a directed sequence of (not necessarily
-measurable) sets is the supremum of the measures. -/
theorem measure_union·µ¢_eq_sup·µ¢ [Countable Œπ] {s : Œπ ‚Üí Set Œ±} (hd : Directed (¬∑ ‚äÜ ¬∑) s) :
    Œº (‚ãÉ i, s i) = ‚®Ü i, Œº (s i) := by
  cases nonempty_encodable Œπ
  -- WLOG, `Œπ = ‚Ñï`
  generalize ht : Function.extend Encodable.encode s ‚ä• = t
  replace hd : Directed (¬∑ ‚äÜ ¬∑) t := ht ‚ñ∏ hd.extend_bot Encodable.encode_injective
  suffices Œº (‚ãÉ n, t n) = ‚®Ü n, Œº (t n)
    by
    simp only [‚Üê ht, encodable.encode_injective.apply_extend Œº, ‚Üê supr_eq_Union,
      sup·µ¢_extend_bot Encodable.encode_injective, (¬∑ ‚àò ¬∑), Pi.bot_apply, bot_eq_empty,
      measure_empty] at this
    exact this.trans (sup·µ¢_extend_bot Encodable.encode_injective _)
  clear! Œπ
  -- The `‚â•` inequality is trivial
  refine' le_antisymm _ (sup·µ¢_le fun i => measure_mono <| subset_Union _ _)
  -- Choose `T n ‚äá t n` of the same measure, put `Td n = disjointed T`
  set T : ‚Ñï ‚Üí Set Œ± := fun n => to_measurable Œº (t n)
  set Td : ‚Ñï ‚Üí Set Œ± := disjointed T
  have hm : ‚àÄ n, MeasurableSet (Td n) :=
    MeasurableSet.disjointed fun n => measurable_set_to_measurable _ _
  calc
    Œº (‚ãÉ n, t n) ‚â§ Œº (‚ãÉ n, T n) := measure_mono (Union_mono fun i => subset_to_measurable _ _)
    _ = Œº (‚ãÉ n, Td n) := by rw [union·µ¢_disjointed]
    _ ‚â§ ‚àë' n, Œº (Td n) := (measure_Union_le _)
    _ = ‚®Ü I : Finset ‚Ñï, ‚àë n in I, Œº (Td n) := ENNReal.tsum_eq_sup·µ¢_sum
    _ ‚â§ ‚®Ü n, Œº (t n) := sup·µ¢_le fun I => _
    
  rcases hd.finset_le I with ‚ü®N, hN‚ü©
  calc
    (‚àë n in I, Œº (Td n)) = Œº (‚ãÉ n ‚àà I, Td n) :=
      (measure_bUnion_finset ((disjoint_disjointed T).set_pairwise I) fun n _ => hm n).symm
    _ ‚â§ Œº (‚ãÉ n ‚àà I, T n) := (measure_mono (Union‚ÇÇ_mono fun n hn => disjointed_subset _ _))
    _ = Œº (‚ãÉ n ‚àà I, t n) := (measure_bUnion_to_measurable I.countable_to_set _)
    _ ‚â§ Œº (t N) := (measure_mono (Union‚ÇÇ_subset hN))
    _ ‚â§ ‚®Ü n, Œº (t n) := le_sup·µ¢ (Œº ‚àò t) N
    
#align measure_theory.measure_Union_eq_supr MeasureTheory.measure_union·µ¢_eq_sup·µ¢

/- warning: measure_theory.measure_bUnion_eq_supr -> MeasureTheory.measure_bunion·µ¢_eq_sup·µ¢ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Œπ -> (Set.{u1} Œ±)} {t : Set.{u2} Œπ}, (Set.Countable.{u2} Œπ t) -> (DirectedOn.{u2} Œπ (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±)) s) t) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => Set.union·µ¢.{u1, 0} Œ± (Membership.Mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.hasMem.{u2} Œπ) i t) (fun (H : Membership.Mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.hasMem.{u2} Œπ) i t) => s i)))) (sup·µ¢.{0, succ u2} ENNReal (ConditionallyCompleteLattice.toHasSup.{0} ENNReal (CompleteLattice.toConditionallyCompleteLattice.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ (fun (i : Œπ) => sup·µ¢.{0, 0} ENNReal (ConditionallyCompleteLattice.toHasSup.{0} ENNReal (CompleteLattice.toConditionallyCompleteLattice.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) (Membership.Mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.hasMem.{u2} Œπ) i t) (fun (H : Membership.Mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.hasMem.{u2} Œπ) i t) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (s i)))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m : MeasurableSpace.{u2} Œ±} {Œº : MeasureTheory.Measure.{u2} Œ± m} {s : Œπ -> (Set.{u2} Œ±)} {t : Set.{u1} Œπ}, (Set.Countable.{u1} Œπ t) -> (DirectedOn.{u1} Œπ (Function.onFun.{succ u1, succ u2, 1} Œπ (Set.{u2} Œ±) Prop (fun (x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.7636 : Set.{u2} Œ±) (x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.7638 : Set.{u2} Œ±) => HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.instHasSubsetSet.{u2} Œ±) x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.7636 x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.7638) s) t) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m Œº) (Set.union·µ¢.{u2, succ u1} Œ± Œπ (fun (i : Œπ) => Set.union·µ¢.{u2, 0} Œ± (Membership.mem.{u1, u1} Œπ (Set.{u1} Œπ) (Set.instMembershipSet.{u1} Œπ) i t) (fun (H : Membership.mem.{u1, u1} Œπ (Set.{u1} Œπ) (Set.instMembershipSet.{u1} Œπ) i t) => s i)))) (sup·µ¢.{0, succ u1} ENNReal (ConditionallyCompleteLattice.toSupSet.{0} ENNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} ENNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} ENNReal (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) Œπ (fun (i : Œπ) => sup·µ¢.{0, 0} ENNReal (ConditionallyCompleteLattice.toSupSet.{0} ENNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} ENNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} ENNReal (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) (Membership.mem.{u1, u1} Œπ (Set.{u1} Œπ) (Set.instMembershipSet.{u1} Œπ) i t) (fun (H : Membership.mem.{u1, u1} Œπ (Set.{u1} Œπ) (Set.instMembershipSet.{u1} Œπ) i t) => MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m Œº) (s i)))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_bUnion_eq_supr MeasureTheory.measure_bunion·µ¢_eq_sup·µ¢‚Çì'. -/
theorem measure_bunion·µ¢_eq_sup·µ¢ {s : Œπ ‚Üí Set Œ±} {t : Set Œπ} (ht : t.Countable)
    (hd : DirectedOn ((¬∑ ‚äÜ ¬∑) on s) t) : Œº (‚ãÉ i ‚àà t, s i) = ‚®Ü i ‚àà t, Œº (s i) :=
  by
  haveI := ht.to_encodable
  rw [bUnion_eq_Union, measure_Union_eq_supr hd.directed_coe, ‚Üê sup·µ¢_subtype'']
#align measure_theory.measure_bUnion_eq_supr MeasureTheory.measure_bunion·µ¢_eq_sup·µ¢

/- warning: measure_theory.measure_Inter_eq_infi -> MeasureTheory.measure_inter·µ¢_eq_inf·µ¢ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_1 : Countable.{succ u2} Œπ] {s : Œπ -> (Set.{u1} Œ±)}, (forall (i : Œπ), MeasurableSet.{u1} Œ± m (s i)) -> (Directed.{u1, succ u2} (Set.{u1} Œ±) Œπ (Superset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±)) s) -> (Exists.{succ u2} Œπ (fun (i : Œπ) => Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (s i)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.inter·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => s i))) (inf·µ¢.{0, succ u2} ENNReal (ConditionallyCompleteLattice.toHasInf.{0} ENNReal (CompleteLattice.toConditionallyCompleteLattice.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ (fun (i : Œπ) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (s i))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_1 : Countable.{succ u2} Œπ] {s : Œπ -> (Set.{u1} Œ±)}, (forall (i : Œπ), MeasurableSet.{u1} Œ± m (s i)) -> (Directed.{u1, succ u2} (Set.{u1} Œ±) Œπ (fun (x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.7814 : Set.{u1} Œ±) (x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.7816 : Set.{u1} Œ±) => Superset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.7814 x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.7816) s) -> (Exists.{succ u2} Œπ (fun (i : Œπ) => Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (s i)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.inter·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => s i))) (inf·µ¢.{0, succ u2} ENNReal (ConditionallyCompleteLattice.toInfSet.{0} ENNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} ENNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} ENNReal (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) Œπ (fun (i : Œπ) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (s i))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_Inter_eq_infi MeasureTheory.measure_inter·µ¢_eq_inf·µ¢‚Çì'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t ¬´expr ‚äÜ ¬ª s k) -/
/-- Continuity from above: the measure of the intersection of a decreasing sequence of measurable
sets is the infimum of the measures. -/
theorem measure_inter·µ¢_eq_inf·µ¢ [Countable Œπ] {s : Œπ ‚Üí Set Œ±} (h : ‚àÄ i, MeasurableSet (s i))
    (hd : Directed (¬∑ ‚äá ¬∑) s) (hfin : ‚àÉ i, Œº (s i) ‚â† ‚àû) : Œº (‚ãÇ i, s i) = ‚®Ö i, Œº (s i) :=
  by
  rcases hfin with ‚ü®k, hk‚ü©
  have : ‚àÄ (t) (_ : t ‚äÜ s k), Œº t ‚â† ‚àû := fun t ht => ne_top_of_le_ne_top hk (measure_mono ht)
  rw [‚Üê ENNReal.sub_sub_cancel hk (inf·µ¢_le _ k), ENNReal.sub_inf·µ¢, ‚Üê
    ENNReal.sub_sub_cancel hk (measure_mono (Inter_subset _ k)), ‚Üê
    measure_diff (Inter_subset _ k) (MeasurableSet.inter·µ¢ h) (this _ (Inter_subset _ k)),
    diff_Inter, measure_Union_eq_supr]
  ¬∑ congr 1
    refine' le_antisymm (sup·µ¢_mono' fun i => _) (sup·µ¢_mono fun i => _)
    ¬∑ rcases hd i k with ‚ü®j, hji, hjk‚ü©
      use j
      rw [‚Üê measure_diff hjk (h _) (this _ hjk)]
      exact measure_mono (diff_subset_diff_right hji)
    ¬∑ rw [tsub_le_iff_right, ‚Üê measure_union disjoint_sdiff_left (h i), Set.union_comm]
      exact measure_mono (diff_subset_iff.1 <| subset.refl _)
  ¬∑ exact hd.mono_comp _ fun _ _ => diff_subset_diff_right
#align measure_theory.measure_Inter_eq_infi MeasureTheory.measure_inter·µ¢_eq_inf·µ¢

/- warning: measure_theory.tendsto_measure_Union -> MeasureTheory.tendsto_measure_union·µ¢ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_1 : SemilatticeSup.{u2} Œπ] [_inst_2 : Countable.{succ u2} Œπ] {s : Œπ -> (Set.{u1} Œ±)}, (Monotone.{u2, u1} Œπ (Set.{u1} Œ±) (PartialOrder.toPreorder.{u2} Œπ (SemilatticeSup.toPartialOrder.{u2} Œπ _inst_1)) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±))))))) s) -> (Filter.Tendsto.{u2, 0} Œπ ENNReal (Function.comp.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº) s) (Filter.atTop.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeSup.toPartialOrder.{u2} Œπ _inst_1))) (nhds.{0} ENNReal ENNReal.topologicalSpace (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (n : Œπ) => s n)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_1 : SemilatticeSup.{u2} Œπ] [_inst_2 : Countable.{succ u2} Œπ] {s : Œπ -> (Set.{u1} Œ±)}, (Monotone.{u2, u1} Œπ (Set.{u1} Œ±) (PartialOrder.toPreorder.{u2} Œπ (SemilatticeSup.toPartialOrder.{u2} Œπ _inst_1)) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))))) s) -> (Filter.Tendsto.{u2, 0} Œπ ENNReal (Function.comp.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº)) s) (Filter.atTop.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeSup.toPartialOrder.{u2} Œπ _inst_1))) (nhds.{0} ENNReal ENNReal.instTopologicalSpaceENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (n : Œπ) => s n)))))
Case conversion may be inaccurate. Consider using '#align measure_theory.tendsto_measure_Union MeasureTheory.tendsto_measure_union·µ¢‚Çì'. -/
/-- Continuity from below: the measure of the union of an increasing sequence of measurable sets
is the limit of the measures. -/
theorem tendsto_measure_union·µ¢ [SemilatticeSup Œπ] [Countable Œπ] {s : Œπ ‚Üí Set Œ±} (hm : Monotone s) :
    Tendsto (Œº ‚àò s) atTop (ùìù (Œº (‚ãÉ n, s n))) :=
  by
  rw [measure_Union_eq_supr (directed_of_sup hm)]
  exact tendsto_atTop_sup·µ¢ fun n m hnm => measure_mono <| hm hnm
#align measure_theory.tendsto_measure_Union MeasureTheory.tendsto_measure_union·µ¢

/- warning: measure_theory.tendsto_measure_Inter -> MeasureTheory.tendsto_measure_inter·µ¢ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_1 : Countable.{succ u2} Œπ] [_inst_2 : SemilatticeSup.{u2} Œπ] {s : Œπ -> (Set.{u1} Œ±)}, (forall (n : Œπ), MeasurableSet.{u1} Œ± m (s n)) -> (Antitone.{u2, u1} Œπ (Set.{u1} Œ±) (PartialOrder.toPreorder.{u2} Œπ (SemilatticeSup.toPartialOrder.{u2} Œπ _inst_2)) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±))))))) s) -> (Exists.{succ u2} Œπ (fun (i : Œπ) => Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (s i)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) -> (Filter.Tendsto.{u2, 0} Œπ ENNReal (Function.comp.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº) s) (Filter.atTop.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeSup.toPartialOrder.{u2} Œπ _inst_2))) (nhds.{0} ENNReal ENNReal.topologicalSpace (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.inter·µ¢.{u1, succ u2} Œ± Œπ (fun (n : Œπ) => s n)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_1 : Countable.{succ u2} Œπ] [_inst_2 : SemilatticeSup.{u2} Œπ] {s : Œπ -> (Set.{u1} Œ±)}, (forall (n : Œπ), MeasurableSet.{u1} Œ± m (s n)) -> (Antitone.{u2, u1} Œπ (Set.{u1} Œ±) (PartialOrder.toPreorder.{u2} Œπ (SemilatticeSup.toPartialOrder.{u2} Œπ _inst_2)) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))))) s) -> (Exists.{succ u2} Œπ (fun (i : Œπ) => Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (s i)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) -> (Filter.Tendsto.{u2, 0} Œπ ENNReal (Function.comp.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº)) s) (Filter.atTop.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeSup.toPartialOrder.{u2} Œπ _inst_2))) (nhds.{0} ENNReal ENNReal.instTopologicalSpaceENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.inter·µ¢.{u1, succ u2} Œ± Œπ (fun (n : Œπ) => s n)))))
Case conversion may be inaccurate. Consider using '#align measure_theory.tendsto_measure_Inter MeasureTheory.tendsto_measure_inter·µ¢‚Çì'. -/
/-- Continuity from above: the measure of the intersection of a decreasing sequence of measurable
sets is the limit of the measures. -/
theorem tendsto_measure_inter·µ¢ [Countable Œπ] [SemilatticeSup Œπ] {s : Œπ ‚Üí Set Œ±}
    (hs : ‚àÄ n, MeasurableSet (s n)) (hm : Antitone s) (hf : ‚àÉ i, Œº (s i) ‚â† ‚àû) :
    Tendsto (Œº ‚àò s) atTop (ùìù (Œº (‚ãÇ n, s n))) :=
  by
  rw [measure_Inter_eq_infi hs (directed_of_sup hm) hf]
  exact tendsto_atTop_inf·µ¢ fun n m hnm => measure_mono <| hm hnm
#align measure_theory.tendsto_measure_Inter MeasureTheory.tendsto_measure_inter·µ¢

/- warning: measure_theory.tendsto_measure_bInter_gt -> MeasureTheory.tendsto_measure_binter·µ¢_gt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {Œπ : Type.{u2}} [_inst_1 : LinearOrder.{u2} Œπ] [_inst_2 : TopologicalSpace.{u2} Œπ] [_inst_3 : OrderTopology.{u2} Œπ _inst_2 (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (LinearOrder.toLattice.{u2} Œπ _inst_1))))] [_inst_4 : DenselyOrdered.{u2} Œπ (Preorder.toLT.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (LinearOrder.toLattice.{u2} Œπ _inst_1)))))] [_inst_5 : TopologicalSpace.FirstCountableTopology.{u2} Œπ _inst_2] {s : Œπ -> (Set.{u1} Œ±)} {a : Œπ}, (forall (r : Œπ), (GT.gt.{u2} Œπ (Preorder.toLT.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (LinearOrder.toLattice.{u2} Œπ _inst_1))))) r a) -> (MeasurableSet.{u1} Œ± m (s r))) -> (forall (i : Œπ) (j : Œπ), (LT.lt.{u2} Œπ (Preorder.toLT.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (LinearOrder.toLattice.{u2} Œπ _inst_1))))) a i) -> (LE.le.{u2} Œπ (Preorder.toLE.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (LinearOrder.toLattice.{u2} Œπ _inst_1))))) i j) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (s i) (s j))) -> (Exists.{succ u2} Œπ (fun (r : Œπ) => Exists.{0} (GT.gt.{u2} Œπ (Preorder.toLT.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (LinearOrder.toLattice.{u2} Œπ _inst_1))))) r a) (fun (H : GT.gt.{u2} Œπ (Preorder.toLT.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (LinearOrder.toLattice.{u2} Œπ _inst_1))))) r a) => Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (s r)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))))) -> (Filter.Tendsto.{u2, 0} Œπ ENNReal (Function.comp.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº) s) (nhdsWithin.{u2} Œπ _inst_2 a (Set.Ioi.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (LinearOrder.toLattice.{u2} Œπ _inst_1)))) a)) (nhds.{0} ENNReal ENNReal.topologicalSpace (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.inter·µ¢.{u1, succ u2} Œ± Œπ (fun (r : Œπ) => Set.inter·µ¢.{u1, 0} Œ± (GT.gt.{u2} Œπ (Preorder.toLT.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (LinearOrder.toLattice.{u2} Œπ _inst_1))))) r a) (fun (H : GT.gt.{u2} Œπ (Preorder.toLT.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (LinearOrder.toLattice.{u2} Œπ _inst_1))))) r a) => s r))))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {Œπ : Type.{u2}} [_inst_1 : LinearOrder.{u2} Œπ] [_inst_2 : TopologicalSpace.{u2} Œπ] [_inst_3 : OrderTopology.{u2} Œπ _inst_2 (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (DistribLattice.toLattice.{u2} Œπ (instDistribLattice.{u2} Œπ _inst_1)))))] [_inst_4 : DenselyOrdered.{u2} Œπ (Preorder.toLT.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (DistribLattice.toLattice.{u2} Œπ (instDistribLattice.{u2} Œπ _inst_1))))))] [_inst_5 : TopologicalSpace.FirstCountableTopology.{u2} Œπ _inst_2] {s : Œπ -> (Set.{u1} Œ±)} {a : Œπ}, (forall (r : Œπ), (GT.gt.{u2} Œπ (Preorder.toLT.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (DistribLattice.toLattice.{u2} Œπ (instDistribLattice.{u2} Œπ _inst_1)))))) r a) -> (MeasurableSet.{u1} Œ± m (s r))) -> (forall (i : Œπ) (j : Œπ), (LT.lt.{u2} Œπ (Preorder.toLT.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (DistribLattice.toLattice.{u2} Œπ (instDistribLattice.{u2} Œπ _inst_1)))))) a i) -> (LE.le.{u2} Œπ (Preorder.toLE.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (DistribLattice.toLattice.{u2} Œπ (instDistribLattice.{u2} Œπ _inst_1)))))) i j) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (s i) (s j))) -> (Exists.{succ u2} Œπ (fun (r : Œπ) => And (GT.gt.{u2} Œπ (Preorder.toLT.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (DistribLattice.toLattice.{u2} Œπ (instDistribLattice.{u2} Œπ _inst_1)))))) r a) (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (s r)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))))) -> (Filter.Tendsto.{u2, 0} Œπ ENNReal (Function.comp.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº)) s) (nhdsWithin.{u2} Œπ _inst_2 a (Set.Ioi.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (DistribLattice.toLattice.{u2} Œπ (instDistribLattice.{u2} Œπ _inst_1))))) a)) (nhds.{0} ENNReal ENNReal.instTopologicalSpaceENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.inter·µ¢.{u1, succ u2} Œ± Œπ (fun (r : Œπ) => Set.inter·µ¢.{u1, 0} Œ± (GT.gt.{u2} Œπ (Preorder.toLT.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (DistribLattice.toLattice.{u2} Œπ (instDistribLattice.{u2} Œπ _inst_1)))))) r a) (fun (H : GT.gt.{u2} Œπ (Preorder.toLT.{u2} Œπ (PartialOrder.toPreorder.{u2} Œπ (SemilatticeInf.toPartialOrder.{u2} Œπ (Lattice.toSemilatticeInf.{u2} Œπ (DistribLattice.toLattice.{u2} Œπ (instDistribLattice.{u2} Œπ _inst_1)))))) r a) => s r))))))
Case conversion may be inaccurate. Consider using '#align measure_theory.tendsto_measure_bInter_gt MeasureTheory.tendsto_measure_binter·µ¢_gt‚Çì'. -/
/-- The measure of the intersection of a decreasing sequence of measurable
sets indexed by a linear order with first countable topology is the limit of the measures. -/
theorem tendsto_measure_binter·µ¢_gt {Œπ : Type _} [LinearOrder Œπ] [TopologicalSpace Œπ]
    [OrderTopology Œπ] [DenselyOrdered Œπ] [TopologicalSpace.FirstCountableTopology Œπ] {s : Œπ ‚Üí Set Œ±}
    {a : Œπ} (hs : ‚àÄ r > a, MeasurableSet (s r)) (hm : ‚àÄ i j, a < i ‚Üí i ‚â§ j ‚Üí s i ‚äÜ s j)
    (hf : ‚àÉ r > a, Œº (s r) ‚â† ‚àû) : Tendsto (Œº ‚àò s) (ùìù[Ioi a] a) (ùìù (Œº (‚ãÇ r > a, s r))) :=
  by
  refine' tendsto_order.2 ‚ü®fun l hl => _, fun L hL => _‚ü©
  ¬∑
    filter_upwards [self_mem_nhdsWithin]with r hr using hl.trans_le
        (measure_mono (bInter_subset_of_mem hr))
  obtain ‚ü®u, u_anti, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí Œπ, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, a < u n) ‚àß tendsto u at_top (ùìù a) :=
    by
    rcases hf with ‚ü®r, ar, hr‚ü©
    rcases exists_seq_strictAnti_tendsto' ar with ‚ü®w, w_anti, w_mem, w_lim‚ü©
    exact ‚ü®w, w_anti, fun n => (w_mem n).1, w_lim‚ü©
  have A : tendsto (Œº ‚àò s ‚àò u) at_top (ùìù (Œº (‚ãÇ n, s (u n)))) :=
    by
    refine' tendsto_measure_Inter (fun n => hs _ (u_pos n)) _ _
    ¬∑ intro m n hmn
      exact hm _ _ (u_pos n) (u_anti.antitone hmn)
    ¬∑ rcases hf with ‚ü®r, rpos, hr‚ü©
      obtain ‚ü®n, hn‚ü© : ‚àÉ n : ‚Ñï, u n < r := ((tendsto_order.1 u_lim).2 r rpos).exists
      refine' ‚ü®n, ne_of_lt (lt_of_le_of_lt _ hr.lt_top)‚ü©
      exact measure_mono (hm _ _ (u_pos n) hn.le)
  have B : (‚ãÇ n, s (u n)) = ‚ãÇ r > a, s r :=
    by
    apply subset.antisymm
    ¬∑ simp only [subset_Inter_iff, gt_iff_lt]
      intro r rpos
      obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < r := ((tendsto_order.1 u_lim).2 _ rpos).exists
      exact subset.trans (Inter_subset _ n) (hm (u n) r (u_pos n) hn.le)
    ¬∑ simp only [subset_Inter_iff, gt_iff_lt]
      intro n
      apply bInter_subset_of_mem
      exact u_pos n
  rw [B] at A
  obtain ‚ü®n, hn‚ü© : ‚àÉ n, Œº (s (u n)) < L := ((tendsto_order.1 A).2 _ hL).exists
  have : Ioc a (u n) ‚àà ùìù[>] a := Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, u_pos n‚ü©
  filter_upwards [this]with r hr using lt_of_le_of_lt (measure_mono (hm _ _ hr.1 hr.2)) hn
#align measure_theory.tendsto_measure_bInter_gt MeasureTheory.tendsto_measure_binter·µ¢_gt

/- warning: measure_theory.measure_limsup_eq_zero -> MeasureTheory.measure_limsup_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Nat -> (Set.{u1} Œ±)}, (Ne.{1} ENNReal (tsum.{0, 0} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Nat (fun (i : Nat) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (s i))) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Filter.limsup.{u1, 0} (Set.{u1} Œ±) Nat (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±))))) s (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Nat -> (Set.{u1} Œ±)}, (Ne.{1} ENNReal (tsum.{0, 0} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Nat (fun (i : Nat) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (s i))) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Filter.limsup.{u1, 0} (Set.{u1} Œ±) Nat (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))) s (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_limsup_eq_zero MeasureTheory.measure_limsup_eq_zero‚Çì'. -/
/-- One direction of the **Borel-Cantelli lemma**: if (s·µ¢) is a sequence of sets such
that `‚àë Œº s·µ¢` is finite, then the limit superior of the `s·µ¢` is a null set. -/
theorem measure_limsup_eq_zero {s : ‚Ñï ‚Üí Set Œ±} (hs : (‚àë' i, Œº (s i)) ‚â† ‚àû) :
    Œº (limsup s atTop) = 0 :=
  by
  -- First we replace the sequence `s‚Çô` with a sequence of measurable sets `t‚Çô ‚äá s‚Çô` of the same
  -- measure.
  set t : ‚Ñï ‚Üí Set Œ± := fun n => to_measurable Œº (s n)
  have ht : (‚àë' i, Œº (t i)) ‚â† ‚àû := by simpa only [t, measure_to_measurable] using hs
  suffices Œº (limsup t at_top) = 0
    by
    have A : s ‚â§ t := fun n => subset_to_measurable Œº (s n)
    -- TODO default args fail
    exact
      measure_mono_null
        (limsup_le_limsup (eventually_of_forall (pi.le_def.mp A)) is_cobounded_le_of_bot
          is_bounded_le_of_top)
        this
  -- Next we unfold `limsup` for sets and replace equality with an inequality
  simp only [limsup_eq_infi_supr_of_nat', Set.inf·µ¢_eq_inter·µ¢, Set.sup·µ¢_eq_union·µ¢, ‚Üê
    nonpos_iff_eq_zero]
  -- Finally, we estimate `Œº (‚ãÉ i, t (i + n))` by `‚àë i', Œº (t (i + n))`
  refine'
    le_of_tendsto_of_tendsto'
      (tendsto_measure_Inter
        (fun i => MeasurableSet.union·µ¢ fun b => measurable_set_to_measurable _ _) _
        ‚ü®0, ne_top_of_le_ne_top ht (measure_Union_le t)‚ü©)
      (ENNReal.tendsto_sum_nat_add (Œº ‚àò t) ht) fun n => measure_Union_le _
  intro n m hnm x
  simp only [Set.mem_union·µ¢]
  exact fun ‚ü®i, hi‚ü© => ‚ü®i + (m - n), by simpa only [add_assoc, tsub_add_cancel_of_le hnm] using hi‚ü©
#align measure_theory.measure_limsup_eq_zero MeasureTheory.measure_limsup_eq_zero

/- warning: measure_theory.measure_liminf_eq_zero -> MeasureTheory.measure_liminf_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Nat -> (Set.{u1} Œ±)}, (Ne.{1} ENNReal (tsum.{0, 0} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Nat (fun (i : Nat) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (s i))) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Filter.liminf.{u1, 0} (Set.{u1} Œ±) Nat (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±))))) s (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {s : Nat -> (Set.{u1} Œ±)}, (Ne.{1} ENNReal (tsum.{0, 0} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Nat (fun (i : Nat) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (s i))) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Filter.liminf.{u1, 0} (Set.{u1} Œ±) Nat (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))) s (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_liminf_eq_zero MeasureTheory.measure_liminf_eq_zero‚Çì'. -/
/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic filter.is_bounded_default -/
/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic filter.is_bounded_default -/
theorem measure_liminf_eq_zero {s : ‚Ñï ‚Üí Set Œ±} (h : (‚àë' i, Œº (s i)) ‚â† ‚ä§) : Œº (liminf s atTop) = 0 :=
  by
  rw [‚Üê le_zero_iff]
  have : liminf s at_top ‚â§ limsup s at_top :=
    liminf_le_limsup
      (by
        run_tac
          is_bounded_default)
      (by
        run_tac
          is_bounded_default)
  exact (Œº.mono this).trans (by simp [measure_limsup_eq_zero h])
#align measure_theory.measure_liminf_eq_zero MeasureTheory.measure_liminf_eq_zero

/- warning: measure_theory.limsup_ae_eq_of_forall_ae_eq -> MeasureTheory.limsup_ae_eq_of_forall_ae_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} (s : Nat -> (Set.{u1} Œ±)) {t : Set.{u1} Œ±}, (forall (n : Nat), Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m Œº) (s n) t) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m Œº) (Filter.limsup.{u1, 0} (Set.{u1} Œ±) Nat (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±))))) s (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) t)
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} (s : Nat -> (Set.{u1} Œ±)) {t : Set.{u1} Œ±}, (forall (n : Nat), Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m Œº) (s n) t) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m Œº) (Filter.limsup.{u1, 0} (Set.{u1} Œ±) Nat (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))) s (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) t)
Case conversion may be inaccurate. Consider using '#align measure_theory.limsup_ae_eq_of_forall_ae_eq MeasureTheory.limsup_ae_eq_of_forall_ae_eq‚Çì'. -/
theorem limsup_ae_eq_of_forall_ae_eq (s : ‚Ñï ‚Üí Set Œ±) {t : Set Œ±}
    (h : ‚àÄ n, s n =·µê[Œº] t) :-- Need `@` below because of diamond; see gh issue #16932
        @limsup
        (Set Œ±) ‚Ñï _ s atTop =·µê[Œº]
      t :=
  by
  simp_rw [ae_eq_set] at h‚ä¢
  constructor
  ¬∑ rw [at_top.limsup_sdiff s t]
    apply measure_limsup_eq_zero
    simp [h]
  ¬∑ rw [at_top.sdiff_limsup s t]
    apply measure_liminf_eq_zero
    simp [h]
#align measure_theory.limsup_ae_eq_of_forall_ae_eq MeasureTheory.limsup_ae_eq_of_forall_ae_eq

/- warning: measure_theory.liminf_ae_eq_of_forall_ae_eq -> MeasureTheory.liminf_ae_eq_of_forall_ae_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} (s : Nat -> (Set.{u1} Œ±)) {t : Set.{u1} Œ±}, (forall (n : Nat), Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m Œº) (s n) t) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m Œº) (Filter.liminf.{u1, 0} (Set.{u1} Œ±) Nat (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±))))) s (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) t)
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} (s : Nat -> (Set.{u1} Œ±)) {t : Set.{u1} Œ±}, (forall (n : Nat), Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m Œº) (s n) t) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m Œº) (Filter.liminf.{u1, 0} (Set.{u1} Œ±) Nat (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))) s (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) t)
Case conversion may be inaccurate. Consider using '#align measure_theory.liminf_ae_eq_of_forall_ae_eq MeasureTheory.liminf_ae_eq_of_forall_ae_eq‚Çì'. -/
theorem liminf_ae_eq_of_forall_ae_eq (s : ‚Ñï ‚Üí Set Œ±) {t : Set Œ±}
    (h : ‚àÄ n, s n =·µê[Œº] t) :-- Need `@` below because of diamond; see gh issue #16932
        @liminf
        (Set Œ±) ‚Ñï _ s atTop =·µê[Œº]
      t :=
  by
  simp_rw [ae_eq_set] at h‚ä¢
  constructor
  ¬∑ rw [at_top.liminf_sdiff s t]
    apply measure_liminf_eq_zero
    simp [h]
  ¬∑ rw [at_top.sdiff_liminf s t]
    apply measure_limsup_eq_zero
    simp [h]
#align measure_theory.liminf_ae_eq_of_forall_ae_eq MeasureTheory.liminf_ae_eq_of_forall_ae_eq

/- warning: measure_theory.measure_if -> MeasureTheory.measure_if is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {x : Œ≤} {t : Set.{u2} Œ≤} {s : Set.{u1} Œ±}, Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (ite.{succ u1} (Set.{u1} Œ±) (Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) x t) (Classical.propDecidable (Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) x t)) s (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.hasEmptyc.{u1} Œ±)))) (Set.indicator.{u2, 0} Œ≤ ENNReal ENNReal.hasZero t (fun (_x : Œ≤) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s) x)
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} {x : Œ≤} {t : Set.{u2} Œ≤} {s : Set.{u1} Œ±}, Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (ite.{succ u1} (Set.{u1} Œ±) (Membership.mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instMembershipSet.{u2} Œ≤) x t) (Classical.propDecidable (Membership.mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instMembershipSet.{u2} Œ≤) x t)) s (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.instEmptyCollectionSet.{u1} Œ±)))) (Set.indicator.{u2, 0} Œ≤ ENNReal instENNRealZero t (fun (_x : Œ≤) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s) x)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_if MeasureTheory.measure_if‚Çì'. -/
theorem measure_if {x : Œ≤} {t : Set Œ≤} {s : Set Œ±} :
    Œº (if x ‚àà t then s else ‚àÖ) = indicator t (fun _ => Œº s) x := by split_ifs <;> simp [h]
#align measure_theory.measure_if MeasureTheory.measure_if

end

section OuterMeasure

variable [ms : MeasurableSpace Œ±] {s t : Set Œ±}

include ms

#print MeasureTheory.OuterMeasure.toMeasure /-
/-- Obtain a measure by giving an outer measure where all sets in the œÉ-algebra are
  Carath√©odory measurable. -/
def OuterMeasure.toMeasure (m : OuterMeasure Œ±) (h : ms ‚â§ m.caratheodory) : Measure Œ± :=
  Measure.ofMeasurable (fun s _ => m s) m.Empty fun f hf hd =>
    m.union·µ¢_eq_of_caratheodory (fun i => h _ (hf i)) hd
#align measure_theory.outer_measure.to_measure MeasureTheory.OuterMeasure.toMeasure
-/

#print MeasureTheory.le_toOuterMeasure_caratheodory /-
theorem le_toOuterMeasure_caratheodory (Œº : Measure Œ±) : ms ‚â§ Œº.toOuterMeasure.caratheodory :=
  fun s hs t => (measure_inter_add_diff _ hs).symm
#align measure_theory.le_to_outer_measure_caratheodory MeasureTheory.le_toOuterMeasure_caratheodory
-/

#print MeasureTheory.toMeasure_toOuterMeasure /-
@[simp]
theorem toMeasure_toOuterMeasure (m : OuterMeasure Œ±) (h : ms ‚â§ m.caratheodory) :
    (m.toMeasure h).toOuterMeasure = m.trim :=
  rfl
#align measure_theory.to_measure_to_outer_measure MeasureTheory.toMeasure_toOuterMeasure
-/

#print MeasureTheory.toMeasure_apply /-
@[simp]
theorem toMeasure_apply (m : OuterMeasure Œ±) (h : ms ‚â§ m.caratheodory) {s : Set Œ±}
    (hs : MeasurableSet s) : m.toMeasure h s = m s :=
  m.trim_eq hs
#align measure_theory.to_measure_apply MeasureTheory.toMeasure_apply
-/

/- warning: measure_theory.le_to_measure_apply -> MeasureTheory.le_toMeasure_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [ms : MeasurableSpace.{u1} Œ±] (m : MeasureTheory.OuterMeasure.{u1} Œ±) (h : LE.le.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.hasLe.{u1} Œ±) ms (MeasureTheory.OuterMeasure.caratheodory.{u1} Œ± m)) (s : Set.{u1} Œ±), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (fun (_x : MeasureTheory.OuterMeasure.{u1} Œ±) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.OuterMeasure.instCoeFun.{u1} Œ±) m s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± ms) (fun (_x : MeasureTheory.Measure.{u1} Œ± ms) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± ms) (MeasureTheory.OuterMeasure.toMeasure.{u1} Œ± ms m h) s)
but is expected to have type
  forall {Œ± : Type.{u1}} [ms : MeasurableSpace.{u1} Œ±] (m : MeasureTheory.OuterMeasure.{u1} Œ±) (h : LE.le.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instLEMeasurableSpace.{u1} Œ±) ms (MeasureTheory.OuterMeasure.caratheodory.{u1} Œ± m)) (s : Set.{u1} Œ±), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± m s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± ms (MeasureTheory.OuterMeasure.toMeasure.{u1} Œ± ms m h)) s)
Case conversion may be inaccurate. Consider using '#align measure_theory.le_to_measure_apply MeasureTheory.le_toMeasure_apply‚Çì'. -/
theorem le_toMeasure_apply (m : OuterMeasure Œ±) (h : ms ‚â§ m.caratheodory) (s : Set Œ±) :
    m s ‚â§ m.toMeasure h s :=
  m.le_trim s
#align measure_theory.le_to_measure_apply MeasureTheory.le_toMeasure_apply

#print MeasureTheory.toMeasure_apply‚ÇÄ /-
theorem toMeasure_apply‚ÇÄ (m : OuterMeasure Œ±) (h : ms ‚â§ m.caratheodory) {s : Set Œ±}
    (hs : NullMeasurableSet s (m.toMeasure h)) : m.toMeasure h s = m s :=
  by
  refine' le_antisymm _ (le_to_measure_apply _ _ _)
  rcases hs.exists_measurable_subset_ae_eq with ‚ü®t, hts, htm, heq‚ü©
  calc
    m.to_measure h s = m.to_measure h t := measure_congr HEq.symm
    _ = m t := (to_measure_apply m h htm)
    _ ‚â§ m s := m.mono hts
    
#align measure_theory.to_measure_apply‚ÇÄ MeasureTheory.toMeasure_apply‚ÇÄ
-/

#print MeasureTheory.toOuterMeasure_toMeasure /-
@[simp]
theorem toOuterMeasure_toMeasure {Œº : Measure Œ±} :
    Œº.toOuterMeasure.toMeasure (le_toOuterMeasure_caratheodory _) = Œº :=
  Measure.ext fun s => Œº.toOuterMeasure.trim_eq
#align measure_theory.to_outer_measure_to_measure MeasureTheory.toOuterMeasure_toMeasure
-/

#print MeasureTheory.boundedBy_measure /-
@[simp]
theorem boundedBy_measure (Œº : Measure Œ±) : OuterMeasure.boundedBy Œº = Œº.toOuterMeasure :=
  Œº.toOuterMeasure.boundedBy_eq_self
#align measure_theory.bounded_by_measure MeasureTheory.boundedBy_measure
-/

end OuterMeasure

variable {m0 : MeasurableSpace Œ±} [MeasurableSpace Œ≤] [MeasurableSpace Œ≥]

variable {Œº Œº‚ÇÅ Œº‚ÇÇ Œº‚ÇÉ ŒΩ ŒΩ' ŒΩ‚ÇÅ ŒΩ‚ÇÇ : Measure Œ±} {s s' t : Set Œ±}

namespace Measure

/- warning: measure_theory.measure.measure_inter_eq_of_measure_eq -> MeasureTheory.Measure.measure_inter_eq_of_measure_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±} {u : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº t) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº u)) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) t u) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº t) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) t s)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) u s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±} {u : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) t) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) u)) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) t u) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) t) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) t s)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) u s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.measure_inter_eq_of_measure_eq MeasureTheory.Measure.measure_inter_eq_of_measure_eq‚Çì'. -/
/-- If `u` is a superset of `t` with the same (finite) measure (both sets possibly non-measurable),
then for any measurable set `s` one also has `Œº (t ‚à© s) = Œº (u ‚à© s)`. -/
theorem measure_inter_eq_of_measure_eq {s t u : Set Œ±} (hs : MeasurableSet s) (h : Œº t = Œº u)
    (htu : t ‚äÜ u) (ht_ne_top : Œº t ‚â† ‚àû) : Œº (t ‚à© s) = Œº (u ‚à© s) :=
  by
  rw [h] at ht_ne_top
  refine' le_antisymm (measure_mono (inter_subset_inter_left _ htu)) _
  have A : Œº (u ‚à© s) + Œº (u \ s) ‚â§ Œº (t ‚à© s) + Œº (u \ s) :=
    calc
      Œº (u ‚à© s) + Œº (u \ s) = Œº u := measure_inter_add_diff _ hs
      _ = Œº t := h.symm
      _ = Œº (t ‚à© s) + Œº (t \ s) := (measure_inter_add_diff _ hs).symm
      _ ‚â§ Œº (t ‚à© s) + Œº (u \ s) :=
        add_le_add le_rfl (measure_mono (diff_subset_diff htu subset.rfl))
      
  have B : Œº (u \ s) ‚â† ‚àû := (lt_of_le_of_lt (measure_mono (diff_subset _ _)) ht_ne_top.lt_top).Ne
  exact ENNReal.le_of_add_le_add_right B A
#align measure_theory.measure.measure_inter_eq_of_measure_eq MeasureTheory.Measure.measure_inter_eq_of_measure_eq

/- warning: measure_theory.measure.measure_to_measurable_inter -> MeasureTheory.Measure.measure_toMeasurable_inter is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº t) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) (MeasureTheory.toMeasurable.{u1} Œ± m0 Œº t) s)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) t s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) t) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) (MeasureTheory.toMeasurable.{u1} Œ± m0 Œº t) s)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) t s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.measure_to_measurable_inter MeasureTheory.Measure.measure_toMeasurable_inter‚Çì'. -/
/-- The measurable superset `to_measurable Œº t` of `t` (which has the same measure as `t`)
satisfies, for any measurable set `s`, the equality `Œº (to_measurable Œº t ‚à© s) = Œº (u ‚à© s)`.
Here, we require that the measure of `t` is finite. The conclusion holds without this assumption
when the measure is sigma_finite, see `measure_to_measurable_inter_of_sigma_finite`. -/
theorem measure_toMeasurable_inter {s t : Set Œ±} (hs : MeasurableSet s) (ht : Œº t ‚â† ‚àû) :
    Œº (toMeasurable Œº t ‚à© s) = Œº (t ‚à© s) :=
  (measure_inter_eq_of_measure_eq hs (measure_toMeasurable t).symm (subset_toMeasurable Œº t)
      ht).symm
#align measure_theory.measure.measure_to_measurable_inter MeasureTheory.Measure.measure_toMeasurable_inter

/-! ### The `‚Ñù‚â•0‚àû`-module of measures -/


instance [MeasurableSpace Œ±] : Zero (Measure Œ±) :=
  ‚ü®{  toOuterMeasure := 0
      m_union·µ¢ := fun f hf hd => tsum_zero.symm
      trimmed := OuterMeasure.trim_zero }‚ü©

#print MeasureTheory.Measure.zero_toOuterMeasure /-
@[simp]
theorem zero_toOuterMeasure {m : MeasurableSpace Œ±} : (0 : Measure Œ±).toOuterMeasure = 0 :=
  rfl
#align measure_theory.measure.zero_to_outer_measure MeasureTheory.Measure.zero_toOuterMeasure
-/

/- warning: measure_theory.measure.coe_zero -> MeasureTheory.Measure.coe_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±}, Eq.{succ u1} ((Set.{u1} Œ±) -> ENNReal) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m) 0 (OfNat.mk.{u1} (MeasureTheory.Measure.{u1} Œ± m) 0 (Zero.zero.{u1} (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.instZero.{u1} Œ± m))))) (OfNat.ofNat.{u1} ((Set.{u1} Œ±) -> ENNReal) 0 (OfNat.mk.{u1} ((Set.{u1} Œ±) -> ENNReal) 0 (Zero.zero.{u1} ((Set.{u1} Œ±) -> ENNReal) (Pi.instZero.{u1, 0} (Set.{u1} Œ±) (fun (·æ∞ : Set.{u1} Œ±) => ENNReal) (fun (i : Set.{u1} Œ±) => ENNReal.hasZero)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±}, Eq.{succ u1} ((Set.{u1} Œ±) -> ENNReal) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m) 0 (Zero.toOfNat0.{u1} (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.instZero.{u1} Œ± m))))) (OfNat.ofNat.{u1} ((Set.{u1} Œ±) -> ENNReal) 0 (Zero.toOfNat0.{u1} ((Set.{u1} Œ±) -> ENNReal) (Pi.instZero.{u1, 0} (Set.{u1} Œ±) (fun (a._@.Mathlib.MeasureTheory.Measure.OuterMeasure._hyg.11 : Set.{u1} Œ±) => ENNReal) (fun (i : Set.{u1} Œ±) => instENNRealZero))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.coe_zero MeasureTheory.Measure.coe_zero‚Çì'. -/
@[simp, norm_cast]
theorem coe_zero {m : MeasurableSpace Œ±} : ‚áë(0 : Measure Œ±) = 0 :=
  rfl
#align measure_theory.measure.coe_zero MeasureTheory.Measure.coe_zero

instance [IsEmpty Œ±] {m : MeasurableSpace Œ±} : Subsingleton (Measure Œ±) :=
  ‚ü®fun Œº ŒΩ => by
    ext1 s hs
    simp only [eq_empty_of_is_empty s, measure_empty]‚ü©

#print MeasureTheory.Measure.eq_zero_of_isEmpty /-
theorem eq_zero_of_isEmpty [IsEmpty Œ±] {m : MeasurableSpace Œ±} (Œº : Measure Œ±) : Œº = 0 :=
  Subsingleton.elim Œº 0
#align measure_theory.measure.eq_zero_of_is_empty MeasureTheory.Measure.eq_zero_of_isEmpty
-/

instance [MeasurableSpace Œ±] : Inhabited (Measure Œ±) :=
  ‚ü®0‚ü©

instance [MeasurableSpace Œ±] : Add (Measure Œ±) :=
  ‚ü®fun Œº‚ÇÅ Œº‚ÇÇ =>
    { toOuterMeasure := Œº‚ÇÅ.toOuterMeasure + Œº‚ÇÇ.toOuterMeasure
      m_union·µ¢ := fun s hs hd =>
        show Œº‚ÇÅ (‚ãÉ i, s i) + Œº‚ÇÇ (‚ãÉ i, s i) = ‚àë' i, Œº‚ÇÅ (s i) + Œº‚ÇÇ (s i) by
          rw [ENNReal.tsum_add, measure_Union hd hs, measure_Union hd hs]
      trimmed := by rw [outer_measure.trim_add, Œº‚ÇÅ.trimmed, Œº‚ÇÇ.trimmed] }‚ü©

#print MeasureTheory.Measure.add_toOuterMeasure /-
@[simp]
theorem add_toOuterMeasure {m : MeasurableSpace Œ±} (Œº‚ÇÅ Œº‚ÇÇ : Measure Œ±) :
    (Œº‚ÇÅ + Œº‚ÇÇ).toOuterMeasure = Œº‚ÇÅ.toOuterMeasure + Œº‚ÇÇ.toOuterMeasure :=
  rfl
#align measure_theory.measure.add_to_outer_measure MeasureTheory.Measure.add_toOuterMeasure
-/

/- warning: measure_theory.measure.coe_add -> MeasureTheory.Measure.coe_add is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} (Œº‚ÇÅ : MeasureTheory.Measure.{u1} Œ± m) (Œº‚ÇÇ : MeasureTheory.Measure.{u1} Œ± m), Eq.{succ u1} ((Set.{u1} Œ±) -> ENNReal) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.{u1} Œ± m) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.instAdd.{u1} Œ± m)) Œº‚ÇÅ Œº‚ÇÇ)) (HAdd.hAdd.{u1, u1, u1} ((Set.{u1} Œ±) -> ENNReal) ((Set.{u1} Œ±) -> ENNReal) ((Set.{u1} Œ±) -> ENNReal) (instHAdd.{u1} ((Set.{u1} Œ±) -> ENNReal) (Pi.instAdd.{u1, 0} (Set.{u1} Œ±) (fun (·æ∞ : Set.{u1} Œ±) => ENNReal) (fun (i : Set.{u1} Œ±) => Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº‚ÇÅ) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº‚ÇÇ))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} (Œº‚ÇÅ : MeasureTheory.Measure.{u1} Œ± m) (Œº‚ÇÇ : MeasureTheory.Measure.{u1} Œ± m), Eq.{succ u1} ((Set.{u1} Œ±) -> ENNReal) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.{u1} Œ± m) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.instAdd.{u1} Œ± m)) Œº‚ÇÅ Œº‚ÇÇ))) (HAdd.hAdd.{u1, u1, u1} ((Set.{u1} Œ±) -> ENNReal) ((Set.{u1} Œ±) -> ENNReal) ((Set.{u1} Œ±) -> ENNReal) (instHAdd.{u1} ((Set.{u1} Œ±) -> ENNReal) (Pi.instAdd.{u1, 0} (Set.{u1} Œ±) (fun (·æ∞ : Set.{u1} Œ±) => ENNReal) (fun (i : Set.{u1} Œ±) => Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº‚ÇÅ)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº‚ÇÇ)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.coe_add MeasureTheory.Measure.coe_add‚Çì'. -/
@[simp, norm_cast]
theorem coe_add {m : MeasurableSpace Œ±} (Œº‚ÇÅ Œº‚ÇÇ : Measure Œ±) : ‚áë(Œº‚ÇÅ + Œº‚ÇÇ) = Œº‚ÇÅ + Œº‚ÇÇ :=
  rfl
#align measure_theory.measure.coe_add MeasureTheory.Measure.coe_add

/- warning: measure_theory.measure.add_apply -> MeasureTheory.Measure.add_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} (Œº‚ÇÅ : MeasureTheory.Measure.{u1} Œ± m) (Œº‚ÇÇ : MeasureTheory.Measure.{u1} Œ± m) (s : Set.{u1} Œ±), Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.{u1} Œ± m) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.instAdd.{u1} Œ± m)) Œº‚ÇÅ Œº‚ÇÇ) s) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº‚ÇÅ s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº‚ÇÇ s))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} (Œº‚ÇÅ : MeasureTheory.Measure.{u1} Œ± m) (Œº‚ÇÇ : MeasureTheory.Measure.{u1} Œ± m) (s : Set.{u1} Œ±), Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.{u1} Œ± m) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.instAdd.{u1} Œ± m)) Œº‚ÇÅ Œº‚ÇÇ)) s) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº‚ÇÅ) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº‚ÇÇ) s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.add_apply MeasureTheory.Measure.add_apply‚Çì'. -/
theorem add_apply {m : MeasurableSpace Œ±} (Œº‚ÇÅ Œº‚ÇÇ : Measure Œ±) (s : Set Œ±) :
    (Œº‚ÇÅ + Œº‚ÇÇ) s = Œº‚ÇÅ s + Œº‚ÇÇ s :=
  rfl
#align measure_theory.measure.add_apply MeasureTheory.Measure.add_apply

section SMul

variable [SMul R ‚Ñù‚â•0‚àû] [IsScalarTower R ‚Ñù‚â•0‚àû ‚Ñù‚â•0‚àû]

variable [SMul R' ‚Ñù‚â•0‚àû] [IsScalarTower R' ‚Ñù‚â•0‚àû ‚Ñù‚â•0‚àû]

instance [MeasurableSpace Œ±] : SMul R (Measure Œ±) :=
  ‚ü®fun c Œº =>
    { toOuterMeasure := c ‚Ä¢ Œº.toOuterMeasure
      m_union·µ¢ := fun s hs hd =>
        by
        rw [‚Üê smul_one_smul ‚Ñù‚â•0‚àû c (_ : outer_measure Œ±)]
        dsimp
        simp_rw [measure_Union hd hs, ENNReal.tsum_mul_left]
      trimmed := by rw [outer_measure.trim_smul, Œº.trimmed] }‚ü©

/- warning: measure_theory.measure.smul_to_outer_measure -> MeasureTheory.Measure.smul_toOuterMeasure is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {R : Type.{u2}} [_inst_3 : SMul.{u2, 0} R ENNReal] [_inst_4 : IsScalarTower.{u2, 0, 0} R ENNReal ENNReal _inst_3 (Mul.toSMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) _inst_3] {m : MeasurableSpace.{u1} Œ±} (c : R) (Œº : MeasureTheory.Measure.{u1} Œ± m), Eq.{succ u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m (SMul.smul.{u2, u1} R (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.instSMul.{u1, u2} Œ± R _inst_3 _inst_4 m) c Œº)) (SMul.smul.{u2, u1} R (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.hasSmul.{u1, u2} Œ± R _inst_3 _inst_4) c (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº))
but is expected to have type
  forall {Œ± : Type.{u2}} {R : Type.{u1}} [_inst_3 : SMul.{u1, 0} R ENNReal] [_inst_4 : IsScalarTower.{u1, 0, 0} R ENNReal ENNReal _inst_3 (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_3] {m : MeasurableSpace.{u2} Œ±} (c : R) (Œº : MeasureTheory.Measure.{u2} Œ± m), Eq.{succ u2} (MeasureTheory.OuterMeasure.{u2} Œ±) (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m (HSMul.hSMul.{u1, u2, u2} R (MeasureTheory.Measure.{u2} Œ± m) (MeasureTheory.Measure.{u2} Œ± m) (instHSMul.{u1, u2} R (MeasureTheory.Measure.{u2} Œ± m) (MeasureTheory.Measure.instSMul.{u2, u1} Œ± R _inst_3 _inst_4 m)) c Œº)) (HSMul.hSMul.{u1, u2, u2} R (MeasureTheory.OuterMeasure.{u2} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ±) (instHSMul.{u1, u2} R (MeasureTheory.OuterMeasure.{u2} Œ±) (MeasureTheory.OuterMeasure.instSMul.{u2, u1} Œ± R _inst_3 _inst_4)) c (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m Œº))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.smul_to_outer_measure MeasureTheory.Measure.smul_toOuterMeasure‚Çì'. -/
@[simp]
theorem smul_toOuterMeasure {m : MeasurableSpace Œ±} (c : R) (Œº : Measure Œ±) :
    (c ‚Ä¢ Œº).toOuterMeasure = c ‚Ä¢ Œº.toOuterMeasure :=
  rfl
#align measure_theory.measure.smul_to_outer_measure MeasureTheory.Measure.smul_toOuterMeasure

/- warning: measure_theory.measure.coe_smul -> MeasureTheory.Measure.coe_smul is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {R : Type.{u2}} [_inst_3 : SMul.{u2, 0} R ENNReal] [_inst_4 : IsScalarTower.{u2, 0, 0} R ENNReal ENNReal _inst_3 (Mul.toSMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) _inst_3] {m : MeasurableSpace.{u1} Œ±} (c : R) (Œº : MeasureTheory.Measure.{u1} Œ± m), Eq.{succ u1} ((Set.{u1} Œ±) -> ENNReal) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) (SMul.smul.{u2, u1} R (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.instSMul.{u1, u2} Œ± R _inst_3 _inst_4 m) c Œº)) (SMul.smul.{u2, u1} R ((Set.{u1} Œ±) -> ENNReal) (Function.hasSMul.{u1, u2, 0} (Set.{u1} Œ±) R ENNReal _inst_3) c (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº))
but is expected to have type
  forall {Œ± : Type.{u2}} {R : Type.{u1}} [_inst_3 : SMul.{u1, 0} R ENNReal] [_inst_4 : IsScalarTower.{u1, 0, 0} R ENNReal ENNReal _inst_3 (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_3] {m : MeasurableSpace.{u2} Œ±} (c : R) (Œº : MeasureTheory.Measure.{u2} Œ± m), Eq.{succ u2} ((Set.{u2} Œ±) -> ENNReal) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m (HSMul.hSMul.{u1, u2, u2} R (MeasureTheory.Measure.{u2} Œ± m) (MeasureTheory.Measure.{u2} Œ± m) (instHSMul.{u1, u2} R (MeasureTheory.Measure.{u2} Œ± m) (MeasureTheory.Measure.instSMul.{u2, u1} Œ± R _inst_3 _inst_4 m)) c Œº))) (HSMul.hSMul.{u1, u2, u2} R ((Set.{u2} Œ±) -> ENNReal) ((Set.{u2} Œ±) -> ENNReal) (instHSMul.{u1, u2} R ((Set.{u2} Œ±) -> ENNReal) (Pi.instSMul.{u2, 0, u1} (Set.{u2} Œ±) R (fun (a._@.Mathlib.MeasureTheory.Measure.OuterMeasure._hyg.11 : Set.{u2} Œ±) => ENNReal) (fun (i : Set.{u2} Œ±) => _inst_3))) c (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m Œº)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.coe_smul MeasureTheory.Measure.coe_smul‚Çì'. -/
@[simp, norm_cast]
theorem coe_smul {m : MeasurableSpace Œ±} (c : R) (Œº : Measure Œ±) : ‚áë(c ‚Ä¢ Œº) = c ‚Ä¢ Œº :=
  rfl
#align measure_theory.measure.coe_smul MeasureTheory.Measure.coe_smul

/- warning: measure_theory.measure.smul_apply -> MeasureTheory.Measure.smul_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {R : Type.{u2}} [_inst_3 : SMul.{u2, 0} R ENNReal] [_inst_4 : IsScalarTower.{u2, 0, 0} R ENNReal ENNReal _inst_3 (Mul.toSMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) _inst_3] {m : MeasurableSpace.{u1} Œ±} (c : R) (Œº : MeasureTheory.Measure.{u1} Œ± m) (s : Set.{u1} Œ±), Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) (SMul.smul.{u2, u1} R (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.instSMul.{u1, u2} Œ± R _inst_3 _inst_4 m) c Œº) s) (SMul.smul.{u2, 0} R ENNReal _inst_3 c (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s))
but is expected to have type
  forall {Œ± : Type.{u2}} {R : Type.{u1}} [_inst_3 : SMul.{u1, 0} R ENNReal] [_inst_4 : IsScalarTower.{u1, 0, 0} R ENNReal ENNReal _inst_3 (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_3] {m : MeasurableSpace.{u2} Œ±} (c : R) (Œº : MeasureTheory.Measure.{u2} Œ± m) (s : Set.{u2} Œ±), Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m (HSMul.hSMul.{u1, u2, u2} R (MeasureTheory.Measure.{u2} Œ± m) (MeasureTheory.Measure.{u2} Œ± m) (instHSMul.{u1, u2} R (MeasureTheory.Measure.{u2} Œ± m) (MeasureTheory.Measure.instSMul.{u2, u1} Œ± R _inst_3 _inst_4 m)) c Œº)) s) (HSMul.hSMul.{u1, 0, 0} R ENNReal ENNReal (instHSMul.{u1, 0} R ENNReal _inst_3) c (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m Œº) s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.smul_apply MeasureTheory.Measure.smul_apply‚Çì'. -/
@[simp]
theorem smul_apply {m : MeasurableSpace Œ±} (c : R) (Œº : Measure Œ±) (s : Set Œ±) :
    (c ‚Ä¢ Œº) s = c ‚Ä¢ Œº s :=
  rfl
#align measure_theory.measure.smul_apply MeasureTheory.Measure.smul_apply

instance [SMulCommClass R R' ‚Ñù‚â•0‚àû] [MeasurableSpace Œ±] : SMulCommClass R R' (Measure Œ±) :=
  ‚ü®fun _ _ _ => ext fun _ _ => smul_comm _ _ _‚ü©

instance [SMul R R'] [IsScalarTower R R' ‚Ñù‚â•0‚àû] [MeasurableSpace Œ±] :
    IsScalarTower R R' (Measure Œ±) :=
  ‚ü®fun _ _ _ => ext fun _ _ => smul_assoc _ _ _‚ü©

instance [SMul R·µê·µí·µñ ‚Ñù‚â•0‚àû] [IsCentralScalar R ‚Ñù‚â•0‚àû] [MeasurableSpace Œ±] :
    IsCentralScalar R (Measure Œ±) :=
  ‚ü®fun _ _ => ext fun _ _ => op_smul_eq_smul _ _‚ü©

end SMul

instance [Monoid R] [MulAction R ‚Ñù‚â•0‚àû] [IsScalarTower R ‚Ñù‚â•0‚àû ‚Ñù‚â•0‚àû] [MeasurableSpace Œ±] :
    MulAction R (Measure Œ±) :=
  Injective.mulAction _ toOuterMeasure_injective smul_toOuterMeasure

#print MeasureTheory.Measure.instAddCommMonoid /-
instance instAddCommMonoid [MeasurableSpace Œ±] : AddCommMonoid (Measure Œ±) :=
  toOuterMeasure_injective.AddCommMonoid toOuterMeasure zero_toOuterMeasure add_toOuterMeasure
    fun _ _ => smul_toOuterMeasure _ _
#align measure_theory.measure.add_comm_monoid MeasureTheory.Measure.instAddCommMonoid
-/

#print MeasureTheory.Measure.coeAddHom /-
/-- Coercion to function as an additive monoid homomorphism. -/
def coeAddHom {m : MeasurableSpace Œ±} : Measure Œ± ‚Üí+ Set Œ± ‚Üí ‚Ñù‚â•0‚àû :=
  ‚ü®coeFn, coe_zero, coe_add‚ü©
#align measure_theory.measure.coe_add_hom MeasureTheory.Measure.coeAddHom
-/

/- warning: measure_theory.measure.coe_finset_sum -> MeasureTheory.Measure.coe_finset_sum is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} (I : Finset.{u2} Œπ) (Œº : Œπ -> (MeasureTheory.Measure.{u1} Œ± m)), Eq.{succ u1} ((Set.{u1} Œ±) -> ENNReal) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) (Finset.sum.{u1, u2} (MeasureTheory.Measure.{u1} Œ± m) Œπ (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m) I (fun (i : Œπ) => Œº i))) (Finset.sum.{u1, u2} ((Set.{u1} Œ±) -> ENNReal) Œπ (Pi.addCommMonoid.{u1, 0} (Set.{u1} Œ±) (fun (·æ∞ : Set.{u1} Œ±) => ENNReal) (fun (i : Set.{u1} Œ±) => OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) I (fun (i : Œπ) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) (Œº i)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m : MeasurableSpace.{u2} Œ±} (I : Finset.{u1} Œπ) (Œº : Œπ -> (MeasureTheory.Measure.{u2} Œ± m)), Eq.{succ u2} ((Set.{u2} Œ±) -> ENNReal) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m (Finset.sum.{u2, u1} (MeasureTheory.Measure.{u2} Œ± m) Œπ (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ± m) I (fun (i : Œπ) => Œº i)))) (Finset.sum.{u2, u1} ((Set.{u2} Œ±) -> ENNReal) Œπ (Pi.addCommMonoid.{u2, 0} (Set.{u2} Œ±) (fun (·æ∞ : Set.{u2} Œ±) => ENNReal) (fun (i : Set.{u2} Œ±) => LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal))) I (fun (i : Œπ) => MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m (Œº i))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.coe_finset_sum MeasureTheory.Measure.coe_finset_sum‚Çì'. -/
@[simp]
theorem coe_finset_sum {m : MeasurableSpace Œ±} (I : Finset Œπ) (Œº : Œπ ‚Üí Measure Œ±) :
    ‚áë(‚àë i in I, Œº i) = ‚àë i in I, Œº i :=
  (@coeAddHom Œ± m).map_sum _ _
#align measure_theory.measure.coe_finset_sum MeasureTheory.Measure.coe_finset_sum

/- warning: measure_theory.measure.finset_sum_apply -> MeasureTheory.Measure.finset_sum_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m : MeasurableSpace.{u1} Œ±} (I : Finset.{u2} Œπ) (Œº : Œπ -> (MeasureTheory.Measure.{u1} Œ± m)) (s : Set.{u1} Œ±), Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) (Finset.sum.{u1, u2} (MeasureTheory.Measure.{u1} Œ± m) Œπ (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m) I (fun (i : Œπ) => Œº i)) s) (Finset.sum.{0, u2} ENNReal Œπ (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) I (fun (i : Œπ) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) (Œº i) s))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m : MeasurableSpace.{u2} Œ±} (I : Finset.{u1} Œπ) (Œº : Œπ -> (MeasureTheory.Measure.{u2} Œ± m)) (s : Set.{u2} Œ±), Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m (Finset.sum.{u2, u1} (MeasureTheory.Measure.{u2} Œ± m) Œπ (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ± m) I (fun (i : Œπ) => Œº i))) s) (Finset.sum.{0, u1} ENNReal Œπ (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) I (fun (i : Œπ) => MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m (Œº i)) s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.finset_sum_apply MeasureTheory.Measure.finset_sum_apply‚Çì'. -/
theorem finset_sum_apply {m : MeasurableSpace Œ±} (I : Finset Œπ) (Œº : Œπ ‚Üí Measure Œ±) (s : Set Œ±) :
    (‚àë i in I, Œº i) s = ‚àë i in I, Œº i s := by rw [coe_finset_sum, Finset.sum_apply]
#align measure_theory.measure.finset_sum_apply MeasureTheory.Measure.finset_sum_apply

instance [Monoid R] [DistribMulAction R ‚Ñù‚â•0‚àû] [IsScalarTower R ‚Ñù‚â•0‚àû ‚Ñù‚â•0‚àû] [MeasurableSpace Œ±] :
    DistribMulAction R (Measure Œ±) :=
  Injective.distribMulAction ‚ü®toOuterMeasure, zero_toOuterMeasure, add_toOuterMeasure‚ü©
    toOuterMeasure_injective smul_toOuterMeasure

instance [Semiring R] [Module R ‚Ñù‚â•0‚àû] [IsScalarTower R ‚Ñù‚â•0‚àû ‚Ñù‚â•0‚àû] [MeasurableSpace Œ±] :
    Module R (Measure Œ±) :=
  Injective.module R ‚ü®toOuterMeasure, zero_toOuterMeasure, add_toOuterMeasure‚ü©
    toOuterMeasure_injective smul_toOuterMeasure

/- warning: measure_theory.measure.coe_nnreal_smul_apply -> MeasureTheory.Measure.coe_nnreal_smul_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} (c : NNReal) (Œº : MeasureTheory.Measure.{u1} Œ± m) (s : Set.{u1} Œ±), Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) (SMul.smul.{0, u1} NNReal (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± NNReal (MulAction.toHasSmul.{0, 0} NNReal ENNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal NNReal.semiring)) (ENNReal.mulAction.{0} ENNReal (Monoid.toMulAction.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (ENNReal.isScalarTower.{0, 0} ENNReal ENNReal (Monoid.toMulAction.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Monoid.toMulAction.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Mul.toSMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) m) c Œº) s) (HMul.hMul.{0, 0, 0} ENNReal ENNReal ENNReal (instHMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) NNReal ENNReal (HasLiftT.mk.{1, 1} NNReal ENNReal (CoeTC‚Çì.coe.{1, 1} NNReal ENNReal (coeBase.{1, 1} NNReal ENNReal ENNReal.hasCoe))) c) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} (c : NNReal) (Œº : MeasureTheory.Measure.{u1} Œ± m) (s : Set.{u1} Œ±), Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m (HSMul.hSMul.{0, u1, u1} NNReal (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.{u1} Œ± m) (instHSMul.{0, u1} NNReal (MeasureTheory.Measure.{u1} Œ± m) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± NNReal (Algebra.toSMul.{0, 0} NNReal ENNReal instNNRealCommSemiring (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (ENNReal.instAlgebraNNRealInstNNRealCommSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (ENNReal.instIsScalarTowerNNRealToSMulToMonoidToMonoidWithZeroInstNNRealSemiringInstMulActionNNRealToMonoidToMonoidWithZeroInstNNRealSemiringToSMulInstMulActionNNRealToMonoidToMonoidWithZeroInstNNRealSemiring.{0, 0} ENNReal ENNReal (MulActionWithZero.toMulAction.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) instENNRealZero (MonoidWithZero.toMulActionWithZero.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (MulActionWithZero.toMulAction.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) instENNRealZero (MonoidWithZero.toMulActionWithZero.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) m)) c Œº)) s) (HMul.hMul.{0, 0, 0} ENNReal ENNReal ENNReal (instHMul.{0} ENNReal (CanonicallyOrderedCommSemiring.toMul.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (ENNReal.some c) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.coe_nnreal_smul_apply MeasureTheory.Measure.coe_nnreal_smul_apply‚Çì'. -/
@[simp]
theorem coe_nnreal_smul_apply {m : MeasurableSpace Œ±} (c : ‚Ñù‚â•0) (Œº : Measure Œ±) (s : Set Œ±) :
    (c ‚Ä¢ Œº) s = c * Œº s :=
  rfl
#align measure_theory.measure.coe_nnreal_smul_apply MeasureTheory.Measure.coe_nnreal_smul_apply

/- warning: measure_theory.measure.ae_smul_measure_iff -> MeasureTheory.Measure.ae_smul_measure_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {p : Œ± -> Prop} {c : ENNReal}, (Ne.{1} ENNReal c (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Iff (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u1} Œ± m0 (SMul.smul.{0, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± ENNReal (SMulZeroClass.toHasSmul.{0, 0} ENNReal ENNReal (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (SMulWithZero.toSmulZeroClass.{0, 0} ENNReal ENNReal (MulZeroClass.toHasZero.{0} ENNReal (MulZeroOneClass.toMulZeroClass.{0} ENNReal (MonoidWithZero.toMulZeroOneClass.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (MulActionWithZero.toSMulWithZero.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (Module.toMulActionWithZero.{0, 0} ENNReal ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Algebra.toModule.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) m0) c Œº))) (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {p : Œ± -> Prop} {c : ENNReal}, (Ne.{1} ENNReal c (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Iff (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u1} Œ± m0 (HSMul.hSMul.{0, u1, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHSMul.{0, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± ENNReal (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0)) c Œº))) (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.ae_smul_measure_iff MeasureTheory.Measure.ae_smul_measure_iff‚Çì'. -/
theorem ae_smul_measure_iff {p : Œ± ‚Üí Prop} {c : ‚Ñù‚â•0‚àû} (hc : c ‚â† 0) :
    (‚àÄ·µê x ‚àÇc ‚Ä¢ Œº, p x) ‚Üî ‚àÄ·µê x ‚àÇŒº, p x := by simp [ae_iff, hc]
#align measure_theory.measure.ae_smul_measure_iff MeasureTheory.Measure.ae_smul_measure_iff

/- warning: measure_theory.measure.measure_eq_left_of_subset_of_measure_add_eq -> MeasureTheory.Measure.measure_eq_left_of_subset_of_measure_add_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ) t) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s t) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ) s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ) t)) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº t))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ)) t) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s t) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ)) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ)) t)) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) t))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.measure_eq_left_of_subset_of_measure_add_eq MeasureTheory.Measure.measure_eq_left_of_subset_of_measure_add_eq‚Çì'. -/
theorem measure_eq_left_of_subset_of_measure_add_eq {s t : Set Œ±} (h : (Œº + ŒΩ) t ‚â† ‚àû) (h' : s ‚äÜ t)
    (h'' : (Œº + ŒΩ) s = (Œº + ŒΩ) t) : Œº s = Œº t :=
  by
  refine' le_antisymm (measure_mono h') _
  have : Œº t + ŒΩ t ‚â§ Œº s + ŒΩ t :=
    calc
      Œº t + ŒΩ t = Œº s + ŒΩ s := h''.symm
      _ ‚â§ Œº s + ŒΩ t := add_le_add le_rfl (measure_mono h')
      
  apply ENNReal.le_of_add_le_add_right _ this
  simp only [not_or, ENNReal.add_eq_top, Pi.add_apply, Ne.def, coe_add] at h
  exact h.2
#align measure_theory.measure.measure_eq_left_of_subset_of_measure_add_eq MeasureTheory.Measure.measure_eq_left_of_subset_of_measure_add_eq

/- warning: measure_theory.measure.measure_eq_right_of_subset_of_measure_add_eq -> MeasureTheory.Measure.measure_eq_right_of_subset_of_measure_add_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ) t) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s t) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ) s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ) t)) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) ŒΩ s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) ŒΩ t))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ)) t) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s t) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ)) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ)) t)) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 ŒΩ) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 ŒΩ) t))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.measure_eq_right_of_subset_of_measure_add_eq MeasureTheory.Measure.measure_eq_right_of_subset_of_measure_add_eq‚Çì'. -/
theorem measure_eq_right_of_subset_of_measure_add_eq {s t : Set Œ±} (h : (Œº + ŒΩ) t ‚â† ‚àû) (h' : s ‚äÜ t)
    (h'' : (Œº + ŒΩ) s = (Œº + ŒΩ) t) : ŒΩ s = ŒΩ t :=
  by
  rw [add_comm] at h'' h
  exact measure_eq_left_of_subset_of_measure_add_eq h h' h''
#align measure_theory.measure.measure_eq_right_of_subset_of_measure_add_eq MeasureTheory.Measure.measure_eq_right_of_subset_of_measure_add_eq

/- warning: measure_theory.measure.measure_to_measurable_add_inter_left -> MeasureTheory.Measure.measure_toMeasurable_add_inter_left is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ) t) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) (MeasureTheory.toMeasurable.{u1} Œ± m0 (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ) t) s)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) t s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ)) t) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) (MeasureTheory.toMeasurable.{u1} Œ± m0 (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ) t) s)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) t s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.measure_to_measurable_add_inter_left MeasureTheory.Measure.measure_toMeasurable_add_inter_left‚Çì'. -/
theorem measure_toMeasurable_add_inter_left {s t : Set Œ±} (hs : MeasurableSet s)
    (ht : (Œº + ŒΩ) t ‚â† ‚àû) : Œº (toMeasurable (Œº + ŒΩ) t ‚à© s) = Œº (t ‚à© s) :=
  by
  refine' (measure_inter_eq_of_measure_eq hs _ (subset_to_measurable _ _) _).symm
  ¬∑ refine'
      measure_eq_left_of_subset_of_measure_add_eq _ (subset_to_measurable _ _)
        (measure_to_measurable t).symm
    rwa [measure_to_measurable t]
  ¬∑ simp only [not_or, ENNReal.add_eq_top, Pi.add_apply, Ne.def, coe_add] at ht
    exact ht.1
#align measure_theory.measure.measure_to_measurable_add_inter_left MeasureTheory.Measure.measure_toMeasurable_add_inter_left

/- warning: measure_theory.measure.measure_to_measurable_add_inter_right -> MeasureTheory.Measure.measure_toMeasurable_add_inter_right is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ) t) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) ŒΩ (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) (MeasureTheory.toMeasurable.{u1} Œ± m0 (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ) t) s)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) ŒΩ (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) t s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ)) t) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 ŒΩ) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) (MeasureTheory.toMeasurable.{u1} Œ± m0 (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ) t) s)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 ŒΩ) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) t s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.measure_to_measurable_add_inter_right MeasureTheory.Measure.measure_toMeasurable_add_inter_right‚Çì'. -/
theorem measure_toMeasurable_add_inter_right {s t : Set Œ±} (hs : MeasurableSet s)
    (ht : (Œº + ŒΩ) t ‚â† ‚àû) : ŒΩ (toMeasurable (Œº + ŒΩ) t ‚à© s) = ŒΩ (t ‚à© s) :=
  by
  rw [add_comm] at ht‚ä¢
  exact measure_to_measurable_add_inter_left hs ht
#align measure_theory.measure.measure_to_measurable_add_inter_right MeasureTheory.Measure.measure_toMeasurable_add_inter_right

/-! ### The complete lattice of measures -/


/-- Measures are partially ordered.

The definition of less equal here is equivalent to the definition without the
measurable set condition, and this is shown by `measure.le_iff'`. It is defined
this way since, to prove `Œº ‚â§ ŒΩ`, we may simply `intros s hs` instead of rewriting followed
by `intros s hs`. -/
instance [MeasurableSpace Œ±] : PartialOrder (Measure Œ±)
    where
  le m‚ÇÅ m‚ÇÇ := ‚àÄ s, MeasurableSet s ‚Üí m‚ÇÅ s ‚â§ m‚ÇÇ s
  le_refl m s hs := le_rfl
  le_trans m‚ÇÅ m‚ÇÇ m‚ÇÉ h‚ÇÅ h‚ÇÇ s hs := le_trans (h‚ÇÅ s hs) (h‚ÇÇ s hs)
  le_antisymm m‚ÇÅ m‚ÇÇ h‚ÇÅ h‚ÇÇ := ext fun s hs => le_antisymm (h‚ÇÅ s hs) (h‚ÇÇ s hs)

/- warning: measure_theory.measure.le_iff -> MeasureTheory.Measure.le_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº‚ÇÅ : MeasureTheory.Measure.{u1} Œ± m0} {Œº‚ÇÇ : MeasureTheory.Measure.{u1} Œ± m0}, Iff (LE.le.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº‚ÇÅ Œº‚ÇÇ) (forall (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m0 s) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº‚ÇÅ s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº‚ÇÇ s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº‚ÇÅ : MeasureTheory.Measure.{u1} Œ± m0} {Œº‚ÇÇ : MeasureTheory.Measure.{u1} Œ± m0}, Iff (LE.le.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº‚ÇÅ Œº‚ÇÇ) (forall (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m0 s) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº‚ÇÅ) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº‚ÇÇ) s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.le_iff MeasureTheory.Measure.le_iff‚Çì'. -/
theorem le_iff : Œº‚ÇÅ ‚â§ Œº‚ÇÇ ‚Üî ‚àÄ s, MeasurableSet s ‚Üí Œº‚ÇÅ s ‚â§ Œº‚ÇÇ s :=
  Iff.rfl
#align measure_theory.measure.le_iff MeasureTheory.Measure.le_iff

#print MeasureTheory.Measure.toOuterMeasure_le /-
theorem toOuterMeasure_le : Œº‚ÇÅ.toOuterMeasure ‚â§ Œº‚ÇÇ.toOuterMeasure ‚Üî Œº‚ÇÅ ‚â§ Œº‚ÇÇ := by
  rw [‚Üê Œº‚ÇÇ.trimmed, outer_measure.le_trim_iff] <;> rfl
#align measure_theory.measure.to_outer_measure_le MeasureTheory.Measure.toOuterMeasure_le
-/

/- warning: measure_theory.measure.le_iff' -> MeasureTheory.Measure.le_iff' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº‚ÇÅ : MeasureTheory.Measure.{u1} Œ± m0} {Œº‚ÇÇ : MeasureTheory.Measure.{u1} Œ± m0}, Iff (LE.le.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº‚ÇÅ Œº‚ÇÇ) (forall (s : Set.{u1} Œ±), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº‚ÇÅ s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº‚ÇÇ s))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº‚ÇÅ : MeasureTheory.Measure.{u1} Œ± m0} {Œº‚ÇÇ : MeasureTheory.Measure.{u1} Œ± m0}, Iff (LE.le.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº‚ÇÅ Œº‚ÇÇ) (forall (s : Set.{u1} Œ±), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº‚ÇÅ) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº‚ÇÇ) s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.le_iff' MeasureTheory.Measure.le_iff'‚Çì'. -/
theorem le_iff' : Œº‚ÇÅ ‚â§ Œº‚ÇÇ ‚Üî ‚àÄ s, Œº‚ÇÅ s ‚â§ Œº‚ÇÇ s :=
  toOuterMeasure_le.symm
#align measure_theory.measure.le_iff' MeasureTheory.Measure.le_iff'

/- warning: measure_theory.measure.lt_iff -> MeasureTheory.Measure.lt_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, Iff (LT.lt.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLT.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº ŒΩ) (And (LE.le.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº ŒΩ) (Exists.{succ u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => And (MeasurableSet.{u1} Œ± m0 s) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) ŒΩ s)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, Iff (LT.lt.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLT.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº ŒΩ) (And (LE.le.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº ŒΩ) (Exists.{succ u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => And (MeasurableSet.{u1} Œ± m0 s) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 ŒΩ) s)))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.lt_iff MeasureTheory.Measure.lt_iff‚Çì'. -/
theorem lt_iff : Œº < ŒΩ ‚Üî Œº ‚â§ ŒΩ ‚àß ‚àÉ s, MeasurableSet s ‚àß Œº s < ŒΩ s :=
  lt_iff_le_not_le.trans <|
    and_congr Iff.rfl <| by simp only [le_iff, not_forall, not_le, exists_prop]
#align measure_theory.measure.lt_iff MeasureTheory.Measure.lt_iff

/- warning: measure_theory.measure.lt_iff' -> MeasureTheory.Measure.lt_iff' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, Iff (LT.lt.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLT.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº ŒΩ) (And (LE.le.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº ŒΩ) (Exists.{succ u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) ŒΩ s))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, Iff (LT.lt.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLT.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº ŒΩ) (And (LE.le.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº ŒΩ) (Exists.{succ u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 ŒΩ) s))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.lt_iff' MeasureTheory.Measure.lt_iff'‚Çì'. -/
theorem lt_iff' : Œº < ŒΩ ‚Üî Œº ‚â§ ŒΩ ‚àß ‚àÉ s, Œº s < ŒΩ s :=
  lt_iff_le_not_le.trans <| and_congr Iff.rfl <| by simp only [le_iff', not_forall, not_le]
#align measure_theory.measure.lt_iff' MeasureTheory.Measure.lt_iff'

#print MeasureTheory.Measure.covariantAddLE /-
instance covariantAddLE [MeasurableSpace Œ±] :
    CovariantClass (Measure Œ±) (Measure Œ±) (¬∑ + ¬∑) (¬∑ ‚â§ ¬∑) :=
  ‚ü®fun ŒΩ Œº‚ÇÅ Œº‚ÇÇ hŒº s hs => add_le_add_left (hŒº s hs) _‚ü©
#align measure_theory.measure.covariant_add_le MeasureTheory.Measure.covariantAddLE
-/

#print MeasureTheory.Measure.le_add_left /-
protected theorem le_add_left (h : Œº ‚â§ ŒΩ) : Œº ‚â§ ŒΩ' + ŒΩ := fun s hs => le_add_left (h s hs)
#align measure_theory.measure.le_add_left MeasureTheory.Measure.le_add_left
-/

#print MeasureTheory.Measure.le_add_right /-
protected theorem le_add_right (h : Œº ‚â§ ŒΩ) : Œº ‚â§ ŒΩ + ŒΩ' := fun s hs => le_add_right (h s hs)
#align measure_theory.measure.le_add_right MeasureTheory.Measure.le_add_right
-/

section Inf

variable {m : Set (Measure Œ±)}

/- warning: measure_theory.measure.Inf_caratheodory -> MeasureTheory.Measure.inf‚Çõ_caratheodory is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {m : Set.{u1} (MeasureTheory.Measure.{u1} Œ± m0)} (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m0 s) -> (MeasurableSet.{u1} Œ± (MeasureTheory.OuterMeasure.caratheodory.{u1} Œ± (InfSet.inf‚Çõ.{u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.instCompleteLattice.{u1} Œ±))) (Set.image.{u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0) m))) s)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {m : Set.{u1} (MeasureTheory.Measure.{u1} Œ± m0)} (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m0 s) -> (MeasurableSet.{u1} Œ± (MeasureTheory.OuterMeasure.caratheodory.{u1} Œ± (InfSet.inf‚Çõ.{u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.instCompleteLattice.{u1} Œ±))) (Set.image.{u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0) m))) s)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.Inf_caratheodory MeasureTheory.Measure.inf‚Çõ_caratheodory‚Çì'. -/
theorem inf‚Çõ_caratheodory (s : Set Œ±) (hs : MeasurableSet s) :
    measurable_set[(inf‚Çõ (toOuterMeasure '' m)).caratheodory] s :=
  by
  rw [outer_measure.Inf_eq_bounded_by_Inf_gen]
  refine' outer_measure.bounded_by_caratheodory fun t => _
  simp only [outer_measure.Inf_gen, le_inf·µ¢_iff, ball_image_iff, coe_to_outer_measure,
    measure_eq_infi t]
  intro Œº hŒº u htu hu
  have hm : ‚àÄ {s t}, s ‚äÜ t ‚Üí outer_measure.Inf_gen (to_outer_measure '' m) s ‚â§ Œº t :=
    by
    intro s t hst
    rw [outer_measure.Inf_gen_def]
    refine' inf·µ¢_le_of_le Œº.to_outer_measure (inf·µ¢_le_of_le (mem_image_of_mem _ hŒº) _)
    rw [to_outer_measure_apply]
    refine' measure_mono hst
  rw [‚Üê measure_inter_add_diff u hs]
  refine' add_le_add (hm <| inter_subset_inter_left _ htu) (hm <| diff_subset_diff_left htu)
#align measure_theory.measure.Inf_caratheodory MeasureTheory.Measure.inf‚Çõ_caratheodory

instance [MeasurableSpace Œ±] : InfSet (Measure Œ±) :=
  ‚ü®fun m => (inf‚Çõ (toOuterMeasure '' m)).toMeasure <| inf‚Çõ_caratheodory‚ü©

/- warning: measure_theory.measure.Inf_apply -> MeasureTheory.Measure.inf‚Çõ_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {s : Set.{u1} Œ±} {m : Set.{u1} (MeasureTheory.Measure.{u1} Œ± m0)}, (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (InfSet.inf‚Çõ.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.hasInf.{u1} Œ± m0) m) s) (coeFn.{succ u1, succ u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (fun (_x : MeasureTheory.OuterMeasure.{u1} Œ±) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.OuterMeasure.instCoeFun.{u1} Œ±) (InfSet.inf‚Çõ.{u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.instCompleteLattice.{u1} Œ±))) (Set.image.{u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0) m)) s))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {s : Set.{u1} Œ±} {m : Set.{u1} (MeasureTheory.Measure.{u1} Œ± m0)}, (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (InfSet.inf‚Çõ.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instInfSetMeasure.{u1} Œ± m0) m)) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (InfSet.inf‚Çõ.{u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.instCompleteLattice.{u1} Œ±))) (Set.image.{u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0) m)) s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.Inf_apply MeasureTheory.Measure.inf‚Çõ_apply‚Çì'. -/
theorem inf‚Çõ_apply (hs : MeasurableSet s) : inf‚Çõ m s = inf‚Çõ (toOuterMeasure '' m) s :=
  toMeasure_apply _ _ hs
#align measure_theory.measure.Inf_apply MeasureTheory.Measure.inf‚Çõ_apply

private theorem measure_Inf_le (h : Œº ‚àà m) : inf‚Çõ m ‚â§ Œº :=
  have : inf‚Çõ (toOuterMeasure '' m) ‚â§ Œº.toOuterMeasure := inf‚Çõ_le (mem_image_of_mem _ h)
  fun s hs => by rw [inf‚Çõ_apply hs, ‚Üê to_outer_measure_apply] <;> exact this s
#align measure_theory.measure.measure_Inf_le measure_theory.measure.measure_Inf_le

private theorem measure_le_Inf (h : ‚àÄ Œº' ‚àà m, Œº ‚â§ Œº') : Œº ‚â§ inf‚Çõ m :=
  have : Œº.toOuterMeasure ‚â§ inf‚Çõ (toOuterMeasure '' m) :=
    le_inf‚Çõ <| ball_image_of_ball fun Œº hŒº => toOuterMeasure_le.2 <| h _ hŒº
  fun s hs => by rw [inf‚Çõ_apply hs, ‚Üê to_outer_measure_apply] <;> exact this s
#align measure_theory.measure.measure_le_Inf measure_theory.measure.measure_le_Inf

instance [MeasurableSpace Œ±] : CompleteSemilatticeInf (Measure Œ±) :=
  { (by infer_instance : PartialOrder (Measure Œ±)),
    (by infer_instance :
      InfSet (Measure Œ±)) with
    inf_le := fun s a => measure_inf‚Çõ_le
    le_inf := fun s a => measure_le_inf‚Çõ }

instance [MeasurableSpace Œ±] : CompleteLattice (Measure Œ±) :=
  {/- Adding an explicit `top` makes `leanchecker` fail, see lean#364, disable for now
      
        top := (‚ä§ : outer_measure Œ±).to_measure (by rw [outer_measure.top_caratheodory]; exact le_top),
        le_top := Œª a s hs,
          by cases s.eq_empty_or_nonempty with h  h;
            simp [h, to_measure_apply ‚ä§ _ hs, outer_measure.top_apply],
      -/
      completeLatticeOfCompleteSemilatticeInf
      (Measure Œ±) with
    bot := 0
    bot_le := fun a s hs => bot_le }

end Inf

@[simp]
theorem MeasureTheory.OuterMeasure.toMeasure_top [MeasurableSpace Œ±] :
    (‚ä§ : OuterMeasure Œ±).toMeasure (by rw [outer_measure.top_caratheodory] <;> exact le_top) =
      (‚ä§ : Measure Œ±) :=
  top_unique fun s hs => by
    cases' s.eq_empty_or_nonempty with h h <;>
      simp [h, to_measure_apply ‚ä§ _ hs, outer_measure.top_apply]
#align measure_theory.outer_measure.to_measure_top MeasureTheory.OuterMeasure.toMeasure_top

@[simp]
theorem toOuterMeasure_top [MeasurableSpace Œ±] :
    (‚ä§ : Measure Œ±).toOuterMeasure = (‚ä§ : OuterMeasure Œ±) := by
  rw [‚Üê outer_measure.to_measure_top, to_measure_to_outer_measure, outer_measure.trim_top]
#align measure_theory.measure.to_outer_measure_top MeasureTheory.Measure.toOuterMeasure_top

/- warning: measure_theory.measure.top_add -> MeasureTheory.Measure.top_add is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) (Top.top.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (CompleteLattice.toHasTop.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instCompleteLattice.{u1} Œ± m0))) Œº) (Top.top.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (CompleteLattice.toHasTop.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instCompleteLattice.{u1} Œ± m0)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) (Top.top.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (CompleteLattice.toTop.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instCompleteLattice.{u1} Œ± m0))) Œº) (Top.top.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (CompleteLattice.toTop.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instCompleteLattice.{u1} Œ± m0)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.top_add MeasureTheory.Measure.top_add‚Çì'. -/
@[simp]
theorem top_add : ‚ä§ + Œº = ‚ä§ :=
  top_unique <| Measure.le_add_right le_rfl
#align measure_theory.measure.top_add MeasureTheory.Measure.top_add

/- warning: measure_theory.measure.add_top -> MeasureTheory.Measure.add_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº (Top.top.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (CompleteLattice.toHasTop.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instCompleteLattice.{u1} Œ± m0)))) (Top.top.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (CompleteLattice.toHasTop.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instCompleteLattice.{u1} Œ± m0)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº (Top.top.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (CompleteLattice.toTop.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instCompleteLattice.{u1} Œ± m0)))) (Top.top.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (CompleteLattice.toTop.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instCompleteLattice.{u1} Œ± m0)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.add_top MeasureTheory.Measure.add_top‚Çì'. -/
@[simp]
theorem add_top : Œº + ‚ä§ = ‚ä§ :=
  top_unique <| Measure.le_add_left le_rfl
#align measure_theory.measure.add_top MeasureTheory.Measure.add_top

#print MeasureTheory.Measure.zero_le /-
protected theorem zero_le {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) : 0 ‚â§ Œº :=
  bot_le
#align measure_theory.measure.zero_le MeasureTheory.Measure.zero_le
-/

#print MeasureTheory.Measure.nonpos_iff_eq_zero' /-
theorem nonpos_iff_eq_zero' : Œº ‚â§ 0 ‚Üî Œº = 0 :=
  Œº.zero_le.le_iff_eq
#align measure_theory.measure.nonpos_iff_eq_zero' MeasureTheory.Measure.nonpos_iff_eq_zero'
-/

/- warning: measure_theory.measure.measure_univ_eq_zero -> MeasureTheory.Measure.measure_univ_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Iff (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.univ.{u1} Œ±)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (OfNat.mk.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.zero.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Iff (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Set.univ.{u1} Œ±)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.toOfNat0.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.measure_univ_eq_zero MeasureTheory.Measure.measure_univ_eq_zero‚Çì'. -/
@[simp]
theorem measure_univ_eq_zero : Œº univ = 0 ‚Üî Œº = 0 :=
  ‚ü®fun h => bot_unique fun s hs => trans_rel_left (¬∑ ‚â§ ¬∑) (measure_mono (subset_univ s)) h, fun h =>
    h.symm ‚ñ∏ rfl‚ü©
#align measure_theory.measure.measure_univ_eq_zero MeasureTheory.Measure.measure_univ_eq_zero

/- warning: measure_theory.measure.measure_univ_ne_zero -> MeasureTheory.Measure.measure_univ_ne_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Iff (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.univ.{u1} Œ±)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) (Ne.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (OfNat.mk.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.zero.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Iff (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Set.univ.{u1} Œ±)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) (Ne.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.toOfNat0.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.measure_univ_ne_zero MeasureTheory.Measure.measure_univ_ne_zero‚Çì'. -/
theorem measure_univ_ne_zero : Œº univ ‚â† 0 ‚Üî Œº ‚â† 0 :=
  measure_univ_eq_zero.Not
#align measure_theory.measure.measure_univ_ne_zero MeasureTheory.Measure.measure_univ_ne_zero

/- warning: measure_theory.measure.measure_univ_pos -> MeasureTheory.Measure.measure_univ_pos is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Iff (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.univ.{u1} Œ±))) (Ne.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (OfNat.mk.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.zero.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Iff (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Set.univ.{u1} Œ±))) (Ne.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.toOfNat0.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.measure_univ_pos MeasureTheory.Measure.measure_univ_pos‚Çì'. -/
@[simp]
theorem measure_univ_pos : 0 < Œº univ ‚Üî Œº ‚â† 0 :=
  pos_iff_ne_zero.trans measure_univ_ne_zero
#align measure_theory.measure.measure_univ_pos MeasureTheory.Measure.measure_univ_pos

/-! ### Pushforward and pullback -/


/- warning: measure_theory.measure.lift_linear -> MeasureTheory.Measure.liftLinear is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u2} Œ≤] {m0 : MeasurableSpace.{u1} Œ±} (f : LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_1) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_2)), (forall (Œº : MeasureTheory.Measure.{u1} Œ± m0), LE.le.{u2} (MeasurableSpace.{u2} Œ≤) (MeasurableSpace.hasLe.{u2} Œ≤) _inst_1 (MeasureTheory.OuterMeasure.caratheodory.{u2} Œ≤ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_1) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_2)) (fun (_x : LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_1) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_2)) => (MeasureTheory.OuterMeasure.{u1} Œ±) -> (MeasureTheory.OuterMeasure.{u2} Œ≤)) (LinearMap.hasCoeToFun.{0, 0, u1, u2} ENNReal ENNReal (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_1) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_2) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) f (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº)))) -> (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_3 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_4 _inst_1))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u2} Œ≤] {m0 : MeasurableSpace.{u1} Œ±} (f : LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))), (forall (Œº : MeasureTheory.Measure.{u1} Œ± m0), LE.le.{u2} (MeasurableSpace.{u2} Œ≤) (MeasurableSpace.instLEMeasurableSpace.{u2} Œ≤) _inst_1 (MeasureTheory.OuterMeasure.caratheodory.{u2} Œ≤ (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (fun (_x : MeasureTheory.OuterMeasure.{u1} Œ±) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.OuterMeasure.{u1} Œ±) => MeasureTheory.OuterMeasure.{u2} Œ≤) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u1, u2} ENNReal ENNReal (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) f (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº)))) -> (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_1))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.lift_linear MeasureTheory.Measure.liftLinear‚Çì'. -/
/-- Lift a linear map between `outer_measure` spaces such that for each measure `Œº` every measurable
set is caratheodory-measurable w.r.t. `f Œº` to a linear map between `measure` spaces. -/
def liftLinear {m0 : MeasurableSpace Œ±} (f : OuterMeasure Œ± ‚Üí‚Çó[‚Ñù‚â•0‚àû] OuterMeasure Œ≤)
    (hf : ‚àÄ Œº : Measure Œ±, ‚Äπ_‚Ä∫ ‚â§ (f Œº.toOuterMeasure).caratheodory) : Measure Œ± ‚Üí‚Çó[‚Ñù‚â•0‚àû] Measure Œ≤
    where
  toFun Œº := (f Œº.toOuterMeasure).toMeasure (hf Œº)
  map_add' Œº‚ÇÅ Œº‚ÇÇ := ext fun s hs => by simp [hs]
  map_smul' c Œº := ext fun s hs => by simp [hs]
#align measure_theory.measure.lift_linear MeasureTheory.Measure.liftLinear

/- warning: measure_theory.measure.lift_linear_apply -> MeasureTheory.Measure.liftLinear_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))} (hf : forall (Œº : MeasureTheory.Measure.{u1} Œ± m0), LE.le.{u2} (MeasurableSpace.{u2} Œ≤) (MeasurableSpace.hasLe.{u2} Œ≤) _inst_1 (MeasureTheory.OuterMeasure.caratheodory.{u2} Œ≤ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_1) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_2)) (fun (_x : LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_1) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_2)) => (MeasureTheory.OuterMeasure.{u1} Œ±) -> (MeasureTheory.OuterMeasure.{u2} Œ≤)) (LinearMap.hasCoeToFun.{0, 0, u1, u2} ENNReal ENNReal (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_1) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_2) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) f (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº)))) {s : Set.{u2} Œ≤}, (MeasurableSet.{u2} Œ≤ _inst_1 s) -> (Eq.{1} ENNReal (coeFn.{succ u2, succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (fun (_x : MeasureTheory.Measure.{u2} Œ≤ _inst_1) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u2} Œ≤ _inst_1) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_3 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_4 _inst_1)) (fun (_x : LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_3 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_4 _inst_1)) => (MeasureTheory.Measure.{u1} Œ± m0) -> (MeasureTheory.Measure.{u2} Œ≤ _inst_1)) (LinearMap.hasCoeToFun.{0, 0, u1, u2} ENNReal ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_3 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_4 _inst_1) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (MeasureTheory.Measure.liftLinear.{u1, u2} Œ± Œ≤ _inst_1 m0 f hf) Œº) s) (coeFn.{succ u2, succ u2} (MeasureTheory.OuterMeasure.{u2} Œ≤) (fun (_x : MeasureTheory.OuterMeasure.{u2} Œ≤) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.OuterMeasure.instCoeFun.{u2} Œ≤) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (fun (_x : LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) => (MeasureTheory.OuterMeasure.{u1} Œ±) -> (MeasureTheory.OuterMeasure.{u2} Œ≤)) (LinearMap.hasCoeToFun.{0, 0, u1, u2} ENNReal ENNReal (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) f (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº)) s))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u2} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))} (hf : forall (Œº : MeasureTheory.Measure.{u2} Œ± m0), LE.le.{u1} (MeasurableSpace.{u1} Œ≤) (MeasurableSpace.instLEMeasurableSpace.{u1} Œ≤) _inst_1 (MeasureTheory.OuterMeasure.caratheodory.{u1} Œ≤ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u2} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u2} Œ±) (fun (_x : MeasureTheory.OuterMeasure.{u2} Œ±) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.OuterMeasure.{u2} Œ±) => MeasureTheory.OuterMeasure.{u1} Œ≤) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u2, u1} ENNReal ENNReal (MeasureTheory.OuterMeasure.{u2} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ≤) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) f (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 Œº)))) {s : Set.{u1} Œ≤}, (MeasurableSet.{u1} Œ≤ _inst_1 s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ≤ (MeasureTheory.Measure.toOuterMeasure.{u1} Œ≤ _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_1)) (MeasureTheory.Measure.{u2} Œ± m0) (fun (a : MeasureTheory.Measure.{u2} Œ± m0) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.Measure.{u2} Œ± m0) => MeasureTheory.Measure.{u1} Œ≤ _inst_1) a) (LinearMap.instFunLikeLinearMap.{0, 0, u2, u1} ENNReal ENNReal (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_1) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (MeasureTheory.Measure.liftLinear.{u2, u1} Œ± Œ≤ _inst_1 m0 f hf) Œº)) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ≤ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u2} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u2} Œ±) (fun (_x : MeasureTheory.OuterMeasure.{u2} Œ±) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.OuterMeasure.{u2} Œ±) => MeasureTheory.OuterMeasure.{u1} Œ≤) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u2, u1} ENNReal ENNReal (MeasureTheory.OuterMeasure.{u2} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ≤) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) f (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 Œº)) s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.lift_linear_apply MeasureTheory.Measure.liftLinear_apply‚Çì'. -/
@[simp]
theorem liftLinear_apply {f : OuterMeasure Œ± ‚Üí‚Çó[‚Ñù‚â•0‚àû] OuterMeasure Œ≤} (hf) {s : Set Œ≤}
    (hs : MeasurableSet s) : liftLinear f hf Œº s = f Œº.toOuterMeasure s :=
  toMeasure_apply _ _ hs
#align measure_theory.measure.lift_linear_apply MeasureTheory.Measure.liftLinear_apply

/- warning: measure_theory.measure.le_lift_linear_apply -> MeasureTheory.Measure.le_liftLinear_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))} (hf : forall (Œº : MeasureTheory.Measure.{u1} Œ± m0), LE.le.{u2} (MeasurableSpace.{u2} Œ≤) (MeasurableSpace.hasLe.{u2} Œ≤) _inst_1 (MeasureTheory.OuterMeasure.caratheodory.{u2} Œ≤ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_1) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_2)) (fun (_x : LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_1) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_2)) => (MeasureTheory.OuterMeasure.{u1} Œ±) -> (MeasureTheory.OuterMeasure.{u2} Œ≤)) (LinearMap.hasCoeToFun.{0, 0, u1, u2} ENNReal ENNReal (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_1) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_2) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) f (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº)))) (s : Set.{u2} Œ≤), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u2, succ u2} (MeasureTheory.OuterMeasure.{u2} Œ≤) (fun (_x : MeasureTheory.OuterMeasure.{u2} Œ≤) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.OuterMeasure.instCoeFun.{u2} Œ≤) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (fun (_x : LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) => (MeasureTheory.OuterMeasure.{u1} Œ±) -> (MeasureTheory.OuterMeasure.{u2} Œ≤)) (LinearMap.hasCoeToFun.{0, 0, u1, u2} ENNReal ENNReal (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) f (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº)) s) (coeFn.{succ u2, succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (fun (_x : MeasureTheory.Measure.{u2} Œ≤ _inst_1) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u2} Œ≤ _inst_1) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_3 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_4 _inst_1)) (fun (_x : LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_3 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_4 _inst_1)) => (MeasureTheory.Measure.{u1} Œ± m0) -> (MeasureTheory.Measure.{u2} Œ≤ _inst_1)) (LinearMap.hasCoeToFun.{0, 0, u1, u2} ENNReal ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_3 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.liftLinear._proof_4 _inst_1) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (MeasureTheory.Measure.liftLinear.{u1, u2} Œ± Œ≤ _inst_1 m0 f hf) Œº) s)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u2} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))} (hf : forall (Œº : MeasureTheory.Measure.{u2} Œ± m0), LE.le.{u1} (MeasurableSpace.{u1} Œ≤) (MeasurableSpace.instLEMeasurableSpace.{u1} Œ≤) _inst_1 (MeasureTheory.OuterMeasure.caratheodory.{u1} Œ≤ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u2} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u2} Œ±) (fun (_x : MeasureTheory.OuterMeasure.{u2} Œ±) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.OuterMeasure.{u2} Œ±) => MeasureTheory.OuterMeasure.{u1} Œ≤) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u2, u1} ENNReal ENNReal (MeasureTheory.OuterMeasure.{u2} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ≤) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) f (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 Œº)))) (s : Set.{u1} Œ≤), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ≤ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u2} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u2} Œ±) (fun (_x : MeasureTheory.OuterMeasure.{u2} Œ±) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.OuterMeasure.{u2} Œ±) => MeasureTheory.OuterMeasure.{u1} Œ≤) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u2, u1} ENNReal ENNReal (MeasureTheory.OuterMeasure.{u2} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ≤) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) f (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 Œº)) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ≤ (MeasureTheory.Measure.toOuterMeasure.{u1} Œ≤ _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_1)) (MeasureTheory.Measure.{u2} Œ± m0) (fun (a : MeasureTheory.Measure.{u2} Œ± m0) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.Measure.{u2} Œ± m0) => MeasureTheory.Measure.{u1} Œ≤ _inst_1) a) (LinearMap.instFunLikeLinearMap.{0, 0, u2, u1} ENNReal ENNReal (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_1) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (MeasureTheory.Measure.liftLinear.{u2, u1} Œ± Œ≤ _inst_1 m0 f hf) Œº)) s)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.le_lift_linear_apply MeasureTheory.Measure.le_liftLinear_apply‚Çì'. -/
theorem le_liftLinear_apply {f : OuterMeasure Œ± ‚Üí‚Çó[‚Ñù‚â•0‚àû] OuterMeasure Œ≤} (hf) (s : Set Œ≤) :
    f Œº.toOuterMeasure s ‚â§ liftLinear f hf Œº s :=
  le_toMeasure_apply _ _ s
#align measure_theory.measure.le_lift_linear_apply MeasureTheory.Measure.le_liftLinear_apply

/- warning: measure_theory.measure.map‚Çó -> MeasureTheory.Measure.map‚Çó is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u2} Œ≤] [_inst_3 : MeasurableSpace.{u1} Œ±], (Œ± -> Œ≤) -> (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± _inst_3) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± _inst_3) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_1 _inst_3) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_2 _inst_1))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u2} Œ≤] [_inst_3 : MeasurableSpace.{u1} Œ±], (Œ± -> Œ≤) -> (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.Measure.{u1} Œ± _inst_3) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± _inst_3) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_3) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_1))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.map‚Çó MeasureTheory.Measure.map‚Çó‚Çì'. -/
/-- The pushforward of a measure as a linear map. It is defined to be `0` if `f` is not
a measurable function. -/
def map‚Çó [MeasurableSpace Œ±] (f : Œ± ‚Üí Œ≤) : Measure Œ± ‚Üí‚Çó[‚Ñù‚â•0‚àû] Measure Œ≤ :=
  if hf : Measurable f then
    liftLinear (OuterMeasure.map f) fun Œº s hs t =>
      le_toOuterMeasure_caratheodory Œº _ (hf hs) (f ‚Åª¬π' t)
  else 0
#align measure_theory.measure.map‚Çó MeasureTheory.Measure.map‚Çó

/- warning: measure_theory.measure.map‚Çó_congr -> MeasureTheory.Measure.map‚Çó_congr is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (Measurable.{u1, u2} Œ± Œ≤ m0 _inst_1 f) -> (Measurable.{u1, u2} Œ± Œ≤ m0 _inst_1 g) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) f g) -> (Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_1 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_2 _inst_1)) (fun (_x : LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_1 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_2 _inst_1)) => (MeasureTheory.Measure.{u1} Œ± m0) -> (MeasureTheory.Measure.{u2} Œ≤ _inst_1)) (LinearMap.hasCoeToFun.{0, 0, u1, u2} ENNReal ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_1 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_2 _inst_1) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (MeasureTheory.Measure.map‚Çó.{u1, u2} Œ± Œ≤ _inst_1 m0 f) Œº) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_1 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_2 _inst_1)) (fun (_x : LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_1 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_2 _inst_1)) => (MeasureTheory.Measure.{u1} Œ± m0) -> (MeasureTheory.Measure.{u2} Œ≤ _inst_1)) (LinearMap.hasCoeToFun.{0, 0, u1, u2} ENNReal ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_1 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_2 _inst_1) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (MeasureTheory.Measure.map‚Çó.{u1, u2} Œ± Œ≤ _inst_1 m0 g) Œº))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (Measurable.{u2, u1} Œ± Œ≤ m0 _inst_1 f) -> (Measurable.{u2, u1} Œ± Œ≤ m0 _inst_1 g) -> (Filter.EventuallyEq.{u2, u1} Œ± Œ≤ (MeasureTheory.Measure.ae.{u2} Œ± m0 Œº) f g) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.Measure.{u2} Œ± m0) => MeasureTheory.Measure.{u1} Œ≤ _inst_1) Œº) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_1)) (MeasureTheory.Measure.{u2} Œ± m0) (fun (_x : MeasureTheory.Measure.{u2} Œ± m0) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.Measure.{u2} Œ± m0) => MeasureTheory.Measure.{u1} Œ≤ _inst_1) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u2, u1} ENNReal ENNReal (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_1) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (MeasureTheory.Measure.map‚Çó.{u2, u1} Œ± Œ≤ _inst_1 m0 f) Œº) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_1)) (MeasureTheory.Measure.{u2} Œ± m0) (fun (_x : MeasureTheory.Measure.{u2} Œ± m0) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.Measure.{u2} Œ± m0) => MeasureTheory.Measure.{u1} Œ≤ _inst_1) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u2, u1} ENNReal ENNReal (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_1) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (MeasureTheory.Measure.map‚Çó.{u2, u1} Œ± Œ≤ _inst_1 m0 g) Œº))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.map‚Çó_congr MeasureTheory.Measure.map‚Çó_congr‚Çì'. -/
theorem map‚Çó_congr {f g : Œ± ‚Üí Œ≤} (hf : Measurable f) (hg : Measurable g) (h : f =·µê[Œº] g) :
    map‚Çó f Œº = map‚Çó g Œº := by
  ext1 s hs
  simpa only [map‚Çó, hf, hg, hs, dif_pos, lift_linear_apply, outer_measure.map_apply,
    coe_to_outer_measure] using measure_congr (h.preimage s)
#align measure_theory.measure.map‚Çó_congr MeasureTheory.Measure.map‚Çó_congr

#print MeasureTheory.Measure.map /-
/-- The pushforward of a measure. It is defined to be `0` if `f` is not an almost everywhere
measurable function. -/
irreducible_def map [MeasurableSpace Œ±] (f : Œ± ‚Üí Œ≤) (Œº : Measure Œ±) : Measure Œ≤ :=
  if hf : AEMeasurable f Œº then map‚Çó (hf.mk f) Œº else 0
#align measure_theory.measure.map MeasureTheory.Measure.map
-/

include m0

/- warning: measure_theory.measure.map‚Çó_mk_apply_of_ae_measurable -> MeasureTheory.Measure.map‚Çó_mk_apply_of_aemeasurable is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ≤} (hf : AEMeasurable.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº), Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_1 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_2 _inst_1)) (fun (_x : LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_1 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_2 _inst_1)) => (MeasureTheory.Measure.{u1} Œ± m0) -> (MeasureTheory.Measure.{u2} Œ≤ _inst_1)) (LinearMap.hasCoeToFun.{0, 0, u1, u2} ENNReal ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_1 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_2 _inst_1) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (MeasureTheory.Measure.map‚Çó.{u1, u2} Œ± Œ≤ _inst_1 m0 (AEMeasurable.mk.{u1, u2} Œ± Œ≤ m0 _inst_1 Œº f hf)) Œº) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : Œ± -> Œ≤} (hf : AEMeasurable.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.Measure.{u2} Œ± m0) => MeasureTheory.Measure.{u1} Œ≤ _inst_1) Œº) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_1)) (MeasureTheory.Measure.{u2} Œ± m0) (fun (_x : MeasureTheory.Measure.{u2} Œ± m0) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.Measure.{u2} Œ± m0) => MeasureTheory.Measure.{u1} Œ≤ _inst_1) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u2, u1} ENNReal ENNReal (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_1) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (MeasureTheory.Measure.map‚Çó.{u2, u1} Œ± Œ≤ _inst_1 m0 (AEMeasurable.mk.{u2, u1} Œ± Œ≤ m0 _inst_1 Œº f hf)) Œº) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.map‚Çó_mk_apply_of_ae_measurable MeasureTheory.Measure.map‚Çó_mk_apply_of_aemeasurable‚Çì'. -/
theorem map‚Çó_mk_apply_of_aemeasurable {f : Œ± ‚Üí Œ≤} (hf : AEMeasurable f Œº) :
    map‚Çó (hf.mk f) Œº = map f Œº := by simp [map, hf]
#align measure_theory.measure.map‚Çó_mk_apply_of_ae_measurable MeasureTheory.Measure.map‚Çó_mk_apply_of_aemeasurable

/- warning: measure_theory.measure.map‚Çó_apply_of_measurable -> MeasureTheory.Measure.map‚Çó_apply_of_measurable is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Measurable.{u1, u2} Œ± Œ≤ m0 _inst_1 f) -> (forall (Œº : MeasureTheory.Measure.{u1} Œ± m0), Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_1 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_2 _inst_1)) (fun (_x : LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_1 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_2 _inst_1)) => (MeasureTheory.Measure.{u1} Œ± m0) -> (MeasureTheory.Measure.{u2} Œ≤ _inst_1)) (LinearMap.hasCoeToFun.{0, 0, u1, u2} ENNReal ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_1 m0) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.map‚Çó._proof_2 _inst_1) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (MeasureTheory.Measure.map‚Çó.{u1, u2} Œ± Œ≤ _inst_1 m0 f) Œº) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Measurable.{u2, u1} Œ± Œ≤ m0 _inst_1 f) -> (forall (Œº : MeasureTheory.Measure.{u2} Œ± m0), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.Measure.{u2} Œ± m0) => MeasureTheory.Measure.{u1} Œ≤ _inst_1) Œº) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_1)) (MeasureTheory.Measure.{u2} Œ± m0) (fun (_x : MeasureTheory.Measure.{u2} Œ± m0) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.Measure.{u2} Œ± m0) => MeasureTheory.Measure.{u1} Œ≤ _inst_1) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u2, u1} ENNReal ENNReal (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_1) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (MeasureTheory.Measure.map‚Çó.{u2, u1} Œ± Œ≤ _inst_1 m0 f) Œº) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.map‚Çó_apply_of_measurable MeasureTheory.Measure.map‚Çó_apply_of_measurable‚Çì'. -/
theorem map‚Çó_apply_of_measurable {f : Œ± ‚Üí Œ≤} (hf : Measurable f) (Œº : Measure Œ±) :
    map‚Çó f Œº = map f Œº :=
  by
  simp only [‚Üê map‚Çó_mk_apply_of_ae_measurable hf.ae_measurable]
  exact map‚Çó_congr hf hf.ae_measurable.measurable_mk hf.ae_measurable.ae_eq_mk
#align measure_theory.measure.map‚Çó_apply_of_measurable MeasureTheory.Measure.map‚Çó_apply_of_measurable

/- warning: measure_theory.measure.map_add -> MeasureTheory.Measure.map_add is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] (Œº : MeasureTheory.Measure.{u1} Œ± m0) (ŒΩ : MeasureTheory.Measure.{u1} Œ± m0) {f : Œ± -> Œ≤}, (Measurable.{u1, u2} Œ± Œ≤ m0 _inst_1 f) -> (Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) Œº ŒΩ)) (HAdd.hAdd.{u2, u2, u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (instHAdd.{u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAdd.{u2} Œ≤ _inst_1)) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f ŒΩ)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] (Œº : MeasureTheory.Measure.{u2} Œ± m0) (ŒΩ : MeasureTheory.Measure.{u2} Œ± m0) {f : Œ± -> Œ≤}, (Measurable.{u2, u1} Œ± Œ≤ m0 _inst_1 f) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f (HAdd.hAdd.{u2, u2, u2} (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.{u2} Œ± m0) (instHAdd.{u2} (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.instAdd.{u2} Œ± m0)) Œº ŒΩ)) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instAdd.{u1} Œ≤ _inst_1)) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f ŒΩ)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.map_add MeasureTheory.Measure.map_add‚Çì'. -/
@[simp]
theorem map_add (Œº ŒΩ : Measure Œ±) {f : Œ± ‚Üí Œ≤} (hf : Measurable f) :
    (Œº + ŒΩ).map f = Œº.map f + ŒΩ.map f := by simp [‚Üê map‚Çó_apply_of_measurable hf]
#align measure_theory.measure.map_add MeasureTheory.Measure.map_add

#print MeasureTheory.Measure.map_zero /-
@[simp]
theorem map_zero (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 := by
  by_cases hf : AEMeasurable f (0 : Measure Œ±) <;> simp [map, hf]
#align measure_theory.measure.map_zero MeasureTheory.Measure.map_zero
-/

/- warning: measure_theory.measure.map_of_not_ae_measurable -> MeasureTheory.Measure.map_of_not_aemeasurable is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {f : Œ± -> Œ≤} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, (Not (AEMeasurable.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº)) -> (Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) (OfNat.ofNat.{u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) 0 (OfNat.mk.{u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) 0 (Zero.zero.{u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instZero.{u2} Œ≤ _inst_1)))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {f : Œ± -> Œ≤} {Œº : MeasureTheory.Measure.{u2} Œ± m0}, (Not (AEMeasurable.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº)) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_1) 0 (Zero.toOfNat0.{u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instZero.{u1} Œ≤ _inst_1))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.map_of_not_ae_measurable MeasureTheory.Measure.map_of_not_aemeasurable‚Çì'. -/
theorem map_of_not_aemeasurable {f : Œ± ‚Üí Œ≤} {Œº : Measure Œ±} (hf : ¬¨AEMeasurable f Œº) :
    Œº.map f = 0 := by simp [map, hf]
#align measure_theory.measure.map_of_not_ae_measurable MeasureTheory.Measure.map_of_not_aemeasurable

/- warning: measure_theory.measure.map_congr -> MeasureTheory.Measure.map_congr is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) f g) -> (Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 g Œº))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (Filter.EventuallyEq.{u2, u1} Œ± Œ≤ (MeasureTheory.Measure.ae.{u2} Œ± m0 Œº) f g) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 g Œº))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.map_congr MeasureTheory.Measure.map_congr‚Çì'. -/
theorem map_congr {f g : Œ± ‚Üí Œ≤} (h : f =·µê[Œº] g) : Measure.map f Œº = Measure.map g Œº :=
  by
  by_cases hf : AEMeasurable f Œº
  ¬∑ have hg : AEMeasurable g Œº := hf.congr h
    simp only [‚Üê map‚Çó_mk_apply_of_ae_measurable hf, ‚Üê map‚Çó_mk_apply_of_ae_measurable hg]
    exact
      map‚Çó_congr hf.measurable_mk hg.measurable_mk (hf.ae_eq_mk.symm.trans (h.trans hg.ae_eq_mk))
  ¬∑ have hg : ¬¨AEMeasurable g Œº := by simpa [‚Üê aemeasurable_congr h] using hf
    simp [map_of_not_ae_measurable, hf, hg]
#align measure_theory.measure.map_congr MeasureTheory.Measure.map_congr

/- warning: measure_theory.measure.map_smul -> MeasureTheory.Measure.map_smul is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] (c : ENNReal) (Œº : MeasureTheory.Measure.{u1} Œ± m0) (f : Œ± -> Œ≤), Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f (SMul.smul.{0, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± ENNReal (SMulZeroClass.toHasSmul.{0, 0} ENNReal ENNReal (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (SMulWithZero.toSmulZeroClass.{0, 0} ENNReal ENNReal (MulZeroClass.toHasZero.{0} ENNReal (MulZeroOneClass.toMulZeroClass.{0} ENNReal (MonoidWithZero.toMulZeroOneClass.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (MulActionWithZero.toSMulWithZero.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (Module.toMulActionWithZero.{0, 0} ENNReal ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Algebra.toModule.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) m0) c Œº)) (SMul.smul.{0, u2} ENNReal (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instSMul.{u2, 0} Œ≤ ENNReal (SMulZeroClass.toHasSmul.{0, 0} ENNReal ENNReal (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (SMulWithZero.toSmulZeroClass.{0, 0} ENNReal ENNReal (MulZeroClass.toHasZero.{0} ENNReal (MulZeroOneClass.toMulZeroClass.{0} ENNReal (MonoidWithZero.toMulZeroOneClass.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (MulActionWithZero.toSMulWithZero.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (Module.toMulActionWithZero.{0, 0} ENNReal ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Algebra.toModule.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) _inst_1) c (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] (c : ENNReal) (Œº : MeasureTheory.Measure.{u2} Œ± m0) (f : Œ± -> Œ≤), Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f (HSMul.hSMul.{0, u2, u2} ENNReal (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.{u2} Œ± m0) (instHSMul.{0, u2} ENNReal (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.instSMul.{u2, 0} Œ± ENNReal (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0)) c Œº)) (HSMul.hSMul.{0, u1, u1} ENNReal (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (instHSMul.{0, u1} ENNReal (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instSMul.{u1, 0} Œ≤ ENNReal (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_1)) c (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.map_smul MeasureTheory.Measure.map_smul‚Çì'. -/
@[simp]
protected theorem map_smul (c : ‚Ñù‚â•0‚àû) (Œº : Measure Œ±) (f : Œ± ‚Üí Œ≤) : (c ‚Ä¢ Œº).map f = c ‚Ä¢ Œº.map f :=
  by
  rcases eq_or_ne c 0 with (rfl | hc); ¬∑ simp
  by_cases hf : AEMeasurable f Œº
  ¬∑ have hfc : AEMeasurable f (c ‚Ä¢ Œº) :=
      ‚ü®hf.mk f, hf.measurable_mk, (ae_smul_measure_iff hc).2 hf.ae_eq_mk‚ü©
    simp only [‚Üê map‚Çó_mk_apply_of_ae_measurable hf, ‚Üê map‚Çó_mk_apply_of_ae_measurable hfc,
      LinearMap.map_smul‚Çõ‚Çó, RingHom.id_apply]
    congr 1
    apply map‚Çó_congr hfc.measurable_mk hf.measurable_mk
    exact eventually_eq.trans ((ae_smul_measure_iff hc).1 hfc.ae_eq_mk.symm) hf.ae_eq_mk
  ¬∑ have hfc : ¬¨AEMeasurable f (c ‚Ä¢ Œº) := by
      intro hfc
      exact hf ‚ü®hfc.mk f, hfc.measurable_mk, (ae_smul_measure_iff hc).1 hfc.ae_eq_mk‚ü©
    simp [map_of_not_ae_measurable hf, map_of_not_ae_measurable hfc]
#align measure_theory.measure.map_smul MeasureTheory.Measure.map_smul

/- warning: measure_theory.measure.map_smul_nnreal -> MeasureTheory.Measure.map_smul_nnreal is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] (c : NNReal) (Œº : MeasureTheory.Measure.{u1} Œ± m0) (f : Œ± -> Œ≤), Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f (SMul.smul.{0, u1} NNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± NNReal (MulAction.toHasSmul.{0, 0} NNReal ENNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal NNReal.semiring)) (ENNReal.mulAction.{0} ENNReal (Monoid.toMulAction.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (ENNReal.isScalarTower.{0, 0} ENNReal ENNReal (Monoid.toMulAction.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Monoid.toMulAction.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Mul.toSMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) m0) c Œº)) (SMul.smul.{0, u2} NNReal (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instSMul.{u2, 0} Œ≤ NNReal (MulAction.toHasSmul.{0, 0} NNReal ENNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal NNReal.semiring)) (ENNReal.mulAction.{0} ENNReal (Monoid.toMulAction.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (ENNReal.isScalarTower.{0, 0} ENNReal ENNReal (Monoid.toMulAction.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Monoid.toMulAction.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Mul.toSMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) _inst_1) c (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] (c : NNReal) (Œº : MeasureTheory.Measure.{u2} Œ± m0) (f : Œ± -> Œ≤), Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f (HSMul.hSMul.{0, u2, u2} NNReal (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.{u2} Œ± m0) (instHSMul.{0, u2} NNReal (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.instSMul.{u2, 0} Œ± NNReal (Algebra.toSMul.{0, 0} NNReal ENNReal instNNRealCommSemiring (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (ENNReal.instAlgebraNNRealInstNNRealCommSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (ENNReal.instIsScalarTowerNNRealToSMulToMonoidToMonoidWithZeroInstNNRealSemiringInstMulActionNNRealToMonoidToMonoidWithZeroInstNNRealSemiringToSMulInstMulActionNNRealToMonoidToMonoidWithZeroInstNNRealSemiring.{0, 0} ENNReal ENNReal (MulActionWithZero.toMulAction.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) instENNRealZero (MonoidWithZero.toMulActionWithZero.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (MulActionWithZero.toMulAction.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) instENNRealZero (MonoidWithZero.toMulActionWithZero.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) m0)) c Œº)) (HSMul.hSMul.{0, u1, u1} NNReal (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (instHSMul.{0, u1} NNReal (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instSMul.{u1, 0} Œ≤ NNReal (Algebra.toSMul.{0, 0} NNReal ENNReal instNNRealCommSemiring (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (ENNReal.instAlgebraNNRealInstNNRealCommSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (ENNReal.instIsScalarTowerNNRealToSMulToMonoidToMonoidWithZeroInstNNRealSemiringInstMulActionNNRealToMonoidToMonoidWithZeroInstNNRealSemiringToSMulInstMulActionNNRealToMonoidToMonoidWithZeroInstNNRealSemiring.{0, 0} ENNReal ENNReal (MulActionWithZero.toMulAction.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) instENNRealZero (MonoidWithZero.toMulActionWithZero.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (MulActionWithZero.toMulAction.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) instENNRealZero (MonoidWithZero.toMulActionWithZero.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) _inst_1)) c (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.map_smul_nnreal MeasureTheory.Measure.map_smul_nnreal‚Çì'. -/
@[simp]
protected theorem map_smul_nnreal (c : ‚Ñù‚â•0) (Œº : Measure Œ±) (f : Œ± ‚Üí Œ≤) :
    (c ‚Ä¢ Œº).map f = c ‚Ä¢ Œº.map f :=
  Œº.map_smul (c : ‚Ñù‚â•0‚àû) f
#align measure_theory.measure.map_smul_nnreal MeasureTheory.Measure.map_smul_nnreal

/- warning: measure_theory.measure.map_apply_of_ae_measurable -> MeasureTheory.Measure.map_apply_of_aemeasurable is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) -> (forall {s : Set.{u2} Œ≤}, (MeasurableSet.{u2} Œ≤ _inst_1 s) -> (Eq.{1} ENNReal (coeFn.{succ u2, succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (fun (_x : MeasureTheory.Measure.{u2} Œ≤ _inst_1) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.preimage.{u1, u2} Œ± Œ≤ f s))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) -> (forall {s : Set.{u1} Œ≤}, (MeasurableSet.{u1} Œ≤ _inst_1 s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ≤ (MeasureTheory.Measure.toOuterMeasure.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº)) s) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 Œº) (Set.preimage.{u2, u1} Œ± Œ≤ f s))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.map_apply_of_ae_measurable MeasureTheory.Measure.map_apply_of_aemeasurable‚Çì'. -/
/-- We can evaluate the pushforward on measurable sets. For non-measurable sets, see
  `measure_theory.measure.le_map_apply` and `measurable_equiv.map_apply`. -/
@[simp]
theorem map_apply_of_aemeasurable {f : Œ± ‚Üí Œ≤} (hf : AEMeasurable f Œº) {s : Set Œ≤}
    (hs : MeasurableSet s) : Œº.map f s = Œº (f ‚Åª¬π' s) := by
  simpa only [map‚Çó, hf.measurable_mk, hs, dif_pos, lift_linear_apply, outer_measure.map_apply,
    coe_to_outer_measure, ‚Üê map‚Çó_mk_apply_of_ae_measurable hf] using
    measure_congr (hf.ae_eq_mk.symm.preimage s)
#align measure_theory.measure.map_apply_of_ae_measurable MeasureTheory.Measure.map_apply_of_aemeasurable

/- warning: measure_theory.measure.map_apply -> MeasureTheory.Measure.map_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ≤}, (Measurable.{u1, u2} Œ± Œ≤ m0 _inst_1 f) -> (forall {s : Set.{u2} Œ≤}, (MeasurableSet.{u2} Œ≤ _inst_1 s) -> (Eq.{1} ENNReal (coeFn.{succ u2, succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (fun (_x : MeasureTheory.Measure.{u2} Œ≤ _inst_1) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.preimage.{u1, u2} Œ± Œ≤ f s))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : Œ± -> Œ≤}, (Measurable.{u2, u1} Œ± Œ≤ m0 _inst_1 f) -> (forall {s : Set.{u1} Œ≤}, (MeasurableSet.{u1} Œ≤ _inst_1 s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ≤ (MeasureTheory.Measure.toOuterMeasure.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº)) s) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 Œº) (Set.preimage.{u2, u1} Œ± Œ≤ f s))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.map_apply MeasureTheory.Measure.map_apply‚Çì'. -/
@[simp]
theorem map_apply {f : Œ± ‚Üí Œ≤} (hf : Measurable f) {s : Set Œ≤} (hs : MeasurableSet s) :
    Œº.map f s = Œº (f ‚Åª¬π' s) :=
  map_apply_of_aemeasurable hf.AEMeasurable hs
#align measure_theory.measure.map_apply MeasureTheory.Measure.map_apply

/- warning: measure_theory.measure.map_to_outer_measure -> MeasureTheory.Measure.map_toOuterMeasure is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) -> (Eq.{succ u2} (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.Measure.toOuterMeasure.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº)) (MeasureTheory.OuterMeasure.trim.{u2} Œ≤ _inst_1 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.OuterMeasure.map._proof_1) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.OuterMeasure.map._proof_2)) (fun (_x : LinearMap.{0, 0, u1, u2} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.OuterMeasure.map._proof_1) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.OuterMeasure.map._proof_2)) => (MeasureTheory.OuterMeasure.{u1} Œ±) -> (MeasureTheory.OuterMeasure.{u2} Œ≤)) (LinearMap.hasCoeToFun.{0, 0, u1, u2} ENNReal ENNReal (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u2} Œ≤) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.OuterMeasure.map._proof_1) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.OuterMeasure.map._proof_2) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (MeasureTheory.OuterMeasure.map.{u1, u2} Œ± Œ≤ f) (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) -> (Eq.{succ u1} (MeasureTheory.OuterMeasure.{u1} Œ≤) (MeasureTheory.Measure.toOuterMeasure.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº)) (MeasureTheory.OuterMeasure.trim.{u1} Œ≤ _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u2} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ≤) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u2} Œ±) (fun (_x : MeasureTheory.OuterMeasure.{u2} Œ±) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.OuterMeasure.{u2} Œ±) => MeasureTheory.OuterMeasure.{u1} Œ≤) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u2, u1} ENNReal ENNReal (MeasureTheory.OuterMeasure.{u2} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ≤) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.OuterMeasure.addCommMonoid.{u2} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ≤) (MeasureTheory.OuterMeasure.instModule.{u2, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (MeasureTheory.OuterMeasure.map.{u2, u1} Œ± Œ≤ f) (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 Œº))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.map_to_outer_measure MeasureTheory.Measure.map_toOuterMeasure‚Çì'. -/
theorem map_toOuterMeasure {f : Œ± ‚Üí Œ≤} (hf : AEMeasurable f Œº) :
    (Œº.map f).toOuterMeasure = (OuterMeasure.map f Œº.toOuterMeasure).trim :=
  by
  rw [‚Üê trimmed, outer_measure.trim_eq_trim_iff]
  intro s hs
  rw [coe_to_outer_measure, map_apply_of_ae_measurable hf hs, outer_measure.map_apply,
    coe_to_outer_measure]
#align measure_theory.measure.map_to_outer_measure MeasureTheory.Measure.map_toOuterMeasure

#print MeasureTheory.Measure.map_id /-
@[simp]
theorem map_id : map id Œº = Œº :=
  ext fun s => map_apply measurable_id
#align measure_theory.measure.map_id MeasureTheory.Measure.map_id
-/

#print MeasureTheory.Measure.map_id' /-
@[simp]
theorem map_id' : map (fun x => x) Œº = Œº :=
  map_id
#align measure_theory.measure.map_id' MeasureTheory.Measure.map_id'
-/

/- warning: measure_theory.measure.map_map -> MeasureTheory.Measure.map_map is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] [_inst_2 : MeasurableSpace.{u3} Œ≥] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (Measurable.{u2, u3} Œ≤ Œ≥ _inst_1 _inst_2 g) -> (Measurable.{u1, u2} Œ± Œ≤ m0 _inst_1 f) -> (Eq.{succ u3} (MeasureTheory.Measure.{u3} Œ≥ _inst_2) (MeasureTheory.Measure.map.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_1 g (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº)) (MeasureTheory.Measure.map.{u1, u3} Œ± Œ≥ _inst_2 m0 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f) Œº))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u3} Œ≤] [_inst_2 : MeasurableSpace.{u2} Œ≥] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (Measurable.{u3, u2} Œ≤ Œ≥ _inst_1 _inst_2 g) -> (Measurable.{u1, u3} Œ± Œ≤ m0 _inst_1 f) -> (Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ≥ _inst_2) (MeasureTheory.Measure.map.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_1 g (MeasureTheory.Measure.map.{u1, u3} Œ± Œ≤ _inst_1 m0 f Œº)) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≥ _inst_2 m0 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f) Œº))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.map_map MeasureTheory.Measure.map_map‚Çì'. -/
theorem map_map {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : Measurable g) (hf : Measurable f) :
    (Œº.map f).map g = Œº.map (g ‚àò f) :=
  ext fun s hs => by simp [hf, hg, hs, hg hs, hg.comp hf, ‚Üê preimage_comp]
#align measure_theory.measure.map_map MeasureTheory.Measure.map_map

/- warning: measure_theory.measure.map_mono -> MeasureTheory.Measure.map_mono is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ≤}, (LE.le.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº ŒΩ) -> (Measurable.{u1, u2} Œ± Œ≤ m0 _inst_1 f) -> (LE.le.{u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (Preorder.toLE.{u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (PartialOrder.toPreorder.{u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instPartialOrder.{u2} Œ≤ _inst_1))) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f ŒΩ))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u2} Œ± m0} {f : Œ± -> Œ≤}, (LE.le.{u2} (MeasureTheory.Measure.{u2} Œ± m0) (Preorder.toLE.{u2} (MeasureTheory.Measure.{u2} Œ± m0) (PartialOrder.toPreorder.{u2} (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u2} Œ± m0))) Œº ŒΩ) -> (Measurable.{u2, u1} Œ± Œ≤ m0 _inst_1 f) -> (LE.le.{u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.instPartialOrder.{u1} Œ≤ _inst_1))) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f ŒΩ))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.map_mono MeasureTheory.Measure.map_mono‚Çì'. -/
@[mono]
theorem map_mono {f : Œ± ‚Üí Œ≤} (h : Œº ‚â§ ŒΩ) (hf : Measurable f) : Œº.map f ‚â§ ŒΩ.map f := fun s hs => by
  simp [hf.ae_measurable, hs, h _ (hf hs)]
#align measure_theory.measure.map_mono MeasureTheory.Measure.map_mono

/- warning: measure_theory.measure.le_map_apply -> MeasureTheory.Measure.le_map_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) -> (forall (s : Set.{u2} Œ≤), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.preimage.{u1, u2} Œ± Œ≤ f s)) (coeFn.{succ u2, succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (fun (_x : MeasureTheory.Measure.{u2} Œ≤ _inst_1) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) s))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) -> (forall (s : Set.{u1} Œ≤), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 Œº) (Set.preimage.{u2, u1} Œ± Œ≤ f s)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ≤ (MeasureTheory.Measure.toOuterMeasure.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº)) s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.le_map_apply MeasureTheory.Measure.le_map_apply‚Çì'. -/
/-- Even if `s` is not measurable, we can bound `map f Œº s` from below.
  See also `measurable_equiv.map_apply`. -/
theorem le_map_apply {f : Œ± ‚Üí Œ≤} (hf : AEMeasurable f Œº) (s : Set Œ≤) : Œº (f ‚Åª¬π' s) ‚â§ Œº.map f s :=
  calc
    Œº (f ‚Åª¬π' s) ‚â§ Œº (f ‚Åª¬π' toMeasurable (Œº.map f) s) :=
      measure_mono <| preimage_mono <| subset_toMeasurable _ _
    _ = Œº.map f (toMeasurable (Œº.map f) s) :=
      (map_apply_of_aemeasurable hf <| measurableSet_toMeasurable _ _).symm
    _ = Œº.map f s := measure_toMeasurable _
    
#align measure_theory.measure.le_map_apply MeasureTheory.Measure.le_map_apply

/- warning: measure_theory.measure.preimage_null_of_map_null -> MeasureTheory.Measure.preimage_null_of_map_null is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) -> (forall {s : Set.{u2} Œ≤}, (Eq.{1} ENNReal (coeFn.{succ u2, succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (fun (_x : MeasureTheory.Measure.{u2} Œ≤ _inst_1) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.preimage.{u1, u2} Œ± Œ≤ f s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) -> (forall {s : Set.{u1} Œ≤}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ≤ (MeasureTheory.Measure.toOuterMeasure.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº)) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 Œº) (Set.preimage.{u2, u1} Œ± Œ≤ f s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.preimage_null_of_map_null MeasureTheory.Measure.preimage_null_of_map_null‚Çì'. -/
/-- Even if `s` is not measurable, `map f Œº s = 0` implies that `Œº (f ‚Åª¬π' s) = 0`. -/
theorem preimage_null_of_map_null {f : Œ± ‚Üí Œ≤} (hf : AEMeasurable f Œº) {s : Set Œ≤}
    (hs : Œº.map f s = 0) : Œº (f ‚Åª¬π' s) = 0 :=
  nonpos_iff_eq_zero.mp <| (le_map_apply hf s).trans_eq hs
#align measure_theory.measure.preimage_null_of_map_null MeasureTheory.Measure.preimage_null_of_map_null

/- warning: measure_theory.measure.tendsto_ae_map -> MeasureTheory.Measure.tendsto_ae_map is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) -> (Filter.Tendsto.{u1, u2} Œ± Œ≤ f (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) -> (Filter.Tendsto.{u2, u1} Œ± Œ≤ f (MeasureTheory.Measure.ae.{u2} Œ± m0 Œº) (MeasureTheory.Measure.ae.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.tendsto_ae_map MeasureTheory.Measure.tendsto_ae_map‚Çì'. -/
theorem tendsto_ae_map {f : Œ± ‚Üí Œ≤} (hf : AEMeasurable f Œº) : Tendsto f Œº.ae (Œº.map f).ae :=
  fun s hs => preimage_null_of_map_null hf hs
#align measure_theory.measure.tendsto_ae_map MeasureTheory.Measure.tendsto_ae_map

omit m0

/- warning: measure_theory.measure.comap‚Çó -> MeasureTheory.Measure.comap‚Çó is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u2} Œ≤] [_inst_3 : MeasurableSpace.{u1} Œ±], (Œ± -> Œ≤) -> (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.{u1} Œ± _inst_3) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± _inst_3) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.comap‚Çó._proof_1 _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.comap‚Çó._proof_2 _inst_3))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u2} Œ≤] [_inst_3 : MeasurableSpace.{u1} Œ±], (Œ± -> Œ≤) -> (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.{u1} Œ± _inst_3) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± _inst_3) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_1) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_3))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.comap‚Çó MeasureTheory.Measure.comap‚Çó‚Çì'. -/
/-- Pullback of a `measure` as a linear map. If `f` sends each measurable set to a measurable
set, then for each measurable set `s` we have `comap‚Çó f Œº s = Œº (f '' s)`.

If the linearity is not needed, please use `comap` instead, which works for a larger class of
functions. -/
def comap‚Çó [MeasurableSpace Œ±] (f : Œ± ‚Üí Œ≤) : Measure Œ≤ ‚Üí‚Çó[‚Ñù‚â•0‚àû] Measure Œ± :=
  if hf : Injective f ‚àß ‚àÄ s, MeasurableSet s ‚Üí MeasurableSet (f '' s) then
    liftLinear (OuterMeasure.comap f) fun Œº s hs t =>
      by
      simp only [coe_to_outer_measure, outer_measure.comap_apply, image_inter hf.1, image_diff hf.1]
      apply le_to_outer_measure_caratheodory
      exact hf.2 s hs
  else 0
#align measure_theory.measure.comap‚Çó MeasureTheory.Measure.comap‚Çó

/- warning: measure_theory.measure.comap‚Çó_apply -> MeasureTheory.Measure.comap‚Çó_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} {Œ≤ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] {mŒ≤ : MeasurableSpace.{u2} Œ≤} (f : Œ± -> Œ≤), (Function.Injective.{succ u1, succ u2} Œ± Œ≤ f) -> (forall (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± _inst_3 s) -> (MeasurableSet.{u2} Œ≤ mŒ≤ (Set.image.{u1, u2} Œ± Œ≤ f s))) -> (forall (Œº : MeasureTheory.Measure.{u2} Œ≤ mŒ≤), (MeasurableSet.{u1} Œ± _inst_3 s) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.{u1} Œ± _inst_3) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± _inst_3) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.comap‚Çó._proof_1 mŒ≤) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.comap‚Çó._proof_2 _inst_3)) (fun (_x : LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.{u1} Œ± _inst_3) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± _inst_3) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.comap‚Çó._proof_1 mŒ≤) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.comap‚Çó._proof_2 _inst_3)) => (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) -> (MeasureTheory.Measure.{u1} Œ± _inst_3)) (LinearMap.hasCoeToFun.{0, 0, u2, u1} ENNReal ENNReal (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.{u1} Œ± _inst_3) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± _inst_3) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.comap‚Çó._proof_1 mŒ≤) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.comap‚Çó._proof_2 _inst_3) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (MeasureTheory.Measure.comap‚Çó.{u1, u2} Œ± Œ≤ mŒ≤ _inst_3 f) Œº) s) (coeFn.{succ u2, succ u2} (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) (fun (_x : MeasureTheory.Measure.{u2} Œ≤ mŒ≤) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u2} Œ≤ mŒ≤) Œº (Set.image.{u1, u2} Œ± Œ≤ f s))))
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} {Œ≤ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] {mŒ≤ : MeasurableSpace.{u2} Œ≤} (f : Œ± -> Œ≤), (Function.Injective.{succ u1, succ u2} Œ± Œ≤ f) -> (forall (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± _inst_3 s) -> (MeasurableSet.{u2} Œ≤ mŒ≤ (Set.image.{u1, u2} Œ± Œ≤ f s))) -> (forall (Œº : MeasureTheory.Measure.{u2} Œ≤ mŒ≤), (MeasurableSet.{u1} Œ± _inst_3 s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.{u1} Œ± _inst_3) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± _inst_3) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) mŒ≤) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_3)) (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) (fun (a : MeasureTheory.Measure.{u2} Œ≤ mŒ≤) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.Measure.{u2} Œ≤ mŒ≤) => MeasureTheory.Measure.{u1} Œ± _inst_3) a) (LinearMap.instFunLikeLinearMap.{0, 0, u2, u1} ENNReal ENNReal (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.{u1} Œ± _inst_3) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± _inst_3) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) mŒ≤) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_3) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (MeasureTheory.Measure.comap‚Çó.{u1, u2} Œ± Œ≤ mŒ≤ _inst_3 f) Œº)) s) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ≤ (MeasureTheory.Measure.toOuterMeasure.{u2} Œ≤ mŒ≤ Œº) (Set.image.{u1, u2} Œ± Œ≤ f s))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.comap‚Çó_apply MeasureTheory.Measure.comap‚Çó_apply‚Çì'. -/
theorem comap‚Çó_apply {Œ≤} [MeasurableSpace Œ±] {mŒ≤ : MeasurableSpace Œ≤} (f : Œ± ‚Üí Œ≤)
    (hfi : Injective f) (hf : ‚àÄ s, MeasurableSet s ‚Üí MeasurableSet (f '' s)) (Œº : Measure Œ≤)
    (hs : MeasurableSet s) : comap‚Çó f Œº s = Œº (f '' s) :=
  by
  rw [comap‚Çó, dif_pos, lift_linear_apply _ hs, outer_measure.comap_apply, coe_to_outer_measure]
  exact ‚ü®hfi, hf‚ü©
#align measure_theory.measure.comap‚Çó_apply MeasureTheory.Measure.comap‚Çó_apply

#print MeasureTheory.Measure.comap /-
/-- Pullback of a `measure`. If `f` sends each measurable set to a null-measurable set,
then for each measurable set `s` we have `comap f Œº s = Œº (f '' s)`. -/
def comap [MeasurableSpace Œ±] (f : Œ± ‚Üí Œ≤) (Œº : Measure Œ≤) : Measure Œ± :=
  if hf : Injective f ‚àß ‚àÄ s, MeasurableSet s ‚Üí NullMeasurableSet (f '' s) Œº then
    (OuterMeasure.comap f Œº.toOuterMeasure).toMeasure fun s hs t =>
      by
      simp only [coe_to_outer_measure, outer_measure.comap_apply, image_inter hf.1, image_diff hf.1]
      exact (measure_inter_add_diff‚ÇÄ _ (hf.2 s hs)).symm
  else 0
#align measure_theory.measure.comap MeasureTheory.Measure.comap
-/

/- warning: measure_theory.measure.comap_apply‚ÇÄ -> MeasureTheory.Measure.comap_apply‚ÇÄ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u2} Œ≤] {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±] (f : Œ± -> Œ≤) (Œº : MeasureTheory.Measure.{u2} Œ≤ _inst_1), (Function.Injective.{succ u1, succ u2} Œ± Œ≤ f) -> (forall (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± _inst_3 s) -> (MeasureTheory.NullMeasurableSet.{u2} Œ≤ _inst_1 (Set.image.{u1, u2} Œ± Œ≤ f s) Œº)) -> (MeasureTheory.NullMeasurableSet.{u1} Œ± _inst_3 s (MeasureTheory.Measure.comap.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f Œº)) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.comap.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f Œº) s) (coeFn.{succ u2, succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (fun (_x : MeasureTheory.Measure.{u2} Œ≤ _inst_1) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u2} Œ≤ _inst_1) Œº (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ≤] {s : Set.{u2} Œ±} [_inst_3 : MeasurableSpace.{u2} Œ±] (f : Œ± -> Œ≤) (Œº : MeasureTheory.Measure.{u1} Œ≤ _inst_1), (Function.Injective.{succ u2, succ u1} Œ± Œ≤ f) -> (forall (s : Set.{u2} Œ±), (MeasurableSet.{u2} Œ± _inst_3 s) -> (MeasureTheory.NullMeasurableSet.{u1} Œ≤ _inst_1 (Set.image.{u2, u1} Œ± Œ≤ f s) Œº)) -> (MeasureTheory.NullMeasurableSet.{u2} Œ± _inst_3 s (MeasureTheory.Measure.comap.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f Œº)) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± _inst_3 (MeasureTheory.Measure.comap.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f Œº)) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ≤ (MeasureTheory.Measure.toOuterMeasure.{u1} Œ≤ _inst_1 Œº) (Set.image.{u2, u1} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.comap_apply‚ÇÄ MeasureTheory.Measure.comap_apply‚ÇÄ‚Çì'. -/
theorem comap_apply‚ÇÄ [MeasurableSpace Œ±] (f : Œ± ‚Üí Œ≤) (Œº : Measure Œ≤) (hfi : Injective f)
    (hf : ‚àÄ s, MeasurableSet s ‚Üí NullMeasurableSet (f '' s) Œº)
    (hs : NullMeasurableSet s (comap f Œº)) : comap f Œº s = Œº (f '' s) :=
  by
  rw [comap, dif_pos (And.intro hfi hf)] at hs‚ä¢
  rw [to_measure_apply‚ÇÄ _ _ hs, outer_measure.comap_apply, coe_to_outer_measure]
#align measure_theory.measure.comap_apply‚ÇÄ MeasureTheory.Measure.comap_apply‚ÇÄ

/- warning: measure_theory.measure.le_comap_apply -> MeasureTheory.Measure.le_comap_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] {mŒ≤ : MeasurableSpace.{u2} Œ≤} (f : Œ± -> Œ≤) (Œº : MeasureTheory.Measure.{u2} Œ≤ mŒ≤), (Function.Injective.{succ u1, succ u2} Œ± Œ≤ f) -> (forall (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± _inst_3 s) -> (MeasureTheory.NullMeasurableSet.{u2} Œ≤ mŒ≤ (Set.image.{u1, u2} Œ± Œ≤ f s) Œº)) -> (forall (s : Set.{u1} Œ±), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u2, succ u2} (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) (fun (_x : MeasureTheory.Measure.{u2} Œ≤ mŒ≤) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u2} Œ≤ mŒ≤) Œº (Set.image.{u1, u2} Œ± Œ≤ f s)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.comap.{u1, u2} Œ± Œ≤ mŒ≤ _inst_3 f Œº) s))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] {mŒ≤ : MeasurableSpace.{u2} Œ≤} (f : Œ± -> Œ≤) (Œº : MeasureTheory.Measure.{u2} Œ≤ mŒ≤), (Function.Injective.{succ u1, succ u2} Œ± Œ≤ f) -> (forall (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± _inst_3 s) -> (MeasureTheory.NullMeasurableSet.{u2} Œ≤ mŒ≤ (Set.image.{u1, u2} Œ± Œ≤ f s) Œº)) -> (forall (s : Set.{u1} Œ±), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ≤ (MeasureTheory.Measure.toOuterMeasure.{u2} Œ≤ mŒ≤ Œº) (Set.image.{u1, u2} Œ± Œ≤ f s)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.comap.{u1, u2} Œ± Œ≤ mŒ≤ _inst_3 f Œº)) s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.le_comap_apply MeasureTheory.Measure.le_comap_apply‚Çì'. -/
theorem le_comap_apply {Œ≤} [MeasurableSpace Œ±] {mŒ≤ : MeasurableSpace Œ≤} (f : Œ± ‚Üí Œ≤) (Œº : Measure Œ≤)
    (hfi : Injective f) (hf : ‚àÄ s, MeasurableSet s ‚Üí NullMeasurableSet (f '' s) Œº) (s : Set Œ±) :
    Œº (f '' s) ‚â§ comap f Œº s :=
  by
  rw [comap, dif_pos (And.intro hfi hf)]
  exact le_to_measure_apply _ _ _
#align measure_theory.measure.le_comap_apply MeasureTheory.Measure.le_comap_apply

#print MeasureTheory.Measure.comap_apply /-
theorem comap_apply {Œ≤} [MeasurableSpace Œ±] {mŒ≤ : MeasurableSpace Œ≤} (f : Œ± ‚Üí Œ≤) (hfi : Injective f)
    (hf : ‚àÄ s, MeasurableSet s ‚Üí MeasurableSet (f '' s)) (Œº : Measure Œ≤) (hs : MeasurableSet s) :
    comap f Œº s = Œº (f '' s) :=
  comap_apply‚ÇÄ f Œº hfi (fun s hs => (hf s hs).NullMeasurableSet) hs.NullMeasurableSet
#align measure_theory.measure.comap_apply MeasureTheory.Measure.comap_apply
-/

/- warning: measure_theory.measure.comap‚Çó_eq_comap -> MeasureTheory.Measure.comap‚Çó_eq_comap is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} {Œ≤ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] {mŒ≤ : MeasurableSpace.{u2} Œ≤} (f : Œ± -> Œ≤), (Function.Injective.{succ u1, succ u2} Œ± Œ≤ f) -> (forall (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± _inst_3 s) -> (MeasurableSet.{u2} Œ≤ mŒ≤ (Set.image.{u1, u2} Œ± Œ≤ f s))) -> (forall (Œº : MeasureTheory.Measure.{u2} Œ≤ mŒ≤), (MeasurableSet.{u1} Œ± _inst_3 s) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.{u1} Œ± _inst_3) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± _inst_3) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.comap‚Çó._proof_1 mŒ≤) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.comap‚Çó._proof_2 _inst_3)) (fun (_x : LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.{u1} Œ± _inst_3) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± _inst_3) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.comap‚Çó._proof_1 mŒ≤) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.comap‚Çó._proof_2 _inst_3)) => (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) -> (MeasureTheory.Measure.{u1} Œ± _inst_3)) (LinearMap.hasCoeToFun.{0, 0, u2, u1} ENNReal ENNReal (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.{u1} Œ± _inst_3) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± _inst_3) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.comap‚Çó._proof_1 mŒ≤) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.comap‚Çó._proof_2 _inst_3) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (MeasureTheory.Measure.comap‚Çó.{u1, u2} Œ± Œ≤ mŒ≤ _inst_3 f) Œº) s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.comap.{u1, u2} Œ± Œ≤ mŒ≤ _inst_3 f Œº) s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} {Œ≤ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] {mŒ≤ : MeasurableSpace.{u2} Œ≤} (f : Œ± -> Œ≤), (Function.Injective.{succ u1, succ u2} Œ± Œ≤ f) -> (forall (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± _inst_3 s) -> (MeasurableSet.{u2} Œ≤ mŒ≤ (Set.image.{u1, u2} Œ± Œ≤ f s))) -> (forall (Œº : MeasureTheory.Measure.{u2} Œ≤ mŒ≤), (MeasurableSet.{u1} Œ± _inst_3 s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (LinearMap.{0, 0, u2, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.{u1} Œ± _inst_3) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± _inst_3) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) mŒ≤) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_3)) (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) (fun (a : MeasureTheory.Measure.{u2} Œ≤ mŒ≤) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.Measure.{u2} Œ≤ mŒ≤) => MeasureTheory.Measure.{u1} Œ± _inst_3) a) (LinearMap.instFunLikeLinearMap.{0, 0, u2, u1} ENNReal ENNReal (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.{u1} Œ± _inst_3) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.Measure.instAddCommMonoid.{u2} Œ≤ mŒ≤) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± _inst_3) (MeasureTheory.Measure.instModule.{u2, 0} Œ≤ ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) mŒ≤) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_3) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (MeasureTheory.Measure.comap‚Çó.{u1, u2} Œ± Œ≤ mŒ≤ _inst_3 f) Œº)) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.comap.{u1, u2} Œ± Œ≤ mŒ≤ _inst_3 f Œº)) s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.comap‚Çó_eq_comap MeasureTheory.Measure.comap‚Çó_eq_comap‚Çì'. -/
theorem comap‚Çó_eq_comap {Œ≤} [MeasurableSpace Œ±] {mŒ≤ : MeasurableSpace Œ≤} (f : Œ± ‚Üí Œ≤)
    (hfi : Injective f) (hf : ‚àÄ s, MeasurableSet s ‚Üí MeasurableSet (f '' s)) (Œº : Measure Œ≤)
    (hs : MeasurableSet s) : comap‚Çó f Œº s = comap f Œº s :=
  (comap‚Çó_apply f hfi hf Œº hs).trans (comap_apply f hfi hf Œº hs).symm
#align measure_theory.measure.comap‚Çó_eq_comap MeasureTheory.Measure.comap‚Çó_eq_comap

/- warning: measure_theory.measure.measure_image_eq_zero_of_comap_eq_zero -> MeasureTheory.Measure.measure_image_eq_zero_of_comap_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] {mŒ≤ : MeasurableSpace.{u2} Œ≤} (f : Œ± -> Œ≤) (Œº : MeasureTheory.Measure.{u2} Œ≤ mŒ≤), (Function.Injective.{succ u1, succ u2} Œ± Œ≤ f) -> (forall (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± _inst_3 s) -> (MeasureTheory.NullMeasurableSet.{u2} Œ≤ mŒ≤ (Set.image.{u1, u2} Œ± Œ≤ f s) Œº)) -> (forall {s : Set.{u1} Œ±}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.comap.{u1, u2} Œ± Œ≤ mŒ≤ _inst_3 f Œº) s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u2, succ u2} (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) (fun (_x : MeasureTheory.Measure.{u2} Œ≤ mŒ≤) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u2} Œ≤ mŒ≤) Œº (Set.image.{u1, u2} Œ± Œ≤ f s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] {mŒ≤ : MeasurableSpace.{u2} Œ≤} (f : Œ± -> Œ≤) (Œº : MeasureTheory.Measure.{u2} Œ≤ mŒ≤), (Function.Injective.{succ u1, succ u2} Œ± Œ≤ f) -> (forall (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± _inst_3 s) -> (MeasureTheory.NullMeasurableSet.{u2} Œ≤ mŒ≤ (Set.image.{u1, u2} Œ± Œ≤ f s) Œº)) -> (forall {s : Set.{u1} Œ±}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.comap.{u1, u2} Œ± Œ≤ mŒ≤ _inst_3 f Œº)) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u2} Œ≤ (MeasureTheory.Measure.toOuterMeasure.{u2} Œ≤ mŒ≤ Œº) (Set.image.{u1, u2} Œ± Œ≤ f s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.measure_image_eq_zero_of_comap_eq_zero MeasureTheory.Measure.measure_image_eq_zero_of_comap_eq_zero‚Çì'. -/
theorem measure_image_eq_zero_of_comap_eq_zero {Œ≤} [MeasurableSpace Œ±] {mŒ≤ : MeasurableSpace Œ≤}
    (f : Œ± ‚Üí Œ≤) (Œº : Measure Œ≤) (hfi : Injective f)
    (hf : ‚àÄ s, MeasurableSet s ‚Üí NullMeasurableSet (f '' s) Œº) {s : Set Œ±} (hs : comap f Œº s = 0) :
    Œº (f '' s) = 0 :=
  le_antisymm ((le_comap_apply f Œº hfi hf s).trans hs.le) (zero_le _)
#align measure_theory.measure.measure_image_eq_zero_of_comap_eq_zero MeasureTheory.Measure.measure_image_eq_zero_of_comap_eq_zero

#print MeasureTheory.Measure.ae_eq_image_of_ae_eq_comap /-
theorem ae_eq_image_of_ae_eq_comap {Œ≤} [MeasurableSpace Œ±] {mŒ≤ : MeasurableSpace Œ≤} (f : Œ± ‚Üí Œ≤)
    (Œº : Measure Œ≤) (hfi : Injective f) (hf : ‚àÄ s, MeasurableSet s ‚Üí NullMeasurableSet (f '' s) Œº)
    {s t : Set Œ±} (hst : s =·µê[comap f Œº] t) : f '' s =·µê[Œº] f '' t :=
  by
  rw [eventually_eq, ae_iff] at hst‚ä¢
  have h_eq_Œ± : { a : Œ± | ¬¨s a = t a } = s \ t ‚à™ t \ s :=
    by
    ext1 x
    simp only [eq_iff_iff, mem_set_of_eq, mem_union, mem_diff]
    tauto
  have h_eq_Œ≤ : { a : Œ≤ | ¬¨(f '' s) a = (f '' t) a } = f '' s \ f '' t ‚à™ f '' t \ f '' s :=
    by
    ext1 x
    simp only [eq_iff_iff, mem_set_of_eq, mem_union, mem_diff]
    tauto
  rw [‚Üê Set.image_diff hfi, ‚Üê Set.image_diff hfi, ‚Üê Set.image_union] at h_eq_Œ≤
  rw [h_eq_Œ≤]
  rw [h_eq_Œ±] at hst
  exact measure_image_eq_zero_of_comap_eq_zero f Œº hfi hf hst
#align measure_theory.measure.ae_eq_image_of_ae_eq_comap MeasureTheory.Measure.ae_eq_image_of_ae_eq_comap
-/

#print MeasureTheory.Measure.NullMeasurableSet.image /-
theorem NullMeasurableSet.image {Œ≤} [MeasurableSpace Œ±] {mŒ≤ : MeasurableSpace Œ≤} (f : Œ± ‚Üí Œ≤)
    (Œº : Measure Œ≤) (hfi : Injective f) (hf : ‚àÄ s, MeasurableSet s ‚Üí NullMeasurableSet (f '' s) Œº)
    {s : Set Œ±} (hs : NullMeasurableSet s (Œº.comap f)) : NullMeasurableSet (f '' s) Œº :=
  by
  refine' ‚ü®to_measurable Œº (f '' to_measurable (Œº.comap f) s), measurable_set_to_measurable _ _, _‚ü©
  refine' eventually_eq.trans _ (null_measurable_set.to_measurable_ae_eq _).symm
  swap
  ¬∑ exact hf _ (measurable_set_to_measurable _ _)
  have h : to_measurable (comap f Œº) s =·µê[comap f Œº] s :=
    @null_measurable_set.to_measurable_ae_eq _ _ (Œº.comap f : Measure Œ±) s hs
  exact ae_eq_image_of_ae_eq_comap f Œº hfi hf h.symm
#align measure_theory.measure.null_measurable_set.image MeasureTheory.Measure.NullMeasurableSet.image
-/

/- warning: measure_theory.measure.comap_preimage -> MeasureTheory.Measure.comap_preimage is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] {mŒ≤ : MeasurableSpace.{u2} Œ≤} (f : Œ± -> Œ≤) (Œº : MeasureTheory.Measure.{u2} Œ≤ mŒ≤) {s : Set.{u2} Œ≤}, (Function.Injective.{succ u1, succ u2} Œ± Œ≤ f) -> (Measurable.{u1, u2} Œ± Œ≤ _inst_3 mŒ≤ f) -> (forall (t : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± _inst_3 t) -> (MeasureTheory.NullMeasurableSet.{u2} Œ≤ mŒ≤ (Set.image.{u1, u2} Œ± Œ≤ f t) Œº)) -> (MeasurableSet.{u2} Œ≤ mŒ≤ s) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.comap.{u1, u2} Œ± Œ≤ mŒ≤ _inst_3 f Œº) (Set.preimage.{u1, u2} Œ± Œ≤ f s)) (coeFn.{succ u2, succ u2} (MeasureTheory.Measure.{u2} Œ≤ mŒ≤) (fun (_x : MeasureTheory.Measure.{u2} Œ≤ mŒ≤) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u2} Œ≤ mŒ≤) Œº (Inter.inter.{u2} (Set.{u2} Œ≤) (Set.hasInter.{u2} Œ≤) s (Set.range.{u2, succ u1} Œ≤ Œ± f))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] {mŒ≤ : MeasurableSpace.{u2} Œ≤} (f : Œ± -> Œ≤) (Œº : MeasureTheory.Measure.{u2} Œ≤ mŒ≤) {s : Set.{u2} Œ≤}, (Function.Injective.{succ u1, succ u2} Œ± Œ≤ f) -> (Measurable.{u1, u2} Œ± Œ≤ _inst_3 mŒ≤ f) -> (forall (t : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± _inst_3 t) -> (MeasureTheory.NullMeasurableSet.{u2} Œ≤ mŒ≤ (Set.image.{u1, u2} Œ± Œ≤ f t) Œº)) -> (MeasurableSet.{u2} Œ≤ mŒ≤ s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.comap.{u1, u2} Œ± Œ≤ mŒ≤ _inst_3 f Œº)) (Set.preimage.{u1, u2} Œ± Œ≤ f s)) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ≤ (MeasureTheory.Measure.toOuterMeasure.{u2} Œ≤ mŒ≤ Œº) (Inter.inter.{u2} (Set.{u2} Œ≤) (Set.instInterSet.{u2} Œ≤) s (Set.range.{u2, succ u1} Œ≤ Œ± f))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.comap_preimage MeasureTheory.Measure.comap_preimage‚Çì'. -/
theorem comap_preimage {Œ≤} [MeasurableSpace Œ±] {mŒ≤ : MeasurableSpace Œ≤} (f : Œ± ‚Üí Œ≤) (Œº : Measure Œ≤)
    {s : Set Œ≤} (hf : Injective f) (hf' : Measurable f)
    (h : ‚àÄ t, MeasurableSet t ‚Üí NullMeasurableSet (f '' t) Œº) (hs : MeasurableSet s) :
    Œº.comap f (f ‚Åª¬π' s) = Œº (s ‚à© range f) := by
  rw [comap_apply‚ÇÄ _ _ hf h (hf' hs).NullMeasurableSet, image_preimage_eq_inter_range]
#align measure_theory.measure.comap_preimage MeasureTheory.Measure.comap_preimage

section Subtype

/-! ### Subtype of a measure space -/


section ComapAnyMeasure

#print MeasureTheory.Measure.MeasurableSet.nullMeasurableSet_subtype_coe /-
theorem MeasurableSet.nullMeasurableSet_subtype_coe {t : Set s} (hs : NullMeasurableSet s Œº)
    (ht : MeasurableSet t) : NullMeasurableSet ((coe : s ‚Üí Œ±) '' t) Œº :=
  by
  rw [Subtype.instMeasurableSpace, comap_eq_generate_from] at ht
  refine'
    generate_from_induction (fun t : Set s => null_measurable_set (coe '' t) Œº)
      { t : Set s | ‚àÉ s' : Set Œ±, MeasurableSet s' ‚àß coe ‚Åª¬π' s' = t } _ _ _ _ ht
  ¬∑ rintro t' ‚ü®s', hs', rfl‚ü©
    rw [Subtype.image_preimage_coe]
    exact hs'.null_measurable_set.inter hs
  ¬∑ simp only [image_empty, null_measurable_set_empty]
  ¬∑ intro t'
    simp only [‚Üê range_diff_image Subtype.coe_injective, Subtype.range_coe_subtype, set_of_mem_eq]
    exact hs.diff
  ¬∑ intro f
    rw [image_Union]
    exact null_measurable_set.Union
#align measure_theory.measure.measurable_set.null_measurable_set_subtype_coe MeasureTheory.Measure.MeasurableSet.nullMeasurableSet_subtype_coe
-/

#print MeasureTheory.Measure.NullMeasurableSet.subtype_coe /-
theorem NullMeasurableSet.subtype_coe {t : Set s} (hs : NullMeasurableSet s Œº)
    (ht : NullMeasurableSet t (Œº.comap Subtype.val)) : NullMeasurableSet ((coe : s ‚Üí Œ±) '' t) Œº :=
  NullMeasurableSet.image coe Œº Subtype.coe_injective
    (fun t => MeasurableSet.nullMeasurableSet_subtype_coe hs) ht
#align measure_theory.measure.null_measurable_set.subtype_coe MeasureTheory.Measure.NullMeasurableSet.subtype_coe
-/

/- warning: measure_theory.measure.measure_subtype_coe_le_comap -> MeasureTheory.Measure.measure_subtype_coe_le_comap is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, (MeasureTheory.NullMeasurableSet.{u1} Œ± m0 s Œº) -> (forall (t : Set.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s)), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.image.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeSubtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))))) t)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) (Subtype.instMeasurableSpace.{u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) m0)) (fun (_x : MeasureTheory.Measure.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) (Subtype.instMeasurableSpace.{u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) m0)) => (Set.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s))) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) (Subtype.instMeasurableSpace.{u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) m0)) (MeasureTheory.Measure.comap.{u1, u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) Œ± m0 (Subtype.instMeasurableSpace.{u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) m0) (Subtype.val.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) Œº) t))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, (MeasureTheory.NullMeasurableSet.{u1} Œ± m0 s Œº) -> (forall (t : Set.{u1} (Set.Elem.{u1} Œ± s)), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Set.image.{u1, u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) Œ± (Subtype.val.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) t)) (MeasureTheory.OuterMeasure.measureOf.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (MeasureTheory.Measure.toOuterMeasure.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (Subtype.instMeasurableSpace.{u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) m0) (MeasureTheory.Measure.comap.{u1, u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) Œ± m0 (Subtype.instMeasurableSpace.{u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) m0) (Subtype.val.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) Œº)) t))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.measure_subtype_coe_le_comap MeasureTheory.Measure.measure_subtype_coe_le_comap‚Çì'. -/
theorem measure_subtype_coe_le_comap (hs : NullMeasurableSet s Œº) (t : Set s) :
    Œº ((coe : s ‚Üí Œ±) '' t) ‚â§ Œº.comap Subtype.val t :=
  le_comap_apply _ _ Subtype.coe_injective (fun t => MeasurableSet.nullMeasurableSet_subtype_coe hs)
    _
#align measure_theory.measure.measure_subtype_coe_le_comap MeasureTheory.Measure.measure_subtype_coe_le_comap

/- warning: measure_theory.measure.measure_subtype_coe_eq_zero_of_comap_eq_zero -> MeasureTheory.Measure.measure_subtype_coe_eq_zero_of_comap_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, (MeasureTheory.NullMeasurableSet.{u1} Œ± m0 s Œº) -> (forall {t : Set.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s)}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) (Subtype.instMeasurableSpace.{u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) m0)) (fun (_x : MeasureTheory.Measure.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) (Subtype.instMeasurableSpace.{u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) m0)) => (Set.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s))) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) (Subtype.instMeasurableSpace.{u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) m0)) (MeasureTheory.Measure.comap.{u1, u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) Œ± m0 (Subtype.instMeasurableSpace.{u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) m0) (Subtype.val.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) Œº) t) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.image.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeSubtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))))) t)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, (MeasureTheory.NullMeasurableSet.{u1} Œ± m0 s Œº) -> (forall {t : Set.{u1} (Set.Elem.{u1} Œ± s)}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (MeasureTheory.Measure.toOuterMeasure.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (Subtype.instMeasurableSpace.{u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) m0) (MeasureTheory.Measure.comap.{u1, u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) Œ± m0 (Subtype.instMeasurableSpace.{u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) m0) (Subtype.val.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) Œº)) t) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Set.image.{u1, u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) Œ± (Subtype.val.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) t)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.measure_subtype_coe_eq_zero_of_comap_eq_zero MeasureTheory.Measure.measure_subtype_coe_eq_zero_of_comap_eq_zero‚Çì'. -/
theorem measure_subtype_coe_eq_zero_of_comap_eq_zero (hs : NullMeasurableSet s Œº) {t : Set s}
    (ht : Œº.comap Subtype.val t = 0) : Œº ((coe : s ‚Üí Œ±) '' t) = 0 :=
  eq_bot_iff.mpr <| (measure_subtype_coe_le_comap hs t).trans ht.le
#align measure_theory.measure.measure_subtype_coe_eq_zero_of_comap_eq_zero MeasureTheory.Measure.measure_subtype_coe_eq_zero_of_comap_eq_zero

end ComapAnyMeasure

section MeasureSpace

variable [MeasureSpace Œ±] {p : Œ± ‚Üí Prop}

#print MeasureTheory.Measure.Subtype.measureSpace /-
instance Subtype.measureSpace : MeasureSpace (Subtype p) :=
  { Subtype.instMeasurableSpace with volume := Measure.comap Subtype.val volume }
#align measure_theory.measure.subtype.measure_space MeasureTheory.Measure.Subtype.measureSpace
-/

#print MeasureTheory.Measure.Subtype.volume_def /-
theorem Subtype.volume_def : (volume : Measure s) = volume.comap Subtype.val :=
  rfl
#align measure_theory.measure.subtype.volume_def MeasureTheory.Measure.Subtype.volume_def
-/

#print MeasureTheory.Measure.Subtype.volume_univ /-
theorem Subtype.volume_univ (hs : NullMeasurableSet s) : volume (univ : Set s) = volume s :=
  by
  rw [subtype.volume_def, comap_apply‚ÇÄ _ _ _ _ measurable_set.univ.null_measurable_set]
  ¬∑ congr
    simp only [Subtype.val_eq_coe, image_univ, Subtype.range_coe_subtype, set_of_mem_eq]
  ¬∑ exact Subtype.coe_injective
  ¬∑ exact fun t => measurable_set.null_measurable_set_subtype_coe hs
#align measure_theory.measure.subtype.volume_univ MeasureTheory.Measure.Subtype.volume_univ
-/

/- warning: measure_theory.measure.volume_subtype_coe_le_volume -> MeasureTheory.Measure.volume_subtype_coe_le_volume is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.MeasureSpace.{u1} Œ±], (MeasureTheory.NullMeasurableSet.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_3) s (MeasureTheory.MeasureSpace.volume.{u1} Œ± _inst_3)) -> (forall (t : Set.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s)), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_3)) (fun (_x : MeasureTheory.Measure.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_3)) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_3)) (MeasureTheory.MeasureSpace.volume.{u1} Œ± _inst_3) (Set.image.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeSubtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))))) t)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.Measure.Subtype.measureSpace.{u1} Œ± _inst_3 (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))) (fun (_x : MeasureTheory.Measure.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.Measure.Subtype.measureSpace.{u1} Œ± _inst_3 (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))) => (Set.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s)) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.Measure.Subtype.measureSpace.{u1} Œ± _inst_3 (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))) (MeasureTheory.MeasureSpace.volume.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.Measure.Subtype.measureSpace.{u1} Œ± _inst_3 (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s))) t))
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.MeasureSpace.{u1} Œ±], (MeasureTheory.NullMeasurableSet.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_3) s (MeasureTheory.MeasureSpace.volume.{u1} Œ± _inst_3)) -> (forall (t : Set.{u1} (Set.Elem.{u1} Œ± s)), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_3) (MeasureTheory.MeasureSpace.volume.{u1} Œ± _inst_3)) (Set.image.{u1, u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) Œ± (Subtype.val.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) t)) (MeasureTheory.OuterMeasure.measureOf.{u1} (Set.Elem.{u1} Œ± s) (MeasureTheory.Measure.toOuterMeasure.{u1} (Set.Elem.{u1} Œ± s) (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} (Set.Elem.{u1} Œ± s) (MeasureTheory.Measure.Subtype.measureSpace.{u1} Œ± _inst_3 (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s))) (MeasureTheory.MeasureSpace.volume.{u1} (Set.Elem.{u1} Œ± s) (MeasureTheory.Measure.Subtype.measureSpace.{u1} Œ± _inst_3 (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)))) t))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.volume_subtype_coe_le_volume MeasureTheory.Measure.volume_subtype_coe_le_volume‚Çì'. -/
theorem volume_subtype_coe_le_volume (hs : NullMeasurableSet s) (t : Set s) :
    volume ((coe : s ‚Üí Œ±) '' t) ‚â§ volume t :=
  measure_subtype_coe_le_comap hs t
#align measure_theory.measure.volume_subtype_coe_le_volume MeasureTheory.Measure.volume_subtype_coe_le_volume

/- warning: measure_theory.measure.volume_subtype_coe_eq_zero_of_volume_eq_zero -> MeasureTheory.Measure.volume_subtype_coe_eq_zero_of_volume_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.MeasureSpace.{u1} Œ±], (MeasureTheory.NullMeasurableSet.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_3) s (MeasureTheory.MeasureSpace.volume.{u1} Œ± _inst_3)) -> (forall {t : Set.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s)}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.Measure.Subtype.measureSpace.{u1} Œ± _inst_3 (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))) (fun (_x : MeasureTheory.Measure.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.Measure.Subtype.measureSpace.{u1} Œ± _inst_3 (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))) => (Set.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s)) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.Measure.Subtype.measureSpace.{u1} Œ± _inst_3 (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))) (MeasureTheory.MeasureSpace.volume.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.Measure.Subtype.measureSpace.{u1} Œ± _inst_3 (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s))) t) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_3)) (fun (_x : MeasureTheory.Measure.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_3)) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_3)) (MeasureTheory.MeasureSpace.volume.{u1} Œ± _inst_3) (Set.image.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeSubtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))))) t)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.MeasureSpace.{u1} Œ±], (MeasureTheory.NullMeasurableSet.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_3) s (MeasureTheory.MeasureSpace.volume.{u1} Œ± _inst_3)) -> (forall {t : Set.{u1} (Set.Elem.{u1} Œ± s)}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} (Set.Elem.{u1} Œ± s) (MeasureTheory.Measure.toOuterMeasure.{u1} (Set.Elem.{u1} Œ± s) (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} (Set.Elem.{u1} Œ± s) (MeasureTheory.Measure.Subtype.measureSpace.{u1} Œ± _inst_3 (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s))) (MeasureTheory.MeasureSpace.volume.{u1} (Set.Elem.{u1} Œ± s) (MeasureTheory.Measure.Subtype.measureSpace.{u1} Œ± _inst_3 (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)))) t) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_3) (MeasureTheory.MeasureSpace.volume.{u1} Œ± _inst_3)) (Set.image.{u1, u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) Œ± (Subtype.val.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) t)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.volume_subtype_coe_eq_zero_of_volume_eq_zero MeasureTheory.Measure.volume_subtype_coe_eq_zero_of_volume_eq_zero‚Çì'. -/
theorem volume_subtype_coe_eq_zero_of_volume_eq_zero (hs : NullMeasurableSet s) {t : Set s}
    (ht : volume t = 0) : volume ((coe : s ‚Üí Œ±) '' t) = 0 :=
  measure_subtype_coe_eq_zero_of_comap_eq_zero hs ht
#align measure_theory.measure.volume_subtype_coe_eq_zero_of_volume_eq_zero MeasureTheory.Measure.volume_subtype_coe_eq_zero_of_volume_eq_zero

end MeasureSpace

end Subtype

/-! ### Restricting a measure -/


/- warning: measure_theory.measure.restrict‚Çó -> MeasureTheory.Measure.restrict‚Çó is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±}, (Set.{u1} Œ±) -> (LinearMap.{0, 0, u1, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.restrict‚Çó._proof_1 m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.restrict‚Çó._proof_1 m0))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±}, (Set.{u1} Œ±) -> (LinearMap.{0, 0, u1, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict‚Çó MeasureTheory.Measure.restrict‚Çó‚Çì'. -/
/-- Restrict a measure `Œº` to a set `s` as an `‚Ñù‚â•0‚àû`-linear map. -/
def restrict‚Çó {m0 : MeasurableSpace Œ±} (s : Set Œ±) : Measure Œ± ‚Üí‚Çó[‚Ñù‚â•0‚àû] Measure Œ± :=
  liftLinear (OuterMeasure.restrict s) fun Œº s' hs' t =>
    by
    suffices Œº (s ‚à© t) = Œº (s ‚à© t ‚à© s') + Œº ((s ‚à© t) \ s') by
      simpa [‚Üê Set.inter_assoc, Set.inter_comm _ s, ‚Üê inter_diff_assoc]
    exact le_to_outer_measure_caratheodory _ _ hs' _
#align measure_theory.measure.restrict‚Çó MeasureTheory.Measure.restrict‚Çó

#print MeasureTheory.Measure.restrict /-
/-- Restrict a measure `Œº` to a set `s`. -/
def restrict {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) (s : Set Œ±) : Measure Œ± :=
  restrict‚Çó s Œº
#align measure_theory.measure.restrict MeasureTheory.Measure.restrict
-/

/- warning: measure_theory.measure.restrict‚Çó_apply -> MeasureTheory.Measure.restrict‚Çó_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (s : Set.{u1} Œ±) (Œº : MeasureTheory.Measure.{u1} Œ± m0), Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (coeFn.{succ u1, succ u1} (LinearMap.{0, 0, u1, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.restrict‚Çó._proof_1 m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.restrict‚Çó._proof_1 m0)) (fun (_x : LinearMap.{0, 0, u1, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.restrict‚Çó._proof_1 m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.restrict‚Çó._proof_1 m0)) => (MeasureTheory.Measure.{u1} Œ± m0) -> (MeasureTheory.Measure.{u1} Œ± m0)) (LinearMap.hasCoeToFun.{0, 0, u1, u1} ENNReal ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.restrict‚Çó._proof_1 m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.Measure.restrict‚Çó._proof_1 m0) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (MeasureTheory.Measure.restrict‚Çó.{u1} Œ± m0 s) Œº) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (s : Set.{u1} Œ±) (Œº : MeasureTheory.Measure.{u1} Œ± m0), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.Measure.{u1} Œ± m0) => MeasureTheory.Measure.{u1} Œ± m0) Œº) (FunLike.coe.{succ u1, succ u1, succ u1} (LinearMap.{0, 0, u1, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0)) (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.Measure.{u1} Œ± m0) => MeasureTheory.Measure.{u1} Œ± m0) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u1, u1} ENNReal ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instAddCommMonoid.{u1} Œ± m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (MeasureTheory.Measure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (MeasureTheory.Measure.restrict‚Çó.{u1} Œ± m0 s) Œº) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict‚Çó_apply MeasureTheory.Measure.restrict‚Çó_apply‚Çì'. -/
@[simp]
theorem restrict‚Çó_apply {m0 : MeasurableSpace Œ±} (s : Set Œ±) (Œº : Measure Œ±) :
    restrict‚Çó s Œº = Œº.restrict s :=
  rfl
#align measure_theory.measure.restrict‚Çó_apply MeasureTheory.Measure.restrict‚Çó_apply

/- warning: measure_theory.measure.restrict_to_outer_measure_eq_to_outer_measure_restrict -> MeasureTheory.Measure.restrict_toOuterMeasure_eq_toOuterMeasure_restrict is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{succ u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) (coeFn.{succ u1, succ u1} (LinearMap.{0, 0, u1, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.OuterMeasure.restrict._proof_1) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.OuterMeasure.restrict._proof_1)) (fun (_x : LinearMap.{0, 0, u1, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.OuterMeasure.restrict._proof_1) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.OuterMeasure.restrict._proof_1)) => (MeasureTheory.OuterMeasure.{u1} Œ±) -> (MeasureTheory.OuterMeasure.{u1} Œ±)) (LinearMap.hasCoeToFun.{0, 0, u1, u1} ENNReal ENNReal (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ±) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.OuterMeasure.restrict._proof_1) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) MeasureTheory.OuterMeasure.restrict._proof_1) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (MeasureTheory.OuterMeasure.restrict.{u1} Œ± s) (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{succ u1} (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) (FunLike.coe.{succ u1, succ u1, succ u1} (LinearMap.{0, 0, u1, u1} ENNReal ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))) (MeasureTheory.OuterMeasure.{u1} Œ±) (fun (_x : MeasureTheory.OuterMeasure.{u1} Œ±) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : MeasureTheory.OuterMeasure.{u1} Œ±) => MeasureTheory.OuterMeasure.{u1} Œ±) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u1, u1} ENNReal ENNReal (MeasureTheory.OuterMeasure.{u1} Œ±) (MeasureTheory.OuterMeasure.{u1} Œ±) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.addCommMonoid.{u1} Œ±) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.instModule.{u1, 0} Œ± ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (RingHom.id.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (MeasureTheory.OuterMeasure.restrict.{u1} Œ± s) (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_to_outer_measure_eq_to_outer_measure_restrict MeasureTheory.Measure.restrict_toOuterMeasure_eq_toOuterMeasure_restrict‚Çì'. -/
/-- This lemma shows that `restrict` and `to_outer_measure` commute. Note that the LHS has a
restrict on measures and the RHS has a restrict on outer measures. -/
theorem restrict_toOuterMeasure_eq_toOuterMeasure_restrict (h : MeasurableSet s) :
    (Œº.restrict s).toOuterMeasure = OuterMeasure.restrict s Œº.toOuterMeasure := by
  simp_rw [restrict, restrict‚Çó, lift_linear, LinearMap.coe_mk, to_measure_to_outer_measure,
    outer_measure.restrict_trim h, Œº.trimmed]
#align measure_theory.measure.restrict_to_outer_measure_eq_to_outer_measure_restrict MeasureTheory.Measure.restrict_toOuterMeasure_eq_toOuterMeasure_restrict

/- warning: measure_theory.measure.restrict_apply‚ÇÄ -> MeasureTheory.Measure.restrict_apply‚ÇÄ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasureTheory.NullMeasurableSet.{u1} Œ± m0 t (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s) t) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) t s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasureTheory.NullMeasurableSet.{u1} Œ± m0 t (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) t) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) t s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_apply‚ÇÄ MeasureTheory.Measure.restrict_apply‚ÇÄ‚Çì'. -/
theorem restrict_apply‚ÇÄ (ht : NullMeasurableSet t (Œº.restrict s)) : Œº.restrict s t = Œº (t ‚à© s) :=
  (toMeasure_apply‚ÇÄ _ _ ht).trans <| by
    simp only [coe_to_outer_measure, outer_measure.restrict_apply]
#align measure_theory.measure.restrict_apply‚ÇÄ MeasureTheory.Measure.restrict_apply‚ÇÄ

/- warning: measure_theory.measure.restrict_apply -> MeasureTheory.Measure.restrict_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 t) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s) t) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) t s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 t) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) t) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) t s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_apply MeasureTheory.Measure.restrict_apply‚Çì'. -/
/-- If `t` is a measurable set, then the measure of `t` with respect to the restriction of
  the measure to `s` equals the outer measure of `t ‚à© s`. An alternate version requiring that `s`
  be measurable instead of `t` exists as `measure.restrict_apply'`. -/
@[simp]
theorem restrict_apply (ht : MeasurableSet t) : Œº.restrict s t = Œº (t ‚à© s) :=
  restrict_apply‚ÇÄ ht.NullMeasurableSet
#align measure_theory.measure.restrict_apply MeasureTheory.Measure.restrict_apply

#print MeasureTheory.Measure.restrict_mono' /-
/-- Restriction of a measure to a subset is monotone both in set and in measure. -/
theorem restrict_mono' {m0 : MeasurableSpace Œ±} ‚¶És s' : Set Œ±‚¶Ñ ‚¶ÉŒº ŒΩ : Measure Œ±‚¶Ñ (hs : s ‚â§·µê[Œº] s')
    (hŒºŒΩ : Œº ‚â§ ŒΩ) : Œº.restrict s ‚â§ ŒΩ.restrict s' := fun t ht =>
  calc
    Œº.restrict s t = Œº (t ‚à© s) := restrict_apply ht
    _ ‚â§ Œº (t ‚à© s') := (measure_mono_ae <| hs.mono fun x hx ‚ü®hxt, hxs‚ü© => ‚ü®hxt, hx hxs‚ü©)
    _ ‚â§ ŒΩ (t ‚à© s') := (le_iff'.1 hŒºŒΩ (t ‚à© s'))
    _ = ŒΩ.restrict s' t := (restrict_apply ht).symm
    
#align measure_theory.measure.restrict_mono' MeasureTheory.Measure.restrict_mono'
-/

#print MeasureTheory.Measure.restrict_mono /-
/-- Restriction of a measure to a subset is monotone both in set and in measure. -/
@[mono]
theorem restrict_mono {m0 : MeasurableSpace Œ±} ‚¶És s' : Set Œ±‚¶Ñ (hs : s ‚äÜ s') ‚¶ÉŒº ŒΩ : Measure Œ±‚¶Ñ
    (hŒºŒΩ : Œº ‚â§ ŒΩ) : Œº.restrict s ‚â§ ŒΩ.restrict s' :=
  restrict_mono' (ae_of_all _ hs) hŒºŒΩ
#align measure_theory.measure.restrict_mono MeasureTheory.Measure.restrict_mono
-/

#print MeasureTheory.Measure.restrict_mono_ae /-
theorem restrict_mono_ae (h : s ‚â§·µê[Œº] t) : Œº.restrict s ‚â§ Œº.restrict t :=
  restrict_mono' h (le_refl Œº)
#align measure_theory.measure.restrict_mono_ae MeasureTheory.Measure.restrict_mono_ae
-/

#print MeasureTheory.Measure.restrict_congr_set /-
theorem restrict_congr_set (h : s =·µê[Œº] t) : Œº.restrict s = Œº.restrict t :=
  le_antisymm (restrict_mono_ae h.le) (restrict_mono_ae h.symm.le)
#align measure_theory.measure.restrict_congr_set MeasureTheory.Measure.restrict_congr_set
-/

/- warning: measure_theory.measure.restrict_apply' -> MeasureTheory.Measure.restrict_apply' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s) t) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) t s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) t) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) t s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_apply' MeasureTheory.Measure.restrict_apply'‚Çì'. -/
/-- If `s` is a measurable set, then the outer measure of `t` with respect to the restriction of
the measure to `s` equals the outer measure of `t ‚à© s`. This is an alternate version of
`measure.restrict_apply`, requiring that `s` is measurable instead of `t`. -/
@[simp]
theorem restrict_apply' (hs : MeasurableSet s) : Œº.restrict s t = Œº (t ‚à© s) := by
  rw [‚Üê coe_to_outer_measure, measure.restrict_to_outer_measure_eq_to_outer_measure_restrict hs,
    outer_measure.restrict_apply s t _, coe_to_outer_measure]
#align measure_theory.measure.restrict_apply' MeasureTheory.Measure.restrict_apply'

/- warning: measure_theory.measure.restrict_apply‚ÇÄ' -> MeasureTheory.Measure.restrict_apply‚ÇÄ' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasureTheory.NullMeasurableSet.{u1} Œ± m0 s Œº) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s) t) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) t s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasureTheory.NullMeasurableSet.{u1} Œ± m0 s Œº) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) t) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) t s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_apply‚ÇÄ' MeasureTheory.Measure.restrict_apply‚ÇÄ'‚Çì'. -/
theorem restrict_apply‚ÇÄ' (hs : NullMeasurableSet s Œº) : Œº.restrict s t = Œº (t ‚à© s) := by
  rw [‚Üê restrict_congr_set hs.to_measurable_ae_eq,
    restrict_apply' (measurable_set_to_measurable _ _),
    measure_congr ((ae_eq_refl t).inter hs.to_measurable_ae_eq)]
#align measure_theory.measure.restrict_apply‚ÇÄ' MeasureTheory.Measure.restrict_apply‚ÇÄ'

#print MeasureTheory.Measure.restrict_le_self /-
theorem restrict_le_self : Œº.restrict s ‚â§ Œº := fun t ht =>
  calc
    Œº.restrict s t = Œº (t ‚à© s) := restrict_apply ht
    _ ‚â§ Œº t := measure_mono <| inter_subset_left t s
    
#align measure_theory.measure.restrict_le_self MeasureTheory.Measure.restrict_le_self
-/

variable (Œº)

#print MeasureTheory.Measure.restrict_eq_self /-
theorem restrict_eq_self (h : s ‚äÜ t) : Œº.restrict t s = Œº s :=
  (le_iff'.1 restrict_le_self s).antisymm <|
    calc
      Œº s ‚â§ Œº (toMeasurable (Œº.restrict t) s ‚à© t) :=
        measure_mono (subset_inter (subset_toMeasurable _ _) h)
      _ = Œº.restrict t s := by
        rw [‚Üê restrict_apply (measurable_set_to_measurable _ _), measure_to_measurable]
      
#align measure_theory.measure.restrict_eq_self MeasureTheory.Measure.restrict_eq_self
-/

#print MeasureTheory.Measure.restrict_apply_self /-
@[simp]
theorem restrict_apply_self (s : Set Œ±) : (Œº.restrict s) s = Œº s :=
  restrict_eq_self Œº Subset.rfl
#align measure_theory.measure.restrict_apply_self MeasureTheory.Measure.restrict_apply_self
-/

variable {Œº}

#print MeasureTheory.Measure.restrict_apply_univ /-
theorem restrict_apply_univ (s : Set Œ±) : Œº.restrict s univ = Œº s := by
  rw [restrict_apply MeasurableSet.univ, Set.univ_inter]
#align measure_theory.measure.restrict_apply_univ MeasureTheory.Measure.restrict_apply_univ
-/

/- warning: measure_theory.measure.le_restrict_apply -> MeasureTheory.Measure.le_restrict_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} (s : Set.{u1} Œ±) (t : Set.{u1} Œ±), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) t s)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s) t)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} (s : Set.{u1} Œ±) (t : Set.{u1} Œ±), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) t s)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) t)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.le_restrict_apply MeasureTheory.Measure.le_restrict_apply‚Çì'. -/
theorem le_restrict_apply (s t : Set Œ±) : Œº (t ‚à© s) ‚â§ Œº.restrict s t :=
  calc
    Œº (t ‚à© s) = Œº.restrict s (t ‚à© s) := (restrict_eq_self Œº (inter_subset_right _ _)).symm
    _ ‚â§ Œº.restrict s t := measure_mono (inter_subset_left _ _)
    
#align measure_theory.measure.le_restrict_apply MeasureTheory.Measure.le_restrict_apply

#print MeasureTheory.Measure.restrict_apply_superset /-
theorem restrict_apply_superset (h : s ‚äÜ t) : Œº.restrict s t = Œº s :=
  ((measure_mono (subset_univ _)).trans_eq <| restrict_apply_univ _).antisymm
    ((restrict_apply_self Œº s).symm.trans_le <| measure_mono h)
#align measure_theory.measure.restrict_apply_superset MeasureTheory.Measure.restrict_apply_superset
-/

#print MeasureTheory.Measure.restrict_add /-
@[simp]
theorem restrict_add {m0 : MeasurableSpace Œ±} (Œº ŒΩ : Measure Œ±) (s : Set Œ±) :
    (Œº + ŒΩ).restrict s = Œº.restrict s + ŒΩ.restrict s :=
  (restrict‚Çó s).map_add Œº ŒΩ
#align measure_theory.measure.restrict_add MeasureTheory.Measure.restrict_add
-/

#print MeasureTheory.Measure.restrict_zero /-
@[simp]
theorem restrict_zero {m0 : MeasurableSpace Œ±} (s : Set Œ±) : (0 : Measure Œ±).restrict s = 0 :=
  (restrict‚Çó s).map_zero
#align measure_theory.measure.restrict_zero MeasureTheory.Measure.restrict_zero
-/

#print MeasureTheory.Measure.restrict_smul /-
@[simp]
theorem restrict_smul {m0 : MeasurableSpace Œ±} (c : ‚Ñù‚â•0‚àû) (Œº : Measure Œ±) (s : Set Œ±) :
    (c ‚Ä¢ Œº).restrict s = c ‚Ä¢ Œº.restrict s :=
  (restrict‚Çó s).map_smul c Œº
#align measure_theory.measure.restrict_smul MeasureTheory.Measure.restrict_smul
-/

#print MeasureTheory.Measure.restrict_restrict‚ÇÄ /-
theorem restrict_restrict‚ÇÄ (hs : NullMeasurableSet s (Œº.restrict t)) :
    (Œº.restrict t).restrict s = Œº.restrict (s ‚à© t) :=
  ext fun u hu => by
    simp only [Set.inter_assoc, restrict_apply hu,
      restrict_apply‚ÇÄ (hu.null_measurable_set.inter hs)]
#align measure_theory.measure.restrict_restrict‚ÇÄ MeasureTheory.Measure.restrict_restrict‚ÇÄ
-/

#print MeasureTheory.Measure.restrict_restrict /-
@[simp]
theorem restrict_restrict (hs : MeasurableSet s) : (Œº.restrict t).restrict s = Œº.restrict (s ‚à© t) :=
  restrict_restrict‚ÇÄ hs.NullMeasurableSet
#align measure_theory.measure.restrict_restrict MeasureTheory.Measure.restrict_restrict
-/

#print MeasureTheory.Measure.restrict_restrict_of_subset /-
theorem restrict_restrict_of_subset (h : s ‚äÜ t) : (Œº.restrict t).restrict s = Œº.restrict s :=
  by
  ext1 u hu
  rw [restrict_apply hu, restrict_apply hu, restrict_eq_self]
  exact (inter_subset_right _ _).trans h
#align measure_theory.measure.restrict_restrict_of_subset MeasureTheory.Measure.restrict_restrict_of_subset
-/

#print MeasureTheory.Measure.restrict_restrict‚ÇÄ' /-
theorem restrict_restrict‚ÇÄ' (ht : NullMeasurableSet t Œº) :
    (Œº.restrict t).restrict s = Œº.restrict (s ‚à© t) :=
  ext fun u hu => by simp only [restrict_apply hu, restrict_apply‚ÇÄ' ht, inter_assoc]
#align measure_theory.measure.restrict_restrict‚ÇÄ' MeasureTheory.Measure.restrict_restrict‚ÇÄ'
-/

#print MeasureTheory.Measure.restrict_restrict' /-
theorem restrict_restrict' (ht : MeasurableSet t) :
    (Œº.restrict t).restrict s = Œº.restrict (s ‚à© t) :=
  restrict_restrict‚ÇÄ' ht.NullMeasurableSet
#align measure_theory.measure.restrict_restrict' MeasureTheory.Measure.restrict_restrict'
-/

#print MeasureTheory.Measure.restrict_comm /-
theorem restrict_comm (hs : MeasurableSet s) :
    (Œº.restrict t).restrict s = (Œº.restrict s).restrict t := by
  rw [restrict_restrict hs, restrict_restrict' hs, inter_comm]
#align measure_theory.measure.restrict_comm MeasureTheory.Measure.restrict_comm
-/

/- warning: measure_theory.measure.restrict_apply_eq_zero -> MeasureTheory.Measure.restrict_apply_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 t) -> (Iff (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s) t) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) t s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 t) -> (Iff (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) t) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) t s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_apply_eq_zero MeasureTheory.Measure.restrict_apply_eq_zero‚Çì'. -/
theorem restrict_apply_eq_zero (ht : MeasurableSet t) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 := by
  rw [restrict_apply ht]
#align measure_theory.measure.restrict_apply_eq_zero MeasureTheory.Measure.restrict_apply_eq_zero

/- warning: measure_theory.measure.measure_inter_eq_zero_of_restrict -> MeasureTheory.Measure.measure_inter_eq_zero_of_restrict is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s) t) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) t s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) t) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) t s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.measure_inter_eq_zero_of_restrict MeasureTheory.Measure.measure_inter_eq_zero_of_restrict‚Çì'. -/
theorem measure_inter_eq_zero_of_restrict (h : Œº.restrict s t = 0) : Œº (t ‚à© s) = 0 :=
  nonpos_iff_eq_zero.1 (h ‚ñ∏ le_restrict_apply _ _)
#align measure_theory.measure.measure_inter_eq_zero_of_restrict MeasureTheory.Measure.measure_inter_eq_zero_of_restrict

/- warning: measure_theory.measure.restrict_apply_eq_zero' -> MeasureTheory.Measure.restrict_apply_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Iff (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s) t) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) t s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Iff (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) t) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) t s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_apply_eq_zero' MeasureTheory.Measure.restrict_apply_eq_zero'‚Çì'. -/
theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 := by
  rw [restrict_apply' hs]
#align measure_theory.measure.restrict_apply_eq_zero' MeasureTheory.Measure.restrict_apply_eq_zero'

/- warning: measure_theory.measure.restrict_eq_zero -> MeasureTheory.Measure.restrict_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, Iff (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s) (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (OfNat.mk.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.zero.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0))))) (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, Iff (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s) (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.toOfNat0.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0)))) (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_eq_zero MeasureTheory.Measure.restrict_eq_zero‚Çì'. -/
@[simp]
theorem restrict_eq_zero : Œº.restrict s = 0 ‚Üî Œº s = 0 := by
  rw [‚Üê measure_univ_eq_zero, restrict_apply_univ]
#align measure_theory.measure.restrict_eq_zero MeasureTheory.Measure.restrict_eq_zero

/- warning: measure_theory.measure.restrict_zero_set -> MeasureTheory.Measure.restrict_zero_set is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s) (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (OfNat.mk.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.zero.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s) (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.toOfNat0.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_zero_set MeasureTheory.Measure.restrict_zero_set‚Çì'. -/
theorem restrict_zero_set {s : Set Œ±} (h : Œº s = 0) : Œº.restrict s = 0 :=
  restrict_eq_zero.2 h
#align measure_theory.measure.restrict_zero_set MeasureTheory.Measure.restrict_zero_set

#print MeasureTheory.Measure.restrict_empty /-
@[simp]
theorem restrict_empty : Œº.restrict ‚àÖ = 0 :=
  restrict_zero_set measure_empty
#align measure_theory.measure.restrict_empty MeasureTheory.Measure.restrict_empty
-/

#print MeasureTheory.Measure.restrict_univ /-
@[simp]
theorem restrict_univ : Œº.restrict univ = Œº :=
  ext fun s hs => by simp [hs]
#align measure_theory.measure.restrict_univ MeasureTheory.Measure.restrict_univ
-/

#print MeasureTheory.Measure.restrict_inter_add_diff‚ÇÄ /-
theorem restrict_inter_add_diff‚ÇÄ (s : Set Œ±) (ht : NullMeasurableSet t Œº) :
    Œº.restrict (s ‚à© t) + Œº.restrict (s \ t) = Œº.restrict s :=
  by
  ext1 u hu
  simp only [add_apply, restrict_apply hu, ‚Üê inter_assoc, diff_eq]
  exact measure_inter_add_diff‚ÇÄ (u ‚à© s) ht
#align measure_theory.measure.restrict_inter_add_diff‚ÇÄ MeasureTheory.Measure.restrict_inter_add_diff‚ÇÄ
-/

#print MeasureTheory.Measure.restrict_inter_add_diff /-
theorem restrict_inter_add_diff (s : Set Œ±) (ht : MeasurableSet t) :
    Œº.restrict (s ‚à© t) + Œº.restrict (s \ t) = Œº.restrict s :=
  restrict_inter_add_diff‚ÇÄ s ht.NullMeasurableSet
#align measure_theory.measure.restrict_inter_add_diff MeasureTheory.Measure.restrict_inter_add_diff
-/

#print MeasureTheory.Measure.restrict_union_add_inter‚ÇÄ /-
theorem restrict_union_add_inter‚ÇÄ (s : Set Œ±) (ht : NullMeasurableSet t Œº) :
    Œº.restrict (s ‚à™ t) + Œº.restrict (s ‚à© t) = Œº.restrict s + Œº.restrict t := by
  rw [‚Üê restrict_inter_add_diff‚ÇÄ (s ‚à™ t) ht, union_inter_cancel_right, union_diff_right, ‚Üê
    restrict_inter_add_diff‚ÇÄ s ht, add_comm, ‚Üê add_assoc, add_right_comm]
#align measure_theory.measure.restrict_union_add_inter‚ÇÄ MeasureTheory.Measure.restrict_union_add_inter‚ÇÄ
-/

#print MeasureTheory.Measure.restrict_union_add_inter /-
theorem restrict_union_add_inter (s : Set Œ±) (ht : MeasurableSet t) :
    Œº.restrict (s ‚à™ t) + Œº.restrict (s ‚à© t) = Œº.restrict s + Œº.restrict t :=
  restrict_union_add_inter‚ÇÄ s ht.NullMeasurableSet
#align measure_theory.measure.restrict_union_add_inter MeasureTheory.Measure.restrict_union_add_inter
-/

#print MeasureTheory.Measure.restrict_union_add_inter' /-
theorem restrict_union_add_inter' (hs : MeasurableSet s) (t : Set Œ±) :
    Œº.restrict (s ‚à™ t) + Œº.restrict (s ‚à© t) = Œº.restrict s + Œº.restrict t := by
  simpa only [union_comm, inter_comm, add_comm] using restrict_union_add_inter t hs
#align measure_theory.measure.restrict_union_add_inter' MeasureTheory.Measure.restrict_union_add_inter'
-/

#print MeasureTheory.Measure.restrict_union‚ÇÄ /-
theorem restrict_union‚ÇÄ (h : AEDisjoint Œº s t) (ht : NullMeasurableSet t Œº) :
    Œº.restrict (s ‚à™ t) = Œº.restrict s + Œº.restrict t := by
  simp [‚Üê restrict_union_add_inter‚ÇÄ s ht, restrict_zero_set h]
#align measure_theory.measure.restrict_union‚ÇÄ MeasureTheory.Measure.restrict_union‚ÇÄ
-/

/- warning: measure_theory.measure.restrict_union -> MeasureTheory.Measure.restrict_union is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (Disjoint.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±))) s t) -> (MeasurableSet.{u1} Œ± m0 t) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) s t)) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº t)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (Disjoint.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) s t) -> (MeasurableSet.{u1} Œ± m0 t) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) s t)) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº t)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_union MeasureTheory.Measure.restrict_union‚Çì'. -/
theorem restrict_union (h : Disjoint s t) (ht : MeasurableSet t) :
    Œº.restrict (s ‚à™ t) = Œº.restrict s + Œº.restrict t :=
  restrict_union‚ÇÄ h.AEDisjoint ht.NullMeasurableSet
#align measure_theory.measure.restrict_union MeasureTheory.Measure.restrict_union

/- warning: measure_theory.measure.restrict_union' -> MeasureTheory.Measure.restrict_union' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (Disjoint.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±))) s t) -> (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) s t)) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº t)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (Disjoint.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) s t) -> (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) s t)) (HAdd.hAdd.{u1, u1, u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHAdd.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instAdd.{u1} Œ± m0)) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº t)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_union' MeasureTheory.Measure.restrict_union'‚Çì'. -/
theorem restrict_union' (h : Disjoint s t) (hs : MeasurableSet s) :
    Œº.restrict (s ‚à™ t) = Œº.restrict s + Œº.restrict t := by
  rw [union_comm, restrict_union h.symm hs, add_comm]
#align measure_theory.measure.restrict_union' MeasureTheory.Measure.restrict_union'

#print MeasureTheory.Measure.restrict_add_restrict_compl /-
@[simp]
theorem restrict_add_restrict_compl (hs : MeasurableSet s) : Œº.restrict s + Œº.restrict (s·∂ú) = Œº :=
  by
  rw [‚Üê restrict_union (@disjoint_compl_right (Set Œ±) _ _) hs.compl, union_compl_self,
    restrict_univ]
#align measure_theory.measure.restrict_add_restrict_compl MeasureTheory.Measure.restrict_add_restrict_compl
-/

#print MeasureTheory.Measure.restrict_compl_add_restrict /-
@[simp]
theorem restrict_compl_add_restrict (hs : MeasurableSet s) : Œº.restrict (s·∂ú) + Œº.restrict s = Œº :=
  by rw [add_comm, restrict_add_restrict_compl hs]
#align measure_theory.measure.restrict_compl_add_restrict MeasureTheory.Measure.restrict_compl_add_restrict
-/

#print MeasureTheory.Measure.restrict_union_le /-
theorem restrict_union_le (s s' : Set Œ±) : Œº.restrict (s ‚à™ s') ‚â§ Œº.restrict s + Œº.restrict s' :=
  by
  intro t ht
  suffices Œº (t ‚à© s ‚à™ t ‚à© s') ‚â§ Œº (t ‚à© s) + Œº (t ‚à© s') by simpa [ht, inter_union_distrib_left]
  apply measure_union_le
#align measure_theory.measure.restrict_union_le MeasureTheory.Measure.restrict_union_le
-/

/- warning: measure_theory.measure.restrict_Union_apply_ae -> MeasureTheory.Measure.restrict_union·µ¢_apply_ae is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Countable.{succ u2} Œπ] {s : Œπ -> (Set.{u1} Œ±)}, (Pairwise.{u2} Œπ (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (MeasureTheory.AEDisjoint.{u1} Œ± m0 Œº) s)) -> (forall (i : Œπ), MeasureTheory.NullMeasurableSet.{u1} Œ± m0 (s i) Œº) -> (forall {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 t) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => s i))) t) (tsum.{0, u2} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Œπ (fun (i : Œπ) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i)) t))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Countable.{succ u2} Œπ] {s : Œπ -> (Set.{u1} Œ±)}, (Pairwise.{u2} Œπ (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (MeasureTheory.AEDisjoint.{u1} Œ± m0 Œº) s)) -> (forall (i : Œπ), MeasureTheory.NullMeasurableSet.{u1} Œ± m0 (s i) Œº) -> (forall {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 t) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => s i)))) t) (tsum.{0, u2} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Œπ (fun (i : Œπ) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i))) t))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_Union_apply_ae MeasureTheory.Measure.restrict_union·µ¢_apply_ae‚Çì'. -/
theorem restrict_union·µ¢_apply_ae [Countable Œπ] {s : Œπ ‚Üí Set Œ±} (hd : Pairwise (AEDisjoint Œº on s))
    (hm : ‚àÄ i, NullMeasurableSet (s i) Œº) {t : Set Œ±} (ht : MeasurableSet t) :
    Œº.restrict (‚ãÉ i, s i) t = ‚àë' i, Œº.restrict (s i) t :=
  by
  simp only [restrict_apply, ht, inter_Union]
  exact
    measure_Union‚ÇÄ (hd.mono fun i j h => h.mono (inter_subset_right _ _) (inter_subset_right _ _))
      fun i => ht.null_measurable_set.inter (hm i)
#align measure_theory.measure.restrict_Union_apply_ae MeasureTheory.Measure.restrict_union·µ¢_apply_ae

/- warning: measure_theory.measure.restrict_Union_apply -> MeasureTheory.Measure.restrict_union·µ¢_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Countable.{succ u2} Œπ] {s : Œπ -> (Set.{u1} Œ±)}, (Pairwise.{u2} Œπ (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)))) s)) -> (forall (i : Œπ), MeasurableSet.{u1} Œ± m0 (s i)) -> (forall {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 t) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => s i))) t) (tsum.{0, u2} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Œπ (fun (i : Œπ) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i)) t))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Countable.{succ u2} Œπ] {s : Œπ -> (Set.{u1} Œ±)}, (Pairwise.{u2} Œπ (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))))) s)) -> (forall (i : Œπ), MeasurableSet.{u1} Œ± m0 (s i)) -> (forall {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 t) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => s i)))) t) (tsum.{0, u2} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Œπ (fun (i : Œπ) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i))) t))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_Union_apply MeasureTheory.Measure.restrict_union·µ¢_apply‚Çì'. -/
theorem restrict_union·µ¢_apply [Countable Œπ] {s : Œπ ‚Üí Set Œ±} (hd : Pairwise (Disjoint on s))
    (hm : ‚àÄ i, MeasurableSet (s i)) {t : Set Œ±} (ht : MeasurableSet t) :
    Œº.restrict (‚ãÉ i, s i) t = ‚àë' i, Œº.restrict (s i) t :=
  restrict_union·µ¢_apply_ae hd.AEDisjoint (fun i => (hm i).NullMeasurableSet) ht
#align measure_theory.measure.restrict_Union_apply MeasureTheory.Measure.restrict_union·µ¢_apply

/- warning: measure_theory.measure.restrict_Union_apply_eq_supr -> MeasureTheory.Measure.restrict_union·µ¢_apply_eq_sup·µ¢ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Countable.{succ u2} Œπ] {s : Œπ -> (Set.{u1} Œ±)}, (Directed.{u1, succ u2} (Set.{u1} Œ±) Œπ (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±)) s) -> (forall {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 t) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => s i))) t) (sup·µ¢.{0, succ u2} ENNReal (ConditionallyCompleteLattice.toHasSup.{0} ENNReal (CompleteLattice.toConditionallyCompleteLattice.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œπ (fun (i : Œπ) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i)) t))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Countable.{succ u2} Œπ] {s : Œπ -> (Set.{u1} Œ±)}, (Directed.{u1, succ u2} (Set.{u1} Œ±) Œπ (fun (x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.26330 : Set.{u1} Œ±) (x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.26332 : Set.{u1} Œ±) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.26330 x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.26332) s) -> (forall {t : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 t) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => s i)))) t) (sup·µ¢.{0, succ u2} ENNReal (ConditionallyCompleteLattice.toSupSet.{0} ENNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} ENNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} ENNReal (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) Œπ (fun (i : Œπ) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i))) t))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_Union_apply_eq_supr MeasureTheory.Measure.restrict_union·µ¢_apply_eq_sup·µ¢‚Çì'. -/
theorem restrict_union·µ¢_apply_eq_sup·µ¢ [Countable Œπ] {s : Œπ ‚Üí Set Œ±} (hd : Directed (¬∑ ‚äÜ ¬∑) s)
    {t : Set Œ±} (ht : MeasurableSet t) : Œº.restrict (‚ãÉ i, s i) t = ‚®Ü i, Œº.restrict (s i) t :=
  by
  simp only [restrict_apply ht, inter_Union]
  rw [measure_Union_eq_supr]
  exacts[hd.mono_comp _ fun s‚ÇÅ s‚ÇÇ => inter_subset_inter_right _]
#align measure_theory.measure.restrict_Union_apply_eq_supr MeasureTheory.Measure.restrict_union·µ¢_apply_eq_sup·µ¢

/- warning: measure_theory.measure.restrict_map -> MeasureTheory.Measure.restrict_map is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ≤}, (Measurable.{u1, u2} Œ± Œ≤ m0 _inst_1 f) -> (forall {s : Set.{u2} Œ≤}, (MeasurableSet.{u2} Œ≤ _inst_1 s) -> (Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.restrict.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) s) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.preimage.{u1, u2} Œ± Œ≤ f s)))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : Œ± -> Œ≤}, (Measurable.{u2, u1} Œ± Œ≤ m0 _inst_1 f) -> (forall {s : Set.{u1} Œ≤}, (MeasurableSet.{u1} Œ≤ _inst_1 s) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.restrict.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) s) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f (MeasureTheory.Measure.restrict.{u2} Œ± m0 Œº (Set.preimage.{u2, u1} Œ± Œ≤ f s)))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_map MeasureTheory.Measure.restrict_map‚Çì'. -/
/-- The restriction of the pushforward measure is the pushforward of the restriction. For a version
assuming only `ae_measurable`, see `restrict_map_of_ae_measurable`. -/
theorem restrict_map {f : Œ± ‚Üí Œ≤} (hf : Measurable f) {s : Set Œ≤} (hs : MeasurableSet s) :
    (Œº.map f).restrict s = (Œº.restrict <| f ‚Åª¬π' s).map f :=
  ext fun t ht => by simp [*, hf ht]
#align measure_theory.measure.restrict_map MeasureTheory.Measure.restrict_map

/- warning: measure_theory.measure.restrict_to_measurable -> MeasureTheory.Measure.restrict_toMeasurable is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (MeasureTheory.toMeasurable.{u1} Œ± m0 Œº s)) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (MeasureTheory.toMeasurable.{u1} Œ± m0 Œº s)) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_to_measurable MeasureTheory.Measure.restrict_toMeasurable‚Çì'. -/
theorem restrict_toMeasurable (h : Œº s ‚â† ‚àû) : Œº.restrict (toMeasurable Œº s) = Œº.restrict s :=
  ext fun t ht => by
    rw [restrict_apply ht, restrict_apply ht, inter_comm, measure_to_measurable_inter ht h,
      inter_comm]
#align measure_theory.measure.restrict_to_measurable MeasureTheory.Measure.restrict_toMeasurable

#print MeasureTheory.Measure.restrict_eq_self_of_ae_mem /-
theorem restrict_eq_self_of_ae_mem {m0 : MeasurableSpace Œ±} ‚¶És : Set Œ±‚¶Ñ ‚¶ÉŒº : Measure Œ±‚¶Ñ
    (hs : ‚àÄ·µê x ‚àÇŒº, x ‚àà s) : Œº.restrict s = Œº :=
  calc
    Œº.restrict s = Œº.restrict univ := restrict_congr_set (eventuallyEq_univ.mpr hs)
    _ = Œº := restrict_univ
    
#align measure_theory.measure.restrict_eq_self_of_ae_mem MeasureTheory.Measure.restrict_eq_self_of_ae_mem
-/

/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t ¬´expr ‚äÜ ¬ª s) -/
#print MeasureTheory.Measure.restrict_congr_meas /-
theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ (t) (_ : t ‚äÜ s), MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ (inter_subset_right _ _) (ht.inter hs)]‚ü©
#align measure_theory.measure.restrict_congr_meas MeasureTheory.Measure.restrict_congr_meas
-/

#print MeasureTheory.Measure.restrict_congr_mono /-
theorem restrict_congr_mono (hs : s ‚äÜ t) (h : Œº.restrict t = ŒΩ.restrict t) :
    Œº.restrict s = ŒΩ.restrict s := by
  rw [‚Üê restrict_restrict_of_subset hs, h, restrict_restrict_of_subset hs]
#align measure_theory.measure.restrict_congr_mono MeasureTheory.Measure.restrict_congr_mono
-/

#print MeasureTheory.Measure.restrict_union_congr /-
/-- If two measures agree on all measurable subsets of `s` and `t`, then they agree on all
measurable subsets of `s ‚à™ t`. -/
theorem restrict_union_congr :
    Œº.restrict (s ‚à™ t) = ŒΩ.restrict (s ‚à™ t) ‚Üî
      Œº.restrict s = ŒΩ.restrict s ‚àß Œº.restrict t = ŒΩ.restrict t :=
  by
  refine'
    ‚ü®fun h =>
      ‚ü®restrict_congr_mono (subset_union_left _ _) h,
        restrict_congr_mono (subset_union_right _ _) h‚ü©,
      _‚ü©
  rintro ‚ü®hs, ht‚ü©
  ext1 u hu
  simp only [restrict_apply hu, inter_union_distrib_left]
  rcases exists_measurable_superset‚ÇÇ Œº ŒΩ (u ‚à© s) with ‚ü®US, hsub, hm, hŒº, hŒΩ‚ü©
  calc
    Œº (u ‚à© s ‚à™ u ‚à© t) = Œº (US ‚à™ u ‚à© t) := measure_union_congr_of_subset hsub hŒº.le subset.rfl le_rfl
    _ = Œº US + Œº ((u ‚à© t) \ US) := (measure_add_diff hm _).symm
    _ = restrict Œº s u + restrict Œº t (u \ US) := by
      simp only [restrict_apply, hu, hu.diff hm, hŒº, ‚Üê inter_comm t, inter_diff_assoc]
    _ = restrict ŒΩ s u + restrict ŒΩ t (u \ US) := by rw [hs, ht]
    _ = ŒΩ US + ŒΩ ((u ‚à© t) \ US) := by
      simp only [restrict_apply, hu, hu.diff hm, hŒΩ, ‚Üê inter_comm t, inter_diff_assoc]
    _ = ŒΩ (US ‚à™ u ‚à© t) := (measure_add_diff hm _)
    _ = ŒΩ (u ‚à© s ‚à™ u ‚à© t) := Eq.symm <| measure_union_congr_of_subset hsub hŒΩ.le subset.rfl le_rfl
    
#align measure_theory.measure.restrict_union_congr MeasureTheory.Measure.restrict_union_congr
-/

#print MeasureTheory.Measure.restrict_finset_bunion·µ¢_congr /-
theorem restrict_finset_bunion·µ¢_congr {s : Finset Œπ} {t : Œπ ‚Üí Set Œ±} :
    Œº.restrict (‚ãÉ i ‚àà s, t i) = ŒΩ.restrict (‚ãÉ i ‚àà s, t i) ‚Üî
      ‚àÄ i ‚àà s, Œº.restrict (t i) = ŒΩ.restrict (t i) :=
  by
  induction' s using Finset.induction_on with i s hi hs; ¬∑ simp
  simp only [forall_eq_or_imp, Union_Union_eq_or_left, Finset.mem_insert]
  rw [restrict_union_congr, ‚Üê hs]
#align measure_theory.measure.restrict_finset_bUnion_congr MeasureTheory.Measure.restrict_finset_bunion·µ¢_congr
-/

#print MeasureTheory.Measure.restrict_union·µ¢_congr /-
theorem restrict_union·µ¢_congr [Countable Œπ] {s : Œπ ‚Üí Set Œ±} :
    Œº.restrict (‚ãÉ i, s i) = ŒΩ.restrict (‚ãÉ i, s i) ‚Üî ‚àÄ i, Œº.restrict (s i) = ŒΩ.restrict (s i) :=
  by
  refine' ‚ü®fun h i => restrict_congr_mono (subset_Union _ _) h, fun h => _‚ü©
  ext1 t ht
  have D : Directed (¬∑ ‚äÜ ¬∑) fun t : Finset Œπ => ‚ãÉ i ‚àà t, s i :=
    directed_of_sup fun t‚ÇÅ t‚ÇÇ ht => bUnion_subset_bUnion_left ht
  rw [Union_eq_Union_finset]
  simp only [restrict_Union_apply_eq_supr D ht, restrict_finset_bUnion_congr.2 fun i hi => h i]
#align measure_theory.measure.restrict_Union_congr MeasureTheory.Measure.restrict_union·µ¢_congr
-/

#print MeasureTheory.Measure.restrict_bunion·µ¢_congr /-
theorem restrict_bunion·µ¢_congr {s : Set Œπ} {t : Œπ ‚Üí Set Œ±} (hc : s.Countable) :
    Œº.restrict (‚ãÉ i ‚àà s, t i) = ŒΩ.restrict (‚ãÉ i ‚àà s, t i) ‚Üî
      ‚àÄ i ‚àà s, Œº.restrict (t i) = ŒΩ.restrict (t i) :=
  by
  haveI := hc.to_encodable
  simp only [bUnion_eq_Union, SetCoe.forall', restrict_Union_congr]
#align measure_theory.measure.restrict_bUnion_congr MeasureTheory.Measure.restrict_bunion·µ¢_congr
-/

#print MeasureTheory.Measure.restrict_union‚Çõ_congr /-
theorem restrict_union‚Çõ_congr {S : Set (Set Œ±)} (hc : S.Countable) :
    Œº.restrict (‚ãÉ‚ÇÄ S) = ŒΩ.restrict (‚ãÉ‚ÇÄ S) ‚Üî ‚àÄ s ‚àà S, Œº.restrict s = ŒΩ.restrict s := by
  rw [sUnion_eq_bUnion, restrict_bUnion_congr hc]
#align measure_theory.measure.restrict_sUnion_congr MeasureTheory.Measure.restrict_union‚Çõ_congr
-/

#print MeasureTheory.Measure.restrict_inf‚Çõ_eq_inf‚Çõ_restrict /-
/-- This lemma shows that `Inf` and `restrict` commute for measures. -/
theorem restrict_inf‚Çõ_eq_inf‚Çõ_restrict {m0 : MeasurableSpace Œ±} {m : Set (Measure Œ±)}
    (hm : m.Nonempty) (ht : MeasurableSet t) :
    (inf‚Çõ m).restrict t = inf‚Çõ ((fun Œº : Measure Œ± => Œº.restrict t) '' m) :=
  by
  ext1 s hs
  simp_rw [inf‚Çõ_apply hs, restrict_apply hs, inf‚Çõ_apply (MeasurableSet.inter hs ht),
    Set.image_image, restrict_to_outer_measure_eq_to_outer_measure_restrict ht, ‚Üê
    Set.image_image _ to_outer_measure, ‚Üê outer_measure.restrict_Inf_eq_Inf_restrict _ (hm.image _),
    outer_measure.restrict_apply]
#align measure_theory.measure.restrict_Inf_eq_Inf_restrict MeasureTheory.Measure.restrict_inf‚Çõ_eq_inf‚Çõ_restrict
-/

/- warning: measure_theory.measure.exists_mem_of_measure_ne_zero_of_ae -> MeasureTheory.Measure.exists_mem_of_measure_ne_zero_of_ae is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (forall {p : Œ± -> Prop}, (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s))) -> (Exists.{succ u1} Œ± (fun (x : Œ±) => And (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) (p x))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (forall {p : Œ± -> Prop}, (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s))) -> (Exists.{succ u1} Œ± (fun (x : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) (p x))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.exists_mem_of_measure_ne_zero_of_ae MeasureTheory.Measure.exists_mem_of_measure_ne_zero_of_ae‚Çì'. -/
theorem exists_mem_of_measure_ne_zero_of_ae (hs : Œº s ‚â† 0) {p : Œ± ‚Üí Prop}
    (hp : ‚àÄ·µê x ‚àÇŒº.restrict s, p x) : ‚àÉ x, x ‚àà s ‚àß p x :=
  by
  rw [‚Üê Œº.restrict_apply_self, ‚Üê frequently_ae_mem_iff] at hs
  exact (hs.and_eventually hp).exists
#align measure_theory.measure.exists_mem_of_measure_ne_zero_of_ae MeasureTheory.Measure.exists_mem_of_measure_ne_zero_of_ae

/-! ### Extensionality results -/


#print MeasureTheory.Measure.ext_iff_of_union·µ¢_eq_univ /-
/-- Two measures are equal if they have equal restrictions on a spanning collection of sets
  (formulated using `Union`). -/
theorem ext_iff_of_union·µ¢_eq_univ [Countable Œπ] {s : Œπ ‚Üí Set Œ±} (hs : (‚ãÉ i, s i) = univ) :
    Œº = ŒΩ ‚Üî ‚àÄ i, Œº.restrict (s i) = ŒΩ.restrict (s i) := by
  rw [‚Üê restrict_Union_congr, hs, restrict_univ, restrict_univ]
#align measure_theory.measure.ext_iff_of_Union_eq_univ MeasureTheory.Measure.ext_iff_of_union·µ¢_eq_univ
-/

alias ext_iff_of_Union_eq_univ ‚Üî _ ext_of_Union_eq_univ
#align measure_theory.measure.ext_of_Union_eq_univ MeasureTheory.Measure.ext_of_union·µ¢_eq_univ

#print MeasureTheory.Measure.ext_iff_of_bunion·µ¢_eq_univ /-
/-- Two measures are equal if they have equal restrictions on a spanning collection of sets
  (formulated using `bUnion`). -/
theorem ext_iff_of_bunion·µ¢_eq_univ {S : Set Œπ} {s : Œπ ‚Üí Set Œ±} (hc : S.Countable)
    (hs : (‚ãÉ i ‚àà S, s i) = univ) : Œº = ŒΩ ‚Üî ‚àÄ i ‚àà S, Œº.restrict (s i) = ŒΩ.restrict (s i) := by
  rw [‚Üê restrict_bUnion_congr hc, hs, restrict_univ, restrict_univ]
#align measure_theory.measure.ext_iff_of_bUnion_eq_univ MeasureTheory.Measure.ext_iff_of_bunion·µ¢_eq_univ
-/

alias ext_iff_of_bUnion_eq_univ ‚Üî _ ext_of_bUnion_eq_univ
#align measure_theory.measure.ext_of_bUnion_eq_univ MeasureTheory.Measure.ext_of_bunion·µ¢_eq_univ

#print MeasureTheory.Measure.ext_iff_of_union‚Çõ_eq_univ /-
/-- Two measures are equal if they have equal restrictions on a spanning collection of sets
  (formulated using `sUnion`). -/
theorem ext_iff_of_union‚Çõ_eq_univ {S : Set (Set Œ±)} (hc : S.Countable) (hs : ‚ãÉ‚ÇÄ S = univ) :
    Œº = ŒΩ ‚Üî ‚àÄ s ‚àà S, Œº.restrict s = ŒΩ.restrict s :=
  ext_iff_of_bunion·µ¢_eq_univ hc <| by rwa [‚Üê sUnion_eq_bUnion]
#align measure_theory.measure.ext_iff_of_sUnion_eq_univ MeasureTheory.Measure.ext_iff_of_union‚Çõ_eq_univ
-/

alias ext_iff_of_sUnion_eq_univ ‚Üî _ ext_of_sUnion_eq_univ
#align measure_theory.measure.ext_of_sUnion_eq_univ MeasureTheory.Measure.ext_of_union‚Çõ_eq_univ

/- warning: measure_theory.measure.ext_of_generate_from_of_cover -> MeasureTheory.Measure.ext_of_generateFrom_of_cover is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} {S : Set.{u1} (Set.{u1} Œ±)} {T : Set.{u1} (Set.{u1} Œ±)}, (Eq.{succ u1} (MeasurableSpace.{u1} Œ±) m0 (MeasurableSpace.generateFrom.{u1} Œ± S)) -> (Set.Countable.{u1} (Set.{u1} Œ±) T) -> (IsPiSystem.{u1} Œ± S) -> (Eq.{succ u1} (Set.{u1} Œ±) (Set.union‚Çõ.{u1} Œ± T) (Set.univ.{u1} Œ±)) -> (forall (t : Set.{u1} Œ±), (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasMem.{u1} (Set.{u1} Œ±)) t T) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº t) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) -> (forall (t : Set.{u1} Œ±), (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasMem.{u1} (Set.{u1} Œ±)) t T) -> (forall (s : Set.{u1} Œ±), (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasMem.{u1} (Set.{u1} Œ±)) s S) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s t)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) ŒΩ (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s t))))) -> (forall (t : Set.{u1} Œ±), (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasMem.{u1} (Set.{u1} Œ±)) t T) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº t) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) ŒΩ t))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº ŒΩ)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} {S : Set.{u1} (Set.{u1} Œ±)} {T : Set.{u1} (Set.{u1} Œ±)}, (Eq.{succ u1} (MeasurableSpace.{u1} Œ±) m0 (MeasurableSpace.generateFrom.{u1} Œ± S)) -> (Set.Countable.{u1} (Set.{u1} Œ±) T) -> (IsPiSystem.{u1} Œ± S) -> (Eq.{succ u1} (Set.{u1} Œ±) (Set.union‚Çõ.{u1} Œ± T) (Set.univ.{u1} Œ±)) -> (forall (t : Set.{u1} Œ±), (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instMembershipSet.{u1} (Set.{u1} Œ±)) t T) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) t) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) -> (forall (t : Set.{u1} Œ±), (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instMembershipSet.{u1} (Set.{u1} Œ±)) t T) -> (forall (s : Set.{u1} Œ±), (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instMembershipSet.{u1} (Set.{u1} Œ±)) s S) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s t)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 ŒΩ) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s t))))) -> (forall (t : Set.{u1} Œ±), (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instMembershipSet.{u1} (Set.{u1} Œ±)) t T) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) t) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 ŒΩ) t))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº ŒΩ)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.ext_of_generate_from_of_cover MeasureTheory.Measure.ext_of_generateFrom_of_cover‚Çì'. -/
theorem ext_of_generateFrom_of_cover {S T : Set (Set Œ±)} (h_gen : ‚Äπ_‚Ä∫ = generateFrom S)
    (hc : T.Countable) (h_inter : IsPiSystem S) (hU : ‚ãÉ‚ÇÄ T = univ) (htop : ‚àÄ t ‚àà T, Œº t ‚â† ‚àû)
    (ST_eq : ‚àÄ t ‚àà T, ‚àÄ s ‚àà S, Œº (s ‚à© t) = ŒΩ (s ‚à© t)) (T_eq : ‚àÄ t ‚àà T, Œº t = ŒΩ t) : Œº = ŒΩ :=
  by
  refine' ext_of_sUnion_eq_univ hc hU fun t ht => _
  ext1 u hu
  simp only [restrict_apply hu]
  refine' induction_on_inter h_gen h_inter _ (ST_eq t ht) _ _ hu
  ¬∑ simp only [Set.empty_inter, measure_empty]
  ¬∑ intro v hv hvt
    have := T_eq t ht
    rw [Set.inter_comm] at hvt‚ä¢
    rwa [‚Üê measure_inter_add_diff t hv, ‚Üê measure_inter_add_diff t hv, ‚Üê hvt,
      ENNReal.add_right_inj] at this
    exact ne_top_of_le_ne_top (htop t ht) (measure_mono <| Set.inter_subset_left _ _)
  ¬∑ intro f hfd hfm h_eq
    simp only [‚Üê restrict_apply (hfm _), ‚Üê restrict_apply (MeasurableSet.union·µ¢ hfm)] at h_eq‚ä¢
    simp only [measure_Union hfd hfm, h_eq]
#align measure_theory.measure.ext_of_generate_from_of_cover MeasureTheory.Measure.ext_of_generateFrom_of_cover

/- warning: measure_theory.measure.ext_of_generate_from_of_cover_subset -> MeasureTheory.Measure.ext_of_generateFrom_of_cover_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} {S : Set.{u1} (Set.{u1} Œ±)} {T : Set.{u1} (Set.{u1} Œ±)}, (Eq.{succ u1} (MeasurableSpace.{u1} Œ±) m0 (MeasurableSpace.generateFrom.{u1} Œ± S)) -> (IsPiSystem.{u1} Œ± S) -> (HasSubset.Subset.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasSubset.{u1} (Set.{u1} Œ±)) T S) -> (Set.Countable.{u1} (Set.{u1} Œ±) T) -> (Eq.{succ u1} (Set.{u1} Œ±) (Set.union‚Çõ.{u1} Œ± T) (Set.univ.{u1} Œ±)) -> (forall (s : Set.{u1} Œ±), (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasMem.{u1} (Set.{u1} Œ±)) s T) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) -> (forall (s : Set.{u1} Œ±), (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasMem.{u1} (Set.{u1} Œ±)) s S) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) ŒΩ s))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº ŒΩ)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} {S : Set.{u1} (Set.{u1} Œ±)} {T : Set.{u1} (Set.{u1} Œ±)}, (Eq.{succ u1} (MeasurableSpace.{u1} Œ±) m0 (MeasurableSpace.generateFrom.{u1} Œ± S)) -> (IsPiSystem.{u1} Œ± S) -> (HasSubset.Subset.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instHasSubsetSet.{u1} (Set.{u1} Œ±)) T S) -> (Set.Countable.{u1} (Set.{u1} Œ±) T) -> (Eq.{succ u1} (Set.{u1} Œ±) (Set.union‚Çõ.{u1} Œ± T) (Set.univ.{u1} Œ±)) -> (forall (s : Set.{u1} Œ±), (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instMembershipSet.{u1} (Set.{u1} Œ±)) s T) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) -> (forall (s : Set.{u1} Œ±), (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instMembershipSet.{u1} (Set.{u1} Œ±)) s S) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 ŒΩ) s))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº ŒΩ)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.ext_of_generate_from_of_cover_subset MeasureTheory.Measure.ext_of_generateFrom_of_cover_subset‚Çì'. -/
/-- Two measures are equal if they are equal on the œÄ-system generating the œÉ-algebra,
  and they are both finite on a increasing spanning sequence of sets in the œÄ-system.
  This lemma is formulated using `sUnion`. -/
theorem ext_of_generateFrom_of_cover_subset {S T : Set (Set Œ±)} (h_gen : ‚Äπ_‚Ä∫ = generateFrom S)
    (h_inter : IsPiSystem S) (h_sub : T ‚äÜ S) (hc : T.Countable) (hU : ‚ãÉ‚ÇÄ T = univ)
    (htop : ‚àÄ s ‚àà T, Œº s ‚â† ‚àû) (h_eq : ‚àÄ s ‚àà S, Œº s = ŒΩ s) : Œº = ŒΩ :=
  by
  refine' ext_of_generate_from_of_cover h_gen hc h_inter hU htop _ fun t ht => h_eq t (h_sub ht)
  intro t ht s hs; cases' (s ‚à© t).eq_empty_or_nonempty with H H
  ¬∑ simp only [H, measure_empty]
  ¬∑ exact h_eq _ (h_inter _ hs _ (h_sub ht) H)
#align measure_theory.measure.ext_of_generate_from_of_cover_subset MeasureTheory.Measure.ext_of_generateFrom_of_cover_subset

/- warning: measure_theory.measure.ext_of_generate_from_of_Union -> MeasureTheory.Measure.ext_of_generateFrom_of_union·µ¢ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} (C : Set.{u1} (Set.{u1} Œ±)) (B : Nat -> (Set.{u1} Œ±)), (Eq.{succ u1} (MeasurableSpace.{u1} Œ±) m0 (MeasurableSpace.generateFrom.{u1} Œ± C)) -> (IsPiSystem.{u1} Œ± C) -> (Eq.{succ u1} (Set.{u1} Œ±) (Set.union·µ¢.{u1, 1} Œ± Nat (fun (i : Nat) => B i)) (Set.univ.{u1} Œ±)) -> (forall (i : Nat), Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasMem.{u1} (Set.{u1} Œ±)) (B i) C) -> (forall (i : Nat), Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (B i)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (forall (s : Set.{u1} Œ±), (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasMem.{u1} (Set.{u1} Œ±)) s C) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) ŒΩ s))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº ŒΩ)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} (C : Set.{u1} (Set.{u1} Œ±)) (B : Nat -> (Set.{u1} Œ±)), (Eq.{succ u1} (MeasurableSpace.{u1} Œ±) m0 (MeasurableSpace.generateFrom.{u1} Œ± C)) -> (IsPiSystem.{u1} Œ± C) -> (Eq.{succ u1} (Set.{u1} Œ±) (Set.union·µ¢.{u1, 1} Œ± Nat (fun (i : Nat) => B i)) (Set.univ.{u1} Œ±)) -> (forall (i : Nat), Membership.mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instMembershipSet.{u1} (Set.{u1} Œ±)) (B i) C) -> (forall (i : Nat), Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (B i)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (forall (s : Set.{u1} Œ±), (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instMembershipSet.{u1} (Set.{u1} Œ±)) s C) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 ŒΩ) s))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº ŒΩ)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.ext_of_generate_from_of_Union MeasureTheory.Measure.ext_of_generateFrom_of_union·µ¢‚Çì'. -/
/-- Two measures are equal if they are equal on the œÄ-system generating the œÉ-algebra,
  and they are both finite on a increasing spanning sequence of sets in the œÄ-system.
  This lemma is formulated using `Union`.
  `finite_spanning_sets_in.ext` is a reformulation of this lemma. -/
theorem ext_of_generateFrom_of_union·µ¢ (C : Set (Set Œ±)) (B : ‚Ñï ‚Üí Set Œ±) (hA : ‚Äπ_‚Ä∫ = generateFrom C)
    (hC : IsPiSystem C) (h1B : (‚ãÉ i, B i) = univ) (h2B : ‚àÄ i, B i ‚àà C) (hŒºB : ‚àÄ i, Œº (B i) ‚â† ‚àû)
    (h_eq : ‚àÄ s ‚àà C, Œº s = ŒΩ s) : Œº = ŒΩ :=
  by
  refine' ext_of_generate_from_of_cover_subset hA hC _ (countable_range B) h1B _ h_eq
  ¬∑ rintro _ ‚ü®i, rfl‚ü©
    apply h2B
  ¬∑ rintro _ ‚ü®i, rfl‚ü©
    apply hŒºB
#align measure_theory.measure.ext_of_generate_from_of_Union MeasureTheory.Measure.ext_of_generateFrom_of_union·µ¢

section Dirac

variable [MeasurableSpace Œ±]

#print MeasureTheory.Measure.dirac /-
/-- The dirac measure. -/
def dirac (a : Œ±) : Measure Œ± :=
  (OuterMeasure.dirac a).toMeasure (by simp)
#align measure_theory.measure.dirac MeasureTheory.Measure.dirac
-/

instance : MeasureSpace PUnit :=
  ‚ü®dirac PUnit.unit‚ü©

/- warning: measure_theory.measure.le_dirac_apply -> MeasureTheory.Measure.le_dirac_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±] {a : Œ±}, LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (Set.indicator.{u1, 0} Œ± ENNReal ENNReal.hasZero s (OfNat.ofNat.{u1} (Œ± -> ENNReal) 1 (OfNat.mk.{u1} (Œ± -> ENNReal) 1 (One.one.{u1} (Œ± -> ENNReal) (Pi.instOne.{u1, 0} Œ± (fun (·æ∞ : Œ±) => ENNReal) (fun (i : Œ±) => AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) a) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.dirac.{u1} Œ± _inst_3 a) s)
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±] {a : Œ±}, LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (Set.indicator.{u1, 0} Œ± ENNReal instENNRealZero s (OfNat.ofNat.{u1} (Œ± -> ENNReal) 1 (One.toOfNat1.{u1} (Œ± -> ENNReal) (Pi.instOne.{u1, 0} Œ± (fun (a._@.Mathlib.Algebra.IndicatorFunction._hyg.77 : Œ±) => ENNReal) (fun (i : Œ±) => CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) a) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.dirac.{u1} Œ± _inst_3 a)) s)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.le_dirac_apply MeasureTheory.Measure.le_dirac_apply‚Çì'. -/
theorem le_dirac_apply {a} : s.indicator 1 a ‚â§ dirac a s :=
  OuterMeasure.dirac_apply a s ‚ñ∏ le_toMeasure_apply _ _ _
#align measure_theory.measure.le_dirac_apply MeasureTheory.Measure.le_dirac_apply

/- warning: measure_theory.measure.dirac_apply' -> MeasureTheory.Measure.dirac_apply' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±] (a : Œ±), (MeasurableSet.{u1} Œ± _inst_3 s) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.dirac.{u1} Œ± _inst_3 a) s) (Set.indicator.{u1, 0} Œ± ENNReal ENNReal.hasZero s (OfNat.ofNat.{u1} (Œ± -> ENNReal) 1 (OfNat.mk.{u1} (Œ± -> ENNReal) 1 (One.one.{u1} (Œ± -> ENNReal) (Pi.instOne.{u1, 0} Œ± (fun (·æ∞ : Œ±) => ENNReal) (fun (i : Œ±) => AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) a))
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±] (a : Œ±), (MeasurableSet.{u1} Œ± _inst_3 s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.dirac.{u1} Œ± _inst_3 a)) s) (Set.indicator.{u1, 0} Œ± ENNReal instENNRealZero s (OfNat.ofNat.{u1} (Œ± -> ENNReal) 1 (One.toOfNat1.{u1} (Œ± -> ENNReal) (Pi.instOne.{u1, 0} Œ± (fun (a._@.Mathlib.Algebra.IndicatorFunction._hyg.77 : Œ±) => ENNReal) (fun (i : Œ±) => CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) a))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.dirac_apply' MeasureTheory.Measure.dirac_apply'‚Çì'. -/
@[simp]
theorem dirac_apply' (a : Œ±) (hs : MeasurableSet s) : dirac a s = s.indicator 1 a :=
  toMeasure_apply _ _ hs
#align measure_theory.measure.dirac_apply' MeasureTheory.Measure.dirac_apply'

#print MeasureTheory.Measure.dirac_apply_of_mem /-
@[simp]
theorem dirac_apply_of_mem {a : Œ±} (h : a ‚àà s) : dirac a s = 1 :=
  by
  have : ‚àÄ t : Set Œ±, a ‚àà t ‚Üí t.indicator (1 : Œ± ‚Üí ‚Ñù‚â•0‚àû) a = 1 := fun t ht => indicator_of_mem ht 1
  refine' le_antisymm (this univ trivial ‚ñ∏ _) (this s h ‚ñ∏ le_dirac_apply)
  rw [‚Üê dirac_apply' a MeasurableSet.univ]
  exact measure_mono (subset_univ s)
#align measure_theory.measure.dirac_apply_of_mem MeasureTheory.Measure.dirac_apply_of_mem
-/

/- warning: measure_theory.measure.dirac_apply -> MeasureTheory.Measure.dirac_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_3 : MeasurableSpace.{u1} Œ±] [_inst_4 : MeasurableSingletonClass.{u1} Œ± _inst_3] (a : Œ±) (s : Set.{u1} Œ±), Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.dirac.{u1} Œ± _inst_3 a) s) (Set.indicator.{u1, 0} Œ± ENNReal ENNReal.hasZero s (OfNat.ofNat.{u1} (Œ± -> ENNReal) 1 (OfNat.mk.{u1} (Œ± -> ENNReal) 1 (One.one.{u1} (Œ± -> ENNReal) (Pi.instOne.{u1, 0} Œ± (fun (·æ∞ : Œ±) => ENNReal) (fun (i : Œ±) => AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) a)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_3 : MeasurableSpace.{u1} Œ±] [_inst_4 : MeasurableSingletonClass.{u1} Œ± _inst_3] (a : Œ±) (s : Set.{u1} Œ±), Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.dirac.{u1} Œ± _inst_3 a)) s) (Set.indicator.{u1, 0} Œ± ENNReal instENNRealZero s (OfNat.ofNat.{u1} (Œ± -> ENNReal) 1 (One.toOfNat1.{u1} (Œ± -> ENNReal) (Pi.instOne.{u1, 0} Œ± (fun (a._@.Mathlib.Algebra.IndicatorFunction._hyg.77 : Œ±) => ENNReal) (fun (i : Œ±) => CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) a)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.dirac_apply MeasureTheory.Measure.dirac_apply‚Çì'. -/
@[simp]
theorem dirac_apply [MeasurableSingletonClass Œ±] (a : Œ±) (s : Set Œ±) :
    dirac a s = s.indicator 1 a := by
  by_cases h : a ‚àà s; ¬∑ rw [dirac_apply_of_mem h, indicator_of_mem h, Pi.one_apply]
  rw [indicator_of_not_mem h, ‚Üê nonpos_iff_eq_zero]
  calc
    dirac a s ‚â§ dirac a ({a}·∂ú) := measure_mono (subset_compl_comm.1 <| singleton_subset_iff.2 h)
    _ = 0 := by simp [dirac_apply' _ (measurable_set_singleton _).compl]
    
#align measure_theory.measure.dirac_apply MeasureTheory.Measure.dirac_apply

/- warning: measure_theory.measure.map_dirac -> MeasureTheory.Measure.map_dirac is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u2} Œ≤] [_inst_3 : MeasurableSpace.{u1} Œ±] {f : Œ± -> Œ≤}, (Measurable.{u1, u2} Œ± Œ≤ _inst_3 _inst_1 f) -> (forall (a : Œ±), Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f (MeasureTheory.Measure.dirac.{u1} Œ± _inst_3 a)) (MeasureTheory.Measure.dirac.{u2} Œ≤ _inst_1 (f a)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ≤] [_inst_3 : MeasurableSpace.{u2} Œ±] {f : Œ± -> Œ≤}, (Measurable.{u2, u1} Œ± Œ≤ _inst_3 _inst_1 f) -> (forall (a : Œ±), Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_1) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f (MeasureTheory.Measure.dirac.{u2} Œ± _inst_3 a)) (MeasureTheory.Measure.dirac.{u1} Œ≤ _inst_1 (f a)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.map_dirac MeasureTheory.Measure.map_dirac‚Çì'. -/
theorem map_dirac {f : Œ± ‚Üí Œ≤} (hf : Measurable f) (a : Œ±) : (dirac a).map f = dirac (f a) :=
  ext fun s hs => by simp [hs, map_apply hf hs, hf hs, indicator_apply]
#align measure_theory.measure.map_dirac MeasureTheory.Measure.map_dirac

/- warning: measure_theory.measure.restrict_singleton -> MeasureTheory.Measure.restrict_singleton is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_3 : MeasurableSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± _inst_3) (a : Œ±), Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (MeasureTheory.Measure.restrict.{u1} Œ± _inst_3 Œº (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasSingleton.{u1} Œ±) a)) (SMul.smul.{0, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± _inst_3) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± ENNReal (SMulZeroClass.toHasSmul.{0, 0} ENNReal ENNReal (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (SMulWithZero.toSmulZeroClass.{0, 0} ENNReal ENNReal (MulZeroClass.toHasZero.{0} ENNReal (MulZeroOneClass.toMulZeroClass.{0} ENNReal (MonoidWithZero.toMulZeroOneClass.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (MulActionWithZero.toSMulWithZero.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (Module.toMulActionWithZero.{0, 0} ENNReal ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Algebra.toModule.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) _inst_3) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) Œº (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasSingleton.{u1} Œ±) a)) (MeasureTheory.Measure.dirac.{u1} Œ± _inst_3 a))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_3 : MeasurableSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± _inst_3) (a : Œ±), Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (MeasureTheory.Measure.restrict.{u1} Œ± _inst_3 Œº (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instSingletonSet.{u1} Œ±) a)) (HSMul.hSMul.{0, u1, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± _inst_3) (MeasureTheory.Measure.{u1} Œ± _inst_3) (instHSMul.{0, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± _inst_3) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± ENNReal (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_3)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 Œº) (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instSingletonSet.{u1} Œ±) a)) (MeasureTheory.Measure.dirac.{u1} Œ± _inst_3 a))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_singleton MeasureTheory.Measure.restrict_singleton‚Çì'. -/
@[simp]
theorem restrict_singleton (Œº : Measure Œ±) (a : Œ±) : Œº.restrict {a} = Œº {a} ‚Ä¢ dirac a :=
  by
  ext1 s hs
  by_cases ha : a ‚àà s
  ¬∑ have : s ‚à© {a} = {a} := by simpa
    simp [*]
  ¬∑ have : s ‚à© {a} = ‚àÖ := inter_singleton_eq_empty.2 ha
    simp [*]
#align measure_theory.measure.restrict_singleton MeasureTheory.Measure.restrict_singleton

end Dirac

section Sum

include m0

#print MeasureTheory.Measure.sum /-
/-- Sum of an indexed family of measures. -/
def sum (f : Œπ ‚Üí Measure Œ±) : Measure Œ± :=
  (OuterMeasure.sum fun i => (f i).toOuterMeasure).toMeasure <|
    le_trans (le_inf·µ¢ fun i => le_to_outer_measure_caratheodory _)
      (OuterMeasure.le_sum_caratheodory _)
#align measure_theory.measure.sum MeasureTheory.Measure.sum
-/

/- warning: measure_theory.measure.le_sum_apply -> MeasureTheory.Measure.le_sum_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} (f : Œπ -> (MeasureTheory.Measure.{u1} Œ± m0)) (s : Set.{u1} Œ±), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (tsum.{0, u2} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Œπ (fun (i : Œπ) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (f i) s)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.sum.{u1, u2} Œ± Œπ m0 f) s)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} (f : Œπ -> (MeasureTheory.Measure.{u2} Œ± m0)) (s : Set.{u2} Œ±), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (tsum.{0, u1} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Œπ (fun (i : Œπ) => MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 (f i)) s)) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 (MeasureTheory.Measure.sum.{u2, u1} Œ± Œπ m0 f)) s)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.le_sum_apply MeasureTheory.Measure.le_sum_apply‚Çì'. -/
theorem le_sum_apply (f : Œπ ‚Üí Measure Œ±) (s : Set Œ±) : (‚àë' i, f i s) ‚â§ sum f s :=
  le_toMeasure_apply _ _ _
#align measure_theory.measure.le_sum_apply MeasureTheory.Measure.le_sum_apply

/- warning: measure_theory.measure.sum_apply -> MeasureTheory.Measure.sum_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} (f : Œπ -> (MeasureTheory.Measure.{u1} Œ± m0)) {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.sum.{u1, u2} Œ± Œπ m0 f) s) (tsum.{0, u2} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Œπ (fun (i : Œπ) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (f i) s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} (f : Œπ -> (MeasureTheory.Measure.{u2} Œ± m0)) {s : Set.{u2} Œ±}, (MeasurableSet.{u2} Œ± m0 s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 (MeasureTheory.Measure.sum.{u2, u1} Œ± Œπ m0 f)) s) (tsum.{0, u1} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Œπ (fun (i : Œπ) => MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 (f i)) s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.sum_apply MeasureTheory.Measure.sum_apply‚Çì'. -/
@[simp]
theorem sum_apply (f : Œπ ‚Üí Measure Œ±) {s : Set Œ±} (hs : MeasurableSet s) : sum f s = ‚àë' i, f i s :=
  toMeasure_apply _ _ hs
#align measure_theory.measure.sum_apply MeasureTheory.Measure.sum_apply

/- warning: measure_theory.measure.le_sum -> MeasureTheory.Measure.le_sum is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : Œπ -> (MeasureTheory.Measure.{u1} Œ± m0)) (i : Œπ), LE.le.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) (Œº i) (MeasureTheory.Measure.sum.{u1, u2} Œ± Œπ m0 Œº)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} (Œº : Œπ -> (MeasureTheory.Measure.{u2} Œ± m0)) (i : Œπ), LE.le.{u2} (MeasureTheory.Measure.{u2} Œ± m0) (Preorder.toLE.{u2} (MeasureTheory.Measure.{u2} Œ± m0) (PartialOrder.toPreorder.{u2} (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u2} Œ± m0))) (Œº i) (MeasureTheory.Measure.sum.{u2, u1} Œ± Œπ m0 Œº)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.le_sum MeasureTheory.Measure.le_sum‚Çì'. -/
theorem le_sum (Œº : Œπ ‚Üí Measure Œ±) (i : Œπ) : Œº i ‚â§ sum Œº := fun s hs => by
  simp only [sum_apply Œº hs, ENNReal.le_tsum i]
#align measure_theory.measure.le_sum MeasureTheory.Measure.le_sum

/- warning: measure_theory.measure.sum_apply_eq_zero -> MeasureTheory.Measure.sum_apply_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : Countable.{succ u2} Œπ] {Œº : Œπ -> (MeasureTheory.Measure.{u1} Œ± m0)} {s : Set.{u1} Œ±}, Iff (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.sum.{u1, u2} Œ± Œπ m0 Œº) s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) (forall (i : Œπ), Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (Œº i) s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : Countable.{succ u2} Œπ] {Œº : Œπ -> (MeasureTheory.Measure.{u1} Œ± m0)} {s : Set.{u1} Œ±}, Iff (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.sum.{u1, u2} Œ± Œπ m0 Œº)) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) (forall (i : Œπ), Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (Œº i)) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.sum_apply_eq_zero MeasureTheory.Measure.sum_apply_eq_zero‚Çì'. -/
@[simp]
theorem sum_apply_eq_zero [Countable Œπ] {Œº : Œπ ‚Üí Measure Œ±} {s : Set Œ±} :
    sum Œº s = 0 ‚Üî ‚àÄ i, Œº i s = 0 :=
  by
  refine'
    ‚ü®fun h i => nonpos_iff_eq_zero.1 <| h ‚ñ∏ le_iff'.1 (le_sum Œº i) _, fun h =>
      nonpos_iff_eq_zero.1 _‚ü©
  rcases exists_measurable_superset_forall_eq Œº s with ‚ü®t, hst, htm, ht‚ü©
  calc
    Sum Œº s ‚â§ Sum Œº t := measure_mono hst
    _ = 0 := by simp [*]
    
#align measure_theory.measure.sum_apply_eq_zero MeasureTheory.Measure.sum_apply_eq_zero

/- warning: measure_theory.measure.sum_apply_eq_zero' -> MeasureTheory.Measure.sum_apply_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : Œπ -> (MeasureTheory.Measure.{u1} Œ± m0)} {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Iff (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.sum.{u1, u2} Œ± Œπ m0 Œº) s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) (forall (i : Œπ), Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (Œº i) s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} {Œº : Œπ -> (MeasureTheory.Measure.{u2} Œ± m0)} {s : Set.{u2} Œ±}, (MeasurableSet.{u2} Œ± m0 s) -> (Iff (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 (MeasureTheory.Measure.sum.{u2, u1} Œ± Œπ m0 Œº)) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) (forall (i : Œπ), Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 (Œº i)) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.sum_apply_eq_zero' MeasureTheory.Measure.sum_apply_eq_zero'‚Çì'. -/
theorem sum_apply_eq_zero' {Œº : Œπ ‚Üí Measure Œ±} {s : Set Œ±} (hs : MeasurableSet s) :
    sum Œº s = 0 ‚Üî ‚àÄ i, Œº i s = 0 := by simp [hs]
#align measure_theory.measure.sum_apply_eq_zero' MeasureTheory.Measure.sum_apply_eq_zero'

/- warning: measure_theory.measure.sum_comm -> MeasureTheory.Measure.sum_comm is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œπ' : Type.{u3}} (Œº : Œπ -> Œπ' -> (MeasureTheory.Measure.{u1} Œ± m0)), Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.sum.{u1, u2} Œ± Œπ m0 (fun (n : Œπ) => MeasureTheory.Measure.sum.{u1, u3} Œ± Œπ' m0 (Œº n))) (MeasureTheory.Measure.sum.{u1, u3} Œ± Œπ' m0 (fun (m : Œπ') => MeasureTheory.Measure.sum.{u1, u2} Œ± Œπ m0 (fun (n : Œπ) => Œº n m)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} {Œπ' : Type.{u3}} (Œº : Œπ -> Œπ' -> (MeasureTheory.Measure.{u2} Œ± m0)), Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.sum.{u2, u1} Œ± Œπ m0 (fun (n : Œπ) => MeasureTheory.Measure.sum.{u2, u3} Œ± Œπ' m0 (Œº n))) (MeasureTheory.Measure.sum.{u2, u3} Œ± Œπ' m0 (fun (m : Œπ') => MeasureTheory.Measure.sum.{u2, u1} Œ± Œπ m0 (fun (n : Œπ) => Œº n m)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.sum_comm MeasureTheory.Measure.sum_comm‚Çì'. -/
theorem sum_comm {Œπ' : Type _} (Œº : Œπ ‚Üí Œπ' ‚Üí Measure Œ±) :
    (sum fun n => sum (Œº n)) = sum fun m => sum fun n => Œº n m :=
  by
  ext1 s hs
  simp_rw [sum_apply _ hs]
  rw [ENNReal.tsum_comm]
#align measure_theory.measure.sum_comm MeasureTheory.Measure.sum_comm

#print MeasureTheory.Measure.ae_sum_iff /-
theorem ae_sum_iff [Countable Œπ] {Œº : Œπ ‚Üí Measure Œ±} {p : Œ± ‚Üí Prop} :
    (‚àÄ·µê x ‚àÇsum Œº, p x) ‚Üî ‚àÄ i, ‚àÄ·µê x ‚àÇŒº i, p x :=
  sum_apply_eq_zero
#align measure_theory.measure.ae_sum_iff MeasureTheory.Measure.ae_sum_iff
-/

/- warning: measure_theory.measure.ae_sum_iff' -> MeasureTheory.Measure.ae_sum_iff' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : Œπ -> (MeasureTheory.Measure.{u1} Œ± m0)} {p : Œ± -> Prop}, (MeasurableSet.{u1} Œ± m0 (setOf.{u1} Œ± (fun (x : Œ±) => p x))) -> (Iff (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.sum.{u1, u2} Œ± Œπ m0 Œº))) (forall (i : Œπ), Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u1} Œ± m0 (Œº i))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} {Œº : Œπ -> (MeasureTheory.Measure.{u2} Œ± m0)} {p : Œ± -> Prop}, (MeasurableSet.{u2} Œ± m0 (setOf.{u2} Œ± (fun (x : Œ±) => p x))) -> (Iff (Filter.Eventually.{u2} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u2} Œ± m0 (MeasureTheory.Measure.sum.{u2, u1} Œ± Œπ m0 Œº))) (forall (i : Œπ), Filter.Eventually.{u2} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u2} Œ± m0 (Œº i))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.ae_sum_iff' MeasureTheory.Measure.ae_sum_iff'‚Çì'. -/
theorem ae_sum_iff' {Œº : Œπ ‚Üí Measure Œ±} {p : Œ± ‚Üí Prop} (h : MeasurableSet { x | p x }) :
    (‚àÄ·µê x ‚àÇsum Œº, p x) ‚Üî ‚àÄ i, ‚àÄ·µê x ‚àÇŒº i, p x :=
  sum_apply_eq_zero' h.compl
#align measure_theory.measure.ae_sum_iff' MeasureTheory.Measure.ae_sum_iff'

#print MeasureTheory.Measure.sum_fintype /-
@[simp]
theorem sum_fintype [Fintype Œπ] (Œº : Œπ ‚Üí Measure Œ±) : sum Œº = ‚àë i, Œº i :=
  by
  ext1 s hs
  simp only [sum_apply, finset_sum_apply, hs, tsum_fintype]
#align measure_theory.measure.sum_fintype MeasureTheory.Measure.sum_fintype
-/

#print MeasureTheory.Measure.sum_coe_finset /-
@[simp]
theorem sum_coe_finset (s : Finset Œπ) (Œº : Œπ ‚Üí Measure Œ±) :
    (sum fun i : s => Œº i) = ‚àë i in s, Œº i := by rw [sum_fintype, Finset.sum_coe_sort s Œº]
#align measure_theory.measure.sum_coe_finset MeasureTheory.Measure.sum_coe_finset
-/

/- warning: measure_theory.measure.ae_sum_eq -> MeasureTheory.Measure.ae_sum_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : Countable.{succ u2} Œπ] (Œº : Œπ -> (MeasureTheory.Measure.{u1} Œ± m0)), Eq.{succ u1} (Filter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.sum.{u1, u2} Œ± Œπ m0 Œº)) (sup·µ¢.{u1, succ u2} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasSup.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) Œπ (fun (i : Œπ) => MeasureTheory.Measure.ae.{u1} Œ± m0 (Œº i)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : Countable.{succ u2} Œπ] (Œº : Œπ -> (MeasureTheory.Measure.{u1} Œ± m0)), Eq.{succ u1} (Filter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.sum.{u1, u2} Œ± Œπ m0 Œº)) (sup·µ¢.{u1, succ u2} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toSupSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) Œπ (fun (i : Œπ) => MeasureTheory.Measure.ae.{u1} Œ± m0 (Œº i)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.ae_sum_eq MeasureTheory.Measure.ae_sum_eq‚Çì'. -/
@[simp]
theorem ae_sum_eq [Countable Œπ] (Œº : Œπ ‚Üí Measure Œ±) : (sum Œº).ae = ‚®Ü i, (Œº i).ae :=
  Filter.ext fun s => ae_sum_iff.trans mem_sup·µ¢.symm
#align measure_theory.measure.ae_sum_eq MeasureTheory.Measure.ae_sum_eq

#print MeasureTheory.Measure.sum_bool /-
@[simp]
theorem sum_bool (f : Bool ‚Üí Measure Œ±) : sum f = f true + f false := by
  rw [sum_fintype, Fintype.sum_bool]
#align measure_theory.measure.sum_bool MeasureTheory.Measure.sum_bool
-/

#print MeasureTheory.Measure.sum_cond /-
@[simp]
theorem sum_cond (Œº ŒΩ : Measure Œ±) : (sum fun b => cond b Œº ŒΩ) = Œº + ŒΩ :=
  sum_bool _
#align measure_theory.measure.sum_cond MeasureTheory.Measure.sum_cond
-/

/- warning: measure_theory.measure.restrict_sum -> MeasureTheory.Measure.restrict_sum is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : Œπ -> (MeasureTheory.Measure.{u1} Œ± m0)) {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 (MeasureTheory.Measure.sum.{u1, u2} Œ± Œπ m0 Œº) s) (MeasureTheory.Measure.sum.{u1, u2} Œ± Œπ m0 (fun (i : Œπ) => MeasureTheory.Measure.restrict.{u1} Œ± m0 (Œº i) s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} (Œº : Œπ -> (MeasureTheory.Measure.{u2} Œ± m0)) {s : Set.{u2} Œ±}, (MeasurableSet.{u2} Œ± m0 s) -> (Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ± m0) (MeasureTheory.Measure.restrict.{u2} Œ± m0 (MeasureTheory.Measure.sum.{u2, u1} Œ± Œπ m0 Œº) s) (MeasureTheory.Measure.sum.{u2, u1} Œ± Œπ m0 (fun (i : Œπ) => MeasureTheory.Measure.restrict.{u2} Œ± m0 (Œº i) s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_sum MeasureTheory.Measure.restrict_sum‚Çì'. -/
@[simp]
theorem restrict_sum (Œº : Œπ ‚Üí Measure Œ±) {s : Set Œ±} (hs : MeasurableSet s) :
    (sum Œº).restrict s = sum fun i => (Œº i).restrict s :=
  ext fun t ht => by simp only [sum_apply, restrict_apply, ht, ht.inter hs]
#align measure_theory.measure.restrict_sum MeasureTheory.Measure.restrict_sum

#print MeasureTheory.Measure.sum_of_empty /-
@[simp]
theorem sum_of_empty [IsEmpty Œπ] (Œº : Œπ ‚Üí Measure Œ±) : sum Œº = 0 := by
  rw [‚Üê measure_univ_eq_zero, sum_apply _ MeasurableSet.univ, tsum_empty]
#align measure_theory.measure.sum_of_empty MeasureTheory.Measure.sum_of_empty
-/

#print MeasureTheory.Measure.sum_add_sum_compl /-
theorem sum_add_sum_compl (s : Set Œπ) (Œº : Œπ ‚Üí Measure Œ±) :
    ((sum fun i : s => Œº i) + sum fun i : s·∂ú => Œº i) = sum Œº :=
  by
  ext1 t ht
  simp only [add_apply, sum_apply _ ht]
  exact @tsum_add_tsum_compl ‚Ñù‚â•0‚àû Œπ _ _ _ (fun i => Œº i t) _ s ENNReal.summable ENNReal.summable
#align measure_theory.measure.sum_add_sum_compl MeasureTheory.Measure.sum_add_sum_compl
-/

#print MeasureTheory.Measure.sum_congr /-
theorem sum_congr {Œº ŒΩ : ‚Ñï ‚Üí Measure Œ±} (h : ‚àÄ n, Œº n = ŒΩ n) : sum Œº = sum ŒΩ :=
  congr_arg sum (funext h)
#align measure_theory.measure.sum_congr MeasureTheory.Measure.sum_congr
-/

#print MeasureTheory.Measure.sum_add_sum /-
theorem sum_add_sum (Œº ŒΩ : ‚Ñï ‚Üí Measure Œ±) : sum Œº + sum ŒΩ = sum fun n => Œº n + ŒΩ n :=
  by
  ext1 s hs
  simp only [add_apply, sum_apply _ hs, Pi.add_apply, coe_add,
    tsum_add ENNReal.summable ENNReal.summable]
#align measure_theory.measure.sum_add_sum MeasureTheory.Measure.sum_add_sum
-/

#print MeasureTheory.Measure.map_eq_sum /-
/-- If `f` is a map with countable codomain, then `Œº.map f` is a sum of Dirac measures. -/
theorem map_eq_sum [Countable Œ≤] [MeasurableSingletonClass Œ≤] (Œº : Measure Œ±) (f : Œ± ‚Üí Œ≤)
    (hf : Measurable f) : Œº.map f = sum fun b : Œ≤ => Œº (f ‚Åª¬π' {b}) ‚Ä¢ dirac b :=
  by
  ext1 s hs
  have : ‚àÄ y ‚àà s, MeasurableSet (f ‚Åª¬π' {y}) := fun y _ => hf (measurable_set_singleton _)
  simp [‚Üê tsum_measure_preimage_singleton (to_countable s) this, *,
    tsum_subtype s fun b => Œº (f ‚Åª¬π' {b}), ‚Üê indicator_mul_right s fun b => Œº (f ‚Åª¬π' {b})]
#align measure_theory.measure.map_eq_sum MeasureTheory.Measure.map_eq_sum
-/

#print MeasureTheory.Measure.sum_smul_dirac /-
/-- A measure on a countable type is a sum of Dirac measures. -/
@[simp]
theorem sum_smul_dirac [Countable Œ±] [MeasurableSingletonClass Œ±] (Œº : Measure Œ±) :
    (sum fun a => Œº {a} ‚Ä¢ dirac a) = Œº := by simpa using (map_eq_sum Œº id measurable_id).symm
#align measure_theory.measure.sum_smul_dirac MeasureTheory.Measure.sum_smul_dirac
-/

/- warning: measure_theory.measure.tsum_indicator_apply_singleton -> MeasureTheory.Measure.tsum_indicator_apply_singleton is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : Countable.{succ u1} Œ±] [_inst_4 : MeasurableSingletonClass.{u1} Œ± m0] (Œº : MeasureTheory.Measure.{u1} Œ± m0) (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (tsum.{0, u1} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Œ± (fun (x : Œ±) => Set.indicator.{u1, 0} Œ± ENNReal ENNReal.hasZero s (fun (x : Œ±) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasSingleton.{u1} Œ±) x)) x)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : Countable.{succ u1} Œ±] [_inst_4 : MeasurableSingletonClass.{u1} Œ± m0] (Œº : MeasureTheory.Measure.{u1} Œ± m0) (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (tsum.{0, u1} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Œ± (fun (x : Œ±) => Set.indicator.{u1, 0} Œ± ENNReal instENNRealZero s (fun (x : Œ±) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instSingletonSet.{u1} Œ±) x)) x)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.tsum_indicator_apply_singleton MeasureTheory.Measure.tsum_indicator_apply_singleton‚Çì'. -/
/-- Given that `Œ±` is a countable, measurable space with all singleton sets measurable,
write the measure of a set `s` as the sum of the measure of `{x}` for all `x ‚àà s`. -/
theorem tsum_indicator_apply_singleton [Countable Œ±] [MeasurableSingletonClass Œ±] (Œº : Measure Œ±)
    (s : Set Œ±) (hs : MeasurableSet s) : (‚àë' x : Œ±, s.indicator (fun x => Œº {x}) x) = Œº s :=
  calc
    (‚àë' x : Œ±, s.indicator (fun x => Œº {x}) x) = Measure.sum (fun a => Œº {a} ‚Ä¢ Measure.dirac a) s :=
      by
      simp only [measure.sum_apply _ hs, measure.smul_apply, smul_eq_mul, measure.dirac_apply,
        Set.indicator_apply, mul_ite, Pi.one_apply, mul_one, MulZeroClass.mul_zero]
    _ = Œº s := by rw [Œº.sum_smul_dirac]
    
#align measure_theory.measure.tsum_indicator_apply_singleton MeasureTheory.Measure.tsum_indicator_apply_singleton

omit m0

end Sum

#print MeasureTheory.Measure.restrict_union·µ¢_ae /-
theorem restrict_union·µ¢_ae [Countable Œπ] {s : Œπ ‚Üí Set Œ±} (hd : Pairwise (AEDisjoint Œº on s))
    (hm : ‚àÄ i, NullMeasurableSet (s i) Œº) : Œº.restrict (‚ãÉ i, s i) = sum fun i => Œº.restrict (s i) :=
  ext fun t ht => by simp only [sum_apply _ ht, restrict_Union_apply_ae hd hm ht]
#align measure_theory.measure.restrict_Union_ae MeasureTheory.Measure.restrict_union·µ¢_ae
-/

/- warning: measure_theory.measure.restrict_Union -> MeasureTheory.Measure.restrict_union·µ¢ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Countable.{succ u2} Œπ] {s : Œπ -> (Set.{u1} Œ±)}, (Pairwise.{u2} Œπ (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)))) s)) -> (forall (i : Œπ), MeasurableSet.{u1} Œ± m0 (s i)) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => s i))) (MeasureTheory.Measure.sum.{u1, u2} Œ± Œπ m0 (fun (i : Œπ) => MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Countable.{succ u2} Œπ] {s : Œπ -> (Set.{u1} Œ±)}, (Pairwise.{u2} Œπ (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))))) s)) -> (forall (i : Œπ), MeasurableSet.{u1} Œ± m0 (s i)) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => s i))) (MeasureTheory.Measure.sum.{u1, u2} Œ± Œπ m0 (fun (i : Œπ) => MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_Union MeasureTheory.Measure.restrict_union·µ¢‚Çì'. -/
theorem restrict_union·µ¢ [Countable Œπ] {s : Œπ ‚Üí Set Œ±} (hd : Pairwise (Disjoint on s))
    (hm : ‚àÄ i, MeasurableSet (s i)) : Œº.restrict (‚ãÉ i, s i) = sum fun i => Œº.restrict (s i) :=
  restrict_union·µ¢_ae hd.AEDisjoint fun i => (hm i).NullMeasurableSet
#align measure_theory.measure.restrict_Union MeasureTheory.Measure.restrict_union·µ¢

#print MeasureTheory.Measure.restrict_union·µ¢_le /-
theorem restrict_union·µ¢_le [Countable Œπ] {s : Œπ ‚Üí Set Œ±} :
    Œº.restrict (‚ãÉ i, s i) ‚â§ sum fun i => Œº.restrict (s i) :=
  by
  intro t ht
  suffices Œº (‚ãÉ i, t ‚à© s i) ‚â§ ‚àë' i, Œº (t ‚à© s i) by simpa [ht, inter_Union]
  apply measure_Union_le
#align measure_theory.measure.restrict_Union_le MeasureTheory.Measure.restrict_union·µ¢_le
-/

section Count

variable [MeasurableSpace Œ±]

#print MeasureTheory.Measure.count /-
/-- Counting measure on any measurable space. -/
def count : Measure Œ± :=
  sum dirac
#align measure_theory.measure.count MeasureTheory.Measure.count
-/

/- warning: measure_theory.measure.le_count_apply -> MeasureTheory.Measure.le_count_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±], LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (tsum.{0, u1} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (fun (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) => OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.count.{u1} Œ± _inst_3) s)
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±], LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (tsum.{0, u1} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal (Set.Elem.{u1} Œ± s) (fun (i : Set.Elem.{u1} Œ± s) => OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.count.{u1} Œ± _inst_3)) s)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.le_count_apply MeasureTheory.Measure.le_count_apply‚Çì'. -/
theorem le_count_apply : (‚àë' i : s, 1 : ‚Ñù‚â•0‚àû) ‚â§ count s :=
  calc
    (‚àë' i : s, 1 : ‚Ñù‚â•0‚àû) = ‚àë' i, indicator s 1 i := tsum_subtype s 1
    _ ‚â§ ‚àë' i, dirac i s := (ENNReal.tsum_le_tsum fun x => le_dirac_apply)
    _ ‚â§ count s := le_sum_apply _ _
    
#align measure_theory.measure.le_count_apply MeasureTheory.Measure.le_count_apply

/- warning: measure_theory.measure.count_apply -> MeasureTheory.Measure.count_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±], (MeasurableSet.{u1} Œ± _inst_3 s) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.count.{u1} Œ± _inst_3) s) (tsum.{0, u1} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (fun (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) => OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))))
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±], (MeasurableSet.{u1} Œ± _inst_3 s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.count.{u1} Œ± _inst_3)) s) (tsum.{0, u1} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal (Set.Elem.{u1} Œ± s) (fun (i : Set.Elem.{u1} Œ± s) => OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.count_apply MeasureTheory.Measure.count_apply‚Çì'. -/
theorem count_apply (hs : MeasurableSet s) : count s = ‚àë' i : s, 1 := by
  simp only [count, sum_apply, hs, dirac_apply', ‚Üê tsum_subtype s 1, Pi.one_apply]
#align measure_theory.measure.count_apply MeasureTheory.Measure.count_apply

/- warning: measure_theory.measure.count_empty -> MeasureTheory.Measure.count_empty is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_3 : MeasurableSpace.{u1} Œ±], Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.count.{u1} Œ± _inst_3) (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.hasEmptyc.{u1} Œ±))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_3 : MeasurableSpace.{u1} Œ±], Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.count.{u1} Œ± _inst_3)) (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.instEmptyCollectionSet.{u1} Œ±))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.count_empty MeasureTheory.Measure.count_empty‚Çì'. -/
@[simp]
theorem count_empty : count (‚àÖ : Set Œ±) = 0 := by rw [count_apply MeasurableSet.empty, tsum_empty]
#align measure_theory.measure.count_empty MeasureTheory.Measure.count_empty

#print MeasureTheory.Measure.count_apply_finset' /-
@[simp]
theorem count_apply_finset' {s : Finset Œ±} (s_mble : MeasurableSet (s : Set Œ±)) :
    count (‚Üës : Set Œ±) = s.card :=
  calc
    count (‚Üës : Set Œ±) = ‚àë' i : (‚Üës : Set Œ±), 1 := count_apply s_mble
    _ = ‚àë i in s, 1 := (s.tsum_subtype 1)
    _ = s.card := by simp
    
#align measure_theory.measure.count_apply_finset' MeasureTheory.Measure.count_apply_finset'
-/

#print MeasureTheory.Measure.count_apply_finset /-
@[simp]
theorem count_apply_finset [MeasurableSingletonClass Œ±] (s : Finset Œ±) :
    count (‚Üës : Set Œ±) = s.card :=
  count_apply_finset' s.MeasurableSet
#align measure_theory.measure.count_apply_finset MeasureTheory.Measure.count_apply_finset
-/

#print MeasureTheory.Measure.count_apply_finite' /-
theorem count_apply_finite' {s : Set Œ±} (s_fin : s.Finite) (s_mble : MeasurableSet s) :
    count s = s_fin.toFinset.card := by
  simp [‚Üê
    @count_apply_finset' _ _ s_fin.to_finset (by simpa only [finite.coe_to_finset] using s_mble)]
#align measure_theory.measure.count_apply_finite' MeasureTheory.Measure.count_apply_finite'
-/

#print MeasureTheory.Measure.count_apply_finite /-
theorem count_apply_finite [MeasurableSingletonClass Œ±] (s : Set Œ±) (hs : s.Finite) :
    count s = hs.toFinset.card := by rw [‚Üê count_apply_finset, finite.coe_to_finset]
#align measure_theory.measure.count_apply_finite MeasureTheory.Measure.count_apply_finite
-/

/- warning: measure_theory.measure.count_apply_infinite -> MeasureTheory.Measure.count_apply_infinite is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±], (Set.Infinite.{u1} Œ± s) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.count.{u1} Œ± _inst_3) s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±], (Set.Infinite.{u1} Œ± s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.count.{u1} Œ± _inst_3)) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.count_apply_infinite MeasureTheory.Measure.count_apply_infinite‚Çì'. -/
/-- `count` measure evaluates to infinity at infinite sets. -/
theorem count_apply_infinite (hs : s.Infinite) : count s = ‚àû :=
  by
  refine' top_unique (le_of_tendsto' ENNReal.tendsto_nat_nhds_top fun n => _)
  rcases hs.exists_subset_card_eq n with ‚ü®t, ht, rfl‚ü©
  calc
    (t.card : ‚Ñù‚â•0‚àû) = ‚àë i in t, 1 := by simp
    _ = ‚àë' i : (t : Set Œ±), 1 := (t.tsum_subtype 1).symm
    _ ‚â§ count (t : Set Œ±) := le_count_apply
    _ ‚â§ count s := measure_mono ht
    
#align measure_theory.measure.count_apply_infinite MeasureTheory.Measure.count_apply_infinite

/- warning: measure_theory.measure.count_apply_eq_top' -> MeasureTheory.Measure.count_apply_eq_top' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±], (MeasurableSet.{u1} Œ± _inst_3 s) -> (Iff (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.count.{u1} Œ± _inst_3) s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) (Set.Infinite.{u1} Œ± s))
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±], (MeasurableSet.{u1} Œ± _inst_3 s) -> (Iff (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.count.{u1} Œ± _inst_3)) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) (Set.Infinite.{u1} Œ± s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.count_apply_eq_top' MeasureTheory.Measure.count_apply_eq_top'‚Çì'. -/
@[simp]
theorem count_apply_eq_top' (s_mble : MeasurableSet s) : count s = ‚àû ‚Üî s.Infinite :=
  by
  by_cases hs : s.finite
  ¬∑ simp [Set.Infinite, hs, count_apply_finite' hs s_mble]
  ¬∑ change s.infinite at hs
    simp [hs, count_apply_infinite]
#align measure_theory.measure.count_apply_eq_top' MeasureTheory.Measure.count_apply_eq_top'

/- warning: measure_theory.measure.count_apply_eq_top -> MeasureTheory.Measure.count_apply_eq_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±] [_inst_4 : MeasurableSingletonClass.{u1} Œ± _inst_3], Iff (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.count.{u1} Œ± _inst_3) s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) (Set.Infinite.{u1} Œ± s)
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±] [_inst_4 : MeasurableSingletonClass.{u1} Œ± _inst_3], Iff (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.count.{u1} Œ± _inst_3)) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) (Set.Infinite.{u1} Œ± s)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.count_apply_eq_top MeasureTheory.Measure.count_apply_eq_top‚Çì'. -/
@[simp]
theorem count_apply_eq_top [MeasurableSingletonClass Œ±] : count s = ‚àû ‚Üî s.Infinite :=
  by
  by_cases hs : s.finite
  ¬∑ exact count_apply_eq_top' hs.measurable_set
  ¬∑ change s.infinite at hs
    simp [hs, count_apply_infinite]
#align measure_theory.measure.count_apply_eq_top MeasureTheory.Measure.count_apply_eq_top

/- warning: measure_theory.measure.count_apply_lt_top' -> MeasureTheory.Measure.count_apply_lt_top' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±], (MeasurableSet.{u1} Œ± _inst_3 s) -> (Iff (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.count.{u1} Œ± _inst_3) s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) (Set.Finite.{u1} Œ± s))
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±], (MeasurableSet.{u1} Œ± _inst_3 s) -> (Iff (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.count.{u1} Œ± _inst_3)) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) (Set.Finite.{u1} Œ± s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.count_apply_lt_top' MeasureTheory.Measure.count_apply_lt_top'‚Çì'. -/
@[simp]
theorem count_apply_lt_top' (s_mble : MeasurableSet s) : count s < ‚àû ‚Üî s.Finite :=
  calc
    count s < ‚àû ‚Üî count s ‚â† ‚àû := lt_top_iff_ne_top
    _ ‚Üî ¬¨s.Infinite := (not_congr (count_apply_eq_top' s_mble))
    _ ‚Üî s.Finite := Classical.not_not
    
#align measure_theory.measure.count_apply_lt_top' MeasureTheory.Measure.count_apply_lt_top'

/- warning: measure_theory.measure.count_apply_lt_top -> MeasureTheory.Measure.count_apply_lt_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±] [_inst_4 : MeasurableSingletonClass.{u1} Œ± _inst_3], Iff (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.count.{u1} Œ± _inst_3) s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) (Set.Finite.{u1} Œ± s)
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±] [_inst_4 : MeasurableSingletonClass.{u1} Œ± _inst_3], Iff (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.count.{u1} Œ± _inst_3)) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) (Set.Finite.{u1} Œ± s)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.count_apply_lt_top MeasureTheory.Measure.count_apply_lt_top‚Çì'. -/
@[simp]
theorem count_apply_lt_top [MeasurableSingletonClass Œ±] : count s < ‚àû ‚Üî s.Finite :=
  calc
    count s < ‚àû ‚Üî count s ‚â† ‚àû := lt_top_iff_ne_top
    _ ‚Üî ¬¨s.Infinite := (not_congr count_apply_eq_top)
    _ ‚Üî s.Finite := Classical.not_not
    
#align measure_theory.measure.count_apply_lt_top MeasureTheory.Measure.count_apply_lt_top

/- warning: measure_theory.measure.empty_of_count_eq_zero' -> MeasureTheory.Measure.empty_of_count_eq_zero' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±], (MeasurableSet.{u1} Œ± _inst_3 s) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.count.{u1} Œ± _inst_3) s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{succ u1} (Set.{u1} Œ±) s (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.hasEmptyc.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±], (MeasurableSet.{u1} Œ± _inst_3 s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.count.{u1} Œ± _inst_3)) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{succ u1} (Set.{u1} Œ±) s (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.instEmptyCollectionSet.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.empty_of_count_eq_zero' MeasureTheory.Measure.empty_of_count_eq_zero'‚Çì'. -/
theorem empty_of_count_eq_zero' (s_mble : MeasurableSet s) (hsc : count s = 0) : s = ‚àÖ :=
  by
  have hs : s.finite := by
    rw [‚Üê count_apply_lt_top' s_mble, hsc]
    exact WithTop.zero_lt_top
  simpa [count_apply_finite' hs s_mble] using hsc
#align measure_theory.measure.empty_of_count_eq_zero' MeasureTheory.Measure.empty_of_count_eq_zero'

/- warning: measure_theory.measure.empty_of_count_eq_zero -> MeasureTheory.Measure.empty_of_count_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±] [_inst_4 : MeasurableSingletonClass.{u1} Œ± _inst_3], (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.count.{u1} Œ± _inst_3) s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{succ u1} (Set.{u1} Œ±) s (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.hasEmptyc.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±] [_inst_4 : MeasurableSingletonClass.{u1} Œ± _inst_3], (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.count.{u1} Œ± _inst_3)) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{succ u1} (Set.{u1} Œ±) s (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.instEmptyCollectionSet.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.empty_of_count_eq_zero MeasureTheory.Measure.empty_of_count_eq_zero‚Çì'. -/
theorem empty_of_count_eq_zero [MeasurableSingletonClass Œ±] (hsc : count s = 0) : s = ‚àÖ :=
  by
  have hs : s.finite := by
    rw [‚Üê count_apply_lt_top, hsc]
    exact WithTop.zero_lt_top
  simpa [count_apply_finite _ hs] using hsc
#align measure_theory.measure.empty_of_count_eq_zero MeasureTheory.Measure.empty_of_count_eq_zero

/- warning: measure_theory.measure.count_eq_zero_iff' -> MeasureTheory.Measure.count_eq_zero_iff' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±], (MeasurableSet.{u1} Œ± _inst_3 s) -> (Iff (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.count.{u1} Œ± _inst_3) s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) (Eq.{succ u1} (Set.{u1} Œ±) s (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.hasEmptyc.{u1} Œ±))))
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±], (MeasurableSet.{u1} Œ± _inst_3 s) -> (Iff (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.count.{u1} Œ± _inst_3)) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) (Eq.{succ u1} (Set.{u1} Œ±) s (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.instEmptyCollectionSet.{u1} Œ±))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.count_eq_zero_iff' MeasureTheory.Measure.count_eq_zero_iff'‚Çì'. -/
@[simp]
theorem count_eq_zero_iff' (s_mble : MeasurableSet s) : count s = 0 ‚Üî s = ‚àÖ :=
  ‚ü®empty_of_count_eq_zero' s_mble, fun h => h.symm ‚ñ∏ count_empty‚ü©
#align measure_theory.measure.count_eq_zero_iff' MeasureTheory.Measure.count_eq_zero_iff'

/- warning: measure_theory.measure.count_eq_zero_iff -> MeasureTheory.Measure.count_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±] [_inst_4 : MeasurableSingletonClass.{u1} Œ± _inst_3], Iff (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.count.{u1} Œ± _inst_3) s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) (Eq.{succ u1} (Set.{u1} Œ±) s (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.hasEmptyc.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±] [_inst_4 : MeasurableSingletonClass.{u1} Œ± _inst_3], Iff (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.count.{u1} Œ± _inst_3)) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) (Eq.{succ u1} (Set.{u1} Œ±) s (EmptyCollection.emptyCollection.{u1} (Set.{u1} Œ±) (Set.instEmptyCollectionSet.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.count_eq_zero_iff MeasureTheory.Measure.count_eq_zero_iff‚Çì'. -/
@[simp]
theorem count_eq_zero_iff [MeasurableSingletonClass Œ±] : count s = 0 ‚Üî s = ‚àÖ :=
  ‚ü®empty_of_count_eq_zero, fun h => h.symm ‚ñ∏ count_empty‚ü©
#align measure_theory.measure.count_eq_zero_iff MeasureTheory.Measure.count_eq_zero_iff

/- warning: measure_theory.measure.count_ne_zero' -> MeasureTheory.Measure.count_ne_zero' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±], (Set.Nonempty.{u1} Œ± s) -> (MeasurableSet.{u1} Œ± _inst_3 s) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.count.{u1} Œ± _inst_3) s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±], (Set.Nonempty.{u1} Œ± s) -> (MeasurableSet.{u1} Œ± _inst_3 s) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.count.{u1} Œ± _inst_3)) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.count_ne_zero' MeasureTheory.Measure.count_ne_zero'‚Çì'. -/
theorem count_ne_zero' (hs' : s.Nonempty) (s_mble : MeasurableSet s) : count s ‚â† 0 :=
  by
  rw [Ne.def, count_eq_zero_iff' s_mble]
  exact hs'.ne_empty
#align measure_theory.measure.count_ne_zero' MeasureTheory.Measure.count_ne_zero'

/- warning: measure_theory.measure.count_ne_zero -> MeasureTheory.Measure.count_ne_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±] [_inst_4 : MeasurableSingletonClass.{u1} Œ± _inst_3], (Set.Nonempty.{u1} Œ± s) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.count.{u1} Œ± _inst_3) s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} {s : Set.{u1} Œ±} [_inst_3 : MeasurableSpace.{u1} Œ±] [_inst_4 : MeasurableSingletonClass.{u1} Œ± _inst_3], (Set.Nonempty.{u1} Œ± s) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 (MeasureTheory.Measure.count.{u1} Œ± _inst_3)) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.count_ne_zero MeasureTheory.Measure.count_ne_zero‚Çì'. -/
theorem count_ne_zero [MeasurableSingletonClass Œ±] (hs' : s.Nonempty) : count s ‚â† 0 :=
  by
  rw [Ne.def, count_eq_zero_iff]
  exact hs'.ne_empty
#align measure_theory.measure.count_ne_zero MeasureTheory.Measure.count_ne_zero

#print MeasureTheory.Measure.count_singleton' /-
@[simp]
theorem count_singleton' {a : Œ±} (ha : MeasurableSet ({a} : Set Œ±)) : count ({a} : Set Œ±) = 1 :=
  by
  rw [count_apply_finite' (Set.finite_singleton a) ha, Set.Finite.toFinset]
  simp
#align measure_theory.measure.count_singleton' MeasureTheory.Measure.count_singleton'
-/

#print MeasureTheory.Measure.count_singleton /-
@[simp]
theorem count_singleton [MeasurableSingletonClass Œ±] (a : Œ±) : count ({a} : Set Œ±) = 1 :=
  count_singleton' (measurableSet_singleton a)
#align measure_theory.measure.count_singleton MeasureTheory.Measure.count_singleton
-/

#print MeasureTheory.Measure.count_injective_image' /-
theorem count_injective_image' {f : Œ≤ ‚Üí Œ±} (hf : Function.Injective f) {s : Set Œ≤}
    (s_mble : MeasurableSet s) (fs_mble : MeasurableSet (f '' s)) : count (f '' s) = count s :=
  by
  by_cases hs : s.finite
  ¬∑ lift s to Finset Œ≤ using hs
    rw [‚Üê Finset.coe_image, count_apply_finset' _, count_apply_finset' s_mble,
      s.card_image_of_injective hf]
    simpa only [Finset.coe_image] using fs_mble
  rw [count_apply_infinite hs]
  rw [‚Üê finite_image_iff <| hf.inj_on _] at hs
  rw [count_apply_infinite hs]
#align measure_theory.measure.count_injective_image' MeasureTheory.Measure.count_injective_image'
-/

/- warning: measure_theory.measure.count_injective_image -> MeasureTheory.Measure.count_injective_image is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u2} Œ≤] [_inst_3 : MeasurableSpace.{u1} Œ±] [_inst_4 : MeasurableSingletonClass.{u1} Œ± _inst_3] [_inst_5 : MeasurableSingletonClass.{u2} Œ≤ _inst_1] {f : Œ≤ -> Œ±}, (Function.Injective.{succ u2, succ u1} Œ≤ Œ± f) -> (forall (s : Set.{u2} Œ≤), Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) (MeasureTheory.Measure.count.{u1} Œ± _inst_3) (Set.image.{u2, u1} Œ≤ Œ± f s)) (coeFn.{succ u2, succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (fun (_x : MeasureTheory.Measure.{u2} Œ≤ _inst_1) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u2} Œ≤ _inst_1) (MeasureTheory.Measure.count.{u2} Œ≤ _inst_1) s))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ≤] [_inst_3 : MeasurableSpace.{u2} Œ±] [_inst_4 : MeasurableSingletonClass.{u2} Œ± _inst_3] [_inst_5 : MeasurableSingletonClass.{u1} Œ≤ _inst_1] {f : Œ≤ -> Œ±}, (Function.Injective.{succ u1, succ u2} Œ≤ Œ± f) -> (forall (s : Set.{u1} Œ≤), Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± _inst_3 (MeasureTheory.Measure.count.{u2} Œ± _inst_3)) (Set.image.{u1, u2} Œ≤ Œ± f s)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ≤ (MeasureTheory.Measure.toOuterMeasure.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.count.{u1} Œ≤ _inst_1)) s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.count_injective_image MeasureTheory.Measure.count_injective_image‚Çì'. -/
theorem count_injective_image [MeasurableSingletonClass Œ±] [MeasurableSingletonClass Œ≤] {f : Œ≤ ‚Üí Œ±}
    (hf : Function.Injective f) (s : Set Œ≤) : count (f '' s) = count s :=
  by
  by_cases hs : s.finite
  ¬∑ exact count_injective_image' hf hs.measurable_set (finite.image f hs).MeasurableSet
  rw [count_apply_infinite hs]
  rw [‚Üê finite_image_iff <| hf.inj_on _] at hs
  rw [count_apply_infinite hs]
#align measure_theory.measure.count_injective_image MeasureTheory.Measure.count_injective_image

end Count

/-! ### Absolute continuity -/


#print MeasureTheory.Measure.AbsolutelyContinuous /-
/-- We say that `Œº` is absolutely continuous with respect to `ŒΩ`, or that `Œº` is dominated by `ŒΩ`,
  if `ŒΩ(A) = 0` implies that `Œº(A) = 0`. -/
def AbsolutelyContinuous {m0 : MeasurableSpace Œ±} (Œº ŒΩ : Measure Œ±) : Prop :=
  ‚àÄ ‚¶És : Set Œ±‚¶Ñ, ŒΩ s = 0 ‚Üí Œº s = 0
#align measure_theory.measure.absolutely_continuous MeasureTheory.Measure.AbsolutelyContinuous
-/

-- mathport name: measure.absolutely_continuous
scoped[MeasureTheory] infixl:50 " ‚â™ " => MeasureTheory.Measure.AbsolutelyContinuous

#print MeasureTheory.Measure.absolutelyContinuous_of_le /-
theorem absolutelyContinuous_of_le (h : Œº ‚â§ ŒΩ) : Œº ‚â™ ŒΩ := fun s hs =>
  nonpos_iff_eq_zero.1 <| hs ‚ñ∏ le_iff'.1 h s
#align measure_theory.measure.absolutely_continuous_of_le MeasureTheory.Measure.absolutelyContinuous_of_le
-/

alias absolutely_continuous_of_le ‚Üê _root_.has_le.le.absolutely_continuous
#align has_le.le.absolutely_continuous LE.le.absolutelyContinuous

#print MeasureTheory.Measure.absolutelyContinuous_of_eq /-
theorem absolutelyContinuous_of_eq (h : Œº = ŒΩ) : Œº ‚â™ ŒΩ :=
  h.le.AbsolutelyContinuous
#align measure_theory.measure.absolutely_continuous_of_eq MeasureTheory.Measure.absolutelyContinuous_of_eq
-/

alias absolutely_continuous_of_eq ‚Üê _root_.eq.absolutely_continuous
#align eq.absolutely_continuous Eq.absolutelyContinuous

namespace AbsolutelyContinuous

/- warning: measure_theory.measure.absolutely_continuous.mk -> MeasureTheory.Measure.AbsolutelyContinuous.mk is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, (forall {{s : Set.{u1} Œ±}}, (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) ŒΩ s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))) -> (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œº ŒΩ)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, (forall {{s : Set.{u1} Œ±}}, (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 ŒΩ) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))) -> (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œº ŒΩ)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.absolutely_continuous.mk MeasureTheory.Measure.AbsolutelyContinuous.mk‚Çì'. -/
theorem mk (h : ‚àÄ ‚¶És : Set Œ±‚¶Ñ, MeasurableSet s ‚Üí ŒΩ s = 0 ‚Üí Œº s = 0) : Œº ‚â™ ŒΩ :=
  by
  intro s hs
  rcases exists_measurable_superset_of_null hs with ‚ü®t, h1t, h2t, h3t‚ü©
  exact measure_mono_null h1t (h h2t h3t)
#align measure_theory.measure.absolutely_continuous.mk MeasureTheory.Measure.AbsolutelyContinuous.mk

#print MeasureTheory.Measure.AbsolutelyContinuous.refl /-
@[refl]
protected theorem refl {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) : Œº ‚â™ Œº :=
  rfl.AbsolutelyContinuous
#align measure_theory.measure.absolutely_continuous.refl MeasureTheory.Measure.AbsolutelyContinuous.refl
-/

#print MeasureTheory.Measure.AbsolutelyContinuous.rfl /-
protected theorem rfl : Œº ‚â™ Œº := fun s hs => hs
#align measure_theory.measure.absolutely_continuous.rfl MeasureTheory.Measure.AbsolutelyContinuous.rfl
-/

instance [MeasurableSpace Œ±] : IsRefl (Measure Œ±) (¬∑ ‚â™ ¬∑) :=
  ‚ü®fun Œº => AbsolutelyContinuous.rfl‚ü©

#print MeasureTheory.Measure.AbsolutelyContinuous.trans /-
@[trans]
protected theorem trans (h1 : Œº‚ÇÅ ‚â™ Œº‚ÇÇ) (h2 : Œº‚ÇÇ ‚â™ Œº‚ÇÉ) : Œº‚ÇÅ ‚â™ Œº‚ÇÉ := fun s hs => h1 <| h2 hs
#align measure_theory.measure.absolutely_continuous.trans MeasureTheory.Measure.AbsolutelyContinuous.trans
-/

/- warning: measure_theory.measure.absolutely_continuous.map -> MeasureTheory.Measure.AbsolutelyContinuous.map is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œº ŒΩ) -> (forall {f : Œ± -> Œ≤}, (Measurable.{u1, u2} Œ± Œ≤ m0 _inst_1 f) -> (MeasureTheory.Measure.AbsolutelyContinuous.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f ŒΩ)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u2} Œ± m0}, (MeasureTheory.Measure.AbsolutelyContinuous.{u2} Œ± m0 Œº ŒΩ) -> (forall {f : Œ± -> Œ≤}, (Measurable.{u2, u1} Œ± Œ≤ m0 _inst_1 f) -> (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f ŒΩ)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.absolutely_continuous.map MeasureTheory.Measure.AbsolutelyContinuous.map‚Çì'. -/
@[mono]
protected theorem map (h : Œº ‚â™ ŒΩ) {f : Œ± ‚Üí Œ≤} (hf : Measurable f) : Œº.map f ‚â™ ŒΩ.map f :=
  AbsolutelyContinuous.mk fun s hs => by simpa [hf, hs] using @h _
#align measure_theory.measure.absolutely_continuous.map MeasureTheory.Measure.AbsolutelyContinuous.map

/- warning: measure_theory.measure.absolutely_continuous.smul -> MeasureTheory.Measure.AbsolutelyContinuous.smul is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {R : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Monoid.{u2} R] [_inst_4 : DistribMulAction.{u2, 0} R ENNReal _inst_3 (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))] [_inst_5 : IsScalarTower.{u2, 0, 0} R ENNReal ENNReal (SMulZeroClass.toHasSmul.{u2, 0} R ENNReal (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))) (DistribSMul.toSmulZeroClass.{u2, 0} R ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))) (DistribMulAction.toDistribSMul.{u2, 0} R ENNReal _inst_3 (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)) _inst_4))) (Mul.toSMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (SMulZeroClass.toHasSmul.{u2, 0} R ENNReal (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))) (DistribSMul.toSmulZeroClass.{u2, 0} R ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))) (DistribMulAction.toDistribSMul.{u2, 0} R ENNReal _inst_3 (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)) _inst_4)))], (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œº ŒΩ) -> (forall (c : R), MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 (SMul.smul.{u2, u1} R (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, u2} Œ± R (SMulZeroClass.toHasSmul.{u2, 0} R ENNReal (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))) (DistribSMul.toSmulZeroClass.{u2, 0} R ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))) (DistribMulAction.toDistribSMul.{u2, 0} R ENNReal _inst_3 (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)) _inst_4))) _inst_5 m0) c Œº) ŒΩ)
but is expected to have type
  forall {Œ± : Type.{u1}} {R : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Monoid.{u2} R] [_inst_4 : DistribMulAction.{u2, 0} R ENNReal _inst_3 (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal instENNRealAddCommMonoidWithOne))] [_inst_5 : IsScalarTower.{u2, 0, 0} R ENNReal ENNReal (SMulZeroClass.toSMul.{u2, 0} R ENNReal instENNRealZero (DistribSMul.toSMulZeroClass.{u2, 0} R ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal instENNRealAddCommMonoidWithOne))) (DistribMulAction.toDistribSMul.{u2, 0} R ENNReal _inst_3 (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal instENNRealAddCommMonoidWithOne)) _inst_4))) (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (SMulZeroClass.toSMul.{u2, 0} R ENNReal instENNRealZero (DistribSMul.toSMulZeroClass.{u2, 0} R ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal instENNRealAddCommMonoidWithOne))) (DistribMulAction.toDistribSMul.{u2, 0} R ENNReal _inst_3 (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal instENNRealAddCommMonoidWithOne)) _inst_4)))], (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œº ŒΩ) -> (forall (c : R), MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 (HSMul.hSMul.{u2, u1, u1} R (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHSMul.{u2, u1} R (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, u2} Œ± R (SMulZeroClass.toSMul.{u2, 0} R ENNReal instENNRealZero (DistribSMul.toSMulZeroClass.{u2, 0} R ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal instENNRealAddCommMonoidWithOne))) (DistribMulAction.toDistribSMul.{u2, 0} R ENNReal _inst_3 (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal instENNRealAddCommMonoidWithOne)) _inst_4))) _inst_5 m0)) c Œº) ŒΩ)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.absolutely_continuous.smul MeasureTheory.Measure.AbsolutelyContinuous.smul‚Çì'. -/
protected theorem smul [Monoid R] [DistribMulAction R ‚Ñù‚â•0‚àû] [IsScalarTower R ‚Ñù‚â•0‚àû ‚Ñù‚â•0‚àû] (h : Œº ‚â™ ŒΩ)
    (c : R) : c ‚Ä¢ Œº ‚â™ ŒΩ := fun s hŒΩs => by simp only [h hŒΩs, smul_eq_mul, smul_apply, smul_zero]
#align measure_theory.measure.absolutely_continuous.smul MeasureTheory.Measure.AbsolutelyContinuous.smul

end AbsolutelyContinuous

/- warning: measure_theory.measure.absolutely_continuous_of_le_smul -> MeasureTheory.Measure.absolutelyContinuous_of_le_smul is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {Œº' : MeasureTheory.Measure.{u1} Œ± m0} {c : ENNReal}, (LE.le.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº' (SMul.smul.{0, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± ENNReal (SMulZeroClass.toHasSmul.{0, 0} ENNReal ENNReal (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (SMulWithZero.toSmulZeroClass.{0, 0} ENNReal ENNReal (MulZeroClass.toHasZero.{0} ENNReal (MulZeroOneClass.toMulZeroClass.{0} ENNReal (MonoidWithZero.toMulZeroOneClass.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (MulActionWithZero.toSMulWithZero.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (Module.toMulActionWithZero.{0, 0} ENNReal ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Algebra.toModule.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) m0) c Œº)) -> (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œº' Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {Œº' : MeasureTheory.Measure.{u1} Œ± m0} {c : ENNReal}, (LE.le.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº' (HSMul.hSMul.{0, u1, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHSMul.{0, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± ENNReal (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0)) c Œº)) -> (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œº' Œº)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.absolutely_continuous_of_le_smul MeasureTheory.Measure.absolutelyContinuous_of_le_smul‚Çì'. -/
theorem absolutelyContinuous_of_le_smul {Œº' : Measure Œ±} {c : ‚Ñù‚â•0‚àû} (hŒº'_le : Œº' ‚â§ c ‚Ä¢ Œº) :
    Œº' ‚â™ Œº :=
  (Measure.absolutelyContinuous_of_le hŒº'_le).trans (Measure.AbsolutelyContinuous.rfl.smul c)
#align measure_theory.measure.absolutely_continuous_of_le_smul MeasureTheory.Measure.absolutelyContinuous_of_le_smul

/- warning: measure_theory.measure.ae_le_iff_absolutely_continuous -> MeasureTheory.Measure.ae_le_iff_absolutelyContinuous is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (MeasureTheory.Measure.ae.{u1} Œ± m0 ŒΩ)) (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œº ŒΩ)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, Iff (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (MeasureTheory.Measure.ae.{u1} Œ± m0 ŒΩ)) (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œº ŒΩ)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.ae_le_iff_absolutely_continuous MeasureTheory.Measure.ae_le_iff_absolutelyContinuous‚Çì'. -/
theorem ae_le_iff_absolutelyContinuous : Œº.ae ‚â§ ŒΩ.ae ‚Üî Œº ‚â™ ŒΩ :=
  ‚ü®fun h s => by
    rw [measure_zero_iff_ae_nmem, measure_zero_iff_ae_nmem]
    exact fun hs => h hs, fun h s hs => h hs‚ü©
#align measure_theory.measure.ae_le_iff_absolutely_continuous MeasureTheory.Measure.ae_le_iff_absolutelyContinuous

/- warning: has_le.le.absolutely_continuous_of_ae -> LE.le.absolutelyContinuous_of_ae is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (MeasureTheory.Measure.ae.{u1} Œ± m0 ŒΩ)) -> (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œº ŒΩ)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (MeasureTheory.Measure.ae.{u1} Œ± m0 ŒΩ)) -> (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œº ŒΩ)
Case conversion may be inaccurate. Consider using '#align has_le.le.absolutely_continuous_of_ae LE.le.absolutelyContinuous_of_ae‚Çì'. -/
/- warning: measure_theory.measure.absolutely_continuous.ae_le -> MeasureTheory.Measure.AbsolutelyContinuous.ae_le is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œº ŒΩ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (MeasureTheory.Measure.ae.{u1} Œ± m0 ŒΩ))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œº ŒΩ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (MeasureTheory.Measure.ae.{u1} Œ± m0 ŒΩ))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.absolutely_continuous.ae_le MeasureTheory.Measure.AbsolutelyContinuous.ae_le‚Çì'. -/
alias ae_le_iff_absolutely_continuous ‚Üî
  _root_.has_le.le.absolutely_continuous_of_ae absolutely_continuous.ae_le
#align has_le.le.absolutely_continuous_of_ae LE.le.absolutelyContinuous_of_ae
#align measure_theory.measure.absolutely_continuous.ae_le MeasureTheory.Measure.AbsolutelyContinuous.ae_le

/- warning: measure_theory.measure.ae_mono' -> MeasureTheory.Measure.ae_mono' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œº ŒΩ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (MeasureTheory.Measure.ae.{u1} Œ± m0 ŒΩ))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œº ŒΩ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (MeasureTheory.Measure.ae.{u1} Œ± m0 ŒΩ))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.ae_mono' MeasureTheory.Measure.ae_mono'‚Çì'. -/
alias absolutely_continuous.ae_le ‚Üê ae_mono'
#align measure_theory.measure.ae_mono' MeasureTheory.Measure.ae_mono'

/- warning: measure_theory.measure.absolutely_continuous.ae_eq -> MeasureTheory.Measure.AbsolutelyContinuous.ae_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œº ŒΩ) -> (forall {f : Œ± -> Œ¥} {g : Œ± -> Œ¥}, (Filter.EventuallyEq.{u1, u2} Œ± Œ¥ (MeasureTheory.Measure.ae.{u1} Œ± m0 ŒΩ) f g) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ¥ (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) f g))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ¥ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} {Œº : MeasureTheory.Measure.{u2} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u2} Œ± m0}, (MeasureTheory.Measure.AbsolutelyContinuous.{u2} Œ± m0 Œº ŒΩ) -> (forall {f : Œ± -> Œ¥} {g : Œ± -> Œ¥}, (Filter.EventuallyEq.{u2, u1} Œ± Œ¥ (MeasureTheory.Measure.ae.{u2} Œ± m0 ŒΩ) f g) -> (Filter.EventuallyEq.{u2, u1} Œ± Œ¥ (MeasureTheory.Measure.ae.{u2} Œ± m0 Œº) f g))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.absolutely_continuous.ae_eq MeasureTheory.Measure.AbsolutelyContinuous.ae_eq‚Çì'. -/
theorem AbsolutelyContinuous.ae_eq (h : Œº ‚â™ ŒΩ) {f g : Œ± ‚Üí Œ¥} (h' : f =·µê[ŒΩ] g) : f =·µê[Œº] g :=
  h.ae_le h'
#align measure_theory.measure.absolutely_continuous.ae_eq MeasureTheory.Measure.AbsolutelyContinuous.ae_eq

/-! ### Quasi measure preserving maps (a.k.a. non-singular maps) -/


#print MeasureTheory.Measure.QuasiMeasurePreserving /-
/-- A map `f : Œ± ‚Üí Œ≤` is said to be *quasi measure preserving* (a.k.a. non-singular) w.r.t. measures
`Œºa` and `Œºb` if it is measurable and `Œºb s = 0` implies `Œºa (f ‚Åª¬π' s) = 0`. -/
@[protect_proj]
structure QuasiMeasurePreserving {m0 : MeasurableSpace Œ±} (f : Œ± ‚Üí Œ≤)
  (Œºa : Measure Œ± := by exact MeasureTheory.MeasureSpace.volume)
  (Œºb : Measure Œ≤ := by exact MeasureTheory.MeasureSpace.volume) : Prop where
  Measurable : Measurable f
  AbsolutelyContinuous : Œºa.map f ‚â™ Œºb
#align measure_theory.measure.quasi_measure_preserving MeasureTheory.Measure.QuasiMeasurePreserving
-/

namespace QuasiMeasurePreserving

#print MeasureTheory.Measure.QuasiMeasurePreserving.id /-
protected theorem id {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) : QuasiMeasurePreserving id Œº Œº :=
  ‚ü®measurable_id, map_id.AbsolutelyContinuous‚ü©
#align measure_theory.measure.quasi_measure_preserving.id MeasureTheory.Measure.QuasiMeasurePreserving.id
-/

variable {Œºa Œºa' : Measure Œ±} {Œºb Œºb' : Measure Œ≤} {Œºc : Measure Œ≥} {f : Œ± ‚Üí Œ≤}

/- warning: measurable.quasi_measure_preserving -> Measurable.quasiMeasurePreserving is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u2} Œ≤] {f : Œ± -> Œ≤} {m0 : MeasurableSpace.{u1} Œ±}, (Measurable.{u1, u2} Œ± Œ≤ m0 _inst_1 f) -> (forall (Œº : MeasureTheory.Measure.{u1} Œ± m0), MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ≤] {f : Œ± -> Œ≤} {m0 : MeasurableSpace.{u2} Œ±}, (Measurable.{u2, u1} Œ± Œ≤ m0 _inst_1 f) -> (forall (Œº : MeasureTheory.Measure.{u2} Œ± m0), MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº))
Case conversion may be inaccurate. Consider using '#align measurable.quasi_measure_preserving Measurable.quasiMeasurePreserving‚Çì'. -/
protected theorem Measurable.quasiMeasurePreserving {m0 : MeasurableSpace Œ±} (hf : Measurable f)
    (Œº : Measure Œ±) : QuasiMeasurePreserving f Œº (Œº.map f) :=
  ‚ü®hf, AbsolutelyContinuous.rfl‚ü©
#align measurable.quasi_measure_preserving Measurable.quasiMeasurePreserving

/- warning: measure_theory.measure.quasi_measure_preserving.mono_left -> MeasureTheory.Measure.QuasiMeasurePreserving.mono_left is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œºa : MeasureTheory.Measure.{u1} Œ± m0} {Œºa' : MeasureTheory.Measure.{u1} Œ± m0} {Œºb : MeasureTheory.Measure.{u2} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œºa' Œºa) -> (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œºa' Œºb)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œºa : MeasureTheory.Measure.{u2} Œ± m0} {Œºa' : MeasureTheory.Measure.{u2} Œ± m0} {Œºb : MeasureTheory.Measure.{u1} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (MeasureTheory.Measure.AbsolutelyContinuous.{u2} Œ± m0 Œºa' Œºa) -> (MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œºa' Œºb)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.quasi_measure_preserving.mono_left MeasureTheory.Measure.QuasiMeasurePreserving.mono_left‚Çì'. -/
theorem mono_left (h : QuasiMeasurePreserving f Œºa Œºb) (ha : Œºa' ‚â™ Œºa) :
    QuasiMeasurePreserving f Œºa' Œºb :=
  ‚ü®h.1, (ha.map h.1).trans h.2‚ü©
#align measure_theory.measure.quasi_measure_preserving.mono_left MeasureTheory.Measure.QuasiMeasurePreserving.mono_left

/- warning: measure_theory.measure.quasi_measure_preserving.mono_right -> MeasureTheory.Measure.QuasiMeasurePreserving.mono_right is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œºa : MeasureTheory.Measure.{u1} Œ± m0} {Œºb : MeasureTheory.Measure.{u2} Œ≤ _inst_1} {Œºb' : MeasureTheory.Measure.{u2} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (MeasureTheory.Measure.AbsolutelyContinuous.{u2} Œ≤ _inst_1 Œºb Œºb') -> (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œºa Œºb')
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œºa : MeasureTheory.Measure.{u2} Œ± m0} {Œºb : MeasureTheory.Measure.{u1} Œ≤ _inst_1} {Œºb' : MeasureTheory.Measure.{u1} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ≤ _inst_1 Œºb Œºb') -> (MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œºa Œºb')
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.quasi_measure_preserving.mono_right MeasureTheory.Measure.QuasiMeasurePreserving.mono_right‚Çì'. -/
theorem mono_right (h : QuasiMeasurePreserving f Œºa Œºb) (ha : Œºb ‚â™ Œºb') :
    QuasiMeasurePreserving f Œºa Œºb' :=
  ‚ü®h.1, h.2.trans ha‚ü©
#align measure_theory.measure.quasi_measure_preserving.mono_right MeasureTheory.Measure.QuasiMeasurePreserving.mono_right

/- warning: measure_theory.measure.quasi_measure_preserving.mono -> MeasureTheory.Measure.QuasiMeasurePreserving.mono is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œºa : MeasureTheory.Measure.{u1} Œ± m0} {Œºa' : MeasureTheory.Measure.{u1} Œ± m0} {Œºb : MeasureTheory.Measure.{u2} Œ≤ _inst_1} {Œºb' : MeasureTheory.Measure.{u2} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ± m0 Œºa' Œºa) -> (MeasureTheory.Measure.AbsolutelyContinuous.{u2} Œ≤ _inst_1 Œºb Œºb') -> (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œºa' Œºb')
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œºa : MeasureTheory.Measure.{u2} Œ± m0} {Œºa' : MeasureTheory.Measure.{u2} Œ± m0} {Œºb : MeasureTheory.Measure.{u1} Œ≤ _inst_1} {Œºb' : MeasureTheory.Measure.{u1} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.AbsolutelyContinuous.{u2} Œ± m0 Œºa' Œºa) -> (MeasureTheory.Measure.AbsolutelyContinuous.{u1} Œ≤ _inst_1 Œºb Œºb') -> (MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œºa' Œºb')
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.quasi_measure_preserving.mono MeasureTheory.Measure.QuasiMeasurePreserving.mono‚Çì'. -/
@[mono]
theorem mono (ha : Œºa' ‚â™ Œºa) (hb : Œºb ‚â™ Œºb') (h : QuasiMeasurePreserving f Œºa Œºb) :
    QuasiMeasurePreserving f Œºa' Œºb' :=
  (h.mono_left ha).mono_right hb
#align measure_theory.measure.quasi_measure_preserving.mono MeasureTheory.Measure.QuasiMeasurePreserving.mono

/- warning: measure_theory.measure.quasi_measure_preserving.comp -> MeasureTheory.Measure.QuasiMeasurePreserving.comp is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] [_inst_2 : MeasurableSpace.{u3} Œ≥] {Œºa : MeasureTheory.Measure.{u1} Œ± m0} {Œºb : MeasureTheory.Measure.{u2} Œ≤ _inst_1} {Œºc : MeasureTheory.Measure.{u3} Œ≥ _inst_2} {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_1 g Œºb Œºc) -> (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u3} Œ± Œ≥ _inst_2 m0 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f) Œºa Œºc)
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u3} Œ≤] [_inst_2 : MeasurableSpace.{u2} Œ≥] {Œºa : MeasureTheory.Measure.{u1} Œ± m0} {Œºb : MeasureTheory.Measure.{u3} Œ≤ _inst_1} {Œºc : MeasureTheory.Measure.{u2} Œ≥ _inst_2} {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_1 g Œºb Œºc) -> (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u3} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ± Œ≥ _inst_2 m0 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f) Œºa Œºc)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.quasi_measure_preserving.comp MeasureTheory.Measure.QuasiMeasurePreserving.comp‚Çì'. -/
protected theorem comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : QuasiMeasurePreserving g Œºb Œºc)
    (hf : QuasiMeasurePreserving f Œºa Œºb) : QuasiMeasurePreserving (g ‚àò f) Œºa Œºc :=
  ‚ü®hg.Measurable.comp hf.Measurable, by
    rw [‚Üê map_map hg.1 hf.1]
    exact (hf.2.map hg.1).trans hg.2‚ü©
#align measure_theory.measure.quasi_measure_preserving.comp MeasureTheory.Measure.QuasiMeasurePreserving.comp

#print MeasureTheory.Measure.QuasiMeasurePreserving.iterate /-
protected theorem iterate {f : Œ± ‚Üí Œ±} (hf : QuasiMeasurePreserving f Œºa Œºa) :
    ‚àÄ n, QuasiMeasurePreserving (f^[n]) Œºa Œºa
  | 0 => QuasiMeasurePreserving.id Œºa
  | n + 1 => (iterate n).comp hf
#align measure_theory.measure.quasi_measure_preserving.iterate MeasureTheory.Measure.QuasiMeasurePreserving.iterate
-/

/- warning: measure_theory.measure.quasi_measure_preserving.ae_measurable -> MeasureTheory.Measure.QuasiMeasurePreserving.aemeasurable is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œºa : MeasureTheory.Measure.{u1} Œ± m0} {Œºb : MeasureTheory.Measure.{u2} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (AEMeasurable.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œºa)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œºa : MeasureTheory.Measure.{u2} Œ± m0} {Œºb : MeasureTheory.Measure.{u1} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (AEMeasurable.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œºa)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.quasi_measure_preserving.ae_measurable MeasureTheory.Measure.QuasiMeasurePreserving.aemeasurable‚Çì'. -/
protected theorem aemeasurable (hf : QuasiMeasurePreserving f Œºa Œºb) : AEMeasurable f Œºa :=
  hf.1.AEMeasurable
#align measure_theory.measure.quasi_measure_preserving.ae_measurable MeasureTheory.Measure.QuasiMeasurePreserving.aemeasurable

/- warning: measure_theory.measure.quasi_measure_preserving.ae_map_le -> MeasureTheory.Measure.QuasiMeasurePreserving.ae_map_le is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œºa : MeasureTheory.Measure.{u1} Œ± m0} {Œºb : MeasureTheory.Measure.{u2} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œºa)) (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_1 Œºb))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œºa : MeasureTheory.Measure.{u2} Œ± m0} {Œºb : MeasureTheory.Measure.{u1} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (LE.le.{u1} (Filter.{u1} Œ≤) (Preorder.toLE.{u1} (Filter.{u1} Œ≤) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ≤) (Filter.instPartialOrderFilter.{u1} Œ≤))) (MeasureTheory.Measure.ae.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œºa)) (MeasureTheory.Measure.ae.{u1} Œ≤ _inst_1 Œºb))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.quasi_measure_preserving.ae_map_le MeasureTheory.Measure.QuasiMeasurePreserving.ae_map_le‚Çì'. -/
theorem ae_map_le (h : QuasiMeasurePreserving f Œºa Œºb) : (Œºa.map f).ae ‚â§ Œºb.ae :=
  h.2.ae_le
#align measure_theory.measure.quasi_measure_preserving.ae_map_le MeasureTheory.Measure.QuasiMeasurePreserving.ae_map_le

/- warning: measure_theory.measure.quasi_measure_preserving.tendsto_ae -> MeasureTheory.Measure.QuasiMeasurePreserving.tendsto_ae is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œºa : MeasureTheory.Measure.{u1} Œ± m0} {Œºb : MeasureTheory.Measure.{u2} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (Filter.Tendsto.{u1, u2} Œ± Œ≤ f (MeasureTheory.Measure.ae.{u1} Œ± m0 Œºa) (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_1 Œºb))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œºa : MeasureTheory.Measure.{u2} Œ± m0} {Œºb : MeasureTheory.Measure.{u1} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (Filter.Tendsto.{u2, u1} Œ± Œ≤ f (MeasureTheory.Measure.ae.{u2} Œ± m0 Œºa) (MeasureTheory.Measure.ae.{u1} Œ≤ _inst_1 Œºb))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.quasi_measure_preserving.tendsto_ae MeasureTheory.Measure.QuasiMeasurePreserving.tendsto_ae‚Çì'. -/
theorem tendsto_ae (h : QuasiMeasurePreserving f Œºa Œºb) : Tendsto f Œºa.ae Œºb.ae :=
  (tendsto_ae_map h.AEMeasurable).mono_right h.ae_map_le
#align measure_theory.measure.quasi_measure_preserving.tendsto_ae MeasureTheory.Measure.QuasiMeasurePreserving.tendsto_ae

/- warning: measure_theory.measure.quasi_measure_preserving.ae -> MeasureTheory.Measure.QuasiMeasurePreserving.ae is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œºa : MeasureTheory.Measure.{u1} Œ± m0} {Œºb : MeasureTheory.Measure.{u2} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (forall {p : Œ≤ -> Prop}, (Filter.Eventually.{u2} Œ≤ (fun (x : Œ≤) => p x) (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_1 Œºb)) -> (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p (f x)) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œºa)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œºa : MeasureTheory.Measure.{u2} Œ± m0} {Œºb : MeasureTheory.Measure.{u1} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (forall {p : Œ≤ -> Prop}, (Filter.Eventually.{u1} Œ≤ (fun (x : Œ≤) => p x) (MeasureTheory.Measure.ae.{u1} Œ≤ _inst_1 Œºb)) -> (Filter.Eventually.{u2} Œ± (fun (x : Œ±) => p (f x)) (MeasureTheory.Measure.ae.{u2} Œ± m0 Œºa)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.quasi_measure_preserving.ae MeasureTheory.Measure.QuasiMeasurePreserving.ae‚Çì'. -/
theorem ae (h : QuasiMeasurePreserving f Œºa Œºb) {p : Œ≤ ‚Üí Prop} (hg : ‚àÄ·µê x ‚àÇŒºb, p x) :
    ‚àÄ·µê x ‚àÇŒºa, p (f x) :=
  h.tendsto_ae hg
#align measure_theory.measure.quasi_measure_preserving.ae MeasureTheory.Measure.QuasiMeasurePreserving.ae

/- warning: measure_theory.measure.quasi_measure_preserving.ae_eq -> MeasureTheory.Measure.QuasiMeasurePreserving.ae_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ¥ : Type.{u3}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œºa : MeasureTheory.Measure.{u1} Œ± m0} {Œºb : MeasureTheory.Measure.{u2} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (forall {g‚ÇÅ : Œ≤ -> Œ¥} {g‚ÇÇ : Œ≤ -> Œ¥}, (Filter.EventuallyEq.{u2, u3} Œ≤ Œ¥ (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_1 Œºb) g‚ÇÅ g‚ÇÇ) -> (Filter.EventuallyEq.{u1, u3} Œ± Œ¥ (MeasureTheory.Measure.ae.{u1} Œ± m0 Œºa) (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ¥ g‚ÇÅ f) (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ¥ g‚ÇÇ f)))
but is expected to have type
  forall {Œ± : Type.{u3}} {Œ≤ : Type.{u2}} {Œ¥ : Type.{u1}} {m0 : MeasurableSpace.{u3} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œºa : MeasureTheory.Measure.{u3} Œ± m0} {Œºb : MeasureTheory.Measure.{u2} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u3, u2} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (forall {g‚ÇÅ : Œ≤ -> Œ¥} {g‚ÇÇ : Œ≤ -> Œ¥}, (Filter.EventuallyEq.{u2, u1} Œ≤ Œ¥ (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_1 Œºb) g‚ÇÅ g‚ÇÇ) -> (Filter.EventuallyEq.{u3, u1} Œ± Œ¥ (MeasureTheory.Measure.ae.{u3} Œ± m0 Œºa) (Function.comp.{succ u3, succ u2, succ u1} Œ± Œ≤ Œ¥ g‚ÇÅ f) (Function.comp.{succ u3, succ u2, succ u1} Œ± Œ≤ Œ¥ g‚ÇÇ f)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.quasi_measure_preserving.ae_eq MeasureTheory.Measure.QuasiMeasurePreserving.ae_eq‚Çì'. -/
theorem ae_eq (h : QuasiMeasurePreserving f Œºa Œºb) {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ¥} (hg : g‚ÇÅ =·µê[Œºb] g‚ÇÇ) :
    g‚ÇÅ ‚àò f =·µê[Œºa] g‚ÇÇ ‚àò f :=
  h.ae hg
#align measure_theory.measure.quasi_measure_preserving.ae_eq MeasureTheory.Measure.QuasiMeasurePreserving.ae_eq

/- warning: measure_theory.measure.quasi_measure_preserving.preimage_null -> MeasureTheory.Measure.QuasiMeasurePreserving.preimage_null is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œºa : MeasureTheory.Measure.{u1} Œ± m0} {Œºb : MeasureTheory.Measure.{u2} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (forall {s : Set.{u2} Œ≤}, (Eq.{1} ENNReal (coeFn.{succ u2, succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_1) (fun (_x : MeasureTheory.Measure.{u2} Œ≤ _inst_1) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u2} Œ≤ _inst_1) Œºb s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œºa (Set.preimage.{u1, u2} Œ± Œ≤ f s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œºa : MeasureTheory.Measure.{u2} Œ± m0} {Œºb : MeasureTheory.Measure.{u1} Œ≤ _inst_1} {f : Œ± -> Œ≤}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œºa Œºb) -> (forall {s : Set.{u1} Œ≤}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ≤ (MeasureTheory.Measure.toOuterMeasure.{u1} Œ≤ _inst_1 Œºb) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 Œºa) (Set.preimage.{u2, u1} Œ± Œ≤ f s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.quasi_measure_preserving.preimage_null MeasureTheory.Measure.QuasiMeasurePreserving.preimage_null‚Çì'. -/
theorem preimage_null (h : QuasiMeasurePreserving f Œºa Œºb) {s : Set Œ≤} (hs : Œºb s = 0) :
    Œºa (f ‚Åª¬π' s) = 0 :=
  preimage_null_of_map_null h.AEMeasurable (h.2 hs)
#align measure_theory.measure.quasi_measure_preserving.preimage_null MeasureTheory.Measure.QuasiMeasurePreserving.preimage_null

#print MeasureTheory.Measure.QuasiMeasurePreserving.preimage_mono_ae /-
theorem preimage_mono_ae {s t : Set Œ≤} (hf : QuasiMeasurePreserving f Œºa Œºb) (h : s ‚â§·µê[Œºb] t) :
    f ‚Åª¬π' s ‚â§·µê[Œºa] f ‚Åª¬π' t :=
  eventually_map.mp <|
    Eventually.filter_mono (tendsto_ae_map hf.AEMeasurable) (Eventually.filter_mono hf.ae_map_le h)
#align measure_theory.measure.quasi_measure_preserving.preimage_mono_ae MeasureTheory.Measure.QuasiMeasurePreserving.preimage_mono_ae
-/

#print MeasureTheory.Measure.QuasiMeasurePreserving.preimage_ae_eq /-
theorem preimage_ae_eq {s t : Set Œ≤} (hf : QuasiMeasurePreserving f Œºa Œºb) (h : s =·µê[Œºb] t) :
    f ‚Åª¬π' s =·µê[Œºa] f ‚Åª¬π' t :=
  EventuallyLE.antisymm (hf.preimage_mono_ae h.le) (hf.preimage_mono_ae h.symm.le)
#align measure_theory.measure.quasi_measure_preserving.preimage_ae_eq MeasureTheory.Measure.QuasiMeasurePreserving.preimage_ae_eq
-/

#print MeasureTheory.Measure.QuasiMeasurePreserving.preimage_iterate_ae_eq /-
theorem preimage_iterate_ae_eq {s : Set Œ±} {f : Œ± ‚Üí Œ±} (hf : QuasiMeasurePreserving f Œº Œº) (k : ‚Ñï)
    (hs : f ‚Åª¬π' s =·µê[Œº] s) : f^[k] ‚Åª¬π' s =·µê[Œº] s :=
  by
  induction' k with k ih; ¬∑ simp
  rw [iterate_succ, preimage_comp]
  exact eventually_eq.trans (hf.preimage_ae_eq ih) hs
#align measure_theory.measure.quasi_measure_preserving.preimage_iterate_ae_eq MeasureTheory.Measure.QuasiMeasurePreserving.preimage_iterate_ae_eq
-/

#print MeasureTheory.Measure.QuasiMeasurePreserving.image_zpow_ae_eq /-
theorem image_zpow_ae_eq {s : Set Œ±} {e : Œ± ‚âÉ Œ±} (he : QuasiMeasurePreserving e Œº Œº)
    (he' : QuasiMeasurePreserving e.symm Œº Œº) (k : ‚Ñ§) (hs : e '' s =·µê[Œº] s) :
    ‚áë(e ^ k) '' s =·µê[Œº] s := by
  rw [Equiv.image_eq_preimage]
  obtain ‚ü®k, rfl | rfl‚ü© := k.eq_coe_or_neg
  ¬∑ replace hs : ‚áëe‚Åª¬π ‚Åª¬π' s =·µê[Œº] s
    ¬∑ rwa [Equiv.image_eq_preimage] at hs
    replace he' : ‚áëe‚Åª¬π^[k] ‚Åª¬π' s =·µê[Œº] s := he'.preimage_iterate_ae_eq k hs
    rwa [Equiv.Perm.iterate_eq_pow e‚Åª¬π k, inv_pow e k] at he'
  ¬∑ rw [zpow_neg, zpow_ofNat]
    replace hs : e ‚Åª¬π' s =·µê[Œº] s
    ¬∑ convert he.preimage_ae_eq hs.symm
      rw [Equiv.preimage_image]
    replace he : ‚áëe^[k] ‚Åª¬π' s =·µê[Œº] s := he.preimage_iterate_ae_eq k hs
    rwa [Equiv.Perm.iterate_eq_pow e k] at he
#align measure_theory.measure.quasi_measure_preserving.image_zpow_ae_eq MeasureTheory.Measure.QuasiMeasurePreserving.image_zpow_ae_eq
-/

/- warning: measure_theory.measure.quasi_measure_preserving.limsup_preimage_iterate_ae_eq -> MeasureTheory.Measure.QuasiMeasurePreserving.limsup_preimage_iterate_ae_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {f : Œ± -> Œ±}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u1} Œ± Œ± m0 m0 f Œº Œº) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.preimage.{u1, u1} Œ± Œ± f s) s) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Filter.limsup.{u1, 0} (Set.{u1} Œ±) Nat (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±))))) (fun (n : Nat) => Nat.iterate.{succ u1} (Set.{u1} Œ±) (Set.preimage.{u1, u1} Œ± Œ± f) n s) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) s)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {f : Œ± -> Œ±}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u1} Œ± Œ± m0 m0 f Œº Œº) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.preimage.{u1, u1} Œ± Œ± f s) s) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Filter.limsup.{u1, 0} (Set.{u1} Œ±) Nat (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))) (fun (n : Nat) => Nat.iterate.{succ u1} (Set.{u1} Œ±) (Set.preimage.{u1, u1} Œ± Œ± f) n s) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) s)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.quasi_measure_preserving.limsup_preimage_iterate_ae_eq MeasureTheory.Measure.QuasiMeasurePreserving.limsup_preimage_iterate_ae_eq‚Çì'. -/
theorem limsup_preimage_iterate_ae_eq {f : Œ± ‚Üí Œ±} (hf : QuasiMeasurePreserving f Œº Œº)
    (hs : f ‚Åª¬π' s =·µê[Œº] s) :-- Need `@` below because of diamond; see gh issue #16932
        @limsup
        (Set Œ±) ‚Ñï _ (fun n => (preimage f^[n]) s) atTop =·µê[Œº]
      s :=
  haveI : ‚àÄ n, (preimage f^[n]) s =·µê[Œº] s := by
    intro n
    induction' n with n ih
    ¬∑ simp
    simpa only [iterate_succ', comp_app] using ae_eq_trans (hf.ae_eq ih) hs
  (limsup_ae_eq_of_forall_ae_eq (fun n => (preimage f^[n]) s) this).trans (ae_eq_refl _)
#align measure_theory.measure.quasi_measure_preserving.limsup_preimage_iterate_ae_eq MeasureTheory.Measure.QuasiMeasurePreserving.limsup_preimage_iterate_ae_eq

/- warning: measure_theory.measure.quasi_measure_preserving.liminf_preimage_iterate_ae_eq -> MeasureTheory.Measure.QuasiMeasurePreserving.liminf_preimage_iterate_ae_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {f : Œ± -> Œ±}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u1} Œ± Œ± m0 m0 f Œº Œº) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.preimage.{u1, u1} Œ± Œ± f s) s) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Filter.liminf.{u1, 0} (Set.{u1} Œ±) Nat (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±))))) (fun (n : Nat) => Nat.iterate.{succ u1} (Set.{u1} Œ±) (Set.preimage.{u1, u1} Œ± Œ± f) n s) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) s)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {f : Œ± -> Œ±}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u1} Œ± Œ± m0 m0 f Œº Œº) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.preimage.{u1, u1} Œ± Œ± f s) s) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Filter.liminf.{u1, 0} (Set.{u1} Œ±) Nat (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))) (fun (n : Nat) => Nat.iterate.{succ u1} (Set.{u1} Œ±) (Set.preimage.{u1, u1} Œ± Œ± f) n s) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) s)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.quasi_measure_preserving.liminf_preimage_iterate_ae_eq MeasureTheory.Measure.QuasiMeasurePreserving.liminf_preimage_iterate_ae_eq‚Çì'. -/
theorem liminf_preimage_iterate_ae_eq {f : Œ± ‚Üí Œ±} (hf : QuasiMeasurePreserving f Œº Œº)
    (hs : f ‚Åª¬π' s =·µê[Œº] s) :-- Need `@` below because of diamond; see gh issue #16932
        @liminf
        (Set Œ±) ‚Ñï _ (fun n => (preimage f^[n]) s) atTop =·µê[Œº]
      s :=
  by
  -- Need `@` below because of diamond; see gh issue #16932
  rw [‚Üê ae_eq_set_compl_compl, @Filter.liminf_compl (Set Œ±)]
  rw [‚Üê ae_eq_set_compl_compl, ‚Üê preimage_compl] at hs
  convert hf.limsup_preimage_iterate_ae_eq hs
  ext1 n
  simp only [‚Üê Set.preimage_iterate_eq, comp_app, preimage_compl]
#align measure_theory.measure.quasi_measure_preserving.liminf_preimage_iterate_ae_eq MeasureTheory.Measure.QuasiMeasurePreserving.liminf_preimage_iterate_ae_eq

#print MeasureTheory.Measure.QuasiMeasurePreserving.exists_preimage_eq_of_preimage_ae /-
/-- By replacing a measurable set that is almost invariant with the `limsup` of its preimages, we
obtain a measurable set that is almost equal and strictly invariant.

(The `liminf` would work just as well.) -/
theorem exists_preimage_eq_of_preimage_ae {f : Œ± ‚Üí Œ±} (h : QuasiMeasurePreserving f Œº Œº)
    (hs : MeasurableSet s) (hs' : f ‚Åª¬π' s =·µê[Œº] s) :
    ‚àÉ t : Set Œ±, MeasurableSet t ‚àß t =·µê[Œº] s ‚àß f ‚Åª¬π' t = t :=
  ‚ü®limsup (fun n => (preimage f^[n]) s) atTop,
    MeasurableSet.measurableSet_limsup fun n =>
      @preimage_iterate_eq Œ± f n ‚ñ∏ h.Measurable.iterate n hs,
    h.limsup_preimage_iterate_ae_eq hs', (CompleteLatticeHom.setPreimage f).apply_limsup_iterate s‚ü©
#align measure_theory.measure.quasi_measure_preserving.exists_preimage_eq_of_preimage_ae MeasureTheory.Measure.QuasiMeasurePreserving.exists_preimage_eq_of_preimage_ae
-/

open Pointwise

/- warning: measure_theory.measure.quasi_measure_preserving.smul_ae_eq_of_ae_eq -> MeasureTheory.Measure.QuasiMeasurePreserving.smul_ae_eq_of_ae_eq is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} {Œ± : Type.{u2}} [_inst_3 : Group.{u1} G] [_inst_4 : MulAction.{u1, u2} G Œ± (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))] [_inst_5 : MeasurableSpace.{u2} Œ±] {s : Set.{u2} Œ±} {t : Set.{u2} Œ±} {Œº : MeasureTheory.Measure.{u2} Œ± _inst_5} (g : G), (MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u2} Œ± Œ± _inst_5 _inst_5 (SMul.smul.{u1, u2} G Œ± (MulAction.toHasSmul.{u1, u2} G Œ± (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) _inst_4) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) g)) Œº Œº) -> (Filter.EventuallyEq.{u2, 0} Œ± Prop (MeasureTheory.Measure.ae.{u2} Œ± _inst_5 Œº) s t) -> (Filter.EventuallyEq.{u2, 0} Œ± Prop (MeasureTheory.Measure.ae.{u2} Œ± _inst_5 Œº) (SMul.smul.{u1, u2} G (Set.{u2} Œ±) (Set.smulSet.{u1, u2} G Œ± (MulAction.toHasSmul.{u1, u2} G Œ± (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) _inst_4)) g s) (SMul.smul.{u1, u2} G (Set.{u2} Œ±) (Set.smulSet.{u1, u2} G Œ± (MulAction.toHasSmul.{u1, u2} G Œ± (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) _inst_4)) g t))
but is expected to have type
  forall {G : Type.{u2}} {Œ± : Type.{u1}} [_inst_3 : Group.{u2} G] [_inst_4 : MulAction.{u2, u1} G Œ± (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))] [_inst_5 : MeasurableSpace.{u1} Œ±] {s : Set.{u1} Œ±} {t : Set.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± _inst_5} (g : G), (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u1} Œ± Œ± _inst_5 _inst_5 ((fun (x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.40100 : G) (x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.40102 : Œ±) => HSMul.hSMul.{u2, u1, u1} G Œ± Œ± (instHSMul.{u2, u1} G Œ± (MulAction.toSMul.{u2, u1} G Œ± (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) _inst_4)) x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.40100 x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.40102) (Inv.inv.{u2} G (InvOneClass.toInv.{u2} G (DivInvOneMonoid.toInvOneClass.{u2} G (DivisionMonoid.toDivInvOneMonoid.{u2} G (Group.toDivisionMonoid.{u2} G _inst_3)))) g)) Œº Œº) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± _inst_5 Œº) s t) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± _inst_5 Œº) (HSMul.hSMul.{u2, u1, u1} G (Set.{u1} Œ±) (Set.{u1} Œ±) (instHSMul.{u2, u1} G (Set.{u1} Œ±) (Set.smulSet.{u2, u1} G Œ± (MulAction.toSMul.{u2, u1} G Œ± (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) _inst_4))) g s) (HSMul.hSMul.{u2, u1, u1} G (Set.{u1} Œ±) (Set.{u1} Œ±) (instHSMul.{u2, u1} G (Set.{u1} Œ±) (Set.smulSet.{u2, u1} G Œ± (MulAction.toSMul.{u2, u1} G Œ± (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) _inst_4))) g t))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.quasi_measure_preserving.smul_ae_eq_of_ae_eq MeasureTheory.Measure.QuasiMeasurePreserving.smul_ae_eq_of_ae_eq‚Çì'. -/
@[to_additive]
theorem smul_ae_eq_of_ae_eq {G Œ± : Type _} [Group G] [MulAction G Œ±] [MeasurableSpace Œ±]
    {s t : Set Œ±} {Œº : Measure Œ±} (g : G) (h_qmp : QuasiMeasurePreserving ((¬∑ ‚Ä¢ ¬∑) g‚Åª¬π : Œ± ‚Üí Œ±) Œº Œº)
    (h_ae_eq : s =·µê[Œº] t) : (g ‚Ä¢ s : Set Œ±) =·µê[Œº] (g ‚Ä¢ t : Set Œ±) := by
  simpa only [‚Üê preimage_smul_inv] using h_qmp.ae_eq h_ae_eq
#align measure_theory.measure.quasi_measure_preserving.smul_ae_eq_of_ae_eq MeasureTheory.Measure.QuasiMeasurePreserving.smul_ae_eq_of_ae_eq
#align measure_theory.measure.quasi_measure_preserving.vadd_ae_eq_of_ae_eq MeasureTheory.Measure.QuasiMeasurePreserving.vadd_ae_eq_of_ae_eq

end QuasiMeasurePreserving

section Pointwise

open Pointwise

/- warning: measure_theory.measure.pairwise_ae_disjoint_of_ae_disjoint_forall_ne_one -> MeasureTheory.Measure.pairwise_aedisjoint_of_aedisjoint_forall_ne_one is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} {Œ± : Type.{u2}} [_inst_3 : Group.{u1} G] [_inst_4 : MulAction.{u1, u2} G Œ± (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))] [_inst_5 : MeasurableSpace.{u2} Œ±] {Œº : MeasureTheory.Measure.{u2} Œ± _inst_5} {s : Set.{u2} Œ±}, (forall (g : G), (Ne.{succ u1} G g (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)))))))) -> (MeasureTheory.AEDisjoint.{u2} Œ± _inst_5 Œº (SMul.smul.{u1, u2} G (Set.{u2} Œ±) (Set.smulSet.{u1, u2} G Œ± (MulAction.toHasSmul.{u1, u2} G Œ± (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) _inst_4)) g s) s)) -> (forall (g : G), MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u2} Œ± Œ± _inst_5 _inst_5 (SMul.smul.{u1, u2} G Œ± (MulAction.toHasSmul.{u1, u2} G Œ± (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) _inst_4) g) Œº Œº) -> (Pairwise.{u1} G (Function.onFun.{succ u1, succ u2, 1} G (Set.{u2} Œ±) Prop (MeasureTheory.AEDisjoint.{u2} Œ± _inst_5 Œº) (fun (g : G) => SMul.smul.{u1, u2} G (Set.{u2} Œ±) (Set.smulSet.{u1, u2} G Œ± (MulAction.toHasSmul.{u1, u2} G Œ± (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) _inst_4)) g s)))
but is expected to have type
  forall {G : Type.{u2}} {Œ± : Type.{u1}} [_inst_3 : Group.{u2} G] [_inst_4 : MulAction.{u2, u1} G Œ± (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))] [_inst_5 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_5} {s : Set.{u1} Œ±}, (forall (g : G), (Ne.{succ u2} G g (OfNat.ofNat.{u2} G 1 (One.toOfNat1.{u2} G (InvOneClass.toOne.{u2} G (DivInvOneMonoid.toInvOneClass.{u2} G (DivisionMonoid.toDivInvOneMonoid.{u2} G (Group.toDivisionMonoid.{u2} G _inst_3))))))) -> (MeasureTheory.AEDisjoint.{u1} Œ± _inst_5 Œº (HSMul.hSMul.{u2, u1, u1} G (Set.{u1} Œ±) (Set.{u1} Œ±) (instHSMul.{u2, u1} G (Set.{u1} Œ±) (Set.smulSet.{u2, u1} G Œ± (MulAction.toSMul.{u2, u1} G Œ± (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) _inst_4))) g s) s)) -> (forall (g : G), MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u1} Œ± Œ± _inst_5 _inst_5 ((fun (x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.40257 : G) (x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.40259 : Œ±) => HSMul.hSMul.{u2, u1, u1} G Œ± Œ± (instHSMul.{u2, u1} G Œ± (MulAction.toSMul.{u2, u1} G Œ± (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) _inst_4)) x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.40257 x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.40259) g) Œº Œº) -> (Pairwise.{u2} G (Function.onFun.{succ u2, succ u1, 1} G (Set.{u1} Œ±) Prop (MeasureTheory.AEDisjoint.{u1} Œ± _inst_5 Œº) (fun (g : G) => HSMul.hSMul.{u2, u1, u1} G (Set.{u1} Œ±) (Set.{u1} Œ±) (instHSMul.{u2, u1} G (Set.{u1} Œ±) (Set.smulSet.{u2, u1} G Œ± (MulAction.toSMul.{u2, u1} G Œ± (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) _inst_4))) g s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.pairwise_ae_disjoint_of_ae_disjoint_forall_ne_one MeasureTheory.Measure.pairwise_aedisjoint_of_aedisjoint_forall_ne_one‚Çì'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (g ¬´expr ‚â† ¬ª (1 : G)) -/
@[to_additive]
theorem pairwise_aedisjoint_of_aedisjoint_forall_ne_one {G Œ± : Type _} [Group G] [MulAction G Œ±]
    [MeasurableSpace Œ±] {Œº : Measure Œ±} {s : Set Œ±}
    (h_ae_disjoint : ‚àÄ (g) (_ : g ‚â† (1 : G)), AEDisjoint Œº (g ‚Ä¢ s) s)
    (h_qmp : ‚àÄ g : G, QuasiMeasurePreserving ((¬∑ ‚Ä¢ ¬∑) g : Œ± ‚Üí Œ±) Œº Œº) :
    Pairwise (AEDisjoint Œº on fun g : G => g ‚Ä¢ s) :=
  by
  intro g‚ÇÅ g‚ÇÇ hg
  let g := g‚ÇÇ‚Åª¬π * g‚ÇÅ
  replace hg : g ‚â† 1
  ¬∑ rw [Ne.def, inv_mul_eq_one]
    exact hg.symm
  have : (¬∑ ‚Ä¢ ¬∑) g‚ÇÇ‚Åª¬π ‚Åª¬π' (g ‚Ä¢ s ‚à© s) = g‚ÇÅ ‚Ä¢ s ‚à© g‚ÇÇ ‚Ä¢ s := by
    rw [preimage_eq_iff_eq_image (MulAction.bijective g‚ÇÇ‚Åª¬π), image_smul, smul_set_inter, smul_smul,
      smul_smul, inv_mul_self, one_smul]
  change Œº (g‚ÇÅ ‚Ä¢ s ‚à© g‚ÇÇ ‚Ä¢ s) = 0
  exact this ‚ñ∏ (h_qmp g‚ÇÇ‚Åª¬π).preimage_null (h_ae_disjoint g hg)
#align measure_theory.measure.pairwise_ae_disjoint_of_ae_disjoint_forall_ne_one MeasureTheory.Measure.pairwise_aedisjoint_of_aedisjoint_forall_ne_one
#align measure_theory.measure.pairwise_ae_disjoint_of_ae_disjoint_forall_ne_zero MeasureTheory.Measure.pairwise_aedisjoint_of_aedisjoint_forall_ne_zero

end Pointwise

/-! ### The `cofinite` filter -/


#print MeasureTheory.Measure.cofinite /-
/-- The filter of sets `s` such that `s·∂ú` has finite measure. -/
def cofinite {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) : Filter Œ±
    where
  sets := { s | Œº (s·∂ú) < ‚àû }
  univ_sets := by simp
  inter_sets s t hs ht := by
    simp only [compl_inter, mem_set_of_eq]
    calc
      Œº (s·∂ú ‚à™ t·∂ú) ‚â§ Œº (s·∂ú) + Œº (t·∂ú) := measure_union_le _ _
      _ < ‚àû := ENNReal.add_lt_top.2 ‚ü®hs, ht‚ü©
      
  sets_of_superset s t hs hst := lt_of_le_of_lt (measure_mono <| compl_subset_compl.2 hst) hs
#align measure_theory.measure.cofinite MeasureTheory.Measure.cofinite
-/

/- warning: measure_theory.measure.mem_cofinite -> MeasureTheory.Measure.mem_cofinite is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (MeasureTheory.Measure.cofinite.{u1} Œ± m0 Œº)) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, Iff (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (MeasureTheory.Measure.cofinite.{u1} Œ± m0 Œº)) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) s)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.mem_cofinite MeasureTheory.Measure.mem_cofinite‚Çì'. -/
theorem mem_cofinite : s ‚àà Œº.cofinite ‚Üî Œº (s·∂ú) < ‚àû :=
  Iff.rfl
#align measure_theory.measure.mem_cofinite MeasureTheory.Measure.mem_cofinite

/- warning: measure_theory.measure.compl_mem_cofinite -> MeasureTheory.Measure.compl_mem_cofinite is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s) (MeasureTheory.Measure.cofinite.{u1} Œ± m0 Œº)) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, Iff (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) s) (MeasureTheory.Measure.cofinite.{u1} Œ± m0 Œº)) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.compl_mem_cofinite MeasureTheory.Measure.compl_mem_cofinite‚Çì'. -/
theorem compl_mem_cofinite : s·∂ú ‚àà Œº.cofinite ‚Üî Œº s < ‚àû := by rw [mem_cofinite, compl_compl]
#align measure_theory.measure.compl_mem_cofinite MeasureTheory.Measure.compl_mem_cofinite

/- warning: measure_theory.measure.eventually_cofinite -> MeasureTheory.Measure.eventually_cofinite is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {p : Œ± -> Prop}, Iff (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.cofinite.{u1} Œ± m0 Œº)) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (setOf.{u1} Œ± (fun (x : Œ±) => Not (p x)))) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {p : Œ± -> Prop}, Iff (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.cofinite.{u1} Œ± m0 Œº)) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (setOf.{u1} Œ± (fun (x : Œ±) => Not (p x)))) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.eventually_cofinite MeasureTheory.Measure.eventually_cofinite‚Çì'. -/
theorem eventually_cofinite {p : Œ± ‚Üí Prop} : (‚àÄ·∂† x in Œº.cofinite, p x) ‚Üî Œº { x | ¬¨p x } < ‚àû :=
  Iff.rfl
#align measure_theory.measure.eventually_cofinite MeasureTheory.Measure.eventually_cofinite

end Measure

open Measure

open MeasureTheory

#print MeasureTheory.NullMeasurableSet.preimage /-
/-- The preimage of a null measurable set under a (quasi) measure preserving map is a null
measurable set. -/
theorem NullMeasurableSet.preimage {ŒΩ : Measure Œ≤} {f : Œ± ‚Üí Œ≤} {t : Set Œ≤}
    (ht : NullMeasurableSet t ŒΩ) (hf : QuasiMeasurePreserving f Œº ŒΩ) :
    NullMeasurableSet (f ‚Åª¬π' t) Œº :=
  ‚ü®f ‚Åª¬π' toMeasurable ŒΩ t, hf.Measurable (measurableSet_toMeasurable _ _),
    hf.ae_eq ht.toMeasurable_ae_eq.symm‚ü©
#align measure_theory.null_measurable_set.preimage MeasureTheory.NullMeasurableSet.preimage
-/

#print MeasureTheory.NullMeasurableSet.mono_ac /-
theorem NullMeasurableSet.mono_ac (h : NullMeasurableSet s Œº) (hle : ŒΩ ‚â™ Œº) :
    NullMeasurableSet s ŒΩ :=
  h.Preimage <| (QuasiMeasurePreserving.id Œº).mono_left hle
#align measure_theory.null_measurable_set.mono_ac MeasureTheory.NullMeasurableSet.mono_ac
-/

#print MeasureTheory.NullMeasurableSet.mono /-
theorem NullMeasurableSet.mono (h : NullMeasurableSet s Œº) (hle : ŒΩ ‚â§ Œº) : NullMeasurableSet s ŒΩ :=
  h.mono_ac hle.AbsolutelyContinuous
#align measure_theory.null_measurable_set.mono MeasureTheory.NullMeasurableSet.mono
-/

#print MeasureTheory.AeDisjoint.preimage /-
theorem AeDisjoint.preimage {ŒΩ : Measure Œ≤} {f : Œ± ‚Üí Œ≤} {s t : Set Œ≤} (ht : AEDisjoint ŒΩ s t)
    (hf : QuasiMeasurePreserving f Œº ŒΩ) : AEDisjoint Œº (f ‚Åª¬π' s) (f ‚Åª¬π' t) :=
  hf.preimage_null ht
#align measure_theory.ae_disjoint.preimage MeasureTheory.AeDisjoint.preimage
-/

/- warning: measure_theory.ae_eq_bot -> MeasureTheory.ae_eq_bot is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Iff (Eq.{succ u1} (Filter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))) (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (OfNat.mk.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.zero.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Iff (Eq.{succ u1} (Filter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))) (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.toOfNat0.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0))))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_eq_bot MeasureTheory.ae_eq_bot‚Çì'. -/
@[simp]
theorem ae_eq_bot : Œº.ae = ‚ä• ‚Üî Œº = 0 := by
  rw [‚Üê empty_mem_iff_bot, mem_ae_iff, compl_empty, measure_univ_eq_zero]
#align measure_theory.ae_eq_bot MeasureTheory.ae_eq_bot

#print MeasureTheory.ae_neBot /-
@[simp]
theorem ae_neBot : Œº.ae.ne_bot ‚Üî Œº ‚â† 0 :=
  neBot_iff.trans (not_congr ae_eq_bot)
#align measure_theory.ae_ne_bot MeasureTheory.ae_neBot
-/

/- warning: measure_theory.ae_zero -> MeasureTheory.ae_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±}, Eq.{succ u1} (Filter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (OfNat.mk.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.zero.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0))))) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±}, Eq.{succ u1} (Filter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.toOfNat0.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0)))) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_zero MeasureTheory.ae_zero‚Çì'. -/
@[simp]
theorem ae_zero {m0 : MeasurableSpace Œ±} : (0 : Measure Œ±).ae = ‚ä• :=
  ae_eq_bot.2 rfl
#align measure_theory.ae_zero MeasureTheory.ae_zero

/- warning: measure_theory.ae_mono -> MeasureTheory.ae_mono is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, (LE.le.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº ŒΩ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (MeasureTheory.Measure.ae.{u1} Œ± m0 ŒΩ))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0}, (LE.le.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº ŒΩ) -> (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (MeasureTheory.Measure.ae.{u1} Œ± m0 ŒΩ))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_mono MeasureTheory.ae_mono‚Çì'. -/
@[mono]
theorem ae_mono (h : Œº ‚â§ ŒΩ) : Œº.ae ‚â§ ŒΩ.ae :=
  h.AbsolutelyContinuous.ae_le
#align measure_theory.ae_mono MeasureTheory.ae_mono

/- warning: measure_theory.mem_ae_map_iff -> MeasureTheory.mem_ae_map_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) -> (forall {s : Set.{u2} Œ≤}, (MeasurableSet.{u2} Œ≤ _inst_1 s) -> (Iff (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) s (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº))) (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) (Set.preimage.{u1, u2} Œ± Œ≤ f s) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) -> (forall {s : Set.{u1} Œ≤}, (MeasurableSet.{u1} Œ≤ _inst_1 s) -> (Iff (Membership.mem.{u1, u1} (Set.{u1} Œ≤) (Filter.{u1} Œ≤) (instMembershipSetFilter.{u1} Œ≤) s (MeasureTheory.Measure.ae.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº))) (Membership.mem.{u2, u2} (Set.{u2} Œ±) (Filter.{u2} Œ±) (instMembershipSetFilter.{u2} Œ±) (Set.preimage.{u2, u1} Œ± Œ≤ f s) (MeasureTheory.Measure.ae.{u2} Œ± m0 Œº))))
Case conversion may be inaccurate. Consider using '#align measure_theory.mem_ae_map_iff MeasureTheory.mem_ae_map_iff‚Çì'. -/
theorem mem_ae_map_iff {f : Œ± ‚Üí Œ≤} (hf : AEMeasurable f Œº) {s : Set Œ≤} (hs : MeasurableSet s) :
    s ‚àà (Œº.map f).ae ‚Üî f ‚Åª¬π' s ‚àà Œº.ae := by
  simp only [mem_ae_iff, map_apply_of_ae_measurable hf hs.compl, preimage_compl]
#align measure_theory.mem_ae_map_iff MeasureTheory.mem_ae_map_iff

/- warning: measure_theory.mem_ae_of_mem_ae_map -> MeasureTheory.mem_ae_of_mem_ae_map is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) -> (forall {s : Set.{u2} Œ≤}, (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) s (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº))) -> (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) (Set.preimage.{u1, u2} Œ± Œ≤ f s) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) -> (forall {s : Set.{u1} Œ≤}, (Membership.mem.{u1, u1} (Set.{u1} Œ≤) (Filter.{u1} Œ≤) (instMembershipSetFilter.{u1} Œ≤) s (MeasureTheory.Measure.ae.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº))) -> (Membership.mem.{u2, u2} (Set.{u2} Œ±) (Filter.{u2} Œ±) (instMembershipSetFilter.{u2} Œ±) (Set.preimage.{u2, u1} Œ± Œ≤ f s) (MeasureTheory.Measure.ae.{u2} Œ± m0 Œº)))
Case conversion may be inaccurate. Consider using '#align measure_theory.mem_ae_of_mem_ae_map MeasureTheory.mem_ae_of_mem_ae_map‚Çì'. -/
theorem mem_ae_of_mem_ae_map {f : Œ± ‚Üí Œ≤} (hf : AEMeasurable f Œº) {s : Set Œ≤}
    (hs : s ‚àà (Œº.map f).ae) : f ‚Åª¬π' s ‚àà Œº.ae :=
  (tendsto_ae_map hf).Eventually hs
#align measure_theory.mem_ae_of_mem_ae_map MeasureTheory.mem_ae_of_mem_ae_map

/- warning: measure_theory.ae_map_iff -> MeasureTheory.ae_map_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) -> (forall {p : Œ≤ -> Prop}, (MeasurableSet.{u2} Œ≤ _inst_1 (setOf.{u2} Œ≤ (fun (x : Œ≤) => p x))) -> (Iff (Filter.Eventually.{u2} Œ≤ (fun (y : Œ≤) => p y) (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº))) (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p (f x)) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) -> (forall {p : Œ≤ -> Prop}, (MeasurableSet.{u1} Œ≤ _inst_1 (setOf.{u1} Œ≤ (fun (x : Œ≤) => p x))) -> (Iff (Filter.Eventually.{u1} Œ≤ (fun (y : Œ≤) => p y) (MeasureTheory.Measure.ae.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº))) (Filter.Eventually.{u2} Œ± (fun (x : Œ±) => p (f x)) (MeasureTheory.Measure.ae.{u2} Œ± m0 Œº))))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_map_iff MeasureTheory.ae_map_iff‚Çì'. -/
theorem ae_map_iff {f : Œ± ‚Üí Œ≤} (hf : AEMeasurable f Œº) {p : Œ≤ ‚Üí Prop}
    (hp : MeasurableSet { x | p x }) : (‚àÄ·µê y ‚àÇŒº.map f, p y) ‚Üî ‚àÄ·µê x ‚àÇŒº, p (f x) :=
  mem_ae_map_iff hf hp
#align measure_theory.ae_map_iff MeasureTheory.ae_map_iff

/- warning: measure_theory.ae_of_ae_map -> MeasureTheory.ae_of_ae_map is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) -> (forall {p : Œ≤ -> Prop}, (Filter.Eventually.{u2} Œ≤ (fun (y : Œ≤) => p y) (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº))) -> (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p (f x)) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : Œ± -> Œ≤}, (AEMeasurable.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) -> (forall {p : Œ≤ -> Prop}, (Filter.Eventually.{u1} Œ≤ (fun (y : Œ≤) => p y) (MeasureTheory.Measure.ae.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº))) -> (Filter.Eventually.{u2} Œ± (fun (x : Œ±) => p (f x)) (MeasureTheory.Measure.ae.{u2} Œ± m0 Œº)))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_of_ae_map MeasureTheory.ae_of_ae_map‚Çì'. -/
theorem ae_of_ae_map {f : Œ± ‚Üí Œ≤} (hf : AEMeasurable f Œº) {p : Œ≤ ‚Üí Prop} (h : ‚àÄ·µê y ‚àÇŒº.map f, p y) :
    ‚àÄ·µê x ‚àÇŒº, p (f x) :=
  mem_ae_of_mem_ae_map hf h
#align measure_theory.ae_of_ae_map MeasureTheory.ae_of_ae_map

/- warning: measure_theory.ae_map_mem_range -> MeasureTheory.ae_map_mem_range is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u2} Œ≤] {m0 : MeasurableSpace.{u1} Œ±} (f : Œ± -> Œ≤), (MeasurableSet.{u2} Œ≤ _inst_1 (Set.range.{u2, succ u1} Œ≤ Œ± f)) -> (forall (Œº : MeasureTheory.Measure.{u1} Œ± m0), Filter.Eventually.{u2} Œ≤ (fun (x : Œ≤) => Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) x (Set.range.{u2, succ u1} Œ≤ Œ± f)) (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ≤] {m0 : MeasurableSpace.{u2} Œ±} (f : Œ± -> Œ≤), (MeasurableSet.{u1} Œ≤ _inst_1 (Set.range.{u1, succ u2} Œ≤ Œ± f)) -> (forall (Œº : MeasureTheory.Measure.{u2} Œ± m0), Filter.Eventually.{u1} Œ≤ (fun (x : Œ≤) => Membership.mem.{u1, u1} Œ≤ (Set.{u1} Œ≤) (Set.instMembershipSet.{u1} Œ≤) x (Set.range.{u1, succ u2} Œ≤ Œ± f)) (MeasureTheory.Measure.ae.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº)))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_map_mem_range MeasureTheory.ae_map_mem_range‚Çì'. -/
theorem ae_map_mem_range {m0 : MeasurableSpace Œ±} (f : Œ± ‚Üí Œ≤) (hf : MeasurableSet (range f))
    (Œº : Measure Œ±) : ‚àÄ·µê x ‚àÇŒº.map f, x ‚àà range f :=
  by
  by_cases h : AEMeasurable f Œº
  ¬∑ change range f ‚àà (Œº.map f).ae
    rw [mem_ae_map_iff h hf]
    apply eventually_of_forall
    exact mem_range_self
  ¬∑ simp [map_of_not_ae_measurable h]
#align measure_theory.ae_map_mem_range MeasureTheory.ae_map_mem_range

/- warning: measure_theory.ae_restrict_Union_eq -> MeasureTheory.ae_restrict_union·µ¢_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Countable.{succ u2} Œπ] (s : Œπ -> (Set.{u1} Œ±)), Eq.{succ u1} (Filter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => s i)))) (sup·µ¢.{u1, succ u2} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasSup.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) Œπ (fun (i : Œπ) => MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Countable.{succ u2} Œπ] (s : Œπ -> (Set.{u1} Œ±)), Eq.{succ u1} (Filter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => s i)))) (sup·µ¢.{u1, succ u2} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toSupSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) Œπ (fun (i : Œπ) => MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i))))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_restrict_Union_eq MeasureTheory.ae_restrict_union·µ¢_eq‚Çì'. -/
@[simp]
theorem ae_restrict_union·µ¢_eq [Countable Œπ] (s : Œπ ‚Üí Set Œ±) :
    (Œº.restrict (‚ãÉ i, s i)).ae = ‚®Ü i, (Œº.restrict (s i)).ae :=
  le_antisymm ((ae_sum_eq fun i => Œº.restrict (s i)) ‚ñ∏ ae_mono restrict_union·µ¢_le) <|
    sup·µ¢_le fun i => ae_mono <| restrict_mono (subset_union·µ¢ s i) le_rfl
#align measure_theory.ae_restrict_Union_eq MeasureTheory.ae_restrict_union·µ¢_eq

#print MeasureTheory.ae_restrict_union_eq /-
@[simp]
theorem ae_restrict_union_eq (s t : Set Œ±) :
    (Œº.restrict (s ‚à™ t)).ae = (Œº.restrict s).ae ‚äî (Œº.restrict t).ae := by
  simp [union_eq_Union, sup·µ¢_bool_eq]
#align measure_theory.ae_restrict_union_eq MeasureTheory.ae_restrict_union_eq
-/

/- warning: measure_theory.ae_restrict_bUnion_eq -> MeasureTheory.ae_restrict_bunion·µ¢_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} (s : Œπ -> (Set.{u1} Œ±)) {t : Set.{u2} Œπ}, (Set.Countable.{u2} Œπ t) -> (Eq.{succ u1} (Filter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => Set.union·µ¢.{u1, 0} Œ± (Membership.Mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.hasMem.{u2} Œπ) i t) (fun (H : Membership.Mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.hasMem.{u2} Œπ) i t) => s i))))) (sup·µ¢.{u1, succ u2} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasSup.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) Œπ (fun (i : Œπ) => sup·µ¢.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasSup.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) (Membership.Mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.hasMem.{u2} Œπ) i t) (fun (H : Membership.Mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.hasMem.{u2} Œπ) i t) => MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i))))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} {Œº : MeasureTheory.Measure.{u2} Œ± m0} (s : Œπ -> (Set.{u2} Œ±)) {t : Set.{u1} Œπ}, (Set.Countable.{u1} Œπ t) -> (Eq.{succ u2} (Filter.{u2} Œ±) (MeasureTheory.Measure.ae.{u2} Œ± m0 (MeasureTheory.Measure.restrict.{u2} Œ± m0 Œº (Set.union·µ¢.{u2, succ u1} Œ± Œπ (fun (i : Œπ) => Set.union·µ¢.{u2, 0} Œ± (Membership.mem.{u1, u1} Œπ (Set.{u1} Œπ) (Set.instMembershipSet.{u1} Œπ) i t) (fun (H : Membership.mem.{u1, u1} Œπ (Set.{u1} Œπ) (Set.instMembershipSet.{u1} Œπ) i t) => s i))))) (sup·µ¢.{u2, succ u1} (Filter.{u2} Œ±) (ConditionallyCompleteLattice.toSupSet.{u2} (Filter.{u2} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Filter.{u2} Œ±) (Filter.instCompleteLatticeFilter.{u2} Œ±))) Œπ (fun (i : Œπ) => sup·µ¢.{u2, 0} (Filter.{u2} Œ±) (ConditionallyCompleteLattice.toSupSet.{u2} (Filter.{u2} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Filter.{u2} Œ±) (Filter.instCompleteLatticeFilter.{u2} Œ±))) (Membership.mem.{u1, u1} Œπ (Set.{u1} Œπ) (Set.instMembershipSet.{u1} Œπ) i t) (fun (H : Membership.mem.{u1, u1} Œπ (Set.{u1} Œπ) (Set.instMembershipSet.{u1} Œπ) i t) => MeasureTheory.Measure.ae.{u2} Œ± m0 (MeasureTheory.Measure.restrict.{u2} Œ± m0 Œº (s i))))))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_restrict_bUnion_eq MeasureTheory.ae_restrict_bunion·µ¢_eq‚Çì'. -/
theorem ae_restrict_bunion·µ¢_eq (s : Œπ ‚Üí Set Œ±) {t : Set Œπ} (ht : t.Countable) :
    (Œº.restrict (‚ãÉ i ‚àà t, s i)).ae = ‚®Ü i ‚àà t, (Œº.restrict (s i)).ae :=
  by
  haveI := ht.to_subtype
  rw [bUnion_eq_Union, ae_restrict_Union_eq, ‚Üê sup·µ¢_subtype'']
#align measure_theory.ae_restrict_bUnion_eq MeasureTheory.ae_restrict_bunion·µ¢_eq

/- warning: measure_theory.ae_restrict_bUnion_finset_eq -> MeasureTheory.ae_restrict_bunion·µ¢_finset_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} (s : Œπ -> (Set.{u1} Œ±)) (t : Finset.{u2} Œπ), Eq.{succ u1} (Filter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => Set.union·µ¢.{u1, 0} Œ± (Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) i t) (fun (H : Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) i t) => s i))))) (sup·µ¢.{u1, succ u2} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasSup.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) Œπ (fun (i : Œπ) => sup·µ¢.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasSup.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) (Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) i t) (fun (H : Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) i t) => MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i)))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} {Œº : MeasureTheory.Measure.{u2} Œ± m0} (s : Œπ -> (Set.{u2} Œ±)) (t : Finset.{u1} Œπ), Eq.{succ u2} (Filter.{u2} Œ±) (MeasureTheory.Measure.ae.{u2} Œ± m0 (MeasureTheory.Measure.restrict.{u2} Œ± m0 Œº (Set.union·µ¢.{u2, succ u1} Œ± Œπ (fun (i : Œπ) => Set.union·µ¢.{u2, 0} Œ± (Membership.mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.instMembershipFinset.{u1} Œπ) i t) (fun (H : Membership.mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.instMembershipFinset.{u1} Œπ) i t) => s i))))) (sup·µ¢.{u2, succ u1} (Filter.{u2} Œ±) (ConditionallyCompleteLattice.toSupSet.{u2} (Filter.{u2} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Filter.{u2} Œ±) (Filter.instCompleteLatticeFilter.{u2} Œ±))) Œπ (fun (i : Œπ) => sup·µ¢.{u2, 0} (Filter.{u2} Œ±) (ConditionallyCompleteLattice.toSupSet.{u2} (Filter.{u2} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Filter.{u2} Œ±) (Filter.instCompleteLatticeFilter.{u2} Œ±))) (Membership.mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.instMembershipFinset.{u1} Œπ) i t) (fun (H : Membership.mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.instMembershipFinset.{u1} Œπ) i t) => MeasureTheory.Measure.ae.{u2} Œ± m0 (MeasureTheory.Measure.restrict.{u2} Œ± m0 Œº (s i)))))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_restrict_bUnion_finset_eq MeasureTheory.ae_restrict_bunion·µ¢_finset_eq‚Çì'. -/
theorem ae_restrict_bunion·µ¢_finset_eq (s : Œπ ‚Üí Set Œ±) (t : Finset Œπ) :
    (Œº.restrict (‚ãÉ i ‚àà t, s i)).ae = ‚®Ü i ‚àà t, (Œº.restrict (s i)).ae :=
  ae_restrict_bunion·µ¢_eq s t.countable_toSet
#align measure_theory.ae_restrict_bUnion_finset_eq MeasureTheory.ae_restrict_bunion·µ¢_finset_eq

#print MeasureTheory.ae_restrict_union·µ¢_iff /-
theorem ae_restrict_union·µ¢_iff [Countable Œπ] (s : Œπ ‚Üí Set Œ±) (p : Œ± ‚Üí Prop) :
    (‚àÄ·µê x ‚àÇŒº.restrict (‚ãÉ i, s i), p x) ‚Üî ‚àÄ i, ‚àÄ·µê x ‚àÇŒº.restrict (s i), p x := by simp
#align measure_theory.ae_restrict_Union_iff MeasureTheory.ae_restrict_union·µ¢_iff
-/

#print MeasureTheory.ae_restrict_union_iff /-
theorem ae_restrict_union_iff (s t : Set Œ±) (p : Œ± ‚Üí Prop) :
    (‚àÄ·µê x ‚àÇŒº.restrict (s ‚à™ t), p x) ‚Üî (‚àÄ·µê x ‚àÇŒº.restrict s, p x) ‚àß ‚àÄ·µê x ‚àÇŒº.restrict t, p x := by simp
#align measure_theory.ae_restrict_union_iff MeasureTheory.ae_restrict_union_iff
-/

/- warning: measure_theory.ae_restrict_bUnion_iff -> MeasureTheory.ae_restrict_bunion·µ¢_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} (s : Œπ -> (Set.{u1} Œ±)) {t : Set.{u2} Œπ}, (Set.Countable.{u2} Œπ t) -> (forall (p : Œ± -> Prop), Iff (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => Set.union·µ¢.{u1, 0} Œ± (Membership.Mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.hasMem.{u2} Œπ) i t) (fun (H : Membership.Mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.hasMem.{u2} Œπ) i t) => s i)))))) (forall (i : Œπ), (Membership.Mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.hasMem.{u2} Œπ) i t) -> (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i))))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} {Œº : MeasureTheory.Measure.{u2} Œ± m0} (s : Œπ -> (Set.{u2} Œ±)) {t : Set.{u1} Œπ}, (Set.Countable.{u1} Œπ t) -> (forall (p : Œ± -> Prop), Iff (Filter.Eventually.{u2} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u2} Œ± m0 (MeasureTheory.Measure.restrict.{u2} Œ± m0 Œº (Set.union·µ¢.{u2, succ u1} Œ± Œπ (fun (i : Œπ) => Set.union·µ¢.{u2, 0} Œ± (Membership.mem.{u1, u1} Œπ (Set.{u1} Œπ) (Set.instMembershipSet.{u1} Œπ) i t) (fun (H : Membership.mem.{u1, u1} Œπ (Set.{u1} Œπ) (Set.instMembershipSet.{u1} Œπ) i t) => s i)))))) (forall (i : Œπ), (Membership.mem.{u1, u1} Œπ (Set.{u1} Œπ) (Set.instMembershipSet.{u1} Œπ) i t) -> (Filter.Eventually.{u2} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u2} Œ± m0 (MeasureTheory.Measure.restrict.{u2} Œ± m0 Œº (s i))))))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_restrict_bUnion_iff MeasureTheory.ae_restrict_bunion·µ¢_iff‚Çì'. -/
theorem ae_restrict_bunion·µ¢_iff (s : Œπ ‚Üí Set Œ±) {t : Set Œπ} (ht : t.Countable) (p : Œ± ‚Üí Prop) :
    (‚àÄ·µê x ‚àÇŒº.restrict (‚ãÉ i ‚àà t, s i), p x) ‚Üî ‚àÄ i ‚àà t, ‚àÄ·µê x ‚àÇŒº.restrict (s i), p x := by
  simp_rw [Filter.Eventually, ae_restrict_bUnion_eq s ht, mem_supr]
#align measure_theory.ae_restrict_bUnion_iff MeasureTheory.ae_restrict_bunion·µ¢_iff

/- warning: measure_theory.ae_restrict_bUnion_finset_iff -> MeasureTheory.ae_restrict_bunion·µ¢_finset_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} (s : Œπ -> (Set.{u1} Œ±)) (t : Finset.{u2} Œπ) (p : Œ± -> Prop), Iff (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => Set.union·µ¢.{u1, 0} Œ± (Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) i t) (fun (H : Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) i t) => s i)))))) (forall (i : Œπ), (Membership.Mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.hasMem.{u2} Œπ) i t) -> (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i)))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} {Œº : MeasureTheory.Measure.{u2} Œ± m0} (s : Œπ -> (Set.{u2} Œ±)) (t : Finset.{u1} Œπ) (p : Œ± -> Prop), Iff (Filter.Eventually.{u2} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u2} Œ± m0 (MeasureTheory.Measure.restrict.{u2} Œ± m0 Œº (Set.union·µ¢.{u2, succ u1} Œ± Œπ (fun (i : Œπ) => Set.union·µ¢.{u2, 0} Œ± (Membership.mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.instMembershipFinset.{u1} Œπ) i t) (fun (H : Membership.mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.instMembershipFinset.{u1} Œπ) i t) => s i)))))) (forall (i : Œπ), (Membership.mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.instMembershipFinset.{u1} Œπ) i t) -> (Filter.Eventually.{u2} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u2} Œ± m0 (MeasureTheory.Measure.restrict.{u2} Œ± m0 Œº (s i)))))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_restrict_bUnion_finset_iff MeasureTheory.ae_restrict_bunion·µ¢_finset_iff‚Çì'. -/
@[simp]
theorem ae_restrict_bunion·µ¢_finset_iff (s : Œπ ‚Üí Set Œ±) (t : Finset Œπ) (p : Œ± ‚Üí Prop) :
    (‚àÄ·µê x ‚àÇŒº.restrict (‚ãÉ i ‚àà t, s i), p x) ‚Üî ‚àÄ i ‚àà t, ‚àÄ·µê x ‚àÇŒº.restrict (s i), p x := by
  simp_rw [Filter.Eventually, ae_restrict_bUnion_finset_eq s, mem_supr]
#align measure_theory.ae_restrict_bUnion_finset_iff MeasureTheory.ae_restrict_bunion·µ¢_finset_iff

/- warning: measure_theory.ae_eq_restrict_Union_iff -> MeasureTheory.ae_eq_restrict_union·µ¢_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} {Œπ : Type.{u3}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Countable.{succ u3} Œπ] (s : Œπ -> (Set.{u1} Œ±)) (f : Œ± -> Œ¥) (g : Œ± -> Œ¥), Iff (Filter.EventuallyEq.{u1, u2} Œ± Œ¥ (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u3} Œ± Œπ (fun (i : Œπ) => s i)))) f g) (forall (i : Œπ), Filter.EventuallyEq.{u1, u2} Œ± Œ¥ (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i))) f g)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ¥ : Type.{u1}} {Œπ : Type.{u3}} {m0 : MeasurableSpace.{u2} Œ±} {Œº : MeasureTheory.Measure.{u2} Œ± m0} [_inst_3 : Countable.{succ u3} Œπ] (s : Œπ -> (Set.{u2} Œ±)) (f : Œ± -> Œ¥) (g : Œ± -> Œ¥), Iff (Filter.EventuallyEq.{u2, u1} Œ± Œ¥ (MeasureTheory.Measure.ae.{u2} Œ± m0 (MeasureTheory.Measure.restrict.{u2} Œ± m0 Œº (Set.union·µ¢.{u2, succ u3} Œ± Œπ (fun (i : Œπ) => s i)))) f g) (forall (i : Œπ), Filter.EventuallyEq.{u2, u1} Œ± Œ¥ (MeasureTheory.Measure.ae.{u2} Œ± m0 (MeasureTheory.Measure.restrict.{u2} Œ± m0 Œº (s i))) f g)
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_eq_restrict_Union_iff MeasureTheory.ae_eq_restrict_union·µ¢_iff‚Çì'. -/
theorem ae_eq_restrict_union·µ¢_iff [Countable Œπ] (s : Œπ ‚Üí Set Œ±) (f g : Œ± ‚Üí Œ¥) :
    f =·µê[Œº.restrict (‚ãÉ i, s i)] g ‚Üî ‚àÄ i, f =·µê[Œº.restrict (s i)] g := by
  simp_rw [eventually_eq, ae_restrict_Union_eq, eventually_supr]
#align measure_theory.ae_eq_restrict_Union_iff MeasureTheory.ae_eq_restrict_union·µ¢_iff

/- warning: measure_theory.ae_eq_restrict_bUnion_iff -> MeasureTheory.ae_eq_restrict_bunion·µ¢_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} {Œπ : Type.{u3}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} (s : Œπ -> (Set.{u1} Œ±)) {t : Set.{u3} Œπ}, (Set.Countable.{u3} Œπ t) -> (forall (f : Œ± -> Œ¥) (g : Œ± -> Œ¥), Iff (Filter.EventuallyEq.{u1, u2} Œ± Œ¥ (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u3} Œ± Œπ (fun (i : Œπ) => Set.union·µ¢.{u1, 0} Œ± (Membership.Mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.hasMem.{u3} Œπ) i t) (fun (H : Membership.Mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.hasMem.{u3} Œπ) i t) => s i))))) f g) (forall (i : Œπ), (Membership.Mem.{u3, u3} Œπ (Set.{u3} Œπ) (Set.hasMem.{u3} Œπ) i t) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ¥ (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i))) f g)))
but is expected to have type
  forall {Œ± : Type.{u3}} {Œ¥ : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u3} Œ±} {Œº : MeasureTheory.Measure.{u3} Œ± m0} (s : Œπ -> (Set.{u3} Œ±)) {t : Set.{u2} Œπ}, (Set.Countable.{u2} Œπ t) -> (forall (f : Œ± -> Œ¥) (g : Œ± -> Œ¥), Iff (Filter.EventuallyEq.{u3, u1} Œ± Œ¥ (MeasureTheory.Measure.ae.{u3} Œ± m0 (MeasureTheory.Measure.restrict.{u3} Œ± m0 Œº (Set.union·µ¢.{u3, succ u2} Œ± Œπ (fun (i : Œπ) => Set.union·µ¢.{u3, 0} Œ± (Membership.mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.instMembershipSet.{u2} Œπ) i t) (fun (H : Membership.mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.instMembershipSet.{u2} Œπ) i t) => s i))))) f g) (forall (i : Œπ), (Membership.mem.{u2, u2} Œπ (Set.{u2} Œπ) (Set.instMembershipSet.{u2} Œπ) i t) -> (Filter.EventuallyEq.{u3, u1} Œ± Œ¥ (MeasureTheory.Measure.ae.{u3} Œ± m0 (MeasureTheory.Measure.restrict.{u3} Œ± m0 Œº (s i))) f g)))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_eq_restrict_bUnion_iff MeasureTheory.ae_eq_restrict_bunion·µ¢_iff‚Çì'. -/
theorem ae_eq_restrict_bunion·µ¢_iff (s : Œπ ‚Üí Set Œ±) {t : Set Œπ} (ht : t.Countable) (f g : Œ± ‚Üí Œ¥) :
    f =·µê[Œº.restrict (‚ãÉ i ‚àà t, s i)] g ‚Üî ‚àÄ i ‚àà t, f =·µê[Œº.restrict (s i)] g := by
  simp_rw [ae_restrict_bUnion_eq s ht, eventually_eq, eventually_supr]
#align measure_theory.ae_eq_restrict_bUnion_iff MeasureTheory.ae_eq_restrict_bunion·µ¢_iff

/- warning: measure_theory.ae_eq_restrict_bUnion_finset_iff -> MeasureTheory.ae_eq_restrict_bunion·µ¢_finset_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} {Œπ : Type.{u3}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} (s : Œπ -> (Set.{u1} Œ±)) (t : Finset.{u3} Œπ) (f : Œ± -> Œ¥) (g : Œ± -> Œ¥), Iff (Filter.EventuallyEq.{u1, u2} Œ± Œ¥ (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.union·µ¢.{u1, succ u3} Œ± Œπ (fun (i : Œπ) => Set.union·µ¢.{u1, 0} Œ± (Membership.Mem.{u3, u3} Œπ (Finset.{u3} Œπ) (Finset.hasMem.{u3} Œπ) i t) (fun (H : Membership.Mem.{u3, u3} Œπ (Finset.{u3} Œπ) (Finset.hasMem.{u3} Œπ) i t) => s i))))) f g) (forall (i : Œπ), (Membership.Mem.{u3, u3} Œπ (Finset.{u3} Œπ) (Finset.hasMem.{u3} Œπ) i t) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ¥ (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (s i))) f g))
but is expected to have type
  forall {Œ± : Type.{u3}} {Œ¥ : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u3} Œ±} {Œº : MeasureTheory.Measure.{u3} Œ± m0} (s : Œπ -> (Set.{u3} Œ±)) (t : Finset.{u2} Œπ) (f : Œ± -> Œ¥) (g : Œ± -> Œ¥), Iff (Filter.EventuallyEq.{u3, u1} Œ± Œ¥ (MeasureTheory.Measure.ae.{u3} Œ± m0 (MeasureTheory.Measure.restrict.{u3} Œ± m0 Œº (Set.union·µ¢.{u3, succ u2} Œ± Œπ (fun (i : Œπ) => Set.union·µ¢.{u3, 0} Œ± (Membership.mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.instMembershipFinset.{u2} Œπ) i t) (fun (H : Membership.mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.instMembershipFinset.{u2} Œπ) i t) => s i))))) f g) (forall (i : Œπ), (Membership.mem.{u2, u2} Œπ (Finset.{u2} Œπ) (Finset.instMembershipFinset.{u2} Œπ) i t) -> (Filter.EventuallyEq.{u3, u1} Œ± Œ¥ (MeasureTheory.Measure.ae.{u3} Œ± m0 (MeasureTheory.Measure.restrict.{u3} Œ± m0 Œº (s i))) f g))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_eq_restrict_bUnion_finset_iff MeasureTheory.ae_eq_restrict_bunion·µ¢_finset_iff‚Çì'. -/
theorem ae_eq_restrict_bunion·µ¢_finset_iff (s : Œπ ‚Üí Set Œ±) (t : Finset Œπ) (f g : Œ± ‚Üí Œ¥) :
    f =·µê[Œº.restrict (‚ãÉ i ‚àà t, s i)] g ‚Üî ‚àÄ i ‚àà t, f =·µê[Œº.restrict (s i)] g :=
  ae_eq_restrict_bunion·µ¢_iff s t.countable_toSet f g
#align measure_theory.ae_eq_restrict_bUnion_finset_iff MeasureTheory.ae_eq_restrict_bunion·µ¢_finset_iff

/- warning: measure_theory.ae_restrict_uIoc_eq -> MeasureTheory.ae_restrict_uIoc_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : LinearOrder.{u1} Œ±] (a : Œ±) (b : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.uIoc.{u1} Œ± _inst_3 a b))) (Sup.sup.{u1} (Filter.{u1} Œ±) (SemilatticeSup.toHasSup.{u1} (Filter.{u1} Œ±) (Lattice.toSemilatticeSup.{u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toLattice.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))))) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_3)))) a b))) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_3)))) b a))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : LinearOrder.{u1} Œ±] (a : Œ±) (b : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.uIoc.{u1} Œ± _inst_3 a b))) (Sup.sup.{u1} (Filter.{u1} Œ±) (SemilatticeSup.toSup.{u1} (Filter.{u1} Œ±) (Lattice.toSemilatticeSup.{u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toLattice.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))))) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_3))))) a b))) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_3))))) b a))))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_restrict_uIoc_eq MeasureTheory.ae_restrict_uIoc_eq‚Çì'. -/
theorem ae_restrict_uIoc_eq [LinearOrder Œ±] (a b : Œ±) :
    (Œº.restrict (Œô a b)).ae = (Œº.restrict (Ioc a b)).ae ‚äî (Œº.restrict (Ioc b a)).ae := by
  simp only [uIoc_eq_union, ae_restrict_union_eq]
#align measure_theory.ae_restrict_uIoc_eq MeasureTheory.ae_restrict_uIoc_eq

#print MeasureTheory.ae_restrict_uIoc_iff /-
/-- See also `measure_theory.ae_uIoc_iff`. -/
theorem ae_restrict_uIoc_iff [LinearOrder Œ±] {a b : Œ±} {P : Œ± ‚Üí Prop} :
    (‚àÄ·µê x ‚àÇŒº.restrict (Œô a b), P x) ‚Üî
      (‚àÄ·µê x ‚àÇŒº.restrict (Ioc a b), P x) ‚àß ‚àÄ·µê x ‚àÇŒº.restrict (Ioc b a), P x :=
  by rw [ae_restrict_uIoc_eq, eventually_sup]
#align measure_theory.ae_restrict_uIoc_iff MeasureTheory.ae_restrict_uIoc_iff
-/

#print MeasureTheory.ae_restrict_iff /-
theorem ae_restrict_iff {p : Œ± ‚Üí Prop} (hp : MeasurableSet { x | p x }) :
    (‚àÄ·µê x ‚àÇŒº.restrict s, p x) ‚Üî ‚àÄ·µê x ‚àÇŒº, x ‚àà s ‚Üí p x :=
  by
  simp only [ae_iff, ‚Üê compl_set_of, restrict_apply hp.compl]
  congr with x; simp [and_comm']
#align measure_theory.ae_restrict_iff MeasureTheory.ae_restrict_iff
-/

#print MeasureTheory.ae_imp_of_ae_restrict /-
theorem ae_imp_of_ae_restrict {s : Set Œ±} {p : Œ± ‚Üí Prop} (h : ‚àÄ·µê x ‚àÇŒº.restrict s, p x) :
    ‚àÄ·µê x ‚àÇŒº, x ‚àà s ‚Üí p x := by
  simp only [ae_iff] at h‚ä¢
  simpa [set_of_and, inter_comm] using measure_inter_eq_zero_of_restrict h
#align measure_theory.ae_imp_of_ae_restrict MeasureTheory.ae_imp_of_ae_restrict
-/

#print MeasureTheory.ae_restrict_iff' /-
theorem ae_restrict_iff' {p : Œ± ‚Üí Prop} (hs : MeasurableSet s) :
    (‚àÄ·µê x ‚àÇŒº.restrict s, p x) ‚Üî ‚àÄ·µê x ‚àÇŒº, x ‚àà s ‚Üí p x :=
  by
  simp only [ae_iff, ‚Üê compl_set_of, restrict_apply_eq_zero' hs]
  congr with x; simp [and_comm']
#align measure_theory.ae_restrict_iff' MeasureTheory.ae_restrict_iff'
-/

/- warning: filter.eventually_eq.restrict -> Filter.EventuallyEq.restrict is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ¥} {g : Œ± -> Œ¥} {s : Set.{u1} Œ±}, (Filter.EventuallyEq.{u1, u2} Œ± Œ¥ (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) f g) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ¥ (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) f g)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ¥ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : Œ± -> Œ¥} {g : Œ± -> Œ¥} {s : Set.{u2} Œ±}, (Filter.EventuallyEq.{u2, u1} Œ± Œ¥ (MeasureTheory.Measure.ae.{u2} Œ± m0 Œº) f g) -> (Filter.EventuallyEq.{u2, u1} Œ± Œ¥ (MeasureTheory.Measure.ae.{u2} Œ± m0 (MeasureTheory.Measure.restrict.{u2} Œ± m0 Œº s)) f g)
Case conversion may be inaccurate. Consider using '#align filter.eventually_eq.restrict Filter.EventuallyEq.restrict‚Çì'. -/
theorem Filter.EventuallyEq.restrict {f g : Œ± ‚Üí Œ¥} {s : Set Œ±} (hfg : f =·µê[Œº] g) :
    f =·µê[Œº.restrict s] g :=
  by
  -- note that we cannot use `ae_restrict_iff` since we do not require measurability
  refine' hfg.filter_mono _
  rw [measure.ae_le_iff_absolutely_continuous]
  exact measure.absolutely_continuous_of_le measure.restrict_le_self
#align filter.eventually_eq.restrict Filter.EventuallyEq.restrict

#print MeasureTheory.ae_restrict_mem /-
theorem ae_restrict_mem (hs : MeasurableSet s) : ‚àÄ·µê x ‚àÇŒº.restrict s, x ‚àà s :=
  (ae_restrict_iff' hs).2 (Filter.eventually_of_forall fun x => id)
#align measure_theory.ae_restrict_mem MeasureTheory.ae_restrict_mem
-/

#print MeasureTheory.ae_restrict_mem‚ÇÄ /-
theorem ae_restrict_mem‚ÇÄ (hs : NullMeasurableSet s Œº) : ‚àÄ·µê x ‚àÇŒº.restrict s, x ‚àà s :=
  by
  rcases hs.exists_measurable_subset_ae_eq with ‚ü®t, hts, htm, ht_eq‚ü©
  rw [‚Üê restrict_congr_set ht_eq]
  exact (ae_restrict_mem htm).mono hts
#align measure_theory.ae_restrict_mem‚ÇÄ MeasureTheory.ae_restrict_mem‚ÇÄ
-/

#print MeasureTheory.ae_restrict_of_ae /-
theorem ae_restrict_of_ae {s : Set Œ±} {p : Œ± ‚Üí Prop} (h : ‚àÄ·µê x ‚àÇŒº, p x) : ‚àÄ·µê x ‚àÇŒº.restrict s, p x :=
  Eventually.filter_mono (ae_mono Measure.restrict_le_self) h
#align measure_theory.ae_restrict_of_ae MeasureTheory.ae_restrict_of_ae
-/

#print MeasureTheory.ae_restrict_iff'‚ÇÄ /-
theorem ae_restrict_iff'‚ÇÄ {p : Œ± ‚Üí Prop} (hs : NullMeasurableSet s Œº) :
    (‚àÄ·µê x ‚àÇŒº.restrict s, p x) ‚Üî ‚àÄ·µê x ‚àÇŒº, x ‚àà s ‚Üí p x :=
  by
  refine' ‚ü®fun h => ae_imp_of_ae_restrict h, fun h => _‚ü©
  filter_upwards [ae_restrict_mem‚ÇÄ hs, ae_restrict_of_ae h]with x hx h'x using h'x hx
#align measure_theory.ae_restrict_iff'‚ÇÄ MeasureTheory.ae_restrict_iff'‚ÇÄ
-/

#print MeasureTheory.ae_restrict_of_ae_restrict_of_subset /-
theorem ae_restrict_of_ae_restrict_of_subset {s t : Set Œ±} {p : Œ± ‚Üí Prop} (hst : s ‚äÜ t)
    (h : ‚àÄ·µê x ‚àÇŒº.restrict t, p x) : ‚àÄ·µê x ‚àÇŒº.restrict s, p x :=
  h.filter_mono (ae_mono <| Measure.restrict_mono hst (le_refl Œº))
#align measure_theory.ae_restrict_of_ae_restrict_of_subset MeasureTheory.ae_restrict_of_ae_restrict_of_subset
-/

#print MeasureTheory.ae_of_ae_restrict_of_ae_restrict_compl /-
theorem ae_of_ae_restrict_of_ae_restrict_compl (t : Set Œ±) {p : Œ± ‚Üí Prop}
    (ht : ‚àÄ·µê x ‚àÇŒº.restrict t, p x) (htc : ‚àÄ·µê x ‚àÇŒº.restrict (t·∂ú), p x) : ‚àÄ·µê x ‚àÇŒº, p x :=
  nonpos_iff_eq_zero.1 <|
    calc
      Œº { x | ¬¨p x } = Œº ({ x | ¬¨p x } ‚à© t ‚à™ { x | ¬¨p x } ‚à© t·∂ú) := by
        rw [‚Üê inter_union_distrib_left, union_compl_self, inter_univ]
      _ ‚â§ Œº ({ x | ¬¨p x } ‚à© t) + Œº ({ x | ¬¨p x } ‚à© t·∂ú) := (measure_union_le _ _)
      _ ‚â§ Œº.restrict t { x | ¬¨p x } + Œº.restrict (t·∂ú) { x | ¬¨p x } :=
        (add_le_add (le_restrict_apply _ _) (le_restrict_apply _ _))
      _ = 0 := by rw [ae_iff.1 ht, ae_iff.1 htc, zero_add]
      
#align measure_theory.ae_of_ae_restrict_of_ae_restrict_compl MeasureTheory.ae_of_ae_restrict_of_ae_restrict_compl
-/

/- warning: measure_theory.mem_map_restrict_ae_iff -> MeasureTheory.mem_map_restrict_ae_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {Œ≤ : Type.{u2}} {s : Set.{u1} Œ±} {t : Set.{u2} Œ≤} {f : Œ± -> Œ≤}, (MeasurableSet.{u1} Œ± m0 s) -> (Iff (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) t (Filter.map.{u1, u2} Œ± Œ≤ f (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)))) (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) (Set.preimage.{u1, u2} Œ± Œ≤ f t)) s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {Œ≤ : Type.{u2}} {s : Set.{u1} Œ±} {t : Set.{u2} Œ≤} {f : Œ± -> Œ≤}, (MeasurableSet.{u1} Œ± m0 s) -> (Iff (Membership.mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (instMembershipSetFilter.{u2} Œ≤) t (Filter.map.{u1, u2} Œ± Œ≤ f (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)))) (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) (Set.preimage.{u1, u2} Œ± Œ≤ f t)) s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))))
Case conversion may be inaccurate. Consider using '#align measure_theory.mem_map_restrict_ae_iff MeasureTheory.mem_map_restrict_ae_iff‚Çì'. -/
theorem mem_map_restrict_ae_iff {Œ≤} {s : Set Œ±} {t : Set Œ≤} {f : Œ± ‚Üí Œ≤} (hs : MeasurableSet s) :
    t ‚àà Filter.map f (Œº.restrict s).ae ‚Üî Œº ((f ‚Åª¬π' t)·∂ú ‚à© s) = 0 := by
  rw [mem_map, mem_ae_iff, measure.restrict_apply' hs]
#align measure_theory.mem_map_restrict_ae_iff MeasureTheory.mem_map_restrict_ae_iff

/- warning: measure_theory.ae_smul_measure -> MeasureTheory.ae_smul_measure is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {R : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {p : Œ± -> Prop} [_inst_3 : Monoid.{u2} R] [_inst_4 : DistribMulAction.{u2, 0} R ENNReal _inst_3 (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))] [_inst_5 : IsScalarTower.{u2, 0, 0} R ENNReal ENNReal (SMulZeroClass.toHasSmul.{u2, 0} R ENNReal (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))) (DistribSMul.toSmulZeroClass.{u2, 0} R ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))) (DistribMulAction.toDistribSMul.{u2, 0} R ENNReal _inst_3 (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)) _inst_4))) (Mul.toSMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (SMulZeroClass.toHasSmul.{u2, 0} R ENNReal (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))) (DistribSMul.toSmulZeroClass.{u2, 0} R ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))) (DistribMulAction.toDistribSMul.{u2, 0} R ENNReal _inst_3 (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)) _inst_4)))], (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº)) -> (forall (c : R), Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u1} Œ± m0 (SMul.smul.{u2, u1} R (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, u2} Œ± R (SMulZeroClass.toHasSmul.{u2, 0} R ENNReal (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))) (DistribSMul.toSmulZeroClass.{u2, 0} R ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))) (DistribMulAction.toDistribSMul.{u2, 0} R ENNReal _inst_3 (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)) _inst_4))) _inst_5 m0) c Œº)))
but is expected to have type
  forall {Œ± : Type.{u1}} {R : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {p : Œ± -> Prop} [_inst_3 : Monoid.{u2} R] [_inst_4 : DistribMulAction.{u2, 0} R ENNReal _inst_3 (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal instENNRealAddCommMonoidWithOne))] [_inst_5 : IsScalarTower.{u2, 0, 0} R ENNReal ENNReal (SMulZeroClass.toSMul.{u2, 0} R ENNReal instENNRealZero (DistribSMul.toSMulZeroClass.{u2, 0} R ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal instENNRealAddCommMonoidWithOne))) (DistribMulAction.toDistribSMul.{u2, 0} R ENNReal _inst_3 (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal instENNRealAddCommMonoidWithOne)) _inst_4))) (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (SMulZeroClass.toSMul.{u2, 0} R ENNReal instENNRealZero (DistribSMul.toSMulZeroClass.{u2, 0} R ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal instENNRealAddCommMonoidWithOne))) (DistribMulAction.toDistribSMul.{u2, 0} R ENNReal _inst_3 (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal instENNRealAddCommMonoidWithOne)) _inst_4)))], (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº)) -> (forall (c : R), Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (MeasureTheory.Measure.ae.{u1} Œ± m0 (HSMul.hSMul.{u2, u1, u1} R (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHSMul.{u2, u1} R (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, u2} Œ± R (SMulZeroClass.toSMul.{u2, 0} R ENNReal instENNRealZero (DistribSMul.toSMulZeroClass.{u2, 0} R ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal instENNRealAddCommMonoidWithOne))) (DistribMulAction.toDistribSMul.{u2, 0} R ENNReal _inst_3 (AddMonoidWithOne.toAddMonoid.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal instENNRealAddCommMonoidWithOne)) _inst_4))) _inst_5 m0)) c Œº)))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_smul_measure MeasureTheory.ae_smul_measure‚Çì'. -/
theorem ae_smul_measure {p : Œ± ‚Üí Prop} [Monoid R] [DistribMulAction R ‚Ñù‚â•0‚àû]
    [IsScalarTower R ‚Ñù‚â•0‚àû ‚Ñù‚â•0‚àû] (h : ‚àÄ·µê x ‚àÇŒº, p x) (c : R) : ‚àÄ·µê x ‚àÇc ‚Ä¢ Œº, p x :=
  ae_iff.2 <| by rw [smul_apply, ae_iff.1 h, smul_zero]
#align measure_theory.ae_smul_measure MeasureTheory.ae_smul_measure

#print MeasureTheory.ae_add_measure_iff /-
theorem ae_add_measure_iff {p : Œ± ‚Üí Prop} {ŒΩ} :
    (‚àÄ·µê x ‚àÇŒº + ŒΩ, p x) ‚Üî (‚àÄ·µê x ‚àÇŒº, p x) ‚àß ‚àÄ·µê x ‚àÇŒΩ, p x :=
  add_eq_zero_iff
#align measure_theory.ae_add_measure_iff MeasureTheory.ae_add_measure_iff
-/

/- warning: measure_theory.ae_eq_comp' -> MeasureTheory.ae_eq_comp' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ¥ : Type.{u3}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u2} Œ≤ _inst_1} {f : Œ± -> Œ≤} {g : Œ≤ -> Œ¥} {g' : Œ≤ -> Œ¥}, (AEMeasurable.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) -> (Filter.EventuallyEq.{u2, u3} Œ≤ Œ¥ (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_1 ŒΩ) g g') -> (MeasureTheory.Measure.AbsolutelyContinuous.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) ŒΩ) -> (Filter.EventuallyEq.{u1, u3} Œ± Œ¥ (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ¥ g f) (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ¥ g' f))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} {Œ¥ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u3} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u3} Œ≤ _inst_1} {f : Œ± -> Œ≤} {g : Œ≤ -> Œ¥} {g' : Œ≤ -> Œ¥}, (AEMeasurable.{u2, u3} Œ± Œ≤ _inst_1 m0 f Œº) -> (Filter.EventuallyEq.{u3, u1} Œ≤ Œ¥ (MeasureTheory.Measure.ae.{u3} Œ≤ _inst_1 ŒΩ) g g') -> (MeasureTheory.Measure.AbsolutelyContinuous.{u3} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u3} Œ± Œ≤ _inst_1 m0 f Œº) ŒΩ) -> (Filter.EventuallyEq.{u2, u1} Œ± Œ¥ (MeasureTheory.Measure.ae.{u2} Œ± m0 Œº) (Function.comp.{succ u2, succ u3, succ u1} Œ± Œ≤ Œ¥ g f) (Function.comp.{succ u2, succ u3, succ u1} Œ± Œ≤ Œ¥ g' f))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_eq_comp' MeasureTheory.ae_eq_comp'‚Çì'. -/
theorem ae_eq_comp' {ŒΩ : Measure Œ≤} {f : Œ± ‚Üí Œ≤} {g g' : Œ≤ ‚Üí Œ¥} (hf : AEMeasurable f Œº)
    (h : g =·µê[ŒΩ] g') (h2 : Œº.map f ‚â™ ŒΩ) : g ‚àò f =·µê[Œº] g' ‚àò f :=
  (tendsto_ae_map hf).mono_right h2.ae_le h
#align measure_theory.ae_eq_comp' MeasureTheory.ae_eq_comp'

/- warning: measure_theory.measure.quasi_measure_preserving.ae_eq_comp -> MeasureTheory.Measure.QuasiMeasurePreserving.ae_eq_comp is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ¥ : Type.{u3}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u2} Œ≤ _inst_1} {f : Œ± -> Œ≤} {g : Œ≤ -> Œ¥} {g' : Œ≤ -> Œ¥}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº ŒΩ) -> (Filter.EventuallyEq.{u2, u3} Œ≤ Œ¥ (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_1 ŒΩ) g g') -> (Filter.EventuallyEq.{u1, u3} Œ± Œ¥ (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ¥ g f) (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ¥ g' f))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} {Œ¥ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u3} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u3} Œ≤ _inst_1} {f : Œ± -> Œ≤} {g : Œ≤ -> Œ¥} {g' : Œ≤ -> Œ¥}, (MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u3} Œ± Œ≤ _inst_1 m0 f Œº ŒΩ) -> (Filter.EventuallyEq.{u3, u1} Œ≤ Œ¥ (MeasureTheory.Measure.ae.{u3} Œ≤ _inst_1 ŒΩ) g g') -> (Filter.EventuallyEq.{u2, u1} Œ± Œ¥ (MeasureTheory.Measure.ae.{u2} Œ± m0 Œº) (Function.comp.{succ u2, succ u3, succ u1} Œ± Œ≤ Œ¥ g f) (Function.comp.{succ u2, succ u3, succ u1} Œ± Œ≤ Œ¥ g' f))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.quasi_measure_preserving.ae_eq_comp MeasureTheory.Measure.QuasiMeasurePreserving.ae_eq_comp‚Çì'. -/
theorem Measure.QuasiMeasurePreserving.ae_eq_comp {ŒΩ : Measure Œ≤} {f : Œ± ‚Üí Œ≤} {g g' : Œ≤ ‚Üí Œ¥}
    (hf : QuasiMeasurePreserving f Œº ŒΩ) (h : g =·µê[ŒΩ] g') : g ‚àò f =·µê[Œº] g' ‚àò f :=
  ae_eq_comp' hf.AEMeasurable h hf.AbsolutelyContinuous
#align measure_theory.measure.quasi_measure_preserving.ae_eq_comp MeasureTheory.Measure.QuasiMeasurePreserving.ae_eq_comp

/- warning: measure_theory.ae_eq_comp -> MeasureTheory.ae_eq_comp is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ¥ : Type.{u3}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Œ± -> Œ≤} {g : Œ≤ -> Œ¥} {g' : Œ≤ -> Œ¥}, (AEMeasurable.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) -> (Filter.EventuallyEq.{u2, u3} Œ≤ Œ¥ (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº)) g g') -> (Filter.EventuallyEq.{u1, u3} Œ± Œ¥ (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ¥ g f) (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ¥ g' f))
but is expected to have type
  forall {Œ± : Type.{u3}} {Œ≤ : Type.{u2}} {Œ¥ : Type.{u1}} {m0 : MeasurableSpace.{u3} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u3} Œ± m0} {f : Œ± -> Œ≤} {g : Œ≤ -> Œ¥} {g' : Œ≤ -> Œ¥}, (AEMeasurable.{u3, u2} Œ± Œ≤ _inst_1 m0 f Œº) -> (Filter.EventuallyEq.{u2, u1} Œ≤ Œ¥ (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u3, u2} Œ± Œ≤ _inst_1 m0 f Œº)) g g') -> (Filter.EventuallyEq.{u3, u1} Œ± Œ¥ (MeasureTheory.Measure.ae.{u3} Œ± m0 Œº) (Function.comp.{succ u3, succ u2, succ u1} Œ± Œ≤ Œ¥ g f) (Function.comp.{succ u3, succ u2, succ u1} Œ± Œ≤ Œ¥ g' f))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_eq_comp MeasureTheory.ae_eq_comp‚Çì'. -/
theorem ae_eq_comp {f : Œ± ‚Üí Œ≤} {g g' : Œ≤ ‚Üí Œ¥} (hf : AEMeasurable f Œº) (h : g =·µê[Œº.map f] g') :
    g ‚àò f =·µê[Œº] g' ‚àò f :=
  ae_eq_comp' hf h AbsolutelyContinuous.rfl
#align measure_theory.ae_eq_comp MeasureTheory.ae_eq_comp

/- warning: measure_theory.sub_ae_eq_zero -> MeasureTheory.sub_ae_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {Œ≤ : Type.{u2}} [_inst_3 : AddGroup.{u2} Œ≤] (f : Œ± -> Œ≤) (g : Œ± -> Œ≤), Iff (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Œ± -> Œ≤) (Œ± -> Œ≤) (Œ± -> Œ≤) (instHSub.{max u1 u2} (Œ± -> Œ≤) (Pi.instSub.{u1, u2} Œ± (fun (·æ∞ : Œ±) => Œ≤) (fun (i : Œ±) => SubNegMonoid.toHasSub.{u2} Œ≤ (AddGroup.toSubNegMonoid.{u2} Œ≤ _inst_3)))) f g) (OfNat.ofNat.{max u1 u2} (Œ± -> Œ≤) 0 (OfNat.mk.{max u1 u2} (Œ± -> Œ≤) 0 (Zero.zero.{max u1 u2} (Œ± -> Œ≤) (Pi.instZero.{u1, u2} Œ± (fun (·æ∞ : Œ±) => Œ≤) (fun (i : Œ±) => AddZeroClass.toHasZero.{u2} Œ≤ (AddMonoid.toAddZeroClass.{u2} Œ≤ (SubNegMonoid.toAddMonoid.{u2} Œ≤ (AddGroup.toSubNegMonoid.{u2} Œ≤ _inst_3))))))))) (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) f g)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {Œ≤ : Type.{u2}} [_inst_3 : AddGroup.{u2} Œ≤] (f : Œ± -> Œ≤) (g : Œ± -> Œ≤), Iff (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Œ± -> Œ≤) (Œ± -> Œ≤) (Œ± -> Œ≤) (instHSub.{max u1 u2} (Œ± -> Œ≤) (Pi.instSub.{u1, u2} Œ± (fun (·æ∞ : Œ±) => Œ≤) (fun (i : Œ±) => SubNegMonoid.toSub.{u2} Œ≤ (AddGroup.toSubNegMonoid.{u2} Œ≤ _inst_3)))) f g) (OfNat.ofNat.{max u1 u2} (Œ± -> Œ≤) 0 (Zero.toOfNat0.{max u1 u2} (Œ± -> Œ≤) (Pi.instZero.{u1, u2} Œ± (fun (a._@.Mathlib.Order.Filter.Basic._hyg.19133 : Œ±) => Œ≤) (fun (i : Œ±) => NegZeroClass.toZero.{u2} Œ≤ (SubNegZeroMonoid.toNegZeroClass.{u2} Œ≤ (SubtractionMonoid.toSubNegZeroMonoid.{u2} Œ≤ (AddGroup.toSubtractionMonoid.{u2} Œ≤ _inst_3)))))))) (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) f g)
Case conversion may be inaccurate. Consider using '#align measure_theory.sub_ae_eq_zero MeasureTheory.sub_ae_eq_zero‚Çì'. -/
theorem sub_ae_eq_zero {Œ≤} [AddGroup Œ≤] (f g : Œ± ‚Üí Œ≤) : f - g =·µê[Œº] 0 ‚Üî f =·µê[Œº] g :=
  by
  refine' ‚ü®fun h => h.mono fun x hx => _, fun h => h.mono fun x hx => _‚ü©
  ¬∑ rwa [Pi.sub_apply, Pi.zero_apply, sub_eq_zero] at hx
  ¬∑ rwa [Pi.sub_apply, Pi.zero_apply, sub_eq_zero]
#align measure_theory.sub_ae_eq_zero MeasureTheory.sub_ae_eq_zero

/- warning: measure_theory.le_ae_restrict -> MeasureTheory.le_ae_restrict is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.hasInf.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Filter.principal.{u1} Œ± s)) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.instInfFilter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Filter.principal.{u1} Œ± s)) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s))
Case conversion may be inaccurate. Consider using '#align measure_theory.le_ae_restrict MeasureTheory.le_ae_restrict‚Çì'. -/
theorem le_ae_restrict : Œº.ae ‚äì ùìü s ‚â§ (Œº.restrict s).ae := fun s hs =>
  eventually_inf_principal.2 (ae_imp_of_ae_restrict hs)
#align measure_theory.le_ae_restrict MeasureTheory.le_ae_restrict

/- warning: measure_theory.ae_restrict_eq -> MeasureTheory.ae_restrict_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{succ u1} (Filter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.hasInf.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Filter.principal.{u1} Œ± s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{succ u1} (Filter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.instInfFilter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Filter.principal.{u1} Œ± s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_restrict_eq MeasureTheory.ae_restrict_eq‚Çì'. -/
@[simp]
theorem ae_restrict_eq (hs : MeasurableSet s) : (Œº.restrict s).ae = Œº.ae ‚äì ùìü s :=
  by
  ext t
  simp only [mem_inf_principal, mem_ae_iff, restrict_apply_eq_zero' hs, compl_set_of, not_imp,
    and_comm' (_ ‚àà s)]
  rfl
#align measure_theory.ae_restrict_eq MeasureTheory.ae_restrict_eq

/- warning: measure_theory.ae_restrict_eq_bot -> MeasureTheory.ae_restrict_eq_bot is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, Iff (Eq.{succ u1} (Filter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))) (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, Iff (Eq.{succ u1} (Filter.{u1} Œ±) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))) (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_restrict_eq_bot MeasureTheory.ae_restrict_eq_bot‚Çì'. -/
@[simp]
theorem ae_restrict_eq_bot {s} : (Œº.restrict s).ae = ‚ä• ‚Üî Œº s = 0 :=
  ae_eq_bot.trans restrict_eq_zero
#align measure_theory.ae_restrict_eq_bot MeasureTheory.ae_restrict_eq_bot

/- warning: measure_theory.ae_restrict_ne_bot -> MeasureTheory.ae_restrict_neBot is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, Iff (Filter.NeBot.{u1} Œ± (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s))) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, Iff (Filter.NeBot.{u1} Œ± (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s))) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_restrict_ne_bot MeasureTheory.ae_restrict_neBot‚Çì'. -/
@[simp]
theorem ae_restrict_neBot {s} : (Œº.restrict s).ae.ne_bot ‚Üî 0 < Œº s :=
  neBot_iff.trans <| (not_congr ae_restrict_eq_bot).trans pos_iff_ne_zero.symm
#align measure_theory.ae_restrict_ne_bot MeasureTheory.ae_restrict_neBot

#print MeasureTheory.self_mem_ae_restrict /-
theorem self_mem_ae_restrict {s} (hs : MeasurableSet s) : s ‚àà (Œº.restrict s).ae := by
  simp only [ae_restrict_eq hs, exists_prop, mem_principal, mem_inf_iff] <;>
    exact ‚ü®_, univ_mem, s, subset.rfl, (univ_inter s).symm‚ü©
#align measure_theory.self_mem_ae_restrict MeasureTheory.self_mem_ae_restrict
-/

#print MeasureTheory.ae_restrict_of_ae_eq_of_ae_restrict /-
/-- If two measurable sets are ae_eq then any proposition that is almost everywhere true on one
is almost everywhere true on the other -/
theorem ae_restrict_of_ae_eq_of_ae_restrict {s t} (hst : s =·µê[Œº] t) {p : Œ± ‚Üí Prop} :
    (‚àÄ·µê x ‚àÇŒº.restrict s, p x) ‚Üí ‚àÄ·µê x ‚àÇŒº.restrict t, p x := by simp [measure.restrict_congr_set hst]
#align measure_theory.ae_restrict_of_ae_eq_of_ae_restrict MeasureTheory.ae_restrict_of_ae_eq_of_ae_restrict
-/

#print MeasureTheory.ae_restrict_congr_set /-
/-- If two measurable sets are ae_eq then any proposition that is almost everywhere true on one
is almost everywhere true on the other -/
theorem ae_restrict_congr_set {s t} (hst : s =·µê[Œº] t) {p : Œ± ‚Üí Prop} :
    (‚àÄ·µê x ‚àÇŒº.restrict s, p x) ‚Üî ‚àÄ·µê x ‚àÇŒº.restrict t, p x :=
  ‚ü®ae_restrict_of_ae_eq_of_ae_restrict hst, ae_restrict_of_ae_eq_of_ae_restrict hst.symm‚ü©
#align measure_theory.ae_restrict_congr_set MeasureTheory.ae_restrict_congr_set
-/

/- warning: measure_theory.measure_set_of_frequently_eq_zero -> MeasureTheory.measure_setOf_frequently_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {p : Nat -> Œ± -> Prop}, (Ne.{1} ENNReal (tsum.{0, 0} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Nat (fun (i : Nat) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (setOf.{u1} Œ± (fun (x : Œ±) => p i x)))) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (setOf.{u1} Œ± (fun (x : Œ±) => Filter.Frequently.{0} Nat (fun (n : Nat) => p n x) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {p : Nat -> Œ± -> Prop}, (Ne.{1} ENNReal (tsum.{0, 0} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Nat (fun (i : Nat) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (setOf.{u1} Œ± (fun (x : Œ±) => p i x)))) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (setOf.{u1} Œ± (fun (x : Œ±) => Filter.Frequently.{0} Nat (fun (n : Nat) => p n x) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_set_of_frequently_eq_zero MeasureTheory.measure_setOf_frequently_eq_zero‚Çì'. -/
/-- A version of the **Borel-Cantelli lemma**: if `p·µ¢` is a sequence of predicates such that
`‚àë Œº {x | p·µ¢ x}` is finite, then the measure of `x` such that `p·µ¢ x` holds frequently as `i ‚Üí ‚àû` (or
equivalently, `p·µ¢ x` holds for infinitely many `i`) is equal to zero. -/
theorem measure_setOf_frequently_eq_zero {p : ‚Ñï ‚Üí Œ± ‚Üí Prop} (hp : (‚àë' i, Œº { x | p i x }) ‚â† ‚àû) :
    Œº { x | ‚àÉ·∂† n in atTop, p n x } = 0 := by
  simpa only [limsup_eq_infi_supr_of_nat, frequently_at_top, set_of_forall, set_of_exists] using
    measure_limsup_eq_zero hp
#align measure_theory.measure_set_of_frequently_eq_zero MeasureTheory.measure_setOf_frequently_eq_zero

/- warning: measure_theory.ae_eventually_not_mem -> MeasureTheory.ae_eventually_not_mem is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Nat -> (Set.{u1} Œ±)}, (Ne.{1} ENNReal (tsum.{0, 0} ENNReal (OrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (OrderedSemiring.toOrderedAddCommMonoid.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) ENNReal.topologicalSpace Nat (fun (i : Nat) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (s i))) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => Filter.Eventually.{0} Nat (fun (n : Nat) => Not (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x (s n))) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Nat -> (Set.{u1} Œ±)}, (Ne.{1} ENNReal (tsum.{0, 0} ENNReal (LinearOrderedAddCommMonoid.toAddCommMonoid.{0} ENNReal (LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid.{0} ENNReal ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal)) ENNReal.instTopologicalSpaceENNReal Nat (fun (i : Nat) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (s i))) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => Filter.Eventually.{0} Nat (fun (n : Nat) => Not (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x (s n))) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_eventually_not_mem MeasureTheory.ae_eventually_not_mem‚Çì'. -/
/-- A version of the **Borel-Cantelli lemma**: if `s·µ¢` is a sequence of sets such that
`‚àë Œº s·µ¢` exists, then for almost all `x`, `x` does not belong to almost all `s·µ¢`. -/
theorem ae_eventually_not_mem {s : ‚Ñï ‚Üí Set Œ±} (hs : (‚àë' i, Œº (s i)) ‚â† ‚àû) :
    ‚àÄ·µê x ‚àÇŒº, ‚àÄ·∂† n in atTop, x ‚àâ s n :=
  measure_setOf_frequently_eq_zero hs
#align measure_theory.ae_eventually_not_mem MeasureTheory.ae_eventually_not_mem

section Intervals

/- warning: measure_theory.bsupr_measure_Iic -> MeasureTheory.bsup·µ¢_measure_Iic is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Preorder.{u1} Œ±] {s : Set.{u1} Œ±}, (Set.Countable.{u1} Œ± s) -> (forall (x : Œ±), Exists.{succ u1} Œ± (fun (y : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y s) => LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_3) x y))) -> (DirectedOn.{u1} Œ± (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_3)) s) -> (Eq.{1} ENNReal (sup·µ¢.{0, succ u1} ENNReal (ConditionallyCompleteLattice.toHasSup.{0} ENNReal (CompleteLattice.toConditionallyCompleteLattice.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Œ± (fun (x : Œ±) => sup·µ¢.{0, 0} ENNReal (ConditionallyCompleteLattice.toHasSup.{0} ENNReal (CompleteLattice.toConditionallyCompleteLattice.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.Iic.{u1} Œ± _inst_3 x)))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.univ.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Preorder.{u1} Œ±] {s : Set.{u1} Œ±}, (Set.Countable.{u1} Œ± s) -> (forall (x : Œ±), Exists.{succ u1} Œ± (fun (y : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) y s) (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_3) x y))) -> (DirectedOn.{u1} Œ± (fun (x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.46872 : Œ±) (x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.46874 : Œ±) => LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_3) x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.46872 x._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.46874) s) -> (Eq.{1} ENNReal (sup·µ¢.{0, succ u1} ENNReal (ConditionallyCompleteLattice.toSupSet.{0} ENNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} ENNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} ENNReal (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) Œ± (fun (x : Œ±) => sup·µ¢.{0, 0} ENNReal (ConditionallyCompleteLattice.toSupSet.{0} ENNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} ENNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} ENNReal (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) (fun (H : Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Set.Iic.{u1} Œ± _inst_3 x)))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Set.univ.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align measure_theory.bsupr_measure_Iic MeasureTheory.bsup·µ¢_measure_Iic‚Çì'. -/
theorem bsup·µ¢_measure_Iic [Preorder Œ±] {s : Set Œ±} (hsc : s.Countable)
    (hst : ‚àÄ x : Œ±, ‚àÉ y ‚àà s, x ‚â§ y) (hdir : DirectedOn (¬∑ ‚â§ ¬∑) s) : (‚®Ü x ‚àà s, Œº (Iic x)) = Œº univ :=
  by
  rw [‚Üê measure_bUnion_eq_supr hsc]
  ¬∑ congr
    exact Union‚ÇÇ_eq_univ_iff.2 hst
  ¬∑ exact directedOn_iff_directed.2 (hdir.directed_coe.mono_comp _ fun x y => Iic_subset_Iic.2)
#align measure_theory.bsupr_measure_Iic MeasureTheory.bsup·µ¢_measure_Iic

variable [PartialOrder Œ±] {a b : Œ±}

/- warning: measure_theory.Iio_ae_eq_Iic' -> MeasureTheory.Iio_ae_eq_Iic' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PartialOrder.{u1} Œ±] {a : Œ±}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasSingleton.{u1} Œ±) a)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a) (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PartialOrder.{u1} Œ±] {a : Œ±}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instSingletonSet.{u1} Œ±) a)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a) (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a))
Case conversion may be inaccurate. Consider using '#align measure_theory.Iio_ae_eq_Iic' MeasureTheory.Iio_ae_eq_Iic'‚Çì'. -/
theorem Iio_ae_eq_Iic' (ha : Œº {a} = 0) : Iio a =·µê[Œº] Iic a := by
  rw [‚Üê Iic_diff_right, diff_ae_eq_self, measure_mono_null (Set.inter_subset_right _ _) ha]
#align measure_theory.Iio_ae_eq_Iic' MeasureTheory.Iio_ae_eq_Iic'

/- warning: measure_theory.Ioi_ae_eq_Ici' -> MeasureTheory.Ioi_ae_eq_Ici' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PartialOrder.{u1} Œ±] {a : Œ±}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasSingleton.{u1} Œ±) a)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a) (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PartialOrder.{u1} Œ±] {a : Œ±}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instSingletonSet.{u1} Œ±) a)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a) (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a))
Case conversion may be inaccurate. Consider using '#align measure_theory.Ioi_ae_eq_Ici' MeasureTheory.Ioi_ae_eq_Ici'‚Çì'. -/
theorem Ioi_ae_eq_Ici' (ha : Œº {a} = 0) : Ioi a =·µê[Œº] Ici a :=
  @Iio_ae_eq_Iic' Œ±·µí·µà ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ _ _ ha
#align measure_theory.Ioi_ae_eq_Ici' MeasureTheory.Ioi_ae_eq_Ici'

/- warning: measure_theory.Ioo_ae_eq_Ioc' -> MeasureTheory.Ioo_ae_eq_Ioc' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PartialOrder.{u1} Œ±] {a : Œ±} {b : Œ±}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasSingleton.{u1} Œ±) b)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PartialOrder.{u1} Œ±] {a : Œ±} {b : Œ±}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instSingletonSet.{u1} Œ±) b)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b))
Case conversion may be inaccurate. Consider using '#align measure_theory.Ioo_ae_eq_Ioc' MeasureTheory.Ioo_ae_eq_Ioc'‚Çì'. -/
theorem Ioo_ae_eq_Ioc' (hb : Œº {b} = 0) : Ioo a b =·µê[Œº] Ioc a b :=
  (ae_eq_refl _).inter (Iio_ae_eq_Iic' hb)
#align measure_theory.Ioo_ae_eq_Ioc' MeasureTheory.Ioo_ae_eq_Ioc'

/- warning: measure_theory.Ioc_ae_eq_Icc' -> MeasureTheory.Ioc_ae_eq_Icc' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PartialOrder.{u1} Œ±] {a : Œ±} {b : Œ±}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasSingleton.{u1} Œ±) a)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PartialOrder.{u1} Œ±] {a : Œ±} {b : Œ±}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instSingletonSet.{u1} Œ±) a)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b))
Case conversion may be inaccurate. Consider using '#align measure_theory.Ioc_ae_eq_Icc' MeasureTheory.Ioc_ae_eq_Icc'‚Çì'. -/
theorem Ioc_ae_eq_Icc' (ha : Œº {a} = 0) : Ioc a b =·µê[Œº] Icc a b :=
  (Ioi_ae_eq_Ici' ha).inter (ae_eq_refl _)
#align measure_theory.Ioc_ae_eq_Icc' MeasureTheory.Ioc_ae_eq_Icc'

/- warning: measure_theory.Ioo_ae_eq_Ico' -> MeasureTheory.Ioo_ae_eq_Ico' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PartialOrder.{u1} Œ±] {a : Œ±} {b : Œ±}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasSingleton.{u1} Œ±) a)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PartialOrder.{u1} Œ±] {a : Œ±} {b : Œ±}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instSingletonSet.{u1} Œ±) a)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b))
Case conversion may be inaccurate. Consider using '#align measure_theory.Ioo_ae_eq_Ico' MeasureTheory.Ioo_ae_eq_Ico'‚Çì'. -/
theorem Ioo_ae_eq_Ico' (ha : Œº {a} = 0) : Ioo a b =·µê[Œº] Ico a b :=
  (Ioi_ae_eq_Ici' ha).inter (ae_eq_refl _)
#align measure_theory.Ioo_ae_eq_Ico' MeasureTheory.Ioo_ae_eq_Ico'

/- warning: measure_theory.Ioo_ae_eq_Icc' -> MeasureTheory.Ioo_ae_eq_Icc' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PartialOrder.{u1} Œ±] {a : Œ±} {b : Œ±}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasSingleton.{u1} Œ±) a)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasSingleton.{u1} Œ±) b)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PartialOrder.{u1} Œ±] {a : Œ±} {b : Œ±}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instSingletonSet.{u1} Œ±) a)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instSingletonSet.{u1} Œ±) b)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b))
Case conversion may be inaccurate. Consider using '#align measure_theory.Ioo_ae_eq_Icc' MeasureTheory.Ioo_ae_eq_Icc'‚Çì'. -/
theorem Ioo_ae_eq_Icc' (ha : Œº {a} = 0) (hb : Œº {b} = 0) : Ioo a b =·µê[Œº] Icc a b :=
  (Ioi_ae_eq_Ici' ha).inter (Iio_ae_eq_Iic' hb)
#align measure_theory.Ioo_ae_eq_Icc' MeasureTheory.Ioo_ae_eq_Icc'

/- warning: measure_theory.Ico_ae_eq_Icc' -> MeasureTheory.Ico_ae_eq_Icc' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PartialOrder.{u1} Œ±] {a : Œ±} {b : Œ±}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasSingleton.{u1} Œ±) b)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PartialOrder.{u1} Œ±] {a : Œ±} {b : Œ±}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instSingletonSet.{u1} Œ±) b)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b))
Case conversion may be inaccurate. Consider using '#align measure_theory.Ico_ae_eq_Icc' MeasureTheory.Ico_ae_eq_Icc'‚Çì'. -/
theorem Ico_ae_eq_Icc' (hb : Œº {b} = 0) : Ico a b =·µê[Œº] Icc a b :=
  (ae_eq_refl _).inter (Iio_ae_eq_Iic' hb)
#align measure_theory.Ico_ae_eq_Icc' MeasureTheory.Ico_ae_eq_Icc'

/- warning: measure_theory.Ico_ae_eq_Ioc' -> MeasureTheory.Ico_ae_eq_Ioc' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PartialOrder.{u1} Œ±] {a : Œ±} {b : Œ±}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasSingleton.{u1} Œ±) a)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasSingleton.{u1} Œ±) b)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PartialOrder.{u1} Œ±] {a : Œ±} {b : Œ±}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instSingletonSet.{u1} Œ±) a)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Singleton.singleton.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instSingletonSet.{u1} Œ±) b)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± _inst_3) a b))
Case conversion may be inaccurate. Consider using '#align measure_theory.Ico_ae_eq_Ioc' MeasureTheory.Ico_ae_eq_Ioc'‚Çì'. -/
theorem Ico_ae_eq_Ioc' (ha : Œº {a} = 0) (hb : Œº {b} = 0) : Ico a b =·µê[Œº] Ioc a b :=
  (Ioo_ae_eq_Ico' ha).symm.trans (Ioo_ae_eq_Ioc' hb)
#align measure_theory.Ico_ae_eq_Ioc' MeasureTheory.Ico_ae_eq_Ioc'

end Intervals

section Dirac

variable [MeasurableSpace Œ±]

#print MeasureTheory.mem_ae_dirac_iff /-
theorem mem_ae_dirac_iff {a : Œ±} (hs : MeasurableSet s) : s ‚àà (dirac a).ae ‚Üî a ‚àà s := by
  by_cases a ‚àà s <;> simp [mem_ae_iff, dirac_apply', hs.compl, indicator_apply, *]
#align measure_theory.mem_ae_dirac_iff MeasureTheory.mem_ae_dirac_iff
-/

#print MeasureTheory.ae_dirac_iff /-
theorem ae_dirac_iff {a : Œ±} {p : Œ± ‚Üí Prop} (hp : MeasurableSet { x | p x }) :
    (‚àÄ·µê x ‚àÇdirac a, p x) ‚Üî p a :=
  mem_ae_dirac_iff hp
#align measure_theory.ae_dirac_iff MeasureTheory.ae_dirac_iff
-/

#print MeasureTheory.ae_dirac_eq /-
@[simp]
theorem ae_dirac_eq [MeasurableSingletonClass Œ±] (a : Œ±) : (dirac a).ae = pure a :=
  by
  ext s
  simp [mem_ae_iff, imp_false]
#align measure_theory.ae_dirac_eq MeasureTheory.ae_dirac_eq
-/

#print MeasureTheory.ae_eq_dirac' /-
theorem ae_eq_dirac' [MeasurableSingletonClass Œ≤] {a : Œ±} {f : Œ± ‚Üí Œ≤} (hf : Measurable f) :
    f =·µê[dirac a] const Œ± (f a) :=
  (ae_dirac_iff <| show MeasurableSet (f ‚Åª¬π' {f a}) from hf <| measurableSet_singleton _).2 rfl
#align measure_theory.ae_eq_dirac' MeasureTheory.ae_eq_dirac'
-/

/- warning: measure_theory.ae_eq_dirac -> MeasureTheory.ae_eq_dirac is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] [_inst_4 : MeasurableSingletonClass.{u1} Œ± _inst_3] {a : Œ±} (f : Œ± -> Œ¥), Filter.EventuallyEq.{u1, u2} Œ± Œ¥ (MeasureTheory.Measure.ae.{u1} Œ± _inst_3 (MeasureTheory.Measure.dirac.{u1} Œ± _inst_3 a)) f (Function.const.{succ u2, succ u1} Œ¥ Œ± (f a))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ¥ : Type.{u1}} [_inst_3 : MeasurableSpace.{u2} Œ±] [_inst_4 : MeasurableSingletonClass.{u2} Œ± _inst_3] {a : Œ±} (f : Œ± -> Œ¥), Filter.EventuallyEq.{u2, u1} Œ± Œ¥ (MeasureTheory.Measure.ae.{u2} Œ± _inst_3 (MeasureTheory.Measure.dirac.{u2} Œ± _inst_3 a)) f (Function.const.{succ u1, succ u2} Œ¥ Œ± (f a))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_eq_dirac MeasureTheory.ae_eq_dirac‚Çì'. -/
theorem ae_eq_dirac [MeasurableSingletonClass Œ±] {a : Œ±} (f : Œ± ‚Üí Œ¥) :
    f =·µê[dirac a] const Œ± (f a) := by simp [Filter.EventuallyEq]
#align measure_theory.ae_eq_dirac MeasureTheory.ae_eq_dirac

end Dirac

section IsFiniteMeasure

include m0

#print MeasureTheory.FiniteMeasure /-
/-- A measure `Œº` is called finite if `Œº univ < ‚àû`. -/
class FiniteMeasure (Œº : Measure Œ±) : Prop where
  measure_univ_lt_top : Œº univ < ‚àû
#align measure_theory.is_finite_measure MeasureTheory.FiniteMeasure
-/

/- warning: measure_theory.not_is_finite_measure_iff -> MeasureTheory.not_finiteMeasure_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Iff (Not (MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº)) (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.univ.{u1} Œ±)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Iff (Not (MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº)) (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Set.univ.{u1} Œ±)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))
Case conversion may be inaccurate. Consider using '#align measure_theory.not_is_finite_measure_iff MeasureTheory.not_finiteMeasure_iff‚Çì'. -/
theorem not_finiteMeasure_iff : ¬¨FiniteMeasure Œº ‚Üî Œº Set.univ = ‚àû :=
  by
  refine' ‚ü®fun h => _, fun h => fun h' => h'.measure_univ_lt_top.ne h‚ü©
  by_contra h'
  exact h ‚ü®lt_top_iff_ne_top.mpr h'‚ü©
#align measure_theory.not_is_finite_measure_iff MeasureTheory.not_finiteMeasure_iff

/- warning: measure_theory.restrict.is_finite_measure -> MeasureTheory.Restrict.finiteMeasure is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {s : Set.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [hs : Fact (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))], MeasureTheory.FiniteMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {s : Set.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [hs : Fact (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))], MeasureTheory.FiniteMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)
Case conversion may be inaccurate. Consider using '#align measure_theory.restrict.is_finite_measure MeasureTheory.Restrict.finiteMeasure‚Çì'. -/
instance Restrict.finiteMeasure (Œº : Measure Œ±) [hs : Fact (Œº s < ‚àû)] :
    FiniteMeasure (Œº.restrict s) :=
  ‚ü®by simp [hs.elim]‚ü©
#align measure_theory.restrict.is_finite_measure MeasureTheory.Restrict.finiteMeasure

/- warning: measure_theory.measure_lt_top -> MeasureTheory.measure_lt_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº] (s : Set.{u1} Œ±), LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº] (s : Set.{u1} Œ±), LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_lt_top MeasureTheory.measure_lt_top‚Çì'. -/
theorem measure_lt_top (Œº : Measure Œ±) [FiniteMeasure Œº] (s : Set Œ±) : Œº s < ‚àû :=
  (measure_mono (subset_univ s)).trans_lt FiniteMeasure.measure_univ_lt_top
#align measure_theory.measure_lt_top MeasureTheory.measure_lt_top

#print MeasureTheory.finiteMeasureRestrict /-
instance finiteMeasureRestrict (Œº : Measure Œ±) (s : Set Œ±) [h : FiniteMeasure Œº] :
    FiniteMeasure (Œº.restrict s) :=
  ‚ü®by simp [measure_lt_top Œº s]‚ü©
#align measure_theory.is_finite_measure_restrict MeasureTheory.finiteMeasureRestrict
-/

/- warning: measure_theory.measure_ne_top -> MeasureTheory.measure_ne_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº] (s : Set.{u1} Œ±), Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº] (s : Set.{u1} Œ±), Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_ne_top MeasureTheory.measure_ne_top‚Çì'. -/
theorem measure_ne_top (Œº : Measure Œ±) [FiniteMeasure Œº] (s : Set Œ±) : Œº s ‚â† ‚àû :=
  ne_of_lt (measure_lt_top Œº s)
#align measure_theory.measure_ne_top MeasureTheory.measure_ne_top

/- warning: measure_theory.measure_compl_le_add_of_le_add -> MeasureTheory.measure_compl_le_add_of_le_add is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±} [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº], (MeasurableSet.{u1} Œ± m0 s) -> (MeasurableSet.{u1} Œ± m0 t) -> (forall {Œµ : ENNReal}, (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº t) Œµ)) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) t)) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s)) Œµ)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±} [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº], (MeasurableSet.{u1} Œ± m0 s) -> (MeasurableSet.{u1} Œ± m0 t) -> (forall {Œµ : ENNReal}, (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) t) Œµ)) -> (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) t)) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) s)) Œµ)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_compl_le_add_of_le_add MeasureTheory.measure_compl_le_add_of_le_add‚Çì'. -/
theorem measure_compl_le_add_of_le_add [FiniteMeasure Œº] (hs : MeasurableSet s)
    (ht : MeasurableSet t) {Œµ : ‚Ñù‚â•0‚àû} (h : Œº s ‚â§ Œº t + Œµ) : Œº (t·∂ú) ‚â§ Œº (s·∂ú) + Œµ :=
  by
  rw [measure_compl ht (measure_ne_top Œº _), measure_compl hs (measure_ne_top Œº _),
    tsub_le_iff_right]
  calc
    Œº univ = Œº univ - Œº s + Œº s := (tsub_add_cancel_of_le <| measure_mono s.subset_univ).symm
    _ ‚â§ Œº univ - Œº s + (Œº t + Œµ) := (add_le_add_left h _)
    _ = _ := by rw [add_right_comm, add_assoc]
    
#align measure_theory.measure_compl_le_add_of_le_add MeasureTheory.measure_compl_le_add_of_le_add

/- warning: measure_theory.measure_compl_le_add_iff -> MeasureTheory.measure_compl_le_add_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±} [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº], (MeasurableSet.{u1} Œ± m0 s) -> (MeasurableSet.{u1} Œ± m0 t) -> (forall {Œµ : ENNReal}, Iff (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s)) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) t)) Œµ)) (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº t) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) Œµ)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±} [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº], (MeasurableSet.{u1} Œ± m0 s) -> (MeasurableSet.{u1} Œ± m0 t) -> (forall {Œµ : ENNReal}, Iff (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) s)) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) t)) Œµ)) (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) t) (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) Œµ)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_compl_le_add_iff MeasureTheory.measure_compl_le_add_iff‚Çì'. -/
theorem measure_compl_le_add_iff [FiniteMeasure Œº] (hs : MeasurableSet s) (ht : MeasurableSet t)
    {Œµ : ‚Ñù‚â•0‚àû} : Œº (s·∂ú) ‚â§ Œº (t·∂ú) + Œµ ‚Üî Œº t ‚â§ Œº s + Œµ :=
  ‚ü®fun h => compl_compl s ‚ñ∏ compl_compl t ‚ñ∏ measure_compl_le_add_of_le_add hs.compl ht.compl h,
    measure_compl_le_add_of_le_add ht hs‚ü©
#align measure_theory.measure_compl_le_add_iff MeasureTheory.measure_compl_le_add_iff

#print MeasureTheory.measureUnivNNReal /-
/-- The measure of the whole space with respect to a finite measure, considered as `‚Ñù‚â•0`. -/
def measureUnivNNReal (Œº : Measure Œ±) : ‚Ñù‚â•0 :=
  (Œº univ).toNNReal
#align measure_theory.measure_univ_nnreal MeasureTheory.measureUnivNNReal
-/

#print MeasureTheory.coe_measureUnivNNReal /-
@[simp]
theorem coe_measureUnivNNReal (Œº : Measure Œ±) [FiniteMeasure Œº] : ‚Üë(measureUnivNNReal Œº) = Œº univ :=
  ENNReal.coe_toNNReal (measure_ne_top Œº univ)
#align measure_theory.coe_measure_univ_nnreal MeasureTheory.coe_measureUnivNNReal
-/

#print MeasureTheory.finiteMeasureZero /-
instance finiteMeasureZero : FiniteMeasure (0 : Measure Œ±) :=
  ‚ü®by simp‚ü©
#align measure_theory.is_finite_measure_zero MeasureTheory.finiteMeasureZero
-/

#print MeasureTheory.finiteMeasureOfIsEmpty /-
instance (priority := 100) finiteMeasureOfIsEmpty [IsEmpty Œ±] : FiniteMeasure Œº :=
  by
  rw [eq_zero_of_is_empty Œº]
  infer_instance
#align measure_theory.is_finite_measure_of_is_empty MeasureTheory.finiteMeasureOfIsEmpty
-/

/- warning: measure_theory.measure_univ_nnreal_zero -> MeasureTheory.measureUnivNNReal_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±}, Eq.{1} NNReal (MeasureTheory.measureUnivNNReal.{u1} Œ± m0 (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (OfNat.mk.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.zero.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0))))) (OfNat.ofNat.{0} NNReal 0 (OfNat.mk.{0} NNReal 0 (Zero.zero.{0} NNReal (MulZeroClass.toHasZero.{0} NNReal (NonUnitalNonAssocSemiring.toMulZeroClass.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)))))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±}, Eq.{1} NNReal (MeasureTheory.measureUnivNNReal.{u1} Œ± m0 (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.toOfNat0.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0)))) (OfNat.ofNat.{0} NNReal 0 (Zero.toOfNat0.{0} NNReal instNNRealZero))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_univ_nnreal_zero MeasureTheory.measureUnivNNReal_zero‚Çì'. -/
@[simp]
theorem measureUnivNNReal_zero : measureUnivNNReal (0 : Measure Œ±) = 0 :=
  rfl
#align measure_theory.measure_univ_nnreal_zero MeasureTheory.measureUnivNNReal_zero

omit m0

#print MeasureTheory.finiteMeasureAdd /-
instance finiteMeasureAdd [FiniteMeasure Œº] [FiniteMeasure ŒΩ] : FiniteMeasure (Œº + ŒΩ)
    where measure_univ_lt_top :=
    by
    rw [measure.coe_add, Pi.add_apply, ENNReal.add_lt_top]
    exact ‚ü®measure_lt_top _ _, measure_lt_top _ _‚ü©
#align measure_theory.is_finite_measure_add MeasureTheory.finiteMeasureAdd
-/

/- warning: measure_theory.is_finite_measure_smul_nnreal -> MeasureTheory.finiteMeasureSmulNNReal is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº] {r : NNReal}, MeasureTheory.FiniteMeasure.{u1} Œ± m0 (SMul.smul.{0, u1} NNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± NNReal (MulAction.toHasSmul.{0, 0} NNReal ENNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal NNReal.semiring)) (ENNReal.mulAction.{0} ENNReal (Monoid.toMulAction.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (ENNReal.isScalarTower.{0, 0} ENNReal ENNReal (Monoid.toMulAction.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Monoid.toMulAction.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Mul.toSMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) m0) r Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº] {r : NNReal}, MeasureTheory.FiniteMeasure.{u1} Œ± m0 (HSMul.hSMul.{0, u1, u1} NNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHSMul.{0, u1} NNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± NNReal (Algebra.toSMul.{0, 0} NNReal ENNReal instNNRealCommSemiring (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (ENNReal.instAlgebraNNRealInstNNRealCommSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (ENNReal.instIsScalarTowerNNRealToSMulToMonoidToMonoidWithZeroInstNNRealSemiringInstMulActionNNRealToMonoidToMonoidWithZeroInstNNRealSemiringToSMulInstMulActionNNRealToMonoidToMonoidWithZeroInstNNRealSemiring.{0, 0} ENNReal ENNReal (MulActionWithZero.toMulAction.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) instENNRealZero (MonoidWithZero.toMulActionWithZero.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (MulActionWithZero.toMulAction.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) instENNRealZero (MonoidWithZero.toMulActionWithZero.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) m0)) r Œº)
Case conversion may be inaccurate. Consider using '#align measure_theory.is_finite_measure_smul_nnreal MeasureTheory.finiteMeasureSmulNNReal‚Çì'. -/
instance finiteMeasureSmulNNReal [FiniteMeasure Œº] {r : ‚Ñù‚â•0} : FiniteMeasure (r ‚Ä¢ Œº)
    where measure_univ_lt_top := ENNReal.mul_lt_top ENNReal.coe_ne_top (measure_ne_top _ _)
#align measure_theory.is_finite_measure_smul_nnreal MeasureTheory.finiteMeasureSmulNNReal

/- warning: measure_theory.is_finite_measure_smul_of_nnreal_tower -> MeasureTheory.finiteMeasureSmulOfNNRealTower is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {R : Type.{u2}} [_inst_3 : SMul.{u2, 0} R NNReal] [_inst_4 : SMul.{u2, 0} R ENNReal] [_inst_5 : IsScalarTower.{u2, 0, 0} R NNReal ENNReal _inst_3 (SMulZeroClass.toHasSmul.{0, 0} NNReal ENNReal (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (SMulWithZero.toSmulZeroClass.{0, 0} NNReal ENNReal (MulZeroClass.toHasZero.{0} NNReal (MulZeroOneClass.toMulZeroClass.{0} NNReal (MonoidWithZero.toMulZeroOneClass.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal NNReal.semiring)))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (MulActionWithZero.toSMulWithZero.{0, 0} NNReal ENNReal (Semiring.toMonoidWithZero.{0} NNReal NNReal.semiring) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (Module.toMulActionWithZero.{0, 0} NNReal ENNReal NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (ENNReal.module.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Semiring.toModule.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) _inst_4] [_inst_6 : IsScalarTower.{u2, 0, 0} R ENNReal ENNReal _inst_4 (Mul.toSMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) _inst_4] [_inst_7 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº] {r : R}, MeasureTheory.FiniteMeasure.{u1} Œ± m0 (SMul.smul.{u2, u1} R (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, u2} Œ± R _inst_4 _inst_6 m0) r Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {R : Type.{u2}} [_inst_3 : SMul.{u2, 0} R NNReal] [_inst_4 : SMul.{u2, 0} R ENNReal] [_inst_5 : IsScalarTower.{u2, 0, 0} R NNReal ENNReal _inst_3 (Algebra.toSMul.{0, 0} NNReal ENNReal instNNRealCommSemiring (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (ENNReal.instAlgebraNNRealInstNNRealCommSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) _inst_4] [_inst_6 : IsScalarTower.{u2, 0, 0} R ENNReal ENNReal _inst_4 (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) _inst_4] [_inst_7 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº] {r : R}, MeasureTheory.FiniteMeasure.{u1} Œ± m0 (HSMul.hSMul.{u2, u1, u1} R (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHSMul.{u2, u1} R (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, u2} Œ± R _inst_4 _inst_6 m0)) r Œº)
Case conversion may be inaccurate. Consider using '#align measure_theory.is_finite_measure_smul_of_nnreal_tower MeasureTheory.finiteMeasureSmulOfNNRealTower‚Çì'. -/
instance finiteMeasureSmulOfNNRealTower {R} [SMul R ‚Ñù‚â•0] [SMul R ‚Ñù‚â•0‚àû] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù‚â•0‚àû]
    [IsScalarTower R ‚Ñù‚â•0‚àû ‚Ñù‚â•0‚àû] [FiniteMeasure Œº] {r : R} : FiniteMeasure (r ‚Ä¢ Œº) :=
  by
  rw [‚Üê smul_one_smul ‚Ñù‚â•0 r Œº]
  infer_instance
#align measure_theory.is_finite_measure_smul_of_nnreal_tower MeasureTheory.finiteMeasureSmulOfNNRealTower

#print MeasureTheory.finiteMeasureOfLe /-
theorem finiteMeasureOfLe (Œº : Measure Œ±) [FiniteMeasure Œº] (h : ŒΩ ‚â§ Œº) : FiniteMeasure ŒΩ :=
  { measure_univ_lt_top := lt_of_le_of_lt (h Set.univ MeasurableSet.univ) (measure_lt_top _ _) }
#align measure_theory.is_finite_measure_of_le MeasureTheory.finiteMeasureOfLe
-/

/- warning: measure_theory.measure.is_finite_measure_map -> MeasureTheory.Measure.finiteMeasureMap is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u2} Œ≤] {m : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m) [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m Œº] (f : Œ± -> Œ≤), MeasureTheory.FiniteMeasure.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m f Œº)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u1} Œ≤] {m : MeasurableSpace.{u2} Œ±} (Œº : MeasureTheory.Measure.{u2} Œ± m) [_inst_3 : MeasureTheory.FiniteMeasure.{u2} Œ± m Œº] (f : Œ± -> Œ≤), MeasureTheory.FiniteMeasure.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m f Œº)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.is_finite_measure_map MeasureTheory.Measure.finiteMeasureMap‚Çì'. -/
@[instance]
theorem Measure.finiteMeasureMap {m : MeasurableSpace Œ±} (Œº : Measure Œ±) [FiniteMeasure Œº]
    (f : Œ± ‚Üí Œ≤) : FiniteMeasure (Œº.map f) :=
  by
  by_cases hf : AEMeasurable f Œº
  ¬∑ constructor
    rw [map_apply_of_ae_measurable hf MeasurableSet.univ]
    exact measure_lt_top Œº _
  ¬∑ rw [map_of_not_ae_measurable hf]
    exact MeasureTheory.finiteMeasureZero
#align measure_theory.measure.is_finite_measure_map MeasureTheory.Measure.finiteMeasureMap

/- warning: measure_theory.measure_univ_nnreal_eq_zero -> MeasureTheory.measureUnivNNReal_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº], Iff (Eq.{1} NNReal (MeasureTheory.measureUnivNNReal.{u1} Œ± m0 Œº) (OfNat.ofNat.{0} NNReal 0 (OfNat.mk.{0} NNReal 0 (Zero.zero.{0} NNReal (MulZeroClass.toHasZero.{0} NNReal (NonUnitalNonAssocSemiring.toMulZeroClass.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)))))))) (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (OfNat.mk.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.zero.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº], Iff (Eq.{1} NNReal (MeasureTheory.measureUnivNNReal.{u1} Œ± m0 Œº) (OfNat.ofNat.{0} NNReal 0 (Zero.toOfNat0.{0} NNReal instNNRealZero))) (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.toOfNat0.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_univ_nnreal_eq_zero MeasureTheory.measureUnivNNReal_eq_zero‚Çì'. -/
@[simp]
theorem measureUnivNNReal_eq_zero [FiniteMeasure Œº] : measureUnivNNReal Œº = 0 ‚Üî Œº = 0 :=
  by
  rw [‚Üê MeasureTheory.Measure.measure_univ_eq_zero, ‚Üê coe_measure_univ_nnreal]
  norm_cast
#align measure_theory.measure_univ_nnreal_eq_zero MeasureTheory.measureUnivNNReal_eq_zero

/- warning: measure_theory.measure_univ_nnreal_pos -> MeasureTheory.measureUnivNNReal_pos is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº], (Ne.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (OfNat.mk.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.zero.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0))))) -> (LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (OfNat.ofNat.{0} NNReal 0 (OfNat.mk.{0} NNReal 0 (Zero.zero.{0} NNReal (MulZeroClass.toHasZero.{0} NNReal (NonUnitalNonAssocSemiring.toMulZeroClass.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) (MeasureTheory.measureUnivNNReal.{u1} Œ± m0 Œº))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº], (Ne.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.toOfNat0.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0)))) -> (LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (OfNat.ofNat.{0} NNReal 0 (Zero.toOfNat0.{0} NNReal instNNRealZero)) (MeasureTheory.measureUnivNNReal.{u1} Œ± m0 Œº))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_univ_nnreal_pos MeasureTheory.measureUnivNNReal_pos‚Çì'. -/
theorem measureUnivNNReal_pos [FiniteMeasure Œº] (hŒº : Œº ‚â† 0) : 0 < measureUnivNNReal Œº :=
  by
  contrapose! hŒº
  simpa [measure_univ_nnreal_eq_zero, le_zero_iff] using hŒº
#align measure_theory.measure_univ_nnreal_pos MeasureTheory.measureUnivNNReal_pos

#print MeasureTheory.Measure.le_of_add_le_add_left /-
/-- `le_of_add_le_add_left` is normally applicable to `ordered_cancel_add_comm_monoid`,
but it holds for measures with the additional assumption that Œº is finite. -/
theorem Measure.le_of_add_le_add_left [FiniteMeasure Œº] (A2 : Œº + ŒΩ‚ÇÅ ‚â§ Œº + ŒΩ‚ÇÇ) : ŒΩ‚ÇÅ ‚â§ ŒΩ‚ÇÇ :=
  fun S B1 => ENNReal.le_of_add_le_add_left (MeasureTheory.measure_ne_top Œº S) (A2 S B1)
#align measure_theory.measure.le_of_add_le_add_left MeasureTheory.Measure.le_of_add_le_add_left
-/

/- warning: measure_theory.summable_measure_to_real -> MeasureTheory.summable_measure_toReal is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [hŒº : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº] {f : Nat -> (Set.{u1} Œ±)}, (forall (i : Nat), MeasurableSet.{u1} Œ± m0 (f i)) -> (Pairwise.{0} Nat (Function.onFun.{1, succ u1, 1} Nat (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)))) f)) -> (Summable.{0, 0} Real Nat Real.addCommMonoid (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (x : Nat) => ENNReal.toReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (f x))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [hŒº : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº] {f : Nat -> (Set.{u1} Œ±)}, (forall (i : Nat), MeasurableSet.{u1} Œ± m0 (f i)) -> (Pairwise.{0} Nat (Function.onFun.{1, succ u1, 1} Nat (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))))) f)) -> (Summable.{0, 0} Real Nat Real.instAddCommMonoidReal (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (fun (x : Nat) => ENNReal.toReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (f x))))
Case conversion may be inaccurate. Consider using '#align measure_theory.summable_measure_to_real MeasureTheory.summable_measure_toReal‚Çì'. -/
theorem summable_measure_toReal [hŒº : FiniteMeasure Œº] {f : ‚Ñï ‚Üí Set Œ±}
    (hf‚ÇÅ : ‚àÄ i : ‚Ñï, MeasurableSet (f i)) (hf‚ÇÇ : Pairwise (Disjoint on f)) :
    Summable fun x => (Œº (f x)).toReal :=
  by
  apply ENNReal.summable_toReal
  rw [‚Üê MeasureTheory.measure_union·µ¢ hf‚ÇÇ hf‚ÇÅ]
  exact ne_of_lt (measure_lt_top _ _)
#align measure_theory.summable_measure_to_real MeasureTheory.summable_measure_toReal

#print MeasureTheory.ae_eq_univ_iff_measure_eq /-
theorem ae_eq_univ_iff_measure_eq [FiniteMeasure Œº] (hs : NullMeasurableSet s Œº) :
    s =·µê[Œº] univ ‚Üî Œº s = Œº univ :=
  by
  refine' ‚ü®measure_congr, fun h => _‚ü©
  obtain ‚ü®t, -, ht‚ÇÅ, ht‚ÇÇ‚ü© := hs.exists_measurable_subset_ae_eq
  exact
    ht‚ÇÇ.symm.trans
      (ae_eq_of_subset_of_measure_ge (subset_univ t) (Eq.le ((measure_congr ht‚ÇÇ).trans h).symm) ht‚ÇÅ
        (measure_ne_top Œº univ))
#align measure_theory.ae_eq_univ_iff_measure_eq MeasureTheory.ae_eq_univ_iff_measure_eq
-/

#print MeasureTheory.ae_iff_measure_eq /-
theorem ae_iff_measure_eq [FiniteMeasure Œº] {p : Œ± ‚Üí Prop} (hp : NullMeasurableSet { a | p a } Œº) :
    (‚àÄ·µê a ‚àÇŒº, p a) ‚Üî Œº { a | p a } = Œº univ := by
  rw [‚Üê ae_eq_univ_iff_measure_eq hp, eventually_eq_univ, eventually_iff]
#align measure_theory.ae_iff_measure_eq MeasureTheory.ae_iff_measure_eq
-/

#print MeasureTheory.ae_mem_iff_measure_eq /-
theorem ae_mem_iff_measure_eq [FiniteMeasure Œº] {s : Set Œ±} (hs : NullMeasurableSet s Œº) :
    (‚àÄ·µê a ‚àÇŒº, a ‚àà s) ‚Üî Œº s = Œº univ :=
  ae_iff_measure_eq hs
#align measure_theory.ae_mem_iff_measure_eq MeasureTheory.ae_mem_iff_measure_eq
-/

instance [Finite Œ±] [MeasurableSpace Œ±] : FiniteMeasure (Measure.count : Measure Œ±) :=
  ‚ü®by
    cases nonempty_fintype Œ±
    simpa [measure.count_apply, tsum_fintype] using (ENNReal.nat_ne_top _).lt_top‚ü©

end IsFiniteMeasure

section IsProbabilityMeasure

include m0

#print MeasureTheory.ProbabilityMeasure /-
/-- A measure `Œº` is called a probability measure if `Œº univ = 1`. -/
class ProbabilityMeasure (Œº : Measure Œ±) : Prop where
  measure_univ : Œº univ = 1
#align measure_theory.is_probability_measure MeasureTheory.ProbabilityMeasure
-/

export IsProbabilityMeasure (measure_univ)

attribute [simp] is_probability_measure.measure_univ

#print MeasureTheory.ProbabilityMeasure.toIsFiniteMeasure /-
instance (priority := 100) ProbabilityMeasure.toIsFiniteMeasure (Œº : Measure Œ±)
    [ProbabilityMeasure Œº] : FiniteMeasure Œº :=
  ‚ü®by simp only [measure_univ, ENNReal.one_lt_top]‚ü©
#align measure_theory.is_probability_measure.to_is_finite_measure MeasureTheory.ProbabilityMeasure.toIsFiniteMeasure
-/

#print MeasureTheory.ProbabilityMeasure.ne_zero /-
theorem ProbabilityMeasure.ne_zero (Œº : Measure Œ±) [ProbabilityMeasure Œº] : Œº ‚â† 0 :=
  mt measure_univ_eq_zero.2 <| by simp [measure_univ]
#align measure_theory.is_probability_measure.ne_zero MeasureTheory.ProbabilityMeasure.ne_zero
-/

#print MeasureTheory.ProbabilityMeasure.ae_neBot /-
instance (priority := 200) ProbabilityMeasure.ae_neBot [ProbabilityMeasure Œº] : NeBot Œº.ae :=
  ae_neBot.2 (ProbabilityMeasure.ne_zero Œº)
#align measure_theory.is_probability_measure.ae_ne_bot MeasureTheory.ProbabilityMeasure.ae_neBot
-/

omit m0

#print MeasureTheory.Measure.dirac.isProbabilityMeasure /-
instance Measure.dirac.isProbabilityMeasure [MeasurableSpace Œ±] {x : Œ±} :
    ProbabilityMeasure (dirac x) :=
  ‚ü®dirac_apply_of_mem <| mem_univ x‚ü©
#align measure_theory.measure.dirac.is_probability_measure MeasureTheory.Measure.dirac.isProbabilityMeasure
-/

/- warning: measure_theory.prob_add_prob_compl -> MeasureTheory.prob_add_prob_compl is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.ProbabilityMeasure.{u1} Œ± m0 Œº], (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toHasAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.ProbabilityMeasure.{u1} Œ± m0 Œº], (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (HAdd.hAdd.{0, 0, 0} ENNReal ENNReal ENNReal (instHAdd.{0} ENNReal (Distrib.toAdd.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) s))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))
Case conversion may be inaccurate. Consider using '#align measure_theory.prob_add_prob_compl MeasureTheory.prob_add_prob_compl‚Çì'. -/
theorem prob_add_prob_compl [ProbabilityMeasure Œº] (h : MeasurableSet s) : Œº s + Œº (s·∂ú) = 1 :=
  (measure_add_measure_compl h).trans measure_univ
#align measure_theory.prob_add_prob_compl MeasureTheory.prob_add_prob_compl

/- warning: measure_theory.prob_le_one -> MeasureTheory.prob_le_one is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.ProbabilityMeasure.{u1} Œ± m0 Œº], LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.ProbabilityMeasure.{u1} Œ± m0 Œº], LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))
Case conversion may be inaccurate. Consider using '#align measure_theory.prob_le_one MeasureTheory.prob_le_one‚Çì'. -/
theorem prob_le_one [ProbabilityMeasure Œº] : Œº s ‚â§ 1 :=
  (measure_mono <| Set.subset_univ _).trans_eq measure_univ
#align measure_theory.prob_le_one MeasureTheory.prob_le_one

/- warning: measure_theory.is_probability_measure_smul -> MeasureTheory.isProbabilityMeasureSmul is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº], (Ne.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (OfNat.mk.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.zero.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0))))) -> (MeasureTheory.ProbabilityMeasure.{u1} Œ± m0 (SMul.smul.{0, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± ENNReal (SMulZeroClass.toHasSmul.{0, 0} ENNReal ENNReal (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (SMulWithZero.toSmulZeroClass.{0, 0} ENNReal ENNReal (MulZeroClass.toHasZero.{0} ENNReal (MulZeroOneClass.toMulZeroClass.{0} ENNReal (MonoidWithZero.toMulZeroOneClass.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (MulActionWithZero.toSMulWithZero.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (Module.toMulActionWithZero.{0, 0} ENNReal ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Algebra.toModule.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) m0) (Inv.inv.{0} ENNReal ENNReal.hasInv (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.univ.{u1} Œ±))) Œº))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº], (Ne.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.toOfNat0.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0)))) -> (MeasureTheory.ProbabilityMeasure.{u1} Œ± m0 (HSMul.hSMul.{0, u1, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHSMul.{0, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± ENNReal (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0)) (Inv.inv.{0} ENNReal ENNReal.instInvENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Set.univ.{u1} Œ±))) Œº))
Case conversion may be inaccurate. Consider using '#align measure_theory.is_probability_measure_smul MeasureTheory.isProbabilityMeasureSmul‚Çì'. -/
theorem isProbabilityMeasureSmul [FiniteMeasure Œº] (h : Œº ‚â† 0) :
    ProbabilityMeasure ((Œº univ)‚Åª¬π ‚Ä¢ Œº) := by
  constructor
  rw [smul_apply, smul_eq_mul, ENNReal.inv_mul_cancel]
  ¬∑ rwa [Ne, measure_univ_eq_zero]
  ¬∑ exact measure_ne_top _ _
#align measure_theory.is_probability_measure_smul MeasureTheory.isProbabilityMeasureSmul

/- warning: measure_theory.is_probability_measure_map -> MeasureTheory.isProbabilityMeasureMap is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : MeasureTheory.ProbabilityMeasure.{u1} Œ± m0 Œº] {f : Œ± -> Œ≤}, (AEMeasurable.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) -> (MeasureTheory.ProbabilityMeasure.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} [_inst_3 : MeasureTheory.ProbabilityMeasure.{u2} Œ± m0 Œº] {f : Œ± -> Œ≤}, (AEMeasurable.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) -> (MeasureTheory.ProbabilityMeasure.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº))
Case conversion may be inaccurate. Consider using '#align measure_theory.is_probability_measure_map MeasureTheory.isProbabilityMeasureMap‚Çì'. -/
theorem isProbabilityMeasureMap [ProbabilityMeasure Œº] {f : Œ± ‚Üí Œ≤} (hf : AEMeasurable f Œº) :
    ProbabilityMeasure (map f Œº) :=
  ‚ü®by simp [map_apply_of_ae_measurable, hf]‚ü©
#align measure_theory.is_probability_measure_map MeasureTheory.isProbabilityMeasureMap

/- warning: measure_theory.one_le_prob_iff -> MeasureTheory.one_le_prob_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.ProbabilityMeasure.{u1} Œ± m0 Œº], Iff (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s)) (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.ProbabilityMeasure.{u1} Œ± m0 Œº], Iff (LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s)) (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))))
Case conversion may be inaccurate. Consider using '#align measure_theory.one_le_prob_iff MeasureTheory.one_le_prob_iff‚Çì'. -/
@[simp]
theorem one_le_prob_iff [ProbabilityMeasure Œº] : 1 ‚â§ Œº s ‚Üî Œº s = 1 :=
  ‚ü®fun h => le_antisymm prob_le_one h, fun h => h ‚ñ∏ le_refl _‚ü©
#align measure_theory.one_le_prob_iff MeasureTheory.one_le_prob_iff

/- warning: measure_theory.prob_compl_eq_one_sub -> MeasureTheory.prob_compl_eq_one_sub is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.ProbabilityMeasure.{u1} Œ± m0 Œº], (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s)) (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.hasSub) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.ProbabilityMeasure.{u1} Œ± m0 Œº], (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) s)) (HSub.hSub.{0, 0, 0} ENNReal ENNReal ENNReal (instHSub.{0} ENNReal ENNReal.instSubENNReal) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.prob_compl_eq_one_sub MeasureTheory.prob_compl_eq_one_sub‚Çì'. -/
/-- Note that this is not quite as useful as it looks because the measure takes values in `‚Ñù‚â•0‚àû`.
Thus the subtraction appearing is the truncated subtraction of `‚Ñù‚â•0‚àû`, rather than the
better-behaved subtraction of `‚Ñù`. -/
theorem prob_compl_eq_one_sub [ProbabilityMeasure Œº] (hs : MeasurableSet s) : Œº (s·∂ú) = 1 - Œº s := by
  simpa only [measure_univ] using measure_compl hs (measure_lt_top Œº s).Ne
#align measure_theory.prob_compl_eq_one_sub MeasureTheory.prob_compl_eq_one_sub

/- warning: measure_theory.prob_compl_eq_zero_iff -> MeasureTheory.prob_compl_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.ProbabilityMeasure.{u1} Œ± m0 Œº], (MeasurableSet.{u1} Œ± m0 s) -> (Iff (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.ProbabilityMeasure.{u1} Œ± m0 Œº], (MeasurableSet.{u1} Œ± m0 s) -> (Iff (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))
Case conversion may be inaccurate. Consider using '#align measure_theory.prob_compl_eq_zero_iff MeasureTheory.prob_compl_eq_zero_iff‚Çì'. -/
@[simp]
theorem prob_compl_eq_zero_iff [ProbabilityMeasure Œº] (hs : MeasurableSet s) :
    Œº (s·∂ú) = 0 ‚Üî Œº s = 1 := by
  simp only [prob_compl_eq_one_sub hs, tsub_eq_zero_iff_le, one_le_prob_iff]
#align measure_theory.prob_compl_eq_zero_iff MeasureTheory.prob_compl_eq_zero_iff

/- warning: measure_theory.prob_compl_eq_one_iff -> MeasureTheory.prob_compl_eq_one_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.ProbabilityMeasure.{u1} Œ± m0 Œº], (MeasurableSet.{u1} Œ± m0 s) -> (Iff (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s)) (OfNat.ofNat.{0} ENNReal 1 (OfNat.mk.{0} ENNReal 1 (One.one.{0} ENNReal (AddMonoidWithOne.toOne.{0} ENNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} ENNReal ENNReal.addCommMonoidWithOne)))))) (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.ProbabilityMeasure.{u1} Œ± m0 Œº], (MeasurableSet.{u1} Œ± m0 s) -> (Iff (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) s)) (OfNat.ofNat.{0} ENNReal 1 (One.toOfNat1.{0} ENNReal (CanonicallyOrderedCommSemiring.toOne.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))))
Case conversion may be inaccurate. Consider using '#align measure_theory.prob_compl_eq_one_iff MeasureTheory.prob_compl_eq_one_iff‚Çì'. -/
@[simp]
theorem prob_compl_eq_one_iff [ProbabilityMeasure Œº] (hs : MeasurableSet s) :
    Œº (s·∂ú) = 1 ‚Üî Œº s = 0 := by rwa [‚Üê prob_compl_eq_zero_iff hs.compl, compl_compl]
#align measure_theory.prob_compl_eq_one_iff MeasureTheory.prob_compl_eq_one_iff

end IsProbabilityMeasure

section NoAtoms

#print MeasureTheory.NoAtoms /-
/-- Measure `Œº` *has no atoms* if the measure of each singleton is zero.

NB: Wikipedia assumes that for any measurable set `s` with positive `Œº`-measure,
there exists a measurable `t ‚äÜ s` such that `0 < Œº t < Œº s`. While this implies `Œº {x} = 0`,
the converse is not true. -/
class NoAtoms {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) : Prop where
  measure_singleton : ‚àÄ x, Œº {x} = 0
#align measure_theory.has_no_atoms MeasureTheory.NoAtoms
-/

export HasNoAtoms (measure_singleton)

attribute [simp] measure_singleton

variable [NoAtoms Œº]

/- warning: set.subsingleton.measure_zero -> Set.Subsingleton.measure_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {s : Set.{u1} Œ±}, (Set.Subsingleton.{u1} Œ± s) -> (forall (Œº : MeasureTheory.Measure.{u1} Œ± m) [_inst_4 : MeasureTheory.NoAtoms.{u1} Œ± m Œº], Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {s : Set.{u1} Œ±}, (Set.Subsingleton.{u1} Œ± s) -> (forall (Œº : MeasureTheory.Measure.{u1} Œ± m) [_inst_4 : MeasureTheory.NoAtoms.{u1} Œ± m Œº], Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align set.subsingleton.measure_zero Set.Subsingleton.measure_zero‚Çì'. -/
theorem Set.Subsingleton.measure_zero {Œ± : Type _} {m : MeasurableSpace Œ±} {s : Set Œ±}
    (hs : s.Subsingleton) (Œº : Measure Œ±) [NoAtoms Œº] : Œº s = 0 :=
  hs.inductionOn measure_empty measure_singleton
#align set.subsingleton.measure_zero Set.Subsingleton.measure_zero

#print MeasureTheory.Measure.restrict_singleton' /-
theorem Measure.restrict_singleton' {a : Œ±} : Œº.restrict {a} = 0 := by
  simp only [measure_singleton, measure.restrict_eq_zero]
#align measure_theory.measure.restrict_singleton' MeasureTheory.Measure.restrict_singleton'
-/

instance (s : Set Œ±) : NoAtoms (Œº.restrict s) :=
  by
  refine' ‚ü®fun x => _‚ü©
  obtain ‚ü®t, hxt, ht1, ht2‚ü© := exists_measurable_superset_of_null (measure_singleton x : Œº {x} = 0)
  apply measure_mono_null hxt
  rw [measure.restrict_apply ht1]
  apply measure_mono_null (inter_subset_left t s) ht2

/- warning: set.countable.measure_zero -> Set.Countable.measure_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {s : Set.{u1} Œ±}, (Set.Countable.{u1} Œ± s) -> (forall (Œº : MeasureTheory.Measure.{u1} Œ± m) [_inst_4 : MeasureTheory.NoAtoms.{u1} Œ± m Œº], Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {s : Set.{u1} Œ±}, (Set.Countable.{u1} Œ± s) -> (forall (Œº : MeasureTheory.Measure.{u1} Œ± m) [_inst_4 : MeasureTheory.NoAtoms.{u1} Œ± m Œº], Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align set.countable.measure_zero Set.Countable.measure_zero‚Çì'. -/
theorem Set.Countable.measure_zero {Œ± : Type _} {m : MeasurableSpace Œ±} {s : Set Œ±}
    (h : s.Countable) (Œº : Measure Œ±) [NoAtoms Œº] : Œº s = 0 :=
  by
  rw [‚Üê bUnion_of_singleton s, ‚Üê nonpos_iff_eq_zero]
  refine' le_trans (measure_bUnion_le h _) _
  simp
#align set.countable.measure_zero Set.Countable.measure_zero

#print Set.Countable.ae_not_mem /-
theorem Set.Countable.ae_not_mem {Œ± : Type _} {m : MeasurableSpace Œ±} {s : Set Œ±} (h : s.Countable)
    (Œº : Measure Œ±) [NoAtoms Œº] : ‚àÄ·µê x ‚àÇŒº, x ‚àâ s := by
  simpa only [ae_iff, Classical.not_not] using h.measure_zero Œº
#align set.countable.ae_not_mem Set.Countable.ae_not_mem
-/

/- warning: set.finite.measure_zero -> Set.Finite.measure_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {s : Set.{u1} Œ±}, (Set.Finite.{u1} Œ± s) -> (forall (Œº : MeasureTheory.Measure.{u1} Œ± m) [_inst_4 : MeasureTheory.NoAtoms.{u1} Œ± m Œº], Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {s : Set.{u1} Œ±}, (Set.Finite.{u1} Œ± s) -> (forall (Œº : MeasureTheory.Measure.{u1} Œ± m) [_inst_4 : MeasureTheory.NoAtoms.{u1} Œ± m Œº], Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align set.finite.measure_zero Set.Finite.measure_zero‚Çì'. -/
theorem Set.Finite.measure_zero {Œ± : Type _} {m : MeasurableSpace Œ±} {s : Set Œ±} (h : s.Finite)
    (Œº : Measure Œ±) [NoAtoms Œº] : Œº s = 0 :=
  h.Countable.measure_zero Œº
#align set.finite.measure_zero Set.Finite.measure_zero

/- warning: finset.measure_zero -> Finset.measure_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} (s : Finset.{u1} Œ±) (Œº : MeasureTheory.Measure.{u1} Œ± m) [_inst_4 : MeasureTheory.NoAtoms.{u1} Œ± m Œº], Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} Œ±) (Set.{u1} Œ±) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} Œ±) (Set.{u1} Œ±) (CoeTC‚Çì.coe.{succ u1, succ u1} (Finset.{u1} Œ±) (Set.{u1} Œ±) (Finset.Set.hasCoeT.{u1} Œ±))) s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} (s : Finset.{u1} Œ±) (Œº : MeasureTheory.Measure.{u1} Œ± m) [_inst_4 : MeasureTheory.NoAtoms.{u1} Œ± m Œº], Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Finset.toSet.{u1} Œ± s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))
Case conversion may be inaccurate. Consider using '#align finset.measure_zero Finset.measure_zero‚Çì'. -/
theorem Finset.measure_zero {Œ± : Type _} {m : MeasurableSpace Œ±} (s : Finset Œ±) (Œº : Measure Œ±)
    [NoAtoms Œº] : Œº s = 0 :=
  s.finite_toSet.measure_zero Œº
#align finset.measure_zero Finset.measure_zero

#print MeasureTheory.insert_ae_eq_self /-
theorem insert_ae_eq_self (a : Œ±) (s : Set Œ±) : (insert a s : Set Œ±) =·µê[Œº] s :=
  union_ae_eq_right.2 <| measure_mono_null (diff_subset _ _) (measure_singleton _)
#align measure_theory.insert_ae_eq_self MeasureTheory.insert_ae_eq_self
-/

section

variable [PartialOrder Œ±] {a b : Œ±}

#print MeasureTheory.Iio_ae_eq_Iic /-
theorem Iio_ae_eq_Iic : Iio a =·µê[Œº] Iic a :=
  Iio_ae_eq_Iic' (measure_singleton a)
#align measure_theory.Iio_ae_eq_Iic MeasureTheory.Iio_ae_eq_Iic
-/

#print MeasureTheory.Ioi_ae_eq_Ici /-
theorem Ioi_ae_eq_Ici : Ioi a =·µê[Œº] Ici a :=
  Ioi_ae_eq_Ici' (measure_singleton a)
#align measure_theory.Ioi_ae_eq_Ici MeasureTheory.Ioi_ae_eq_Ici
-/

#print MeasureTheory.Ioo_ae_eq_Ioc /-
theorem Ioo_ae_eq_Ioc : Ioo a b =·µê[Œº] Ioc a b :=
  Ioo_ae_eq_Ioc' (measure_singleton b)
#align measure_theory.Ioo_ae_eq_Ioc MeasureTheory.Ioo_ae_eq_Ioc
-/

#print MeasureTheory.Ioc_ae_eq_Icc /-
theorem Ioc_ae_eq_Icc : Ioc a b =·µê[Œº] Icc a b :=
  Ioc_ae_eq_Icc' (measure_singleton a)
#align measure_theory.Ioc_ae_eq_Icc MeasureTheory.Ioc_ae_eq_Icc
-/

#print MeasureTheory.Ioo_ae_eq_Ico /-
theorem Ioo_ae_eq_Ico : Ioo a b =·µê[Œº] Ico a b :=
  Ioo_ae_eq_Ico' (measure_singleton a)
#align measure_theory.Ioo_ae_eq_Ico MeasureTheory.Ioo_ae_eq_Ico
-/

#print MeasureTheory.Ioo_ae_eq_Icc /-
theorem Ioo_ae_eq_Icc : Ioo a b =·µê[Œº] Icc a b :=
  Ioo_ae_eq_Icc' (measure_singleton a) (measure_singleton b)
#align measure_theory.Ioo_ae_eq_Icc MeasureTheory.Ioo_ae_eq_Icc
-/

#print MeasureTheory.Ico_ae_eq_Icc /-
theorem Ico_ae_eq_Icc : Ico a b =·µê[Œº] Icc a b :=
  Ico_ae_eq_Icc' (measure_singleton b)
#align measure_theory.Ico_ae_eq_Icc MeasureTheory.Ico_ae_eq_Icc
-/

#print MeasureTheory.Ico_ae_eq_Ioc /-
theorem Ico_ae_eq_Ioc : Ico a b =·µê[Œº] Ioc a b :=
  Ico_ae_eq_Ioc' (measure_singleton a) (measure_singleton b)
#align measure_theory.Ico_ae_eq_Ioc MeasureTheory.Ico_ae_eq_Ioc
-/

end

open Interval

#print MeasureTheory.uIoc_ae_eq_interval /-
theorem uIoc_ae_eq_interval [LinearOrder Œ±] {a b : Œ±} : Œô a b =·µê[Œº] [a, b] :=
  Ioc_ae_eq_Icc
#align measure_theory.uIoc_ae_eq_interval MeasureTheory.uIoc_ae_eq_interval
-/

end NoAtoms

/- warning: measure_theory.ite_ae_eq_of_measure_zero -> MeasureTheory.ite_ae_eq_of_measure_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {Œ≥ : Type.{u2}} (f : Œ± -> Œ≥) (g : Œ± -> Œ≥) (s : Set.{u1} Œ±), (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ≥ (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (fun (x : Œ±) => ite.{succ u2} Œ≥ (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) (Classical.propDecidable (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) (f x) (g x)) g)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {Œ≥ : Type.{u2}} (f : Œ± -> Œ≥) (g : Œ± -> Œ≥) (s : Set.{u1} Œ±), (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ≥ (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (fun (x : Œ±) => ite.{succ u2} Œ≥ (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) (Classical.propDecidable (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (f x) (g x)) g)
Case conversion may be inaccurate. Consider using '#align measure_theory.ite_ae_eq_of_measure_zero MeasureTheory.ite_ae_eq_of_measure_zero‚Çì'. -/
theorem ite_ae_eq_of_measure_zero {Œ≥} (f : Œ± ‚Üí Œ≥) (g : Œ± ‚Üí Œ≥) (s : Set Œ±) (hs_zero : Œº s = 0) :
    (fun x => ite (x ‚àà s) (f x) (g x)) =·µê[Œº] g :=
  by
  have h_ss : s·∂ú ‚äÜ { a : Œ± | ite (a ‚àà s) (f a) (g a) = g a } := fun x hx => by
    simp [(Set.mem_compl_iff _ _).mp hx]
  refine' measure_mono_null _ hs_zero
  nth_rw 1 [‚Üê compl_compl s]
  rwa [Set.compl_subset_compl]
#align measure_theory.ite_ae_eq_of_measure_zero MeasureTheory.ite_ae_eq_of_measure_zero

/- warning: measure_theory.ite_ae_eq_of_measure_compl_zero -> MeasureTheory.ite_ae_eq_of_measure_compl_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {Œ≥ : Type.{u2}} (f : Œ± -> Œ≥) (g : Œ± -> Œ≥) (s : Set.{u1} Œ±), (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ≥ (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (fun (x : Œ±) => ite.{succ u2} Œ≥ (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) (Classical.propDecidable (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) (f x) (g x)) f)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {Œ≥ : Type.{u2}} (f : Œ± -> Œ≥) (g : Œ± -> Œ≥) (s : Set.{u1} Œ±), (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ≥ (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº) (fun (x : Œ±) => ite.{succ u2} Œ≥ (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) (Classical.propDecidable (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (f x) (g x)) f)
Case conversion may be inaccurate. Consider using '#align measure_theory.ite_ae_eq_of_measure_compl_zero MeasureTheory.ite_ae_eq_of_measure_compl_zero‚Çì'. -/
theorem ite_ae_eq_of_measure_compl_zero {Œ≥} (f : Œ± ‚Üí Œ≥) (g : Œ± ‚Üí Œ≥) (s : Set Œ±)
    (hs_zero : Œº (s·∂ú) = 0) : (fun x => ite (x ‚àà s) (f x) (g x)) =·µê[Œº] f :=
  by
  filter_upwards [hs_zero]
  intros
  split_ifs
  rfl
#align measure_theory.ite_ae_eq_of_measure_compl_zero MeasureTheory.ite_ae_eq_of_measure_compl_zero

namespace Measure

#print MeasureTheory.Measure.FiniteAtFilter /-
/-- A measure is called finite at filter `f` if it is finite at some set `s ‚àà f`.
Equivalently, it is eventually finite at `s` in `f.small_sets`. -/
def FiniteAtFilter {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) (f : Filter Œ±) : Prop :=
  ‚àÉ s ‚àà f, Œº s < ‚àû
#align measure_theory.measure.finite_at_filter MeasureTheory.Measure.FiniteAtFilter
-/

#print MeasureTheory.Measure.finiteAtFilterOfFinite /-
theorem finiteAtFilterOfFinite {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) [FiniteMeasure Œº]
    (f : Filter Œ±) : Œº.FiniteAtFilter f :=
  ‚ü®univ, univ_mem, measure_lt_top Œº univ‚ü©
#align measure_theory.measure.finite_at_filter_of_finite MeasureTheory.Measure.finiteAtFilterOfFinite
-/

/- warning: measure_theory.measure.finite_at_filter.exists_mem_basis -> MeasureTheory.Measure.FiniteAtFilter.exists_mem_basis is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±}, (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f) -> (forall {p : Œπ -> Prop} {s : Œπ -> (Set.{u1} Œ±)}, (Filter.HasBasis.{u1, succ u2} Œ± Œπ f p s) -> (Exists.{succ u2} Œπ (fun (i : Œπ) => Exists.{0} (p i) (fun (hi : p i) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (s i)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œπ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} {Œº : MeasureTheory.Measure.{u2} Œ± m0} {f : Filter.{u2} Œ±}, (MeasureTheory.Measure.FiniteAtFilter.{u2} Œ± m0 Œº f) -> (forall {p : Œπ -> Prop} {s : Œπ -> (Set.{u2} Œ±)}, (Filter.HasBasis.{u2, succ u1} Œ± Œπ f p s) -> (Exists.{succ u1} Œπ (fun (i : Œπ) => And (p i) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 Œº) (s i)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.finite_at_filter.exists_mem_basis MeasureTheory.Measure.FiniteAtFilter.exists_mem_basis‚Çì'. -/
theorem FiniteAtFilter.exists_mem_basis {f : Filter Œ±} (hŒº : FiniteAtFilter Œº f) {p : Œπ ‚Üí Prop}
    {s : Œπ ‚Üí Set Œ±} (hf : f.HasBasis p s) : ‚àÉ (i : _)(hi : p i), Œº (s i) < ‚àû :=
  (hf.exists_iff fun s t hst ht => (measure_mono hst).trans_lt ht).1 hŒº
#align measure_theory.measure.finite_at_filter.exists_mem_basis MeasureTheory.Measure.FiniteAtFilter.exists_mem_basis

/- warning: measure_theory.measure.finite_at_bot -> MeasureTheory.Measure.finiteAtBot is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0), MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0), MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.finite_at_bot MeasureTheory.Measure.finiteAtBot‚Çì'. -/
theorem finiteAtBot {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) : Œº.FiniteAtFilter ‚ä• :=
  ‚ü®‚àÖ, mem_bot, by simp only [measure_empty, WithTop.zero_lt_top]‚ü©
#align measure_theory.measure.finite_at_bot MeasureTheory.Measure.finiteAtBot

#print MeasureTheory.Measure.FiniteSpanningSetsIn /-
/-- `Œº` has finite spanning sets in `C` if there is a countable sequence of sets in `C` that have
  finite measures. This structure is a type, which is useful if we want to record extra properties
  about the sets, such as that they are monotone.
  `sigma_finite` is defined in terms of this: `Œº` is œÉ-finite if there exists a sequence of
  finite spanning sets in the collection of all measurable sets. -/
@[protect_proj, nolint has_nonempty_instance]
structure FiniteSpanningSetsIn {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) (C : Set (Set Œ±)) where
  Set : ‚Ñï ‚Üí Set Œ±
  set_mem : ‚àÄ i, Set i ‚àà C
  Finite : ‚àÄ i, Œº (Set i) < ‚àû
  spanning : (‚ãÉ i, Set i) = univ
#align measure_theory.measure.finite_spanning_sets_in MeasureTheory.Measure.FiniteSpanningSetsIn
-/

end Measure

open Measure

#print MeasureTheory.SigmaFinite /-
/-- A measure `Œº` is called œÉ-finite if there is a countable collection of sets
 `{ A i | i ‚àà ‚Ñï }` such that `Œº (A i) < ‚àû` and `‚ãÉ i, A i = s`. -/
class SigmaFinite {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) : Prop where
  out' : Nonempty (Œº.FiniteSpanningSetsIn univ)
#align measure_theory.sigma_finite MeasureTheory.SigmaFinite
-/

#print MeasureTheory.sigmaFinite_iff /-
theorem sigmaFinite_iff : SigmaFinite Œº ‚Üî Nonempty (Œº.FiniteSpanningSetsIn univ) :=
  ‚ü®fun h => h.1, fun h => ‚ü®h‚ü©‚ü©
#align measure_theory.sigma_finite_iff MeasureTheory.sigmaFinite_iff
-/

#print MeasureTheory.SigmaFinite.out /-
theorem SigmaFinite.out (h : SigmaFinite Œº) : Nonempty (Œº.FiniteSpanningSetsIn univ) :=
  h.1
#align measure_theory.sigma_finite.out MeasureTheory.SigmaFinite.out
-/

include m0

#print MeasureTheory.Measure.toFiniteSpanningSetsIn /-
/-- If `Œº` is œÉ-finite it has finite spanning sets in the collection of all measurable sets. -/
def Measure.toFiniteSpanningSetsIn (Œº : Measure Œ±) [h : SigmaFinite Œº] :
    Œº.FiniteSpanningSetsIn { s | MeasurableSet s }
    where
  Set n := toMeasurable Œº (h.out.some.Set n)
  set_mem n := measurableSet_toMeasurable _ _
  Finite n := by
    rw [measure_to_measurable]
    exact h.out.some.finite n
  spanning := eq_univ_of_subset (union·µ¢_mono fun n => subset_toMeasurable _ _) h.out.some.spanning
#align measure_theory.measure.to_finite_spanning_sets_in MeasureTheory.Measure.toFiniteSpanningSetsIn
-/

#print MeasureTheory.spanningSets /-
/-- A noncomputable way to get a monotone collection of sets that span `univ` and have finite
  measure using `classical.some`. This definition satisfies monotonicity in addition to all other
  properties in `sigma_finite`. -/
def spanningSets (Œº : Measure Œ±) [SigmaFinite Œº] (i : ‚Ñï) : Set Œ± :=
  Accumulate Œº.toFiniteSpanningSetsIn.Set i
#align measure_theory.spanning_sets MeasureTheory.spanningSets
-/

/- warning: measure_theory.monotone_spanning_sets -> MeasureTheory.monotone_spanningSets is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº], Monotone.{0, u1} Nat (Set.{u1} Œ±) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±))))))) (MeasureTheory.spanningSets.{u1} Œ± m0 Œº _inst_3)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº], Monotone.{0, u1} Nat (Set.{u1} Œ±) (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))))) (MeasureTheory.spanningSets.{u1} Œ± m0 Œº _inst_3)
Case conversion may be inaccurate. Consider using '#align measure_theory.monotone_spanning_sets MeasureTheory.monotone_spanningSets‚Çì'. -/
theorem monotone_spanningSets (Œº : Measure Œ±) [SigmaFinite Œº] : Monotone (spanningSets Œº) :=
  monotone_accumulate
#align measure_theory.monotone_spanning_sets MeasureTheory.monotone_spanningSets

#print MeasureTheory.measurable_spanningSets /-
theorem measurable_spanningSets (Œº : Measure Œ±) [SigmaFinite Œº] (i : ‚Ñï) :
    MeasurableSet (spanningSets Œº i) :=
  MeasurableSet.union·µ¢ fun j => MeasurableSet.union·µ¢ fun hij => Œº.toFiniteSpanningSetsIn.set_mem j
#align measure_theory.measurable_spanning_sets MeasureTheory.measurable_spanningSets
-/

/- warning: measure_theory.measure_spanning_sets_lt_top -> MeasureTheory.measure_spanningSets_lt_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] (i : Nat), LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (MeasureTheory.spanningSets.{u1} Œ± m0 Œº _inst_3 i)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] (i : Nat), LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (MeasureTheory.spanningSets.{u1} Œ± m0 Œº _inst_3 i)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_spanning_sets_lt_top MeasureTheory.measure_spanningSets_lt_top‚Çì'. -/
theorem measure_spanningSets_lt_top (Œº : Measure Œ±) [SigmaFinite Œº] (i : ‚Ñï) :
    Œº (spanningSets Œº i) < ‚àû :=
  measure_bunion·µ¢_lt_top (finite_le_nat i) fun j _ => (Œº.toFiniteSpanningSetsIn.Finite j).Ne
#align measure_theory.measure_spanning_sets_lt_top MeasureTheory.measure_spanningSets_lt_top

#print MeasureTheory.union·µ¢_spanningSets /-
theorem union·µ¢_spanningSets (Œº : Measure Œ±) [SigmaFinite Œº] : (‚ãÉ i : ‚Ñï, spanningSets Œº i) = univ :=
  by simp_rw [spanning_sets, Union_accumulate, Œº.to_finite_spanning_sets_in.spanning]
#align measure_theory.Union_spanning_sets MeasureTheory.union·µ¢_spanningSets
-/

#print MeasureTheory.isCountablySpanning_spanningSets /-
theorem isCountablySpanning_spanningSets (Œº : Measure Œ±) [SigmaFinite Œº] :
    IsCountablySpanning (range (spanningSets Œº)) :=
  ‚ü®spanningSets Œº, mem_range_self, union·µ¢_spanningSets Œº‚ü©
#align measure_theory.is_countably_spanning_spanning_sets MeasureTheory.isCountablySpanning_spanningSets
-/

#print MeasureTheory.spanningSetsIndex /-
/-- `spanning_sets_index Œº x` is the least `n : ‚Ñï` such that `x ‚àà spanning_sets Œº n`. -/
def spanningSetsIndex (Œº : Measure Œ±) [SigmaFinite Œº] (x : Œ±) : ‚Ñï :=
  Nat.find <| union·µ¢_eq_univ_iff.1 (union·µ¢_spanningSets Œº) x
#align measure_theory.spanning_sets_index MeasureTheory.spanningSetsIndex
-/

#print MeasureTheory.measurable_spanningSetsIndex /-
theorem measurable_spanningSetsIndex (Œº : Measure Œ±) [SigmaFinite Œº] :
    Measurable (spanningSetsIndex Œº) :=
  measurable_find _ <| measurable_spanningSets Œº
#align measure_theory.measurable_spanning_sets_index MeasureTheory.measurable_spanningSetsIndex
-/

/- warning: measure_theory.preimage_spanning_sets_index_singleton -> MeasureTheory.preimage_spanningSetsIndex_singleton is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] (n : Nat), Eq.{succ u1} (Set.{u1} Œ±) (Set.preimage.{u1, 0} Œ± Nat (MeasureTheory.spanningSetsIndex.{u1} Œ± m0 Œº _inst_3) (Singleton.singleton.{0, 0} Nat (Set.{0} Nat) (Set.hasSingleton.{0} Nat) n)) (disjointed.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) (MeasureTheory.spanningSets.{u1} Œ± m0 Œº _inst_3) n)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] (n : Nat), Eq.{succ u1} (Set.{u1} Œ±) (Set.preimage.{u1, 0} Œ± Nat (MeasureTheory.spanningSetsIndex.{u1} Œ± m0 Œº _inst_3) (Singleton.singleton.{0, 0} Nat (Set.{0} Nat) (Set.instSingletonSet.{0} Nat) n)) (disjointed.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) (MeasureTheory.spanningSets.{u1} Œ± m0 Œº _inst_3) n)
Case conversion may be inaccurate. Consider using '#align measure_theory.preimage_spanning_sets_index_singleton MeasureTheory.preimage_spanningSetsIndex_singleton‚Çì'. -/
theorem preimage_spanningSetsIndex_singleton (Œº : Measure Œ±) [SigmaFinite Œº] (n : ‚Ñï) :
    spanningSetsIndex Œº ‚Åª¬π' {n} = disjointed (spanningSets Œº) n :=
  preimage_find_eq_disjointed _ _ _
#align measure_theory.preimage_spanning_sets_index_singleton MeasureTheory.preimage_spanningSetsIndex_singleton

/- warning: measure_theory.spanning_sets_index_eq_iff -> MeasureTheory.spanningSetsIndex_eq_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] {x : Œ±} {n : Nat}, Iff (Eq.{1} Nat (MeasureTheory.spanningSetsIndex.{u1} Œ± m0 Œº _inst_3 x) n) (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x (disjointed.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) (MeasureTheory.spanningSets.{u1} Œ± m0 Œº _inst_3) n))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] {x : Œ±} {n : Nat}, Iff (Eq.{1} Nat (MeasureTheory.spanningSetsIndex.{u1} Œ± m0 Œº _inst_3 x) n) (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x (disjointed.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) (MeasureTheory.spanningSets.{u1} Œ± m0 Œº _inst_3) n))
Case conversion may be inaccurate. Consider using '#align measure_theory.spanning_sets_index_eq_iff MeasureTheory.spanningSetsIndex_eq_iff‚Çì'. -/
theorem spanningSetsIndex_eq_iff (Œº : Measure Œ±) [SigmaFinite Œº] {x : Œ±} {n : ‚Ñï} :
    spanningSetsIndex Œº x = n ‚Üî x ‚àà disjointed (spanningSets Œº) n := by
  convert Set.ext_iff.1 (preimage_spanning_sets_index_singleton Œº n) x
#align measure_theory.spanning_sets_index_eq_iff MeasureTheory.spanningSetsIndex_eq_iff

/- warning: measure_theory.mem_disjointed_spanning_sets_index -> MeasureTheory.mem_disjointed_spanningSetsIndex is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] (x : Œ±), Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x (disjointed.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) (MeasureTheory.spanningSets.{u1} Œ± m0 Œº _inst_3) (MeasureTheory.spanningSetsIndex.{u1} Œ± m0 Œº _inst_3 x))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] (x : Œ±), Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x (disjointed.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) (MeasureTheory.spanningSets.{u1} Œ± m0 Œº _inst_3) (MeasureTheory.spanningSetsIndex.{u1} Œ± m0 Œº _inst_3 x))
Case conversion may be inaccurate. Consider using '#align measure_theory.mem_disjointed_spanning_sets_index MeasureTheory.mem_disjointed_spanningSetsIndex‚Çì'. -/
theorem mem_disjointed_spanningSetsIndex (Œº : Measure Œ±) [SigmaFinite Œº] (x : Œ±) :
    x ‚àà disjointed (spanningSets Œº) (spanningSetsIndex Œº x) :=
  (spanningSetsIndex_eq_iff Œº).1 rfl
#align measure_theory.mem_disjointed_spanning_sets_index MeasureTheory.mem_disjointed_spanningSetsIndex

#print MeasureTheory.mem_spanningSetsIndex /-
theorem mem_spanningSetsIndex (Œº : Measure Œ±) [SigmaFinite Œº] (x : Œ±) :
    x ‚àà spanningSets Œº (spanningSetsIndex Œº x) :=
  disjointed_subset _ _ (mem_disjointed_spanningSetsIndex Œº x)
#align measure_theory.mem_spanning_sets_index MeasureTheory.mem_spanningSetsIndex
-/

#print MeasureTheory.mem_spanningSets_of_index_le /-
theorem mem_spanningSets_of_index_le (Œº : Measure Œ±) [SigmaFinite Œº] (x : Œ±) {n : ‚Ñï}
    (hn : spanningSetsIndex Œº x ‚â§ n) : x ‚àà spanningSets Œº n :=
  monotone_spanningSets Œº hn (mem_spanningSetsIndex Œº x)
#align measure_theory.mem_spanning_sets_of_index_le MeasureTheory.mem_spanningSets_of_index_le
-/

#print MeasureTheory.eventually_mem_spanningSets /-
theorem eventually_mem_spanningSets (Œº : Measure Œ±) [SigmaFinite Œº] (x : Œ±) :
    ‚àÄ·∂† n in atTop, x ‚àà spanningSets Œº n :=
  eventually_atTop.2 ‚ü®spanningSetsIndex Œº x, fun b => mem_spanningSets_of_index_le Œº x‚ü©
#align measure_theory.eventually_mem_spanning_sets MeasureTheory.eventually_mem_spanningSets
-/

omit m0

namespace Measure

/- warning: measure_theory.measure.supr_restrict_spanning_sets -> MeasureTheory.Measure.sup·µ¢_restrict_spanningSets is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº], (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (sup·µ¢.{0, 1} ENNReal (ConditionallyCompleteLattice.toHasSup.{0} ENNReal (CompleteLattice.toConditionallyCompleteLattice.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))) Nat (fun (i : Nat) => coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (MeasureTheory.spanningSets.{u1} Œ± m0 Œº _inst_3 i)) s)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº], (MeasurableSet.{u1} Œ± m0 s) -> (Eq.{1} ENNReal (sup·µ¢.{0, 1} ENNReal (ConditionallyCompleteLattice.toSupSet.{0} ENNReal (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{0} ENNReal (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{0} ENNReal (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) Nat (fun (i : Nat) => MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (MeasureTheory.spanningSets.{u1} Œ± m0 Œº _inst_3 i))) s)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.supr_restrict_spanning_sets MeasureTheory.Measure.sup·µ¢_restrict_spanningSets‚Çì'. -/
theorem sup·µ¢_restrict_spanningSets [SigmaFinite Œº] (hs : MeasurableSet s) :
    (‚®Ü i, Œº.restrict (spanningSets Œº i) s) = Œº s :=
  calc
    (‚®Ü i, Œº.restrict (spanningSets Œº i) s) = Œº.restrict (‚ãÉ i, spanningSets Œº i) s :=
      (restrict_union·µ¢_apply_eq_sup·µ¢ (directed_of_sup (monotone_spanningSets Œº)) hs).symm
    _ = Œº s := by rw [Union_spanning_sets, restrict_univ]
    
#align measure_theory.measure.supr_restrict_spanning_sets MeasureTheory.Measure.sup·µ¢_restrict_spanningSets

/- warning: measure_theory.measure.exists_subset_measure_lt_top -> MeasureTheory.Measure.exists_subset_measure_lt_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] {r : ENNReal}, (MeasurableSet.{u1} Œ± m0 s) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) r (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s)) -> (Exists.{succ u1} (Set.{u1} Œ±) (fun (t : Set.{u1} Œ±) => And (MeasurableSet.{u1} Œ± m0 t) (And (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) t s) (And (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) r (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº t)) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº t) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] {r : ENNReal}, (MeasurableSet.{u1} Œ± m0 s) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) r (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s)) -> (Exists.{succ u1} (Set.{u1} Œ±) (fun (t : Set.{u1} Œ±) => And (MeasurableSet.{u1} Œ± m0 t) (And (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) t s) (And (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) r (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) t)) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) t) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.exists_subset_measure_lt_top MeasureTheory.Measure.exists_subset_measure_lt_top‚Çì'. -/
/-- In a œÉ-finite space, any measurable set of measure `> r` contains a measurable subset of
finite measure `> r`. -/
theorem exists_subset_measure_lt_top [SigmaFinite Œº] {r : ‚Ñù‚â•0‚àû} (hs : MeasurableSet s)
    (h's : r < Œº s) : ‚àÉ t, MeasurableSet t ‚àß t ‚äÜ s ‚àß r < Œº t ‚àß Œº t < ‚àû :=
  by
  rw [‚Üê supr_restrict_spanning_sets hs,
    @lt_sup·µ¢_iff _ _ _ r fun i : ‚Ñï => Œº.restrict (spanning_sets Œº i) s] at h's
  rcases h's with ‚ü®n, hn‚ü©
  simp only [restrict_apply hs] at hn
  refine'
    ‚ü®s ‚à© spanning_sets Œº n, hs.inter (measurable_spanning_sets _ _), inter_subset_left _ _, hn, _‚ü©
  exact (measure_mono (inter_subset_right _ _)).trans_lt (measure_spanning_sets_lt_top _ _)
#align measure_theory.measure.exists_subset_measure_lt_top MeasureTheory.Measure.exists_subset_measure_lt_top

/- warning: measure_theory.measure.forall_measure_inter_spanning_sets_eq_zero -> MeasureTheory.Measure.forall_measure_inter_spanningSets_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_3 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_3} [_inst_4 : MeasureTheory.SigmaFinite.{u1} Œ± _inst_3 Œº] (s : Set.{u1} Œ±), Iff (forall (n : Nat), Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s (MeasureTheory.spanningSets.{u1} Œ± _inst_3 Œº _inst_4 n))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) Œº s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_3 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_3} [_inst_4 : MeasureTheory.SigmaFinite.{u1} Œ± _inst_3 Œº] (s : Set.{u1} Œ±), Iff (forall (n : Nat), Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s (MeasureTheory.spanningSets.{u1} Œ± _inst_3 Œº _inst_4 n))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 Œº) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.forall_measure_inter_spanning_sets_eq_zero MeasureTheory.Measure.forall_measure_inter_spanningSets_eq_zero‚Çì'. -/
/-- A set in a œÉ-finite space has zero measure if and only if its intersection with
all members of the countable family of finite measure spanning sets has zero measure. -/
theorem forall_measure_inter_spanningSets_eq_zero [MeasurableSpace Œ±] {Œº : Measure Œ±}
    [SigmaFinite Œº] (s : Set Œ±) : (‚àÄ n, Œº (s ‚à© spanningSets Œº n) = 0) ‚Üî Œº s = 0 :=
  by
  nth_rw 1 [show s = ‚ãÉ n, s ‚à© spanning_sets Œº n by
      rw [‚Üê inter_Union, Union_spanning_sets, inter_univ]]
  rw [measure_Union_null_iff]
#align measure_theory.measure.forall_measure_inter_spanning_sets_eq_zero MeasureTheory.Measure.forall_measure_inter_spanningSets_eq_zero

/- warning: measure_theory.measure.exists_measure_inter_spanning_sets_pos -> MeasureTheory.Measure.exists_measure_inter_spanningSets_pos is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_3 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_3} [_inst_4 : MeasureTheory.SigmaFinite.{u1} Œ± _inst_3 Œº] (s : Set.{u1} Œ±), Iff (Exists.{1} Nat (fun (n : Nat) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s (MeasureTheory.spanningSets.{u1} Œ± _inst_3 Œº _inst_4 n))))) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) Œº s))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_3 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_3} [_inst_4 : MeasureTheory.SigmaFinite.{u1} Œ± _inst_3 Œº] (s : Set.{u1} Œ±), Iff (Exists.{1} Nat (fun (n : Nat) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s (MeasureTheory.spanningSets.{u1} Œ± _inst_3 Œº _inst_4 n))))) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 Œº) s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.exists_measure_inter_spanning_sets_pos MeasureTheory.Measure.exists_measure_inter_spanningSets_pos‚Çì'. -/
/-- A set in a œÉ-finite space has positive measure if and only if its intersection with
some member of the countable family of finite measure spanning sets has positive measure. -/
theorem exists_measure_inter_spanningSets_pos [MeasurableSpace Œ±] {Œº : Measure Œ±} [SigmaFinite Œº]
    (s : Set Œ±) : (‚àÉ n, 0 < Œº (s ‚à© spanningSets Œº n)) ‚Üî 0 < Œº s :=
  by
  rw [‚Üê not_iff_not]
  simp only [not_exists, not_lt, nonpos_iff_eq_zero]
  exact forall_measure_inter_spanning_sets_eq_zero s
#align measure_theory.measure.exists_measure_inter_spanning_sets_pos MeasureTheory.Measure.exists_measure_inter_spanningSets_pos

/- warning: measure_theory.measure.finite_const_le_meas_of_disjoint_Union -> MeasureTheory.Measure.finite_const_le_meas_of_disjoint_union·µ¢ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± _inst_3) {Œµ : ENNReal}, (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) Œµ) -> (forall {As : Œπ -> (Set.{u1} Œ±)}, (forall (i : Œπ), MeasurableSet.{u1} Œ± _inst_3 (As i)) -> (Pairwise.{u2} Œπ (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)))) As)) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => As i))) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Set.Finite.{u2} Œπ (setOf.{u2} Œπ (fun (i : Œπ) => LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) Œµ (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) Œº (As i))))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± _inst_3) {Œµ : ENNReal}, (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) Œµ) -> (forall {As : Œπ -> (Set.{u1} Œ±)}, (forall (i : Œπ), MeasurableSet.{u1} Œ± _inst_3 (As i)) -> (Pairwise.{u2} Œπ (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))))) As)) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 Œº) (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => As i))) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Set.Finite.{u2} Œπ (setOf.{u2} Œπ (fun (i : Œπ) => LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) Œµ (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 Œº) (As i))))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.finite_const_le_meas_of_disjoint_Union MeasureTheory.Measure.finite_const_le_meas_of_disjoint_union·µ¢‚Çì'. -/
/-- If the union of disjoint measurable sets has finite measure, then there are only
finitely many members of the union whose measure exceeds any given positive number. -/
theorem finite_const_le_meas_of_disjoint_union·µ¢ {Œπ : Type _} [MeasurableSpace Œ±] (Œº : Measure Œ±)
    {Œµ : ‚Ñù‚â•0‚àû} (Œµ_pos : 0 < Œµ) {As : Œπ ‚Üí Set Œ±} (As_mble : ‚àÄ i : Œπ, MeasurableSet (As i))
    (As_disj : Pairwise (Disjoint on As)) (Union_As_finite : Œº (‚ãÉ i, As i) ‚â† ‚àû) :
    Set.Finite { i : Œπ | Œµ ‚â§ Œº (As i) } := by
  by_contra con
  have aux :=
    lt_of_le_of_lt (tsum_meas_le_meas_Union_of_disjoint Œº As_mble As_disj)
      (lt_top_iff_ne_top.mpr Union_As_finite)
  exact Con (ENNReal.finite_const_le_of_tsum_ne_top aux.ne Œµ_pos.ne.symm)
#align measure_theory.measure.finite_const_le_meas_of_disjoint_Union MeasureTheory.Measure.finite_const_le_meas_of_disjoint_union·µ¢

/- warning: measure_theory.measure.countable_meas_pos_of_disjoint_of_meas_Union_ne_top -> MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_union·µ¢_ne_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± _inst_3) {As : Œπ -> (Set.{u1} Œ±)}, (forall (i : Œπ), MeasurableSet.{u1} Œ± _inst_3 (As i)) -> (Pairwise.{u2} Œπ (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)))) As)) -> (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) Œº (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => As i))) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Set.Countable.{u2} Œπ (setOf.{u2} Œπ (fun (i : Œπ) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) Œº (As i)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± _inst_3) {As : Œπ -> (Set.{u1} Œ±)}, (forall (i : Œπ), MeasurableSet.{u1} Œ± _inst_3 (As i)) -> (Pairwise.{u2} Œπ (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))))) As)) -> (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 Œº) (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => As i))) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Set.Countable.{u2} Œπ (setOf.{u2} Œπ (fun (i : Œπ) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 Œº) (As i)))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.countable_meas_pos_of_disjoint_of_meas_Union_ne_top MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_union·µ¢_ne_top‚Çì'. -/
/-- If the union of disjoint measurable sets has finite measure, then there are only
countably many members of the union whose measure is positive. -/
theorem countable_meas_pos_of_disjoint_of_meas_union·µ¢_ne_top {Œπ : Type _} [MeasurableSpace Œ±]
    (Œº : Measure Œ±) {As : Œπ ‚Üí Set Œ±} (As_mble : ‚àÄ i : Œπ, MeasurableSet (As i))
    (As_disj : Pairwise (Disjoint on As)) (Union_As_finite : Œº (‚ãÉ i, As i) ‚â† ‚àû) :
    Set.Countable { i : Œπ | 0 < Œº (As i) } :=
  by
  set posmeas := { i : Œπ | 0 < Œº (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ‚Ñù‚â•0‚àû) < 1) with
    ‚ü®as, as_decr, as_mem, as_lim‚ü©
  set fairmeas := fun n : ‚Ñï => { i : Œπ | as n ‚â§ Œº (As i) } with fairmeas_def
  have countable_union : posmeas = ‚ãÉ n, fairmeas n :=
    by
    have fairmeas_eq : ‚àÄ n, fairmeas n = (fun i => Œº (As i)) ‚Åª¬π' Ici (as n) := fun n => by
      simpa only [fairmeas_def]
    simpa only [fairmeas_eq, posmeas_def, ‚Üê preimage_Union,
      union·µ¢_Ici_eq_Ioi_of_lt_of_tendsto (0 : ‚Ñù‚â•0‚àû) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine' countable_Union fun n => finite.countable _
  refine' finite_const_le_meas_of_disjoint_Union Œº (as_mem n).1 As_mble As_disj Union_As_finite
#align measure_theory.measure.countable_meas_pos_of_disjoint_of_meas_Union_ne_top MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_union·µ¢_ne_top

/- warning: measure_theory.measure.countable_meas_pos_of_disjoint_Union -> MeasureTheory.Measure.countable_meas_pos_of_disjoint_union·µ¢ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_3} [_inst_4 : MeasureTheory.SigmaFinite.{u1} Œ± _inst_3 Œº] {As : Œπ -> (Set.{u1} Œ±)}, (forall (i : Œπ), MeasurableSet.{u1} Œ± _inst_3 (As i)) -> (Pairwise.{u2} Œπ (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)))) As)) -> (Set.Countable.{u2} Œπ (setOf.{u2} Œπ (fun (i : Œπ) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) Œº (As i)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_3} [_inst_4 : MeasureTheory.SigmaFinite.{u1} Œ± _inst_3 Œº] {As : Œπ -> (Set.{u1} Œ±)}, (forall (i : Œπ), MeasurableSet.{u1} Œ± _inst_3 (As i)) -> (Pairwise.{u2} Œπ (Function.onFun.{succ u2, succ u1, 1} Œπ (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))))) As)) -> (Set.Countable.{u2} Œπ (setOf.{u2} Œπ (fun (i : Œπ) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_3 Œº) (As i)))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.countable_meas_pos_of_disjoint_Union MeasureTheory.Measure.countable_meas_pos_of_disjoint_union·µ¢‚Çì'. -/
/-- In a œÉ-finite space, among disjoint measurable sets, only countably many can have positive
measure. -/
theorem countable_meas_pos_of_disjoint_union·µ¢ {Œπ : Type _} [MeasurableSpace Œ±] {Œº : Measure Œ±}
    [SigmaFinite Œº] {As : Œπ ‚Üí Set Œ±} (As_mble : ‚àÄ i : Œπ, MeasurableSet (As i))
    (As_disj : Pairwise (Disjoint on As)) : Set.Countable { i : Œπ | 0 < Œº (As i) } :=
  by
  have obs : { i : Œπ | 0 < Œº (As i) } ‚äÜ ‚ãÉ n, { i : Œπ | 0 < Œº (As i ‚à© spanning_sets Œº n) } :=
    by
    intro i i_in_nonzeroes
    by_contra con
    simp only [mem_Union, mem_set_of_eq, not_exists, not_lt, nonpos_iff_eq_zero] at *
    simpa [(forall_measure_inter_spanning_sets_eq_zero _).mp Con] using i_in_nonzeroes
  apply countable.mono obs
  refine' countable_Union fun n => countable_meas_pos_of_disjoint_of_meas_Union_ne_top Œº _ _ _
  ¬∑ exact fun i => MeasurableSet.inter (As_mble i) (measurable_spanning_sets Œº n)
  ¬∑
    exact fun i j i_ne_j b hbi hbj =>
      As_disj i_ne_j (hbi.trans (inter_subset_left _ _)) (hbj.trans (inter_subset_left _ _))
  ¬∑ refine' (lt_of_le_of_lt (measure_mono _) (measure_spanning_sets_lt_top Œº n)).Ne
    exact Union_subset fun i => inter_subset_right _ _
#align measure_theory.measure.countable_meas_pos_of_disjoint_Union MeasureTheory.Measure.countable_meas_pos_of_disjoint_union·µ¢

/- warning: measure_theory.measure.countable_meas_level_set_pos -> MeasureTheory.Measure.countable_meas_level_set_pos is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_3 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_3} [_inst_4 : MeasureTheory.SigmaFinite.{u1} Œ± _inst_3 Œº] [_inst_5 : MeasurableSpace.{u2} Œ≤] [_inst_6 : MeasurableSingletonClass.{u2} Œ≤ _inst_5] {g : Œ± -> Œ≤}, (Measurable.{u1, u2} Œ± Œ≤ _inst_3 _inst_5 g) -> (Set.Countable.{u2} Œ≤ (setOf.{u2} Œ≤ (fun (t : Œ≤) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_3) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_3) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_3) Œº (setOf.{u1} Œ± (fun (a : Œ±) => Eq.{succ u2} Œ≤ (g a) t))))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_3 : MeasurableSpace.{u2} Œ±] {Œº : MeasureTheory.Measure.{u2} Œ± _inst_3} [_inst_4 : MeasureTheory.SigmaFinite.{u2} Œ± _inst_3 Œº] [_inst_5 : MeasurableSpace.{u1} Œ≤] [_inst_6 : MeasurableSingletonClass.{u1} Œ≤ _inst_5] {g : Œ± -> Œ≤}, (Measurable.{u2, u1} Œ± Œ≤ _inst_3 _inst_5 g) -> (Set.Countable.{u1} Œ≤ (setOf.{u1} Œ≤ (fun (t : Œ≤) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± _inst_3 Œº) (setOf.{u2} Œ± (fun (a : Œ±) => Eq.{succ u1} Œ≤ (g a) t))))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.countable_meas_level_set_pos MeasureTheory.Measure.countable_meas_level_set_pos‚Çì'. -/
theorem countable_meas_level_set_pos {Œ± Œ≤ : Type _} [MeasurableSpace Œ±] {Œº : Measure Œ±}
    [SigmaFinite Œº] [MeasurableSpace Œ≤] [MeasurableSingletonClass Œ≤] {g : Œ± ‚Üí Œ≤}
    (g_mble : Measurable g) : Set.Countable { t : Œ≤ | 0 < Œº { a : Œ± | g a = t } } :=
  haveI level_sets_disjoint : Pairwise (Disjoint on fun t : Œ≤ => { a : Œ± | g a = t }) :=
    fun s t hst => Disjoint.preimage g (disjoint_singleton.mpr hst)
  measure.countable_meas_pos_of_disjoint_Union
    (fun b => g_mble (‚ÄπMeasurableSingletonClass Œ≤‚Ä∫.measurableSet_singleton b)) level_sets_disjoint
#align measure_theory.measure.countable_meas_level_set_pos MeasureTheory.Measure.countable_meas_level_set_pos

/- warning: measure_theory.measure.measure_to_measurable_inter_of_cover -> MeasureTheory.Measure.measure_toMeasurable_inter_of_cover is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (forall {t : Set.{u1} Œ±} {v : Nat -> (Set.{u1} Œ±)}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) t (Set.union·µ¢.{u1, 1} Œ± Nat (fun (n : Nat) => v n))) -> (forall (n : Nat), Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) t (v n))) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) (MeasureTheory.toMeasurable.{u1} Œ± m0 Œº t) s)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) t s))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (forall {t : Set.{u1} Œ±} {v : Nat -> (Set.{u1} Œ±)}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) t (Set.union·µ¢.{u1, 1} Œ± Nat (fun (n : Nat) => v n))) -> (forall (n : Nat), Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) t (v n))) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) (MeasureTheory.toMeasurable.{u1} Œ± m0 Œº t) s)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) t s))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.measure_to_measurable_inter_of_cover MeasureTheory.Measure.measure_toMeasurable_inter_of_cover‚Çì'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t' ¬´expr ‚äá ¬ª t) -/
/-- If a set `t` is covered by a countable family of finite measure sets, then its measurable
superset `to_measurable Œº t` (which has the same measure as `t`) satisfies,
for any measurable set `s`, the equality `Œº (to_measurable Œº t ‚à© s) = Œº (t ‚à© s)`. -/
theorem measure_toMeasurable_inter_of_cover {s : Set Œ±} (hs : MeasurableSet s) {t : Set Œ±}
    {v : ‚Ñï ‚Üí Set Œ±} (hv : t ‚äÜ ‚ãÉ n, v n) (h'v : ‚àÄ n, Œº (t ‚à© v n) ‚â† ‚àû) :
    Œº (toMeasurable Œº t ‚à© s) = Œº (t ‚à© s) :=
  by
  -- we show that there is a measurable superset of `t` satisfying the conclusion for any
  -- measurable set `s`. It is built on each member of a spanning family using `to_measurable`
  -- (which is well behaved for finite measure sets thanks to `measure_to_measurable_inter`), and
  -- the desired property passes to the union.
  have A :
    ‚àÉ (t' : _)(_ : t' ‚äá t), MeasurableSet t' ‚àß ‚àÄ u, MeasurableSet u ‚Üí Œº (t' ‚à© u) = Œº (t ‚à© u) :=
    by
    let w n := to_measurable Œº (t ‚à© v n)
    have hw : ‚àÄ n, Œº (w n) < ‚àû := by
      intro n
      simp_rw [w, measure_to_measurable]
      exact (h'v n).lt_top
    set t' := ‚ãÉ n, to_measurable Œº (t ‚à© disjointed w n) with ht'
    have tt' : t ‚äÜ t' :=
      calc
        t ‚äÜ ‚ãÉ n, t ‚à© disjointed w n :=
          by
          rw [‚Üê inter_Union, union·µ¢_disjointed, inter_Union]
          intro x hx
          rcases mem_Union.1 (hv hx) with ‚ü®n, hn‚ü©
          refine' mem_Union.2 ‚ü®n, _‚ü©
          have : x ‚àà t ‚à© v n := ‚ü®hx, hn‚ü©
          exact ‚ü®hx, subset_to_measurable Œº _ this‚ü©
        _ ‚äÜ ‚ãÉ n, to_measurable Œº (t ‚à© disjointed w n) :=
          Union_mono fun n => subset_to_measurable _ _
        
    refine' ‚ü®t', tt', MeasurableSet.union·µ¢ fun n => measurable_set_to_measurable Œº _, fun u hu => _‚ü©
    apply le_antisymm _ (measure_mono (inter_subset_inter tt' subset.rfl))
    calc
      Œº (t' ‚à© u) ‚â§ ‚àë' n, Œº (to_measurable Œº (t ‚à© disjointed w n) ‚à© u) :=
        by
        rw [ht', Union_inter]
        exact measure_Union_le _
      _ = ‚àë' n, Œº (t ‚à© disjointed w n ‚à© u) := by
        congr 1
        ext1 n
        apply measure_to_measurable_inter hu
        apply ne_of_lt
        calc
          Œº (t ‚à© disjointed w n) ‚â§ Œº (t ‚à© w n) :=
            measure_mono (inter_subset_inter_right _ (disjointed_le w n))
          _ ‚â§ Œº (w n) := (measure_mono (inter_subset_right _ _))
          _ < ‚àû := hw n
          
      _ = ‚àë' n, Œº.restrict (t ‚à© u) (disjointed w n) :=
        by
        congr 1
        ext1 n
        rw [restrict_apply, inter_comm t _, inter_assoc]
        apply MeasurableSet.disjointed fun n => _
        exact measurable_set_to_measurable _ _
      _ = Œº.restrict (t ‚à© u) (‚ãÉ n, disjointed w n) :=
        by
        rw [measure_Union]
        ¬∑ exact disjoint_disjointed _
        ¬∑ intro i
          apply MeasurableSet.disjointed fun n => _
          exact measurable_set_to_measurable _ _
      _ ‚â§ Œº.restrict (t ‚à© u) univ := (measure_mono (subset_univ _))
      _ = Œº (t ‚à© u) := by rw [restrict_apply MeasurableSet.univ, univ_inter]
      
  -- thanks to the definition of `to_measurable`, the previous property will also be shared
  -- by `to_measurable Œº t`, which is enough to conclude the proof.
  rw [to_measurable]
  split_ifs with ht
  ¬∑ apply measure_congr
    exact ae_eq_set_inter ht.some_spec.snd.2 (ae_eq_refl _)
  ¬∑ exact A.some_spec.snd.2 s hs
#align measure_theory.measure.measure_to_measurable_inter_of_cover MeasureTheory.Measure.measure_toMeasurable_inter_of_cover

/- warning: measure_theory.measure.restrict_to_measurable_of_cover -> MeasureTheory.Measure.restrict_toMeasurable_of_cover is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {v : Nat -> (Set.{u1} Œ±)}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s (Set.union·µ¢.{u1, 1} Œ± Nat (fun (n : Nat) => v n))) -> (forall (n : Nat), Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) s (v n))) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (MeasureTheory.toMeasurable.{u1} Œ± m0 Œº s)) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {v : Nat -> (Set.{u1} Œ±)}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s (Set.union·µ¢.{u1, 1} Œ± Nat (fun (n : Nat) => v n))) -> (forall (n : Nat), Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) s (v n))) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (MeasureTheory.toMeasurable.{u1} Œ± m0 Œº s)) (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.restrict_to_measurable_of_cover MeasureTheory.Measure.restrict_toMeasurable_of_cover‚Çì'. -/
theorem restrict_toMeasurable_of_cover {s : Set Œ±} {v : ‚Ñï ‚Üí Set Œ±} (hv : s ‚äÜ ‚ãÉ n, v n)
    (h'v : ‚àÄ n, Œº (s ‚à© v n) ‚â† ‚àû) : Œº.restrict (toMeasurable Œº s) = Œº.restrict s :=
  ext fun t ht => by
    simp only [restrict_apply ht, inter_comm t, measure_to_measurable_inter_of_cover ht hv h'v]
#align measure_theory.measure.restrict_to_measurable_of_cover MeasureTheory.Measure.restrict_toMeasurable_of_cover

/- warning: measure_theory.measure.measure_to_measurable_inter_of_sigma_finite -> MeasureTheory.Measure.measure_toMeasurable_inter_of_sigmaFinite is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (forall (t : Set.{u1} Œ±), Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) (MeasureTheory.toMeasurable.{u1} Œ± m0 Œº t) s)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) t s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] {s : Set.{u1} Œ±}, (MeasurableSet.{u1} Œ± m0 s) -> (forall (t : Set.{u1} Œ±), Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) (MeasureTheory.toMeasurable.{u1} Œ± m0 Œº t) s)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) t s)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.measure_to_measurable_inter_of_sigma_finite MeasureTheory.Measure.measure_toMeasurable_inter_of_sigmaFinite‚Çì'. -/
/-- The measurable superset `to_measurable Œº t` of `t` (which has the same measure as `t`)
satisfies, for any measurable set `s`, the equality `Œº (to_measurable Œº t ‚à© s) = Œº (t ‚à© s)`.
This only holds when `Œº` is œÉ-finite. For a version without this assumption (but requiring
that `t` has finite measure), see `measure_to_measurable_inter`. -/
theorem measure_toMeasurable_inter_of_sigmaFinite [SigmaFinite Œº] {s : Set Œ±} (hs : MeasurableSet s)
    (t : Set Œ±) : Œº (toMeasurable Œº t ‚à© s) = Œº (t ‚à© s) :=
  by
  have : t ‚äÜ ‚ãÉ n, spanning_sets Œº n :=
    by
    rw [Union_spanning_sets]
    exact subset_univ _
  apply measure_to_measurable_inter_of_cover hs this fun n => ne_of_lt _
  calc
    Œº (t ‚à© spanning_sets Œº n) ‚â§ Œº (spanning_sets Œº n) := measure_mono (inter_subset_right _ _)
    _ < ‚àû := measure_spanning_sets_lt_top Œº n
    
#align measure_theory.measure.measure_to_measurable_inter_of_sigma_finite MeasureTheory.Measure.measure_toMeasurable_inter_of_sigmaFinite

#print MeasureTheory.Measure.restrict_toMeasurable_of_sigmaFinite /-
@[simp]
theorem restrict_toMeasurable_of_sigmaFinite [SigmaFinite Œº] (s : Set Œ±) :
    Œº.restrict (toMeasurable Œº s) = Œº.restrict s :=
  ext fun t ht => by
    simp only [restrict_apply ht, inter_comm t, measure_to_measurable_inter_of_sigma_finite ht]
#align measure_theory.measure.restrict_to_measurable_of_sigma_finite MeasureTheory.Measure.restrict_toMeasurable_of_sigmaFinite
-/

namespace FiniteSpanningSetsIn

variable {C D : Set (Set Œ±)}

/- warning: measure_theory.measure.finite_spanning_sets_in.mono' -> MeasureTheory.Measure.FiniteSpanningSetsIn.mono' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {C : Set.{u1} (Set.{u1} Œ±)} {D : Set.{u1} (Set.{u1} Œ±)}, (MeasureTheory.Measure.FiniteSpanningSetsIn.{u1} Œ± m0 Œº C) -> (HasSubset.Subset.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasSubset.{u1} (Set.{u1} Œ±)) (Inter.inter.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.hasInter.{u1} (Set.{u1} Œ±)) C (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))))) D) -> (MeasureTheory.Measure.FiniteSpanningSetsIn.{u1} Œ± m0 Œº D)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {C : Set.{u1} (Set.{u1} Œ±)} {D : Set.{u1} (Set.{u1} Œ±)}, (MeasureTheory.Measure.FiniteSpanningSetsIn.{u1} Œ± m0 Œº C) -> (HasSubset.Subset.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instHasSubsetSet.{u1} (Set.{u1} Œ±)) (Inter.inter.{u1} (Set.{u1} (Set.{u1} Œ±)) (Set.instInterSet.{u1} (Set.{u1} Œ±)) C (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))))) D) -> (MeasureTheory.Measure.FiniteSpanningSetsIn.{u1} Œ± m0 Œº D)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.finite_spanning_sets_in.mono' MeasureTheory.Measure.FiniteSpanningSetsIn.mono'‚Çì'. -/
/-- If `Œº` has finite spanning sets in `C` and `C ‚à© {s | Œº s < ‚àû} ‚äÜ D` then `Œº` has finite spanning
sets in `D`. -/
protected def mono' (h : Œº.FiniteSpanningSetsIn C) (hC : C ‚à© { s | Œº s < ‚àû } ‚äÜ D) :
    Œº.FiniteSpanningSetsIn D :=
  ‚ü®h.Set, fun i => hC ‚ü®h.set_mem i, h.Finite i‚ü©, h.Finite, h.spanning‚ü©
#align measure_theory.measure.finite_spanning_sets_in.mono' MeasureTheory.Measure.FiniteSpanningSetsIn.mono'

#print MeasureTheory.Measure.FiniteSpanningSetsIn.mono /-
/-- If `Œº` has finite spanning sets in `C` and `C ‚äÜ D` then `Œº` has finite spanning sets in `D`. -/
protected def mono (h : Œº.FiniteSpanningSetsIn C) (hC : C ‚äÜ D) : Œº.FiniteSpanningSetsIn D :=
  h.mono' fun s hs => hC hs.1
#align measure_theory.measure.finite_spanning_sets_in.mono MeasureTheory.Measure.FiniteSpanningSetsIn.mono
-/

#print MeasureTheory.Measure.FiniteSpanningSetsIn.sigmaFinite /-
/-- If `Œº` has finite spanning sets in the collection of measurable sets `C`, then `Œº` is œÉ-finite.
-/
protected theorem sigmaFinite (h : Œº.FiniteSpanningSetsIn C) : SigmaFinite Œº :=
  ‚ü®‚ü®h.mono <| subset_univ C‚ü©‚ü©
#align measure_theory.measure.finite_spanning_sets_in.sigma_finite MeasureTheory.Measure.FiniteSpanningSetsIn.sigmaFinite
-/

#print MeasureTheory.Measure.FiniteSpanningSetsIn.ext /-
/-- An extensionality for measures. It is `ext_of_generate_from_of_Union` formulated in terms of
`finite_spanning_sets_in`. -/
protected theorem ext {ŒΩ : Measure Œ±} {C : Set (Set Œ±)} (hA : ‚Äπ_‚Ä∫ = generateFrom C)
    (hC : IsPiSystem C) (h : Œº.FiniteSpanningSetsIn C) (h_eq : ‚àÄ s ‚àà C, Œº s = ŒΩ s) : Œº = ŒΩ :=
  ext_of_generateFrom_of_union·µ¢ C _ hA hC h.spanning h.set_mem (fun i => (h.Finite i).Ne) h_eq
#align measure_theory.measure.finite_spanning_sets_in.ext MeasureTheory.Measure.FiniteSpanningSetsIn.ext
-/

#print MeasureTheory.Measure.FiniteSpanningSetsIn.isCountablySpanning /-
protected theorem isCountablySpanning (h : Œº.FiniteSpanningSetsIn C) : IsCountablySpanning C :=
  ‚ü®h.Set, h.set_mem, h.spanning‚ü©
#align measure_theory.measure.finite_spanning_sets_in.is_countably_spanning MeasureTheory.Measure.FiniteSpanningSetsIn.isCountablySpanning
-/

end FiniteSpanningSetsIn

/- warning: measure_theory.measure.sigma_finite_of_countable -> MeasureTheory.Measure.sigmaFinite_of_countable is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {S : Set.{u1} (Set.{u1} Œ±)}, (Set.Countable.{u1} (Set.{u1} Œ±) S) -> (forall (s : Set.{u1} Œ±), (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.hasMem.{u1} (Set.{u1} Œ±)) s S) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) -> (Eq.{succ u1} (Set.{u1} Œ±) (Set.union‚Çõ.{u1} Œ± S) (Set.univ.{u1} Œ±)) -> (MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {S : Set.{u1} (Set.{u1} Œ±)}, (Set.Countable.{u1} (Set.{u1} Œ±) S) -> (forall (s : Set.{u1} Œ±), (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Set.{u1} (Set.{u1} Œ±)) (Set.instMembershipSet.{u1} (Set.{u1} Œ±)) s S) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) -> (Eq.{succ u1} (Set.{u1} Œ±) (Set.union‚Çõ.{u1} Œ± S) (Set.univ.{u1} Œ±)) -> (MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.sigma_finite_of_countable MeasureTheory.Measure.sigmaFinite_of_countable‚Çì'. -/
theorem sigmaFinite_of_countable {S : Set (Set Œ±)} (hc : S.Countable) (hŒº : ‚àÄ s ‚àà S, Œº s < ‚àû)
    (hU : ‚ãÉ‚ÇÄ S = univ) : SigmaFinite Œº :=
  by
  obtain ‚ü®s, hŒº, hs‚ü© : ‚àÉ s : ‚Ñï ‚Üí Set Œ±, (‚àÄ n, Œº (s n) < ‚àû) ‚àß (‚ãÉ n, s n) = univ
  exact (@exists_seq_cover_iff_countable _ (fun x => Œº x < ‚ä§) ‚ü®‚àÖ, by simp‚ü©).2 ‚ü®S, hc, hŒº, hU‚ü©
  exact ‚ü®‚ü®‚ü®fun n => s n, fun n => trivial, hŒº, hs‚ü©‚ü©‚ü©
#align measure_theory.measure.sigma_finite_of_countable MeasureTheory.Measure.sigmaFinite_of_countable

#print MeasureTheory.Measure.FiniteSpanningSetsIn.ofLE /-
/-- Given measures `Œº`, `ŒΩ` where `ŒΩ ‚â§ Œº`, `finite_spanning_sets_in.of_le` provides the induced
`finite_spanning_set` with respect to `ŒΩ` from a `finite_spanning_set` with respect to `Œº`. -/
def FiniteSpanningSetsIn.ofLE (h : ŒΩ ‚â§ Œº) {C : Set (Set Œ±)} (S : Œº.FiniteSpanningSetsIn C) :
    ŒΩ.FiniteSpanningSetsIn C where
  Set := S.Set
  set_mem := S.set_mem
  Finite n := lt_of_le_of_lt (le_iff'.1 h _) (S.Finite n)
  spanning := S.spanning
#align measure_theory.measure.finite_spanning_sets_in.of_le MeasureTheory.Measure.FiniteSpanningSetsIn.ofLE
-/

#print MeasureTheory.Measure.sigmaFinite_of_le /-
theorem sigmaFinite_of_le (Œº : Measure Œ±) [hs : SigmaFinite Œº] (h : ŒΩ ‚â§ Œº) : SigmaFinite ŒΩ :=
  ‚ü®hs.out.map <| FiniteSpanningSetsIn.ofLE h‚ü©
#align measure_theory.measure.sigma_finite_of_le MeasureTheory.Measure.sigmaFinite_of_le
-/

end Measure

#print MeasureTheory.FiniteMeasure.toSigmaFinite /-
/-- Every finite measure is œÉ-finite. -/
instance (priority := 100) FiniteMeasure.toSigmaFinite {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±)
    [FiniteMeasure Œº] : SigmaFinite Œº :=
  ‚ü®‚ü®‚ü®fun _ => univ, fun _ => trivial, fun _ => measure_lt_top Œº _, union·µ¢_const _‚ü©‚ü©‚ü©
#align measure_theory.is_finite_measure.to_sigma_finite MeasureTheory.FiniteMeasure.toSigmaFinite
-/

/- warning: measure_theory.sigma_finite_bot_iff -> MeasureTheory.sigmaFinite_bot_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} (Œº : MeasureTheory.Measure.{u1} Œ± (Bot.bot.{u1} (MeasurableSpace.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.completeLattice.{u1} Œ±)))), Iff (MeasureTheory.SigmaFinite.{u1} Œ± (Bot.bot.{u1} (MeasurableSpace.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.completeLattice.{u1} Œ±))) Œº) (MeasureTheory.FiniteMeasure.{u1} Œ± (Bot.bot.{u1} (MeasurableSpace.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.completeLattice.{u1} Œ±))) Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} (Œº : MeasureTheory.Measure.{u1} Œ± (Bot.bot.{u1} (MeasurableSpace.{u1} Œ±) (CompleteLattice.toBot.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instCompleteLatticeMeasurableSpace.{u1} Œ±)))), Iff (MeasureTheory.SigmaFinite.{u1} Œ± (Bot.bot.{u1} (MeasurableSpace.{u1} Œ±) (CompleteLattice.toBot.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instCompleteLatticeMeasurableSpace.{u1} Œ±))) Œº) (MeasureTheory.FiniteMeasure.{u1} Œ± (Bot.bot.{u1} (MeasurableSpace.{u1} Œ±) (CompleteLattice.toBot.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instCompleteLatticeMeasurableSpace.{u1} Œ±))) Œº)
Case conversion may be inaccurate. Consider using '#align measure_theory.sigma_finite_bot_iff MeasureTheory.sigmaFinite_bot_iff‚Çì'. -/
theorem sigmaFinite_bot_iff (Œº : @Measure Œ± ‚ä•) : SigmaFinite Œº ‚Üî FiniteMeasure Œº :=
  by
  refine'
    ‚ü®fun h => ‚ü®_‚ü©, fun h => by
      haveI := h
      infer_instance‚ü©
  haveI : sigma_finite Œº := h
  let s := spanning_sets Œº
  have hs_univ : (‚ãÉ i, s i) = Set.univ := Union_spanning_sets Œº
  have hs_meas : ‚àÄ i, measurable_set[‚ä•] (s i) := measurable_spanning_sets Œº
  simp_rw [MeasurableSpace.measurableSet_bot_iff] at hs_meas
  by_cases h_univ_empty : Set.univ = ‚àÖ
  ¬∑ rw [h_univ_empty, measure_empty]
    exact ennreal.zero_ne_top.lt_top
  obtain ‚ü®i, hsi‚ü© : ‚àÉ i, s i = Set.univ :=
    by
    by_contra h_not_univ
    push_neg  at h_not_univ
    have h_empty : ‚àÄ i, s i = ‚àÖ := by simpa [h_not_univ] using hs_meas
    simp [h_empty] at hs_univ
    exact h_univ_empty hs_univ.symm
  rw [‚Üê hsi]
  exact measure_spanning_sets_lt_top Œº i
#align measure_theory.sigma_finite_bot_iff MeasureTheory.sigmaFinite_bot_iff

include m0

#print MeasureTheory.Restrict.sigmaFinite /-
instance Restrict.sigmaFinite (Œº : Measure Œ±) [SigmaFinite Œº] (s : Set Œ±) :
    SigmaFinite (Œº.restrict s) :=
  by
  refine' ‚ü®‚ü®‚ü®spanning_sets Œº, fun _ => trivial, fun i => _, Union_spanning_sets Œº‚ü©‚ü©‚ü©
  rw [restrict_apply (measurable_spanning_sets Œº i)]
  exact (measure_mono <| inter_subset_left _ _).trans_lt (measure_spanning_sets_lt_top Œº i)
#align measure_theory.restrict.sigma_finite MeasureTheory.Restrict.sigmaFinite
-/

#print MeasureTheory.sum.sigmaFinite /-
instance sum.sigmaFinite {Œπ} [Finite Œπ] (Œº : Œπ ‚Üí Measure Œ±) [‚àÄ i, SigmaFinite (Œº i)] :
    SigmaFinite (Sum Œº) := by
  cases nonempty_fintype Œπ
  have : ‚àÄ n, MeasurableSet (‚ãÇ i : Œπ, spanning_sets (Œº i) n) := fun n =>
    MeasurableSet.inter·µ¢ fun i => measurable_spanning_sets (Œº i) n
  refine' ‚ü®‚ü®‚ü®fun n => ‚ãÇ i, spanning_sets (Œº i) n, fun _ => trivial, fun n => _, _‚ü©‚ü©‚ü©
  ¬∑ rw [sum_apply _ (this n), tsum_fintype, ENNReal.sum_lt_top_iff]
    rintro i -
    exact (measure_mono <| Inter_subset _ i).trans_lt (measure_spanning_sets_lt_top (Œº i) n)
  ¬∑ rw [Union_Inter_of_monotone]
    simp_rw [Union_spanning_sets, Inter_univ]
    exact fun i => monotone_spanning_sets (Œº i)
#align measure_theory.sum.sigma_finite MeasureTheory.sum.sigmaFinite
-/

#print MeasureTheory.Add.sigmaFinite /-
instance Add.sigmaFinite (Œº ŒΩ : Measure Œ±) [SigmaFinite Œº] [SigmaFinite ŒΩ] : SigmaFinite (Œº + ŒΩ) :=
  by
  rw [‚Üê sum_cond]
  refine' @sum.sigma_finite _ _ _ _ _ (Bool.rec _ _) <;> simpa
#align measure_theory.add.sigma_finite MeasureTheory.Add.sigmaFinite
-/

/- warning: measure_theory.sigma_finite.of_map -> MeasureTheory.SigmaFinite.of_map is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] (Œº : MeasureTheory.Measure.{u1} Œ± m0) {f : Œ± -> Œ≤}, (AEMeasurable.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº) -> (MeasureTheory.SigmaFinite.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 f Œº)) -> (MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] (Œº : MeasureTheory.Measure.{u2} Œ± m0) {f : Œ± -> Œ≤}, (AEMeasurable.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº) -> (MeasureTheory.SigmaFinite.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 f Œº)) -> (MeasureTheory.SigmaFinite.{u2} Œ± m0 Œº)
Case conversion may be inaccurate. Consider using '#align measure_theory.sigma_finite.of_map MeasureTheory.SigmaFinite.of_map‚Çì'. -/
theorem SigmaFinite.of_map (Œº : Measure Œ±) {f : Œ± ‚Üí Œ≤} (hf : AEMeasurable f Œº)
    (h : SigmaFinite (Œº.map f)) : SigmaFinite Œº :=
  ‚ü®‚ü®‚ü®fun n => f ‚Åª¬π' spanningSets (Œº.map f) n, fun n => trivial, fun n => by
        simp only [‚Üê map_apply_of_ae_measurable hf, measurable_spanning_sets,
          measure_spanning_sets_lt_top],
        by rw [‚Üê preimage_Union, Union_spanning_sets, preimage_univ]‚ü©‚ü©‚ü©
#align measure_theory.sigma_finite.of_map MeasureTheory.SigmaFinite.of_map

/- warning: measurable_equiv.sigma_finite_map -> MeasurableEquiv.sigmaFinite_map is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_1 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± m0} (f : MeasurableEquiv.{u1, u2} Œ± Œ≤ m0 _inst_1), (MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº) -> (MeasureTheory.SigmaFinite.{u2} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_1 m0 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MeasurableEquiv.{u1, u2} Œ± Œ≤ m0 _inst_1) (fun (_x : MeasurableEquiv.{u1, u2} Œ± Œ≤ m0 _inst_1) => Œ± -> Œ≤) (MeasurableEquiv.hasCoeToFun.{u1, u2} Œ± Œ≤ m0 _inst_1) f) Œº))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} [_inst_1 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± m0} (f : MeasurableEquiv.{u2, u1} Œ± Œ≤ m0 _inst_1), (MeasureTheory.SigmaFinite.{u2} Œ± m0 Œº) -> (MeasureTheory.SigmaFinite.{u1} Œ≤ _inst_1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_1 m0 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ m0 _inst_1) Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ±) => Œ≤) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ m0 _inst_1) Œ± Œ≤ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ m0 _inst_1) Œ± Œ≤ (MeasurableEquiv.instEquivLike.{u2, u1} Œ± Œ≤ m0 _inst_1))) f) Œº))
Case conversion may be inaccurate. Consider using '#align measurable_equiv.sigma_finite_map MeasurableEquiv.sigmaFinite_map‚Çì'. -/
theorem MeasurableEquiv.sigmaFinite_map {Œº : Measure Œ±} (f : Œ± ‚âÉ·µê Œ≤) (h : SigmaFinite Œº) :
    SigmaFinite (Œº.map f) :=
  by
  refine' sigma_finite.of_map _ f.symm.measurable.ae_measurable _
  rwa [map_map f.symm.measurable f.measurable, f.symm_comp_self, measure.map_id]
#align measurable_equiv.sigma_finite_map MeasurableEquiv.sigmaFinite_map

/- warning: measure_theory.ae_of_forall_measure_lt_top_ae_restrict' -> MeasureTheory.ae_of_forall_measure_lt_top_ae_restrict' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} (ŒΩ : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] [_inst_4 : MeasureTheory.SigmaFinite.{u1} Œ± m0 ŒΩ] (P : Œ± -> Prop), (forall (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m0 s) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) ŒΩ s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => P x) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)))) -> (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => P x) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} (ŒΩ : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] [_inst_4 : MeasureTheory.SigmaFinite.{u1} Œ± m0 ŒΩ] (P : Œ± -> Prop), (forall (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m0 s) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 ŒΩ) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => P x) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)))) -> (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => P x) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_of_forall_measure_lt_top_ae_restrict' MeasureTheory.ae_of_forall_measure_lt_top_ae_restrict'‚Çì'. -/
/-- Similar to `ae_of_forall_measure_lt_top_ae_restrict`, but where you additionally get the
  hypothesis that another œÉ-finite measure has finite values on `s`. -/
theorem ae_of_forall_measure_lt_top_ae_restrict' {Œº : Measure Œ±} (ŒΩ : Measure Œ±) [SigmaFinite Œº]
    [SigmaFinite ŒΩ] (P : Œ± ‚Üí Prop)
    (h : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ŒΩ s < ‚àû ‚Üí ‚àÄ·µê x ‚àÇŒº.restrict s, P x) : ‚àÄ·µê x ‚àÇŒº, P x :=
  by
  have : ‚àÄ n, ‚àÄ·µê x ‚àÇŒº, x ‚àà spanning_sets (Œº + ŒΩ) n ‚Üí P x :=
    by
    intro n
    have := h (spanning_sets (Œº + ŒΩ) n) (measurable_spanning_sets _ _) _ _
    exacts[(ae_restrict_iff' (measurable_spanning_sets _ _)).mp this,
      (self_le_add_right _ _).trans_lt (measure_spanning_sets_lt_top (Œº + ŒΩ) _),
      (self_le_add_left _ _).trans_lt (measure_spanning_sets_lt_top (Œº + ŒΩ) _)]
  filter_upwards [ae_all_iff.2 this]with _ hx using hx _ (mem_spanning_sets_index _ _)
#align measure_theory.ae_of_forall_measure_lt_top_ae_restrict' MeasureTheory.ae_of_forall_measure_lt_top_ae_restrict'

/- warning: measure_theory.ae_of_forall_measure_lt_top_ae_restrict -> MeasureTheory.ae_of_forall_measure_lt_top_ae_restrict is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] (P : Œ± -> Prop), (forall (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m0 s) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => P x) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)))) -> (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => P x) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] (P : Œ± -> Prop), (forall (s : Set.{u1} Œ±), (MeasurableSet.{u1} Œ± m0 s) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => P x) (MeasureTheory.Measure.ae.{u1} Œ± m0 (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº s)))) -> (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => P x) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº))
Case conversion may be inaccurate. Consider using '#align measure_theory.ae_of_forall_measure_lt_top_ae_restrict MeasureTheory.ae_of_forall_measure_lt_top_ae_restrict‚Çì'. -/
/-- To prove something for almost all `x` w.r.t. a œÉ-finite measure, it is sufficient to show that
  this holds almost everywhere in sets where the measure has finite value. -/
theorem ae_of_forall_measure_lt_top_ae_restrict {Œº : Measure Œ±} [SigmaFinite Œº] (P : Œ± ‚Üí Prop)
    (h : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚àÄ·µê x ‚àÇŒº.restrict s, P x) : ‚àÄ·µê x ‚àÇŒº, P x :=
  ae_of_forall_measure_lt_top_ae_restrict' Œº P fun s hs h2s _ => h s hs h2s
#align measure_theory.ae_of_forall_measure_lt_top_ae_restrict MeasureTheory.ae_of_forall_measure_lt_top_ae_restrict

#print MeasureTheory.LocallyFiniteMeasure /-
/-- A measure is called locally finite if it is finite in some neighborhood of each point. -/
class LocallyFiniteMeasure [TopologicalSpace Œ±] (Œº : Measure Œ±) : Prop where
  finite_at_nhds : ‚àÄ x, Œº.FiniteAtFilter (ùìù x)
#align measure_theory.is_locally_finite_measure MeasureTheory.LocallyFiniteMeasure
-/

#print MeasureTheory.FiniteMeasure.toLocallyFiniteMeasure /-
-- see Note [lower instance priority]
instance (priority := 100) FiniteMeasure.toLocallyFiniteMeasure [TopologicalSpace Œ±] (Œº : Measure Œ±)
    [FiniteMeasure Œº] : LocallyFiniteMeasure Œº :=
  ‚ü®fun x => finiteAtFilterOfFinite _ _‚ü©
#align measure_theory.is_finite_measure.to_is_locally_finite_measure MeasureTheory.FiniteMeasure.toLocallyFiniteMeasure
-/

#print MeasureTheory.Measure.finiteAt_nhds /-
theorem Measure.finiteAt_nhds [TopologicalSpace Œ±] (Œº : Measure Œ±) [LocallyFiniteMeasure Œº]
    (x : Œ±) : Œº.FiniteAtFilter (ùìù x) :=
  LocallyFiniteMeasure.finite_at_nhds x
#align measure_theory.measure.finite_at_nhds MeasureTheory.Measure.finiteAt_nhds
-/

/- warning: measure_theory.measure.smul_finite -> MeasureTheory.Measure.smul_finite is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº] {c : ENNReal}, (Ne.{1} ENNReal c (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (MeasureTheory.FiniteMeasure.{u1} Œ± m0 (SMul.smul.{0, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± ENNReal (SMulZeroClass.toHasSmul.{0, 0} ENNReal ENNReal (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (SMulWithZero.toSmulZeroClass.{0, 0} ENNReal ENNReal (MulZeroClass.toHasZero.{0} ENNReal (MulZeroOneClass.toMulZeroClass.{0} ENNReal (MonoidWithZero.toMulZeroOneClass.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (MulActionWithZero.toSMulWithZero.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (Module.toMulActionWithZero.{0, 0} ENNReal ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Algebra.toModule.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) m0) c Œº))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº] {c : ENNReal}, (Ne.{1} ENNReal c (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (MeasureTheory.FiniteMeasure.{u1} Œ± m0 (HSMul.hSMul.{0, u1, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHSMul.{0, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± ENNReal (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0)) c Œº))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.smul_finite MeasureTheory.Measure.smul_finite‚Çì'. -/
theorem Measure.smul_finite (Œº : Measure Œ±) [FiniteMeasure Œº] {c : ‚Ñù‚â•0‚àû} (hc : c ‚â† ‚àû) :
    FiniteMeasure (c ‚Ä¢ Œº) := by
  lift c to ‚Ñù‚â•0 using hc
  exact MeasureTheory.finiteMeasureSmulNNReal
#align measure_theory.measure.smul_finite MeasureTheory.Measure.smul_finite

/- warning: measure_theory.measure.exists_is_open_measure_lt_top -> MeasureTheory.Measure.exists_isOpen_measure_lt_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : TopologicalSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_4 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m0 _inst_3 Œº] (x : Œ±), Exists.{succ u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => And (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) (And (IsOpen.{u1} Œ± _inst_3 s) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : TopologicalSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_4 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m0 _inst_3 Œº] (x : Œ±), Exists.{succ u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) (And (IsOpen.{u1} Œ± _inst_3 s) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.exists_is_open_measure_lt_top MeasureTheory.Measure.exists_isOpen_measure_lt_top‚Çì'. -/
theorem Measure.exists_isOpen_measure_lt_top [TopologicalSpace Œ±] (Œº : Measure Œ±)
    [LocallyFiniteMeasure Œº] (x : Œ±) : ‚àÉ s : Set Œ±, x ‚àà s ‚àß IsOpen s ‚àß Œº s < ‚àû := by
  simpa only [exists_prop, and_assoc] using
    (Œº.finite_at_nhds x).exists_mem_basis (nhds_basis_opens x)
#align measure_theory.measure.exists_is_open_measure_lt_top MeasureTheory.Measure.exists_isOpen_measure_lt_top

/- warning: measure_theory.is_locally_finite_measure_smul_nnreal -> MeasureTheory.locallyFiniteMeasureSmulNnreal is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : TopologicalSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_4 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m0 _inst_3 Œº] (c : NNReal), MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m0 _inst_3 (SMul.smul.{0, u1} NNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± NNReal (MulAction.toHasSmul.{0, 0} NNReal ENNReal (MonoidWithZero.toMonoid.{0} NNReal (Semiring.toMonoidWithZero.{0} NNReal NNReal.semiring)) (ENNReal.mulAction.{0} ENNReal (Monoid.toMulAction.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (ENNReal.isScalarTower.{0, 0} ENNReal ENNReal (Monoid.toMulAction.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Monoid.toMulAction.{0} ENNReal (MonoidWithZero.toMonoid.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Mul.toSMul.{0} ENNReal (Distrib.toHasMul.{0} ENNReal (NonUnitalNonAssocSemiring.toDistrib.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))) m0) c Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : TopologicalSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_4 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m0 _inst_3 Œº] (c : NNReal), MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m0 _inst_3 (HSMul.hSMul.{0, u1, u1} NNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHSMul.{0, u1} NNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± NNReal (Algebra.toSMul.{0, 0} NNReal ENNReal instNNRealCommSemiring (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (ENNReal.instAlgebraNNRealInstNNRealCommSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) (ENNReal.instIsScalarTowerNNRealToSMulToMonoidToMonoidWithZeroInstNNRealSemiringInstMulActionNNRealToMonoidToMonoidWithZeroInstNNRealSemiringToSMulInstMulActionNNRealToMonoidToMonoidWithZeroInstNNRealSemiring.{0, 0} ENNReal ENNReal (MulActionWithZero.toMulAction.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) instENNRealZero (MonoidWithZero.toMulActionWithZero.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (MulActionWithZero.toMulAction.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) instENNRealZero (MonoidWithZero.toMulActionWithZero.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))))) (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)))) m0)) c Œº)
Case conversion may be inaccurate. Consider using '#align measure_theory.is_locally_finite_measure_smul_nnreal MeasureTheory.locallyFiniteMeasureSmulNnreal‚Çì'. -/
instance locallyFiniteMeasureSmulNnreal [TopologicalSpace Œ±] (Œº : Measure Œ±)
    [LocallyFiniteMeasure Œº] (c : ‚Ñù‚â•0) : LocallyFiniteMeasure (c ‚Ä¢ Œº) :=
  by
  refine' ‚ü®fun x => _‚ü©
  rcases Œº.exists_is_open_measure_lt_top x with ‚ü®o, xo, o_open, Œºo‚ü©
  refine' ‚ü®o, o_open.mem_nhds xo, _‚ü©
  apply ENNReal.mul_lt_top _ Œºo.ne
  simp only [RingHom.toMonoidHom_eq_coe, [anonymous], ENNReal.coe_ne_top, ENNReal.coe_ofNNRealHom,
    Ne.def, not_false_iff]
#align measure_theory.is_locally_finite_measure_smul_nnreal MeasureTheory.locallyFiniteMeasureSmulNnreal

/- warning: measure_theory.measure.is_topological_basis_is_open_lt_top -> MeasureTheory.Measure.isTopologicalBasis_isOpen_lt_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : TopologicalSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_4 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m0 _inst_3 Œº], TopologicalSpace.IsTopologicalBasis.{u1} Œ± _inst_3 (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => And (IsOpen.{u1} Œ± _inst_3 s) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : TopologicalSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_4 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m0 _inst_3 Œº], TopologicalSpace.IsTopologicalBasis.{u1} Œ± _inst_3 (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => And (IsOpen.{u1} Œ± _inst_3 s) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.is_topological_basis_is_open_lt_top MeasureTheory.Measure.isTopologicalBasis_isOpen_lt_top‚Çì'. -/
protected theorem Measure.isTopologicalBasis_isOpen_lt_top [TopologicalSpace Œ±] (Œº : Measure Œ±)
    [LocallyFiniteMeasure Œº] : TopologicalSpace.IsTopologicalBasis { s | IsOpen s ‚àß Œº s < ‚àû } :=
  by
  refine' TopologicalSpace.isTopologicalBasis_of_open_of_nhds (fun s hs => hs.1) _
  intro x s xs hs
  rcases Œº.exists_is_open_measure_lt_top x with ‚ü®v, xv, hv, Œºv‚ü©
  refine' ‚ü®v ‚à© s, ‚ü®hv.inter hs, lt_of_le_of_lt _ Œºv‚ü©, ‚ü®xv, xs‚ü©, inter_subset_right _ _‚ü©
  exact measure_mono (inter_subset_left _ _)
#align measure_theory.measure.is_topological_basis_is_open_lt_top MeasureTheory.Measure.isTopologicalBasis_isOpen_lt_top

#print MeasureTheory.FiniteMeasureOnCompacts /-
/-- A measure `Œº` is finite on compacts if any compact set `K` satisfies `Œº K < ‚àû`. -/
@[protect_proj]
class FiniteMeasureOnCompacts [TopologicalSpace Œ±] (Œº : Measure Œ±) : Prop where
  lt_top_of_isCompact : ‚àÄ ‚¶ÉK : Set Œ±‚¶Ñ, IsCompact K ‚Üí Œº K < ‚àû
#align measure_theory.is_finite_measure_on_compacts MeasureTheory.FiniteMeasureOnCompacts
-/

/- warning: is_compact.measure_lt_top -> IsCompact.measure_lt_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : TopologicalSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_4 : MeasureTheory.FiniteMeasureOnCompacts.{u1} Œ± m0 _inst_3 Œº] {{K : Set.{u1} Œ±}}, (IsCompact.{u1} Œ± _inst_3 K) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº K) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : TopologicalSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_4 : MeasureTheory.FiniteMeasureOnCompacts.{u1} Œ± m0 _inst_3 Œº] {{K : Set.{u1} Œ±}}, (IsCompact.{u1} Œ± _inst_3 K) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) K) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))
Case conversion may be inaccurate. Consider using '#align is_compact.measure_lt_top IsCompact.measure_lt_top‚Çì'. -/
/-- A compact subset has finite measure for a measure which is finite on compacts. -/
theorem IsCompact.measure_lt_top [TopologicalSpace Œ±] {Œº : Measure Œ±} [FiniteMeasureOnCompacts Œº]
    ‚¶ÉK : Set Œ±‚¶Ñ (hK : IsCompact K) : Œº K < ‚àû :=
  FiniteMeasureOnCompacts.lt_top_of_isCompact hK
#align is_compact.measure_lt_top IsCompact.measure_lt_top

/- warning: metric.bounded.measure_lt_top -> Metric.Bounded.measure_lt_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : PseudoMetricSpace.{u1} Œ±] [_inst_4 : ProperSpace.{u1} Œ± _inst_3] {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_5 : MeasureTheory.FiniteMeasureOnCompacts.{u1} Œ± m0 (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± _inst_3)) Œº] {{s : Set.{u1} Œ±}}, (Metric.Bounded.{u1} Œ± _inst_3 s) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : PseudoMetricSpace.{u1} Œ±] [_inst_4 : ProperSpace.{u1} Œ± _inst_3] {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_5 : MeasureTheory.FiniteMeasureOnCompacts.{u1} Œ± m0 (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± _inst_3)) Œº] {{s : Set.{u1} Œ±}}, (Metric.Bounded.{u1} Œ± _inst_3 s) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))
Case conversion may be inaccurate. Consider using '#align metric.bounded.measure_lt_top Metric.Bounded.measure_lt_top‚Çì'. -/
/-- A bounded subset has finite measure for a measure which is finite on compact sets, in a
proper space. -/
theorem Metric.Bounded.measure_lt_top [PseudoMetricSpace Œ±] [ProperSpace Œ±] {Œº : Measure Œ±}
    [FiniteMeasureOnCompacts Œº] ‚¶És : Set Œ±‚¶Ñ (hs : Metric.Bounded s) : Œº s < ‚àû :=
  calc
    Œº s ‚â§ Œº (closure s) := measure_mono subset_closure
    _ < ‚àû := (Metric.isCompact_of_isClosed_bounded isClosed_closure hs.closure).measure_lt_top
    
#align metric.bounded.measure_lt_top Metric.Bounded.measure_lt_top

/- warning: measure_theory.measure_closed_ball_lt_top -> MeasureTheory.measure_closedBall_lt_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : PseudoMetricSpace.{u1} Œ±] [_inst_4 : ProperSpace.{u1} Œ± _inst_3] {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_5 : MeasureTheory.FiniteMeasureOnCompacts.{u1} Œ± m0 (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± _inst_3)) Œº] {x : Œ±} {r : Real}, LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Metric.closedBall.{u1} Œ± _inst_3 x r)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : PseudoMetricSpace.{u1} Œ±] [_inst_4 : ProperSpace.{u1} Œ± _inst_3] {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_5 : MeasureTheory.FiniteMeasureOnCompacts.{u1} Œ± m0 (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± _inst_3)) Œº] {x : Œ±} {r : Real}, LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Metric.closedBall.{u1} Œ± _inst_3 x r)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_closed_ball_lt_top MeasureTheory.measure_closedBall_lt_top‚Çì'. -/
theorem measure_closedBall_lt_top [PseudoMetricSpace Œ±] [ProperSpace Œ±] {Œº : Measure Œ±}
    [FiniteMeasureOnCompacts Œº] {x : Œ±} {r : ‚Ñù} : Œº (Metric.closedBall x r) < ‚àû :=
  Metric.bounded_closedBall.measure_lt_top
#align measure_theory.measure_closed_ball_lt_top MeasureTheory.measure_closedBall_lt_top

/- warning: measure_theory.measure_ball_lt_top -> MeasureTheory.measure_ball_lt_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : PseudoMetricSpace.{u1} Œ±] [_inst_4 : ProperSpace.{u1} Œ± _inst_3] {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_5 : MeasureTheory.FiniteMeasureOnCompacts.{u1} Œ± m0 (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± _inst_3)) Œº] {x : Œ±} {r : Real}, LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Metric.ball.{u1} Œ± _inst_3 x r)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : PseudoMetricSpace.{u1} Œ±] [_inst_4 : ProperSpace.{u1} Œ± _inst_3] {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_5 : MeasureTheory.FiniteMeasureOnCompacts.{u1} Œ± m0 (UniformSpace.toTopologicalSpace.{u1} Œ± (PseudoMetricSpace.toUniformSpace.{u1} Œ± _inst_3)) Œº] {x : Œ±} {r : Real}, LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Metric.ball.{u1} Œ± _inst_3 x r)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_ball_lt_top MeasureTheory.measure_ball_lt_top‚Çì'. -/
theorem measure_ball_lt_top [PseudoMetricSpace Œ±] [ProperSpace Œ±] {Œº : Measure Œ±}
    [FiniteMeasureOnCompacts Œº] {x : Œ±} {r : ‚Ñù} : Œº (Metric.ball x r) < ‚àû :=
  Metric.bounded_ball.measure_lt_top
#align measure_theory.measure_ball_lt_top MeasureTheory.measure_ball_lt_top

/- warning: measure_theory.is_finite_measure_on_compacts.smul -> MeasureTheory.FiniteMeasureOnCompacts.smul is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : TopologicalSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_4 : MeasureTheory.FiniteMeasureOnCompacts.{u1} Œ± m0 _inst_3 Œº] {c : ENNReal}, (Ne.{1} ENNReal c (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) -> (MeasureTheory.FiniteMeasureOnCompacts.{u1} Œ± m0 _inst_3 (SMul.smul.{0, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± ENNReal (SMulZeroClass.toHasSmul.{0, 0} ENNReal ENNReal (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (SMulWithZero.toSmulZeroClass.{0, 0} ENNReal ENNReal (MulZeroClass.toHasZero.{0} ENNReal (MulZeroOneClass.toMulZeroClass.{0} ENNReal (MonoidWithZero.toMulZeroOneClass.{0} ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (MulActionWithZero.toSMulWithZero.{0, 0} ENNReal ENNReal (Semiring.toMonoidWithZero.{0} ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (AddZeroClass.toHasZero.{0} ENNReal (AddMonoid.toAddZeroClass.{0} ENNReal (AddCommMonoid.toAddMonoid.{0} ENNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))))) (Module.toMulActionWithZero.{0, 0} ENNReal ENNReal (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} ENNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENNReal (Semiring.toNonAssocSemiring.{0} ENNReal (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring)))))) (Algebra.toModule.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))))))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.canonicallyOrderedCommSemiring))) m0) c Œº))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} [_inst_3 : TopologicalSpace.{u1} Œ±] (Œº : MeasureTheory.Measure.{u1} Œ± m0) [_inst_4 : MeasureTheory.FiniteMeasureOnCompacts.{u1} Œ± m0 _inst_3 Œº] {c : ENNReal}, (Ne.{1} ENNReal c (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) -> (MeasureTheory.FiniteMeasureOnCompacts.{u1} Œ± m0 _inst_3 (HSMul.hSMul.{0, u1, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.{u1} Œ± m0) (instHSMul.{0, u1} ENNReal (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instSMul.{u1, 0} Œ± ENNReal (Algebra.toSMul.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (OrderedSemiring.toSemiring.{0} ENNReal (OrderedCommSemiring.toOrderedSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) (IsScalarTower.right.{0, 0} ENNReal ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal) (CommSemiring.toSemiring.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal)) (Algebra.id.{0} ENNReal (CanonicallyOrderedCommSemiring.toCommSemiring.{0} ENNReal ENNReal.instCanonicallyOrderedCommSemiringENNReal))) m0)) c Œº))
Case conversion may be inaccurate. Consider using '#align measure_theory.is_finite_measure_on_compacts.smul MeasureTheory.FiniteMeasureOnCompacts.smul‚Çì'. -/
protected theorem FiniteMeasureOnCompacts.smul [TopologicalSpace Œ±] (Œº : Measure Œ±)
    [FiniteMeasureOnCompacts Œº] {c : ‚Ñù‚â•0‚àû} (hc : c ‚â† ‚àû) : FiniteMeasureOnCompacts (c ‚Ä¢ Œº) :=
  ‚ü®fun K hK => ENNReal.mul_lt_top hc hK.measure_lt_top.Ne‚ü©
#align measure_theory.is_finite_measure_on_compacts.smul MeasureTheory.FiniteMeasureOnCompacts.smul

#print MeasureTheory.CompactSpace.finiteMeasure /-
/-- Note this cannot be an instance because it would form a typeclass loop with
`is_finite_measure_on_compacts_of_is_locally_finite_measure`. -/
theorem CompactSpace.finiteMeasure [TopologicalSpace Œ±] [CompactSpace Œ±]
    [FiniteMeasureOnCompacts Œº] : FiniteMeasure Œº :=
  ‚ü®FiniteMeasureOnCompacts.lt_top_of_isCompact isCompact_univ‚ü©
#align measure_theory.compact_space.is_finite_measure MeasureTheory.CompactSpace.finiteMeasure
-/

omit m0

#print MeasureTheory.sigmaFinite_of_locallyFinite /-
-- see Note [lower instance priority]
instance (priority := 100) sigmaFinite_of_locallyFinite [TopologicalSpace Œ±]
    [SecondCountableTopology Œ±] [LocallyFiniteMeasure Œº] : SigmaFinite Œº :=
  by
  choose s hsx hsŒº using Œº.finite_at_nhds
  rcases TopologicalSpace.countable_cover_nhds hsx with ‚ü®t, htc, htU‚ü©
  refine' measure.sigma_finite_of_countable (htc.image s) (ball_image_iff.2 fun x hx => hsŒº x) _
  rwa [sUnion_image]
#align measure_theory.sigma_finite_of_locally_finite MeasureTheory.sigmaFinite_of_locallyFinite
-/

#print MeasureTheory.locallyFiniteMeasure_of_finiteMeasureOnCompacts /-
/-- A measure which is finite on compact sets in a locally compact space is locally finite.
Not registered as an instance to avoid a loop with the other direction. -/
theorem locallyFiniteMeasure_of_finiteMeasureOnCompacts [TopologicalSpace Œ±] [LocallyCompactSpace Œ±]
    [FiniteMeasureOnCompacts Œº] : LocallyFiniteMeasure Œº :=
  ‚ü®by
    intro x
    rcases exists_compact_mem_nhds x with ‚ü®K, K_compact, K_mem‚ü©
    exact ‚ü®K, K_mem, K_compact.measure_lt_top‚ü©‚ü©
#align measure_theory.is_locally_finite_measure_of_is_finite_measure_on_compacts MeasureTheory.locallyFiniteMeasure_of_finiteMeasureOnCompacts
-/

/- warning: measure_theory.exists_pos_measure_of_cover -> MeasureTheory.exists_pos_measure_of_cover is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Countable.{succ u2} Œπ] {U : Œπ -> (Set.{u1} Œ±)}, (Eq.{succ u1} (Set.{u1} Œ±) (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => U i)) (Set.univ.{u1} Œ±)) -> (Ne.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (OfNat.mk.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.zero.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0))))) -> (Exists.{succ u2} Œπ (fun (i : Œπ) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (U i))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œπ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : Countable.{succ u2} Œπ] {U : Œπ -> (Set.{u1} Œ±)}, (Eq.{succ u1} (Set.{u1} Œ±) (Set.union·µ¢.{u1, succ u2} Œ± Œπ (fun (i : Œπ) => U i)) (Set.univ.{u1} Œ±)) -> (Ne.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.toOfNat0.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0)))) -> (Exists.{succ u2} Œπ (fun (i : Œπ) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (U i))))
Case conversion may be inaccurate. Consider using '#align measure_theory.exists_pos_measure_of_cover MeasureTheory.exists_pos_measure_of_cover‚Çì'. -/
theorem exists_pos_measure_of_cover [Countable Œπ] {U : Œπ ‚Üí Set Œ±} (hU : (‚ãÉ i, U i) = univ)
    (hŒº : Œº ‚â† 0) : ‚àÉ i, 0 < Œº (U i) := by
  contrapose! hŒº with H
  rw [‚Üê measure_univ_eq_zero, ‚Üê hU]
  exact measure_Union_null fun i => nonpos_iff_eq_zero.1 (H i)
#align measure_theory.exists_pos_measure_of_cover MeasureTheory.exists_pos_measure_of_cover

/- warning: measure_theory.exists_pos_preimage_ball -> MeasureTheory.exists_pos_preimage_ball is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PseudoMetricSpace.{u2} Œ¥] (f : Œ± -> Œ¥) (x : Œ¥), (Ne.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (OfNat.mk.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.zero.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0))))) -> (Exists.{1} Nat (fun (n : Nat) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.preimage.{u1, u2} Œ± Œ¥ f (Metric.ball.{u2} Œ¥ _inst_3 x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n))))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ¥ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PseudoMetricSpace.{u2} Œ¥] (f : Œ± -> Œ¥) (x : Œ¥), (Ne.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.toOfNat0.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0)))) -> (Exists.{1} Nat (fun (n : Nat) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Set.preimage.{u1, u2} Œ± Œ¥ f (Metric.ball.{u2} Œ¥ _inst_3 x (Nat.cast.{0} Real Real.natCast n))))))
Case conversion may be inaccurate. Consider using '#align measure_theory.exists_pos_preimage_ball MeasureTheory.exists_pos_preimage_ball‚Çì'. -/
theorem exists_pos_preimage_ball [PseudoMetricSpace Œ¥] (f : Œ± ‚Üí Œ¥) (x : Œ¥) (hŒº : Œº ‚â† 0) :
    ‚àÉ n : ‚Ñï, 0 < Œº (f ‚Åª¬π' Metric.ball x n) :=
  exists_pos_measure_of_cover (by rw [‚Üê preimage_Union, Metric.union·µ¢_ball_nat, preimage_univ]) hŒº
#align measure_theory.exists_pos_preimage_ball MeasureTheory.exists_pos_preimage_ball

/- warning: measure_theory.exists_pos_ball -> MeasureTheory.exists_pos_ball is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PseudoMetricSpace.{u1} Œ±] (x : Œ±), (Ne.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (OfNat.mk.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.zero.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0))))) -> (Exists.{1} Nat (fun (n : Nat) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Metric.ball.{u1} Œ± _inst_3 x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTC‚Çì.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : PseudoMetricSpace.{u1} Œ±] (x : Œ±), (Ne.{succ u1} (MeasureTheory.Measure.{u1} Œ± m0) Œº (OfNat.ofNat.{u1} (MeasureTheory.Measure.{u1} Œ± m0) 0 (Zero.toOfNat0.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instZero.{u1} Œ± m0)))) -> (Exists.{1} Nat (fun (n : Nat) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Metric.ball.{u1} Œ± _inst_3 x (Nat.cast.{0} Real Real.natCast n)))))
Case conversion may be inaccurate. Consider using '#align measure_theory.exists_pos_ball MeasureTheory.exists_pos_ball‚Çì'. -/
theorem exists_pos_ball [PseudoMetricSpace Œ±] (x : Œ±) (hŒº : Œº ‚â† 0) :
    ‚àÉ n : ‚Ñï, 0 < Œº (Metric.ball x n) :=
  exists_pos_preimage_ball id x hŒº
#align measure_theory.exists_pos_ball MeasureTheory.exists_pos_ball

/- warning: measure_theory.null_of_locally_null -> MeasureTheory.null_of_locally_null is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : TopologicalSpace.{u1} Œ±] [_inst_4 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_3] (s : Set.{u1} Œ±), (forall (x : Œ±), (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) -> (Exists.{succ u1} (Set.{u1} Œ±) (fun (u : Set.{u1} Œ±) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) u (nhdsWithin.{u1} Œ± _inst_3 x s)) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) u (nhdsWithin.{u1} Œ± _inst_3 x s)) => Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº u) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : TopologicalSpace.{u1} Œ±] [_inst_4 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_3] (s : Set.{u1} Œ±), (forall (x : Œ±), (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) -> (Exists.{succ u1} (Set.{u1} Œ±) (fun (u : Set.{u1} Œ±) => And (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) u (nhdsWithin.{u1} Œ± _inst_3 x s)) (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) u) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align measure_theory.null_of_locally_null MeasureTheory.null_of_locally_null‚Çì'. -/
/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure
in a second-countable space. -/
theorem null_of_locally_null [TopologicalSpace Œ±] [SecondCountableTopology Œ±] (s : Set Œ±)
    (hs : ‚àÄ x ‚àà s, ‚àÉ u ‚àà ùìù[s] x, Œº u = 0) : Œº s = 0 :=
  Œº.toOuterMeasure.null_of_locally_null s hs
#align measure_theory.null_of_locally_null MeasureTheory.null_of_locally_null

/- warning: measure_theory.exists_mem_forall_mem_nhds_within_pos_measure -> MeasureTheory.exists_mem_forall_mem_nhdsWithin_pos_measure is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : TopologicalSpace.{u1} Œ±] [_inst_4 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_3] {s : Set.{u1} Œ±}, (Ne.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Exists.{succ u1} Œ± (fun (x : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) => forall (t : Set.{u1} Œ±), (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) t (nhdsWithin.{u1} Œ± _inst_3 x s)) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº t)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} [_inst_3 : TopologicalSpace.{u1} Œ±] [_inst_4 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_3] {s : Set.{u1} Œ±}, (Ne.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Exists.{succ u1} Œ± (fun (x : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) (forall (t : Set.{u1} Œ±), (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) t (nhdsWithin.{u1} Œ± _inst_3 x s)) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) t)))))
Case conversion may be inaccurate. Consider using '#align measure_theory.exists_mem_forall_mem_nhds_within_pos_measure MeasureTheory.exists_mem_forall_mem_nhdsWithin_pos_measure‚Çì'. -/
theorem exists_mem_forall_mem_nhdsWithin_pos_measure [TopologicalSpace Œ±]
    [SecondCountableTopology Œ±] {s : Set Œ±} (hs : Œº s ‚â† 0) : ‚àÉ x ‚àà s, ‚àÄ t ‚àà ùìù[s] x, 0 < Œº t :=
  Œº.toOuterMeasure.exists_mem_forall_mem_nhds_within_pos hs
#align measure_theory.exists_mem_forall_mem_nhds_within_pos_measure MeasureTheory.exists_mem_forall_mem_nhdsWithin_pos_measure

/- warning: measure_theory.exists_ne_forall_mem_nhds_pos_measure_preimage -> MeasureTheory.exists_ne_forall_mem_nhds_pos_measure_preimage is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {Œ≤ : Type.{u2}} [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : T1Space.{u2} Œ≤ _inst_3] [_inst_5 : TopologicalSpace.SecondCountableTopology.{u2} Œ≤ _inst_3] [_inst_6 : Nonempty.{succ u2} Œ≤] {f : Œ± -> Œ≤}, (forall (b : Œ≤), Filter.Frequently.{u1} Œ± (fun (x : Œ±) => Ne.{succ u2} Œ≤ (f x) b) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº)) -> (Exists.{succ u2} Œ≤ (fun (a : Œ≤) => Exists.{succ u2} Œ≤ (fun (b : Œ≤) => And (Ne.{succ u2} Œ≤ a b) (And (forall (s : Set.{u2} Œ≤), (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) s (nhds.{u2} Œ≤ _inst_3 a)) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.preimage.{u1, u2} Œ± Œ≤ f s)))) (forall (t : Set.{u2} Œ≤), (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) t (nhds.{u2} Œ≤ _inst_3 b)) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.preimage.{u1, u2} Œ± Œ≤ f t))))))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {Œ≤ : Type.{u2}} [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : T1Space.{u2} Œ≤ _inst_3] [_inst_5 : TopologicalSpace.SecondCountableTopology.{u2} Œ≤ _inst_3] [_inst_6 : Nonempty.{succ u2} Œ≤] {f : Œ± -> Œ≤}, (forall (b : Œ≤), Filter.Frequently.{u1} Œ± (fun (x : Œ±) => Ne.{succ u2} Œ≤ (f x) b) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº)) -> (Exists.{succ u2} Œ≤ (fun (a : Œ≤) => Exists.{succ u2} Œ≤ (fun (b : Œ≤) => And (Ne.{succ u2} Œ≤ a b) (And (forall (s : Set.{u2} Œ≤), (Membership.mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (instMembershipSetFilter.{u2} Œ≤) s (nhds.{u2} Œ≤ _inst_3 a)) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Set.preimage.{u1, u2} Œ± Œ≤ f s)))) (forall (t : Set.{u2} Œ≤), (Membership.mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (instMembershipSetFilter.{u2} Œ≤) t (nhds.{u2} Œ≤ _inst_3 b)) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (Set.preimage.{u1, u2} Œ± Œ≤ f t))))))))
Case conversion may be inaccurate. Consider using '#align measure_theory.exists_ne_forall_mem_nhds_pos_measure_preimage MeasureTheory.exists_ne_forall_mem_nhds_pos_measure_preimage‚Çì'. -/
theorem exists_ne_forall_mem_nhds_pos_measure_preimage {Œ≤} [TopologicalSpace Œ≤] [T1Space Œ≤]
    [SecondCountableTopology Œ≤] [Nonempty Œ≤] {f : Œ± ‚Üí Œ≤} (h : ‚àÄ b, ‚àÉ·µê x ‚àÇŒº, f x ‚â† b) :
    ‚àÉ a b : Œ≤, a ‚â† b ‚àß (‚àÄ s ‚àà ùìù a, 0 < Œº (f ‚Åª¬π' s)) ‚àß ‚àÄ t ‚àà ùìù b, 0 < Œº (f ‚Åª¬π' t) :=
  by
  -- We use an `outer_measure` so that the proof works without `measurable f`
  set m : outer_measure Œ≤ := outer_measure.map f Œº.to_outer_measure
  replace h : ‚àÄ b : Œ≤, m ({b}·∂ú) ‚â† 0 := fun b => not_eventually.mpr (h b)
  inhabit Œ≤
  have : m univ ‚â† 0 := ne_bot_of_le_ne_bot (h default) (m.mono' <| subset_univ _)
  rcases m.exists_mem_forall_mem_nhds_within_pos this with ‚ü®b, -, hb‚ü©
  simp only [nhdsWithin_univ] at hb
  rcases m.exists_mem_forall_mem_nhds_within_pos (h b) with ‚ü®a, hab : a ‚â† b, ha‚ü©
  simp only [is_open_compl_singleton.nhds_within_eq hab] at ha
  exact ‚ü®a, b, hab, ha, hb‚ü©
#align measure_theory.exists_ne_forall_mem_nhds_pos_measure_preimage MeasureTheory.exists_ne_forall_mem_nhds_pos_measure_preimage

#print MeasureTheory.ext_on_measurableSpace_of_generate_finite /-
/-- If two finite measures give the same mass to the whole space and coincide on a œÄ-system made
of measurable sets, then they coincide on all sets in the œÉ-algebra generated by the œÄ-system. -/
theorem ext_on_measurableSpace_of_generate_finite {Œ±} (m‚ÇÄ : MeasurableSpace Œ±) {Œº ŒΩ : Measure Œ±}
    [FiniteMeasure Œº] (C : Set (Set Œ±)) (hŒºŒΩ : ‚àÄ s ‚àà C, Œº s = ŒΩ s) {m : MeasurableSpace Œ±}
    (h : m ‚â§ m‚ÇÄ) (hA : m = MeasurableSpace.generateFrom C) (hC : IsPiSystem C)
    (h_univ : Œº Set.univ = ŒΩ Set.univ) {s : Set Œ±} (hs : measurable_set[m] s) : Œº s = ŒΩ s :=
  by
  haveI : is_finite_measure ŒΩ := by
    constructor
    rw [‚Üê h_univ]
    apply is_finite_measure.measure_univ_lt_top
  refine' induction_on_inter hA hC (by simp) hŒºŒΩ _ _ hs
  ¬∑ intro t h1t h2t
    have h1t_ : @MeasurableSet Œ± m‚ÇÄ t := h _ h1t
    rw [@measure_compl Œ± m‚ÇÄ Œº t h1t_ (@measure_ne_top Œ± m‚ÇÄ Œº _ t),
      @measure_compl Œ± m‚ÇÄ ŒΩ t h1t_ (@measure_ne_top Œ± m‚ÇÄ ŒΩ _ t), h_univ, h2t]
  ¬∑ intro f h1f h2f h3f
    have h2f_ : ‚àÄ i : ‚Ñï, @MeasurableSet Œ± m‚ÇÄ (f i) := fun i => h _ (h2f i)
    have h_Union : @MeasurableSet Œ± m‚ÇÄ (‚ãÉ i : ‚Ñï, f i) := @MeasurableSet.union·µ¢ Œ± ‚Ñï m‚ÇÄ _ f h2f_
    simp [measure_Union, h_Union, h1f, h3f, h2f_]
#align measure_theory.ext_on_measurable_space_of_generate_finite MeasureTheory.ext_on_measurableSpace_of_generate_finite
-/

#print MeasureTheory.ext_of_generate_finite /-
/-- Two finite measures are equal if they are equal on the œÄ-system generating the œÉ-algebra
  (and `univ`). -/
theorem ext_of_generate_finite (C : Set (Set Œ±)) (hA : m0 = generateFrom C) (hC : IsPiSystem C)
    [FiniteMeasure Œº] (hŒºŒΩ : ‚àÄ s ‚àà C, Œº s = ŒΩ s) (h_univ : Œº univ = ŒΩ univ) : Œº = ŒΩ :=
  Measure.ext fun s hs => ext_on_measurableSpace_of_generate_finite m0 C hŒºŒΩ le_rfl hA hC h_univ hs
#align measure_theory.ext_of_generate_finite MeasureTheory.ext_of_generate_finite
-/

namespace Measure

section disjointed

include m0

#print MeasureTheory.Measure.FiniteSpanningSetsIn.disjointed /-
/-- Given `S : Œº.finite_spanning_sets_in {s | measurable_set s}`,
`finite_spanning_sets_in.disjointed` provides a `finite_spanning_sets_in {s | measurable_set s}`
such that its underlying sets are pairwise disjoint. -/
protected def FiniteSpanningSetsIn.disjointed {Œº : Measure Œ±}
    (S : Œº.FiniteSpanningSetsIn { s | MeasurableSet s }) :
    Œº.FiniteSpanningSetsIn { s | MeasurableSet s } :=
  ‚ü®disjointed S.Set, MeasurableSet.disjointed S.set_mem, fun n =>
    lt_of_le_of_lt (measure_mono (disjointed_subset S.Set n)) (S.Finite _),
    S.spanning ‚ñ∏ union·µ¢_disjointed‚ü©
#align measure_theory.measure.finite_spanning_sets_in.disjointed MeasureTheory.Measure.FiniteSpanningSetsIn.disjointed
-/

/- warning: measure_theory.measure.finite_spanning_sets_in.disjointed_set_eq -> MeasureTheory.Measure.FiniteSpanningSetsIn.disjointed_set_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} (S : MeasureTheory.Measure.FiniteSpanningSetsIn.{u1} Œ± m0 Œº (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s))), Eq.{succ u1} (Nat -> (Set.{u1} Œ±)) (MeasureTheory.Measure.FiniteSpanningSetsIn.set.{u1} Œ± m0 Œº (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s)) (MeasureTheory.Measure.FiniteSpanningSetsIn.disjointed.{u1} Œ± m0 Œº S)) (disjointed.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) (MeasureTheory.Measure.FiniteSpanningSetsIn.set.{u1} Œ± m0 Œº (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s)) S))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} (S : MeasureTheory.Measure.FiniteSpanningSetsIn.{u1} Œ± m0 Œº (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s))), Eq.{succ u1} (Nat -> (Set.{u1} Œ±)) (MeasureTheory.Measure.FiniteSpanningSetsIn.Set.{u1} Œ± m0 Œº (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s)) (MeasureTheory.Measure.FiniteSpanningSetsIn.disjointed.{u1} Œ± m0 Œº S)) (disjointed.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) (MeasureTheory.Measure.FiniteSpanningSetsIn.Set.{u1} Œ± m0 Œº (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s)) S))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.finite_spanning_sets_in.disjointed_set_eq MeasureTheory.Measure.FiniteSpanningSetsIn.disjointed_set_eq‚Çì'. -/
theorem FiniteSpanningSetsIn.disjointed_set_eq {Œº : Measure Œ±}
    (S : Œº.FiniteSpanningSetsIn { s | MeasurableSet s }) : S.disjointed.Set = disjointed S.Set :=
  rfl
#align measure_theory.measure.finite_spanning_sets_in.disjointed_set_eq MeasureTheory.Measure.FiniteSpanningSetsIn.disjointed_set_eq

/- warning: measure_theory.measure.exists_eq_disjoint_finite_spanning_sets_in -> MeasureTheory.Measure.exists_eq_disjoint_finiteSpanningSetsIn is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) (ŒΩ : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] [_inst_4 : MeasureTheory.SigmaFinite.{u1} Œ± m0 ŒΩ], Exists.{succ u1} (MeasureTheory.Measure.FiniteSpanningSetsIn.{u1} Œ± m0 Œº (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s))) (fun (S : MeasureTheory.Measure.FiniteSpanningSetsIn.{u1} Œ± m0 Œº (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s))) => Exists.{succ u1} (MeasureTheory.Measure.FiniteSpanningSetsIn.{u1} Œ± m0 ŒΩ (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s))) (fun (T : MeasureTheory.Measure.FiniteSpanningSetsIn.{u1} Œ± m0 ŒΩ (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s))) => And (Eq.{succ u1} (Nat -> (Set.{u1} Œ±)) (MeasureTheory.Measure.FiniteSpanningSetsIn.set.{u1} Œ± m0 Œº (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s)) S) (MeasureTheory.Measure.FiniteSpanningSetsIn.set.{u1} Œ± m0 ŒΩ (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s)) T)) (Pairwise.{0} Nat (Function.onFun.{1, succ u1, 1} Nat (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)))) (MeasureTheory.Measure.FiniteSpanningSetsIn.set.{u1} Œ± m0 Œº (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s)) S)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} (Œº : MeasureTheory.Measure.{u1} Œ± m0) (ŒΩ : MeasureTheory.Measure.{u1} Œ± m0) [_inst_3 : MeasureTheory.SigmaFinite.{u1} Œ± m0 Œº] [_inst_4 : MeasureTheory.SigmaFinite.{u1} Œ± m0 ŒΩ], Exists.{succ u1} (MeasureTheory.Measure.FiniteSpanningSetsIn.{u1} Œ± m0 Œº (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s))) (fun (S : MeasureTheory.Measure.FiniteSpanningSetsIn.{u1} Œ± m0 Œº (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s))) => Exists.{succ u1} (MeasureTheory.Measure.FiniteSpanningSetsIn.{u1} Œ± m0 ŒΩ (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s))) (fun (T : MeasureTheory.Measure.FiniteSpanningSetsIn.{u1} Œ± m0 ŒΩ (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s))) => And (Eq.{succ u1} (Nat -> (Set.{u1} Œ±)) (MeasureTheory.Measure.FiniteSpanningSetsIn.Set.{u1} Œ± m0 Œº (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s)) S) (MeasureTheory.Measure.FiniteSpanningSetsIn.Set.{u1} Œ± m0 ŒΩ (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s)) T)) (Pairwise.{0} Nat (Function.onFun.{1, succ u1, 1} Nat (Set.{u1} Œ±) Prop (Disjoint.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±))))))) (MeasureTheory.Measure.FiniteSpanningSetsIn.Set.{u1} Œ± m0 Œº (setOf.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => MeasurableSet.{u1} Œ± m0 s)) S)))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.exists_eq_disjoint_finite_spanning_sets_in MeasureTheory.Measure.exists_eq_disjoint_finiteSpanningSetsIn‚Çì'. -/
theorem exists_eq_disjoint_finiteSpanningSetsIn (Œº ŒΩ : Measure Œ±) [SigmaFinite Œº] [SigmaFinite ŒΩ] :
    ‚àÉ (S : Œº.FiniteSpanningSetsIn { s | MeasurableSet s })(T :
      ŒΩ.FiniteSpanningSetsIn { s | MeasurableSet s }),
      S.Set = T.Set ‚àß Pairwise (Disjoint on S.Set) :=
  let S := (Œº + ŒΩ).toFiniteSpanningSetsIn.disjointed
  ‚ü®S.of_le (Measure.le_add_right le_rfl), S.of_le (Measure.le_add_left le_rfl), rfl,
    disjoint_disjointed _‚ü©
#align measure_theory.measure.exists_eq_disjoint_finite_spanning_sets_in MeasureTheory.Measure.exists_eq_disjoint_finiteSpanningSetsIn

end disjointed

namespace FiniteAtFilter

variable {f g : Filter Œ±}

/- warning: measure_theory.measure.finite_at_filter.filter_mono -> MeasureTheory.Measure.FiniteAtFilter.filter_mono is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) f g) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº g) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) f g) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº g) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.finite_at_filter.filter_mono MeasureTheory.Measure.FiniteAtFilter.filter_mono‚Çì'. -/
theorem filter_mono (h : f ‚â§ g) : Œº.FiniteAtFilter g ‚Üí Œº.FiniteAtFilter f := fun ‚ü®s, hs, hŒº‚ü© =>
  ‚ü®s, h hs, hŒº‚ü©
#align measure_theory.measure.finite_at_filter.filter_mono MeasureTheory.Measure.FiniteAtFilter.filter_mono

/- warning: measure_theory.measure.finite_at_filter.inf_of_left -> MeasureTheory.Measure.FiniteAtFilter.inf_of_left is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.hasInf.{u1} Œ±) f g))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.instInfFilter.{u1} Œ±) f g))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.finite_at_filter.inf_of_left MeasureTheory.Measure.FiniteAtFilter.inf_of_left‚Çì'. -/
theorem inf_of_left (h : Œº.FiniteAtFilter f) : Œº.FiniteAtFilter (f ‚äì g) :=
  h.filter_mono inf_le_left
#align measure_theory.measure.finite_at_filter.inf_of_left MeasureTheory.Measure.FiniteAtFilter.inf_of_left

/- warning: measure_theory.measure.finite_at_filter.inf_of_right -> MeasureTheory.Measure.FiniteAtFilter.inf_of_right is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº g) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.hasInf.{u1} Œ±) f g))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº g) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.instInfFilter.{u1} Œ±) f g))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.finite_at_filter.inf_of_right MeasureTheory.Measure.FiniteAtFilter.inf_of_right‚Çì'. -/
theorem inf_of_right (h : Œº.FiniteAtFilter g) : Œº.FiniteAtFilter (f ‚äì g) :=
  h.filter_mono inf_le_right
#align measure_theory.measure.finite_at_filter.inf_of_right MeasureTheory.Measure.FiniteAtFilter.inf_of_right

/- warning: measure_theory.measure.finite_at_filter.inf_ae_iff -> MeasureTheory.Measure.FiniteAtFilter.inf_ae_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±}, Iff (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.hasInf.{u1} Œ±) f (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº))) (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±}, Iff (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.instInfFilter.{u1} Œ±) f (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº))) (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.finite_at_filter.inf_ae_iff MeasureTheory.Measure.FiniteAtFilter.inf_ae_iff‚Çì'. -/
@[simp]
theorem inf_ae_iff : Œº.FiniteAtFilter (f ‚äì Œº.ae) ‚Üî Œº.FiniteAtFilter f :=
  by
  refine' ‚ü®_, fun h => h.filter_mono inf_le_left‚ü©
  rintro ‚ü®s, ‚ü®t, ht, u, hu, rfl‚ü©, hŒº‚ü©
  suffices : Œº t ‚â§ Œº (t ‚à© u); exact ‚ü®t, ht, this.trans_lt hŒº‚ü©
  exact measure_mono_ae (mem_of_superset hu fun x hu ht => ‚ü®ht, hu‚ü©)
#align measure_theory.measure.finite_at_filter.inf_ae_iff MeasureTheory.Measure.FiniteAtFilter.inf_ae_iff

/- warning: measure_theory.measure.finite_at_filter.of_inf_ae -> MeasureTheory.Measure.FiniteAtFilter.of_inf_ae is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±}, (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.hasInf.{u1} Œ±) f (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº))) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±}, (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.instInfFilter.{u1} Œ±) f (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº))) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.finite_at_filter.of_inf_ae MeasureTheory.Measure.FiniteAtFilter.of_inf_ae‚Çì'. -/
alias inf_ae_iff ‚Üî of_inf_ae _
#align measure_theory.measure.finite_at_filter.of_inf_ae MeasureTheory.Measure.FiniteAtFilter.of_inf_ae

/- warning: measure_theory.measure.finite_at_filter.filter_mono_ae -> MeasureTheory.Measure.FiniteAtFilter.filter_mono_ae is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.hasInf.{u1} Œ±) f (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº)) g) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº g) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.instInfFilter.{u1} Œ±) f (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº)) g) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº g) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.finite_at_filter.filter_mono_ae MeasureTheory.Measure.FiniteAtFilter.filter_mono_ae‚Çì'. -/
theorem filter_mono_ae (h : f ‚äì Œº.ae ‚â§ g) (hg : Œº.FiniteAtFilter g) : Œº.FiniteAtFilter f :=
  inf_ae_iff.1 (hg.filter_mono h)
#align measure_theory.measure.finite_at_filter.filter_mono_ae MeasureTheory.Measure.FiniteAtFilter.filter_mono_ae

#print MeasureTheory.Measure.FiniteAtFilter.measure_mono /-
protected theorem measure_mono (h : Œº ‚â§ ŒΩ) : ŒΩ.FiniteAtFilter f ‚Üí Œº.FiniteAtFilter f :=
  fun ‚ü®s, hs, hŒΩ‚ü© => ‚ü®s, hs, (Measure.le_iff'.1 h s).trans_lt hŒΩ‚ü©
#align measure_theory.measure.finite_at_filter.measure_mono MeasureTheory.Measure.FiniteAtFilter.measure_mono
-/

/- warning: measure_theory.measure.finite_at_filter.mono -> MeasureTheory.Measure.FiniteAtFilter.mono is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) f g) -> (LE.le.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº ŒΩ) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 ŒΩ g) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {ŒΩ : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, (LE.le.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) f g) -> (LE.le.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (Preorder.toLE.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (PartialOrder.toPreorder.{u1} (MeasureTheory.Measure.{u1} Œ± m0) (MeasureTheory.Measure.instPartialOrder.{u1} Œ± m0))) Œº ŒΩ) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 ŒΩ g) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f)
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.finite_at_filter.mono MeasureTheory.Measure.FiniteAtFilter.mono‚Çì'. -/
@[mono]
protected theorem mono (hf : f ‚â§ g) (hŒº : Œº ‚â§ ŒΩ) : ŒΩ.FiniteAtFilter g ‚Üí Œº.FiniteAtFilter f :=
  fun h => (h.filter_mono hf).measure_mono hŒº
#align measure_theory.measure.finite_at_filter.mono MeasureTheory.Measure.FiniteAtFilter.mono

/- warning: measure_theory.measure.finite_at_filter.eventually -> MeasureTheory.Measure.FiniteAtFilter.eventually is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±}, (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f) -> (Filter.Eventually.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))) (Filter.smallSets.{u1} Œ± f))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±}, (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f) -> (Filter.Eventually.{u1} (Set.{u1} Œ±) (fun (s : Set.{u1} Œ±) => LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))) (Filter.smallSets.{u1} Œ± f))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.finite_at_filter.eventually MeasureTheory.Measure.FiniteAtFilter.eventually‚Çì'. -/
protected theorem eventually (h : Œº.FiniteAtFilter f) : ‚àÄ·∂† s in f.smallSets, Œº s < ‚àû :=
  (eventually_small_sets' fun s t hst ht => (measure_mono hst).trans_lt ht).2 h
#align measure_theory.measure.finite_at_filter.eventually MeasureTheory.Measure.FiniteAtFilter.eventually

/- warning: measure_theory.measure.finite_at_filter.filter_sup -> MeasureTheory.Measure.FiniteAtFilter.filterSup is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº g) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº (Sup.sup.{u1} (Filter.{u1} Œ±) (SemilatticeSup.toHasSup.{u1} (Filter.{u1} Œ±) (Lattice.toSemilatticeSup.{u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toLattice.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))))) f g))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {f : Filter.{u1} Œ±} {g : Filter.{u1} Œ±}, (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº f) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº g) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº (Sup.sup.{u1} (Filter.{u1} Œ±) (SemilatticeSup.toSup.{u1} (Filter.{u1} Œ±) (Lattice.toSemilatticeSup.{u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toLattice.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))))) f g))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.finite_at_filter.filter_sup MeasureTheory.Measure.FiniteAtFilter.filterSup‚Çì'. -/
theorem filterSup : Œº.FiniteAtFilter f ‚Üí Œº.FiniteAtFilter g ‚Üí Œº.FiniteAtFilter (f ‚äî g) :=
  fun ‚ü®s, hsf, hsŒº‚ü© ‚ü®t, htg, htŒº‚ü© =>
  ‚ü®s ‚à™ t, union_mem_sup hsf htg, (measure_union_le s t).trans_lt (ENNReal.add_lt_top.2 ‚ü®hsŒº, htŒº‚ü©)‚ü©
#align measure_theory.measure.finite_at_filter.filter_sup MeasureTheory.Measure.FiniteAtFilter.filterSup

end FiniteAtFilter

#print MeasureTheory.Measure.finiteAt_nhdsWithin /-
theorem finiteAt_nhdsWithin [TopologicalSpace Œ±] {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±)
    [LocallyFiniteMeasure Œº] (x : Œ±) (s : Set Œ±) : Œº.FiniteAtFilter (ùìù[s] x) :=
  (finiteAt_nhds Œº x).inf_of_left
#align measure_theory.measure.finite_at_nhds_within MeasureTheory.Measure.finiteAt_nhdsWithin
-/

/- warning: measure_theory.measure.finite_at_principal -> MeasureTheory.Measure.finiteAt_principal is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, Iff (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº (Filter.principal.{u1} Œ± s)) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±}, Iff (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± m0 Œº (Filter.principal.{u1} Œ± s)) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure.finite_at_principal MeasureTheory.Measure.finiteAt_principal‚Çì'. -/
@[simp]
theorem finiteAt_principal : Œº.FiniteAtFilter (ùìü s) ‚Üî Œº s < ‚àû :=
  ‚ü®fun ‚ü®t, ht, hŒº‚ü© => (measure_mono ht).trans_lt hŒº, fun h => ‚ü®s, mem_principal_self s, h‚ü©‚ü©
#align measure_theory.measure.finite_at_principal MeasureTheory.Measure.finiteAt_principal

#print MeasureTheory.Measure.locallyFiniteMeasure_of_le /-
theorem locallyFiniteMeasure_of_le [TopologicalSpace Œ±] {m : MeasurableSpace Œ±} {Œº ŒΩ : Measure Œ±}
    [H : LocallyFiniteMeasure Œº] (h : ŒΩ ‚â§ Œº) : LocallyFiniteMeasure ŒΩ :=
  let F := H.finite_at_nhds
  ‚ü®fun x => (F x).measure_mono h‚ü©
#align measure_theory.measure.is_locally_finite_measure_of_le MeasureTheory.Measure.locallyFiniteMeasure_of_le
-/

end Measure

end MeasureTheory

open MeasureTheory MeasureTheory.Measure

namespace MeasurableEmbedding

variable {m0 : MeasurableSpace Œ±} {m1 : MeasurableSpace Œ≤} {f : Œ± ‚Üí Œ≤} (hf : MeasurableEmbedding f)

include hf

/- warning: measurable_embedding.map_apply -> MeasurableEmbedding.map_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {m1 : MeasurableSpace.{u2} Œ≤} {f : Œ± -> Œ≤}, (MeasurableEmbedding.{u1, u2} Œ± Œ≤ m0 m1 f) -> (forall (Œº : MeasureTheory.Measure.{u1} Œ± m0) (s : Set.{u2} Œ≤), Eq.{1} ENNReal (coeFn.{succ u2, succ u2} (MeasureTheory.Measure.{u2} Œ≤ m1) (fun (_x : MeasureTheory.Measure.{u2} Œ≤ m1) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u2} Œ≤ m1) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ m1 m0 f Œº) s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (Set.preimage.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} {m1 : MeasurableSpace.{u1} Œ≤} {f : Œ± -> Œ≤}, (MeasurableEmbedding.{u2, u1} Œ± Œ≤ m0 m1 f) -> (forall (Œº : MeasureTheory.Measure.{u2} Œ± m0) (s : Set.{u1} Œ≤), Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ≤ (MeasureTheory.Measure.toOuterMeasure.{u1} Œ≤ m1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ m1 m0 f Œº)) s) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± m0 Œº) (Set.preimage.{u2, u1} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align measurable_embedding.map_apply MeasurableEmbedding.map_apply‚Çì'. -/
theorem map_apply (Œº : Measure Œ±) (s : Set Œ≤) : Œº.map f s = Œº (f ‚Åª¬π' s) :=
  by
  refine' le_antisymm _ (le_map_apply hf.measurable.ae_measurable s)
  set t := f '' to_measurable Œº (f ‚Åª¬π' s) ‚à™ range f·∂ú
  have htm : MeasurableSet t :=
    (hf.measurable_set_image.2 <| measurable_set_to_measurable _ _).union
      hf.measurable_set_range.compl
  have hst : s ‚äÜ t :=
    by
    rw [subset_union_compl_iff_inter_subset, ‚Üê image_preimage_eq_inter_range]
    exact image_subset _ (subset_to_measurable _ _)
  have hft : f ‚Åª¬π' t = to_measurable Œº (f ‚Åª¬π' s) := by
    rw [preimage_union, preimage_compl, preimage_range, compl_univ, union_empty,
      hf.injective.preimage_image]
  calc
    Œº.map f s ‚â§ Œº.map f t := measure_mono hst
    _ = Œº (f ‚Åª¬π' s) := by rw [map_apply hf.measurable htm, hft, measure_to_measurable]
    
#align measurable_embedding.map_apply MeasurableEmbedding.map_apply

#print MeasurableEmbedding.map_comap /-
theorem map_comap (Œº : Measure Œ≤) : (comap f Œº).map f = Œº.restrict (range f) :=
  by
  ext1 t ht
  rw [hf.map_apply, comap_apply f hf.injective hf.measurable_set_image' _ (hf.measurable ht),
    image_preimage_eq_inter_range, restrict_apply ht]
#align measurable_embedding.map_comap MeasurableEmbedding.map_comap
-/

#print MeasurableEmbedding.comap_apply /-
theorem comap_apply (Œº : Measure Œ≤) (s : Set Œ±) : comap f Œº s = Œº (f '' s) :=
  calc
    comap f Œº s = comap f Œº (f ‚Åª¬π' (f '' s)) := by rw [hf.injective.preimage_image]
    _ = (comap f Œº).map f (f '' s) := (hf.map_apply _ _).symm
    _ = Œº (f '' s) := by
      rw [hf.map_comap, restrict_apply' hf.measurable_set_range,
        inter_eq_self_of_subset_left (image_subset_range _ _)]
    
#align measurable_embedding.comap_apply MeasurableEmbedding.comap_apply
-/

/- warning: measurable_embedding.ae_map_iff -> MeasurableEmbedding.ae_map_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {m1 : MeasurableSpace.{u2} Œ≤} {f : Œ± -> Œ≤}, (MeasurableEmbedding.{u1, u2} Œ± Œ≤ m0 m1 f) -> (forall {p : Œ≤ -> Prop} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Iff (Filter.Eventually.{u2} Œ≤ (fun (x : Œ≤) => p x) (MeasureTheory.Measure.ae.{u2} Œ≤ m1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ m1 m0 f Œº))) (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p (f x)) (MeasureTheory.Measure.ae.{u1} Œ± m0 Œº)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} {m1 : MeasurableSpace.{u1} Œ≤} {f : Œ± -> Œ≤}, (MeasurableEmbedding.{u2, u1} Œ± Œ≤ m0 m1 f) -> (forall {p : Œ≤ -> Prop} {Œº : MeasureTheory.Measure.{u2} Œ± m0}, Iff (Filter.Eventually.{u1} Œ≤ (fun (x : Œ≤) => p x) (MeasureTheory.Measure.ae.{u1} Œ≤ m1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ m1 m0 f Œº))) (Filter.Eventually.{u2} Œ± (fun (x : Œ±) => p (f x)) (MeasureTheory.Measure.ae.{u2} Œ± m0 Œº)))
Case conversion may be inaccurate. Consider using '#align measurable_embedding.ae_map_iff MeasurableEmbedding.ae_map_iff‚Çì'. -/
theorem ae_map_iff {p : Œ≤ ‚Üí Prop} {Œº : Measure Œ±} : (‚àÄ·µê x ‚àÇŒº.map f, p x) ‚Üî ‚àÄ·µê x ‚àÇŒº, p (f x) := by
  simp only [ae_iff, hf.map_apply, preimage_set_of_eq]
#align measurable_embedding.ae_map_iff MeasurableEmbedding.ae_map_iff

/- warning: measurable_embedding.restrict_map -> MeasurableEmbedding.restrict_map is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {m1 : MeasurableSpace.{u2} Œ≤} {f : Œ± -> Œ≤}, (MeasurableEmbedding.{u1, u2} Œ± Œ≤ m0 m1 f) -> (forall (Œº : MeasureTheory.Measure.{u1} Œ± m0) (s : Set.{u2} Œ≤), Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ≤ m1) (MeasureTheory.Measure.restrict.{u2} Œ≤ m1 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ m1 m0 f Œº) s) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ m1 m0 f (MeasureTheory.Measure.restrict.{u1} Œ± m0 Œº (Set.preimage.{u1, u2} Œ± Œ≤ f s))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} {m0 : MeasurableSpace.{u2} Œ±} {m1 : MeasurableSpace.{u1} Œ≤} {f : Œ± -> Œ≤}, (MeasurableEmbedding.{u2, u1} Œ± Œ≤ m0 m1 f) -> (forall (Œº : MeasureTheory.Measure.{u2} Œ± m0) (s : Set.{u1} Œ≤), Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ≤ m1) (MeasureTheory.Measure.restrict.{u1} Œ≤ m1 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ m1 m0 f Œº) s) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ m1 m0 f (MeasureTheory.Measure.restrict.{u2} Œ± m0 Œº (Set.preimage.{u2, u1} Œ± Œ≤ f s))))
Case conversion may be inaccurate. Consider using '#align measurable_embedding.restrict_map MeasurableEmbedding.restrict_map‚Çì'. -/
theorem restrict_map (Œº : Measure Œ±) (s : Set Œ≤) :
    (Œº.map f).restrict s = (Œº.restrict <| f ‚Åª¬π' s).map f :=
  Measure.ext fun t ht => by simp [hf.map_apply, ht, hf.measurable ht]
#align measurable_embedding.restrict_map MeasurableEmbedding.restrict_map

/- warning: measurable_embedding.comap_preimage -> MeasurableEmbedding.comap_preimage is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {m1 : MeasurableSpace.{u2} Œ≤} {f : Œ± -> Œ≤}, (MeasurableEmbedding.{u1, u2} Œ± Œ≤ m0 m1 f) -> (forall (Œº : MeasureTheory.Measure.{u2} Œ≤ m1) {s : Set.{u2} Œ≤}, (MeasurableSet.{u2} Œ≤ m1 s) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) (MeasureTheory.Measure.comap.{u1, u2} Œ± Œ≤ m1 m0 f Œº) (Set.preimage.{u1, u2} Œ± Œ≤ f s)) (coeFn.{succ u2, succ u2} (MeasureTheory.Measure.{u2} Œ≤ m1) (fun (_x : MeasureTheory.Measure.{u2} Œ≤ m1) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u2} Œ≤ m1) Œº (Inter.inter.{u2} (Set.{u2} Œ≤) (Set.hasInter.{u2} Œ≤) s (Set.range.{u2, succ u1} Œ≤ Œ± f)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {m0 : MeasurableSpace.{u1} Œ±} {m1 : MeasurableSpace.{u2} Œ≤} {f : Œ± -> Œ≤}, (MeasurableEmbedding.{u1, u2} Œ± Œ≤ m0 m1 f) -> (forall (Œº : MeasureTheory.Measure.{u2} Œ≤ m1) {s : Set.{u2} Œ≤}, (MeasurableSet.{u2} Œ≤ m1 s) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 (MeasureTheory.Measure.comap.{u1, u2} Œ± Œ≤ m1 m0 f Œº)) (Set.preimage.{u1, u2} Œ± Œ≤ f s)) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ≤ (MeasureTheory.Measure.toOuterMeasure.{u2} Œ≤ m1 Œº) (Inter.inter.{u2} (Set.{u2} Œ≤) (Set.instInterSet.{u2} Œ≤) s (Set.range.{u2, succ u1} Œ≤ Œ± f)))))
Case conversion may be inaccurate. Consider using '#align measurable_embedding.comap_preimage MeasurableEmbedding.comap_preimage‚Çì'. -/
protected theorem comap_preimage (Œº : Measure Œ≤) {s : Set Œ≤} (hs : MeasurableSet s) :
    Œº.comap f (f ‚Åª¬π' s) = Œº (s ‚à© range f) :=
  comap_preimage _ _ hf.Injective hf.Measurable
    (fun t ht => (hf.measurableSet_image' ht).NullMeasurableSet) hs
#align measurable_embedding.comap_preimage MeasurableEmbedding.comap_preimage

end MeasurableEmbedding

section Subtype

#print comap_subtype_coe_apply /-
theorem comap_subtype_coe_apply {m0 : MeasurableSpace Œ±} {s : Set Œ±} (hs : MeasurableSet s)
    (Œº : Measure Œ±) (t : Set s) : comap coe Œº t = Œº (coe '' t) :=
  (MeasurableEmbedding.subtype_coe hs).comap_apply _ _
#align comap_subtype_coe_apply comap_subtype_coe_apply
-/

#print map_comap_subtype_coe /-
theorem map_comap_subtype_coe {m0 : MeasurableSpace Œ±} {s : Set Œ±} (hs : MeasurableSet s)
    (Œº : Measure Œ±) : (comap coe Œº).map (coe : s ‚Üí Œ±) = Œº.restrict s := by
  rw [(MeasurableEmbedding.subtype_coe hs).map_comap, Subtype.range_coe]
#align map_comap_subtype_coe map_comap_subtype_coe
-/

#print ae_restrict_iff_subtype /-
theorem ae_restrict_iff_subtype {m0 : MeasurableSpace Œ±} {Œº : Measure Œ±} {s : Set Œ±}
    (hs : MeasurableSet s) {p : Œ± ‚Üí Prop} :
    (‚àÄ·µê x ‚àÇŒº.restrict s, p x) ‚Üî ‚àÄ·µê x ‚àÇcomap (coe : s ‚Üí Œ±) Œº, p ‚Üëx := by
  rw [‚Üê map_comap_subtype_coe hs, (MeasurableEmbedding.subtype_coe hs).ae_map_iff]
#align ae_restrict_iff_subtype ae_restrict_iff_subtype
-/

variable [MeasureSpace Œ±] {s t : Set Œ±}

/-!
### Volume on `s : set Œ±`
-/


#print SetCoe.measureSpace /-
instance SetCoe.measureSpace (s : Set Œ±) : MeasureSpace s :=
  ‚ü®comap (coe : s ‚Üí Œ±) volume‚ü©
#align set_coe.measure_space SetCoe.measureSpace
-/

#print volume_set_coe_def /-
theorem volume_set_coe_def (s : Set Œ±) : (volume : Measure s) = comap (coe : s ‚Üí Œ±) volume :=
  rfl
#align volume_set_coe_def volume_set_coe_def
-/

#print MeasurableSet.map_coe_volume /-
theorem MeasurableSet.map_coe_volume {s : Set Œ±} (hs : MeasurableSet s) :
    volume.map (coe : s ‚Üí Œ±) = restrict volume s := by
  rw [volume_set_coe_def, (MeasurableEmbedding.subtype_coe hs).map_comap volume, Subtype.range_coe]
#align measurable_set.map_coe_volume MeasurableSet.map_coe_volume
-/

#print volume_image_subtype_coe /-
theorem volume_image_subtype_coe {s : Set Œ±} (hs : MeasurableSet s) (t : Set s) :
    volume (coe '' t : Set Œ±) = volume t :=
  (comap_subtype_coe_apply hs volume t).symm
#align volume_image_subtype_coe volume_image_subtype_coe
-/

/- warning: volume_preimage_coe -> volume_preimage_coe is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : MeasureTheory.MeasureSpace.{u1} Œ±] {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasureTheory.NullMeasurableSet.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_1) s (MeasureTheory.MeasureSpace.volume.{u1} Œ± _inst_1)) -> (MeasurableSet.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_1) t) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (SetCoe.measureSpace.{u1} Œ± _inst_1 s))) (fun (_x : MeasureTheory.Measure.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (SetCoe.measureSpace.{u1} Œ± _inst_1 s))) => (Set.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s)) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (SetCoe.measureSpace.{u1} Œ± _inst_1 s))) (MeasureTheory.MeasureSpace.volume.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (SetCoe.measureSpace.{u1} Œ± _inst_1 s)) (Set.preimage.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeSubtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))))) t)) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_1)) (fun (_x : MeasureTheory.Measure.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_1)) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_1)) (MeasureTheory.MeasureSpace.volume.{u1} Œ± _inst_1) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.hasInter.{u1} Œ±) t s)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : MeasureTheory.MeasureSpace.{u1} Œ±] {s : Set.{u1} Œ±} {t : Set.{u1} Œ±}, (MeasureTheory.NullMeasurableSet.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_1) s (MeasureTheory.MeasureSpace.volume.{u1} Œ± _inst_1)) -> (MeasurableSet.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_1) t) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (MeasureTheory.Measure.toOuterMeasure.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (SetCoe.measureSpace.{u1} Œ± _inst_1 s)) (MeasureTheory.MeasureSpace.volume.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (SetCoe.measureSpace.{u1} Œ± _inst_1 s))) (Set.preimage.{u1, u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) Œ± (Subtype.val.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) t)) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± (MeasureTheory.MeasureSpace.toMeasurableSpace.{u1} Œ± _inst_1) (MeasureTheory.MeasureSpace.volume.{u1} Œ± _inst_1)) (Inter.inter.{u1} (Set.{u1} Œ±) (Set.instInterSet.{u1} Œ±) t s)))
Case conversion may be inaccurate. Consider using '#align volume_preimage_coe volume_preimage_coe‚Çì'. -/
@[simp]
theorem volume_preimage_coe (hs : NullMeasurableSet s) (ht : MeasurableSet t) :
    volume ((coe : s ‚Üí Œ±) ‚Åª¬π' t) = volume (t ‚à© s) := by
  rw [volume_set_coe_def,
    comap_apply‚ÇÄ _ _ Subtype.coe_injective
      (fun h => measurable_set.null_measurable_set_subtype_coe hs)
      (measurable_subtype_coe ht).NullMeasurableSet,
    image_preimage_eq_inter_range, Subtype.range_coe]
#align volume_preimage_coe volume_preimage_coe

end Subtype

namespace MeasurableEquiv

/-! Interactions of measurable equivalences and measures -/


open Equiv MeasureTheory.Measure

variable [MeasurableSpace Œ±] [MeasurableSpace Œ≤] {Œº : Measure Œ±} {ŒΩ : Measure Œ≤}

/- warning: measurable_equiv.map_apply -> MeasurableEquiv.map_apply is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} (f : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) (s : Set.{u2} Œ≤), Eq.{1} ENNReal (coeFn.{succ u2, succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_2) (fun (_x : MeasureTheory.Measure.{u2} Œ≤ _inst_2) => (Set.{u2} Œ≤) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u2} Œ≤ _inst_2) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_2 _inst_1 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) (fun (_x : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) => Œ± -> Œ≤) (MeasurableEquiv.hasCoeToFun.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) f) Œº) s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_1) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_1) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_1) Œº (Set.preimage.{u1, u2} Œ± Œ≤ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) (fun (_x : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) => Œ± -> Œ≤) (MeasurableEquiv.hasCoeToFun.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) f) s))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± _inst_1} (f : MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) (s : Set.{u1} Œ≤), Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ≤ (MeasureTheory.Measure.toOuterMeasure.{u1} Œ≤ _inst_2 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_2 _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± (fun (a : Œ±) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ±) => Œ≤) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (MeasurableEquiv.instEquivLike.{u2, u1} Œ± Œ≤ _inst_1 _inst_2))) f) Œº)) s) (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± _inst_1 Œº) (Set.preimage.{u2, u1} Œ± Œ≤ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ±) => Œ≤) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (MeasurableEquiv.instEquivLike.{u2, u1} Œ± Œ≤ _inst_1 _inst_2))) f) s))
Case conversion may be inaccurate. Consider using '#align measurable_equiv.map_apply MeasurableEquiv.map_apply‚Çì'. -/
/-- If we map a measure along a measurable equivalence, we can compute the measure on all sets
  (not just the measurable ones). -/
protected theorem map_apply (f : Œ± ‚âÉ·µê Œ≤) (s : Set Œ≤) : Œº.map f s = Œº (f ‚Åª¬π' s) :=
  f.MeasurableEmbedding.map_apply _ _
#align measurable_equiv.map_apply MeasurableEquiv.map_apply

/- warning: measurable_equiv.map_symm_map -> MeasurableEquiv.map_symm_map is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} (e : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2), Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_1) (MeasureTheory.Measure.map.{u2, u1} Œ≤ Œ± _inst_1 _inst_2 (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MeasurableEquiv.{u2, u1} Œ≤ Œ± _inst_2 _inst_1) (fun (_x : MeasurableEquiv.{u2, u1} Œ≤ Œ± _inst_2 _inst_1) => Œ≤ -> Œ±) (MeasurableEquiv.hasCoeToFun.{u2, u1} Œ≤ Œ± _inst_2 _inst_1) (MeasurableEquiv.symm.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 e)) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_2 _inst_1 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) (fun (_x : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) => Œ± -> Œ≤) (MeasurableEquiv.hasCoeToFun.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) e) Œº)) Œº
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± _inst_1} (e : MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2), Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ± _inst_1) (MeasureTheory.Measure.map.{u1, u2} Œ≤ Œ± _inst_1 _inst_2 (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MeasurableEquiv.{u1, u2} Œ≤ Œ± _inst_2 _inst_1) Œ≤ (fun (_x : Œ≤) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ≤) => Œ±) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u1, succ u2} (MeasurableEquiv.{u1, u2} Œ≤ Œ± _inst_2 _inst_1) Œ≤ Œ± (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u1, succ u2} (MeasurableEquiv.{u1, u2} Œ≤ Œ± _inst_2 _inst_1) Œ≤ Œ± (MeasurableEquiv.instEquivLike.{u1, u2} Œ≤ Œ± _inst_2 _inst_1))) (MeasurableEquiv.symm.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 e)) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_2 _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ±) => Œ≤) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (MeasurableEquiv.instEquivLike.{u2, u1} Œ± Œ≤ _inst_1 _inst_2))) e) Œº)) Œº
Case conversion may be inaccurate. Consider using '#align measurable_equiv.map_symm_map MeasurableEquiv.map_symm_map‚Çì'. -/
@[simp]
theorem map_symm_map (e : Œ± ‚âÉ·µê Œ≤) : (Œº.map e).map e.symm = Œº := by
  simp [map_map e.symm.measurable e.measurable]
#align measurable_equiv.map_symm_map MeasurableEquiv.map_symm_map

/- warning: measurable_equiv.map_map_symm -> MeasurableEquiv.map_map_symm is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ≤] {ŒΩ : MeasureTheory.Measure.{u2} Œ≤ _inst_2} (e : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2), Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_2) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_2 _inst_1 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) (fun (_x : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) => Œ± -> Œ≤) (MeasurableEquiv.hasCoeToFun.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) e) (MeasureTheory.Measure.map.{u2, u1} Œ≤ Œ± _inst_1 _inst_2 (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MeasurableEquiv.{u2, u1} Œ≤ Œ± _inst_2 _inst_1) (fun (_x : MeasurableEquiv.{u2, u1} Œ≤ Œ± _inst_2 _inst_1) => Œ≤ -> Œ±) (MeasurableEquiv.hasCoeToFun.{u2, u1} Œ≤ Œ± _inst_2 _inst_1) (MeasurableEquiv.symm.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 e)) ŒΩ)) ŒΩ
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ≤] {ŒΩ : MeasureTheory.Measure.{u1} Œ≤ _inst_2} (e : MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2), Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_2) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_2 _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ±) => Œ≤) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (MeasurableEquiv.instEquivLike.{u2, u1} Œ± Œ≤ _inst_1 _inst_2))) e) (MeasureTheory.Measure.map.{u1, u2} Œ≤ Œ± _inst_1 _inst_2 (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MeasurableEquiv.{u1, u2} Œ≤ Œ± _inst_2 _inst_1) Œ≤ (fun (_x : Œ≤) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ≤) => Œ±) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u1, succ u2} (MeasurableEquiv.{u1, u2} Œ≤ Œ± _inst_2 _inst_1) Œ≤ Œ± (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u1, succ u2} (MeasurableEquiv.{u1, u2} Œ≤ Œ± _inst_2 _inst_1) Œ≤ Œ± (MeasurableEquiv.instEquivLike.{u1, u2} Œ≤ Œ± _inst_2 _inst_1))) (MeasurableEquiv.symm.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 e)) ŒΩ)) ŒΩ
Case conversion may be inaccurate. Consider using '#align measurable_equiv.map_map_symm MeasurableEquiv.map_map_symm‚Çì'. -/
@[simp]
theorem map_map_symm (e : Œ± ‚âÉ·µê Œ≤) : (ŒΩ.map e.symm).map e = ŒΩ := by
  simp [map_map e.measurable e.symm.measurable]
#align measurable_equiv.map_map_symm MeasurableEquiv.map_map_symm

/- warning: measurable_equiv.map_measurable_equiv_injective -> MeasurableEquiv.map_measurableEquiv_injective is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ≤] (e : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2), Function.Injective.{succ u1, succ u2} (MeasureTheory.Measure.{u1} Œ± _inst_1) (MeasureTheory.Measure.{u2} Œ≤ _inst_2) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_2 _inst_1 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) (fun (_x : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) => Œ± -> Œ≤) (MeasurableEquiv.hasCoeToFun.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) e))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ≤] (e : MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2), Function.Injective.{succ u2, succ u1} (MeasureTheory.Measure.{u2} Œ± _inst_1) (MeasureTheory.Measure.{u1} Œ≤ _inst_2) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_2 _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ±) => Œ≤) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (MeasurableEquiv.instEquivLike.{u2, u1} Œ± Œ≤ _inst_1 _inst_2))) e))
Case conversion may be inaccurate. Consider using '#align measurable_equiv.map_measurable_equiv_injective MeasurableEquiv.map_measurableEquiv_injective‚Çì'. -/
theorem map_measurableEquiv_injective (e : Œ± ‚âÉ·µê Œ≤) : Injective (map e) :=
  by
  intro Œº‚ÇÅ Œº‚ÇÇ hŒº
  apply_fun map e.symm  at hŒº
  simpa [map_symm_map e] using hŒº
#align measurable_equiv.map_measurable_equiv_injective MeasurableEquiv.map_measurableEquiv_injective

/- warning: measurable_equiv.map_apply_eq_iff_map_symm_apply_eq -> MeasurableEquiv.map_apply_eq_iff_map_symm_apply_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} {ŒΩ : MeasureTheory.Measure.{u2} Œ≤ _inst_2} (e : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2), Iff (Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_2) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_2 _inst_1 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) (fun (_x : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) => Œ± -> Œ≤) (MeasurableEquiv.hasCoeToFun.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) e) Œº) ŒΩ) (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_1) (MeasureTheory.Measure.map.{u2, u1} Œ≤ Œ± _inst_1 _inst_2 (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MeasurableEquiv.{u2, u1} Œ≤ Œ± _inst_2 _inst_1) (fun (_x : MeasurableEquiv.{u2, u1} Œ≤ Œ± _inst_2 _inst_1) => Œ≤ -> Œ±) (MeasurableEquiv.hasCoeToFun.{u2, u1} Œ≤ Œ± _inst_2 _inst_1) (MeasurableEquiv.symm.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 e)) ŒΩ) Œº)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± _inst_1} {ŒΩ : MeasureTheory.Measure.{u1} Œ≤ _inst_2} (e : MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2), Iff (Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_2) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_2 _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ±) => Œ≤) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (MeasurableEquiv.instEquivLike.{u2, u1} Œ± Œ≤ _inst_1 _inst_2))) e) Œº) ŒΩ) (Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ± _inst_1) (MeasureTheory.Measure.map.{u1, u2} Œ≤ Œ± _inst_1 _inst_2 (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MeasurableEquiv.{u1, u2} Œ≤ Œ± _inst_2 _inst_1) Œ≤ (fun (_x : Œ≤) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ≤) => Œ±) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u1, succ u2} (MeasurableEquiv.{u1, u2} Œ≤ Œ± _inst_2 _inst_1) Œ≤ Œ± (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u1, succ u2} (MeasurableEquiv.{u1, u2} Œ≤ Œ± _inst_2 _inst_1) Œ≤ Œ± (MeasurableEquiv.instEquivLike.{u1, u2} Œ≤ Œ± _inst_2 _inst_1))) (MeasurableEquiv.symm.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 e)) ŒΩ) Œº)
Case conversion may be inaccurate. Consider using '#align measurable_equiv.map_apply_eq_iff_map_symm_apply_eq MeasurableEquiv.map_apply_eq_iff_map_symm_apply_eq‚Çì'. -/
theorem map_apply_eq_iff_map_symm_apply_eq (e : Œ± ‚âÉ·µê Œ≤) : Œº.map e = ŒΩ ‚Üî ŒΩ.map e.symm = Œº := by
  rw [‚Üê (map_measurable_equiv_injective e).eq_iff, map_map_symm, eq_comm]
#align measurable_equiv.map_apply_eq_iff_map_symm_apply_eq MeasurableEquiv.map_apply_eq_iff_map_symm_apply_eq

/- warning: measurable_equiv.restrict_map -> MeasurableEquiv.restrict_map is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ≤] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} (e : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) (s : Set.{u2} Œ≤), Eq.{succ u2} (MeasureTheory.Measure.{u2} Œ≤ _inst_2) (MeasureTheory.Measure.restrict.{u2} Œ≤ _inst_2 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_2 _inst_1 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) (fun (_x : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) => Œ± -> Œ≤) (MeasurableEquiv.hasCoeToFun.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) e) Œº) s) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_2 _inst_1 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) (fun (_x : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) => Œ± -> Œ≤) (MeasurableEquiv.hasCoeToFun.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) e) (MeasureTheory.Measure.restrict.{u1} Œ± _inst_1 Œº (Set.preimage.{u1, u2} Œ± Œ≤ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) (fun (_x : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) => Œ± -> Œ≤) (MeasurableEquiv.hasCoeToFun.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) e) s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ≤] {Œº : MeasureTheory.Measure.{u2} Œ± _inst_1} (e : MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) (s : Set.{u1} Œ≤), Eq.{succ u1} (MeasureTheory.Measure.{u1} Œ≤ _inst_2) (MeasureTheory.Measure.restrict.{u1} Œ≤ _inst_2 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_2 _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ±) => Œ≤) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (MeasurableEquiv.instEquivLike.{u2, u1} Œ± Œ≤ _inst_1 _inst_2))) e) Œº) s) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_2 _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ±) => Œ≤) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (MeasurableEquiv.instEquivLike.{u2, u1} Œ± Œ≤ _inst_1 _inst_2))) e) (MeasureTheory.Measure.restrict.{u2} Œ± _inst_1 Œº (Set.preimage.{u2, u1} Œ± Œ≤ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ±) => Œ≤) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (MeasurableEquiv.instEquivLike.{u2, u1} Œ± Œ≤ _inst_1 _inst_2))) e) s)))
Case conversion may be inaccurate. Consider using '#align measurable_equiv.restrict_map MeasurableEquiv.restrict_map‚Çì'. -/
theorem restrict_map (e : Œ± ‚âÉ·µê Œ≤) (s : Set Œ≤) :
    (Œº.map e).restrict s = (Œº.restrict <| e ‚Åª¬π' s).map e :=
  e.MeasurableEmbedding.restrict_map _ _
#align measurable_equiv.restrict_map MeasurableEquiv.restrict_map

/- warning: measurable_equiv.map_ae -> MeasurableEquiv.map_ae is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ≤] (f : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) (Œº : MeasureTheory.Measure.{u1} Œ± _inst_1), Eq.{succ u2} (Filter.{u2} Œ≤) (Filter.map.{u1, u2} Œ± Œ≤ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) (fun (_x : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) => Œ± -> Œ≤) (MeasurableEquiv.hasCoeToFun.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) f) (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 Œº)) (MeasureTheory.Measure.ae.{u2} Œ≤ _inst_2 (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_2 _inst_1 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) (fun (_x : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) => Œ± -> Œ≤) (MeasurableEquiv.hasCoeToFun.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) f) Œº))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ≤] (f : MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) (Œº : MeasureTheory.Measure.{u2} Œ± _inst_1), Eq.{succ u1} (Filter.{u1} Œ≤) (Filter.map.{u2, u1} Œ± Œ≤ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ±) => Œ≤) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (MeasurableEquiv.instEquivLike.{u2, u1} Œ± Œ≤ _inst_1 _inst_2))) f) (MeasureTheory.Measure.ae.{u2} Œ± _inst_1 Œº)) (MeasureTheory.Measure.ae.{u1} Œ≤ _inst_2 (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_2 _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ±) => Œ≤) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (MeasurableEquiv.instEquivLike.{u2, u1} Œ± Œ≤ _inst_1 _inst_2))) f) Œº))
Case conversion may be inaccurate. Consider using '#align measurable_equiv.map_ae MeasurableEquiv.map_ae‚Çì'. -/
theorem map_ae (f : Œ± ‚âÉ·µê Œ≤) (Œº : Measure Œ±) : Filter.map f Œº.ae = (map f Œº).ae :=
  by
  ext s
  simp_rw [mem_map, mem_ae_iff, ‚Üê preimage_compl, f.map_apply]
#align measurable_equiv.map_ae MeasurableEquiv.map_ae

/- warning: measurable_equiv.quasi_measure_preserving_symm -> MeasurableEquiv.quasiMeasurePreserving_symm is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u2} Œ≤] (Œº : MeasureTheory.Measure.{u1} Œ± _inst_1) (e : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2), MeasureTheory.Measure.QuasiMeasurePreserving.{u2, u1} Œ≤ Œ± _inst_1 _inst_2 (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MeasurableEquiv.{u2, u1} Œ≤ Œ± _inst_2 _inst_1) (fun (_x : MeasurableEquiv.{u2, u1} Œ≤ Œ± _inst_2 _inst_1) => Œ≤ -> Œ±) (MeasurableEquiv.hasCoeToFun.{u2, u1} Œ≤ Œ± _inst_2 _inst_1) (MeasurableEquiv.symm.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 e)) (MeasureTheory.Measure.map.{u1, u2} Œ± Œ≤ _inst_2 _inst_1 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) (fun (_x : MeasurableEquiv.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) => Œ± -> Œ≤) (MeasurableEquiv.hasCoeToFun.{u1, u2} Œ± Œ≤ _inst_1 _inst_2) e) Œº) Œº
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ≤] (Œº : MeasureTheory.Measure.{u2} Œ± _inst_1) (e : MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2), MeasureTheory.Measure.QuasiMeasurePreserving.{u1, u2} Œ≤ Œ± _inst_1 _inst_2 (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (MeasurableEquiv.{u1, u2} Œ≤ Œ± _inst_2 _inst_1) Œ≤ (fun (_x : Œ≤) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ≤) => Œ±) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u1, succ u2} (MeasurableEquiv.{u1, u2} Œ≤ Œ± _inst_2 _inst_1) Œ≤ Œ± (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u1, succ u2} (MeasurableEquiv.{u1, u2} Œ≤ Œ± _inst_2 _inst_1) Œ≤ Œ± (MeasurableEquiv.instEquivLike.{u1, u2} Œ≤ Œ± _inst_2 _inst_1))) (MeasurableEquiv.symm.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 e)) (MeasureTheory.Measure.map.{u2, u1} Œ± Œ≤ _inst_2 _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± (fun (_x : Œ±) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Œ±) => Œ≤) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MeasurableEquiv.{u2, u1} Œ± Œ≤ _inst_1 _inst_2) Œ± Œ≤ (MeasurableEquiv.instEquivLike.{u2, u1} Œ± Œ≤ _inst_1 _inst_2))) e) Œº) Œº
Case conversion may be inaccurate. Consider using '#align measurable_equiv.quasi_measure_preserving_symm MeasurableEquiv.quasiMeasurePreserving_symm‚Çì'. -/
theorem quasiMeasurePreserving_symm (Œº : Measure Œ±) (e : Œ± ‚âÉ·µê Œ≤) :
    QuasiMeasurePreserving e.symm (map e Œº) Œº :=
  ‚ü®e.symm.Measurable, by rw [measure.map_map, e.symm_comp_self, measure.map_id] <;> measurability‚ü©
#align measurable_equiv.quasi_measure_preserving_symm MeasurableEquiv.quasiMeasurePreserving_symm

end MeasurableEquiv

namespace MeasureTheory

#print MeasureTheory.OuterMeasure.toMeasure_zero /-
theorem OuterMeasure.toMeasure_zero [MeasurableSpace Œ±] :
    (0 : OuterMeasure Œ±).toMeasure (le_top.trans OuterMeasure.zero_caratheodory.symm.le) = 0 := by
  rw [‚Üê measure.measure_univ_eq_zero, to_measure_apply _ _ MeasurableSet.univ,
    outer_measure.coe_zero, Pi.zero_apply]
#align measure_theory.outer_measure.to_measure_zero MeasureTheory.OuterMeasure.toMeasure_zero
-/

section Trim

#print MeasureTheory.Measure.trim /-
/-- Restriction of a measure to a sub-sigma algebra.
It is common to see a measure `Œº` on a measurable space structure `m0` as being also a measure on
any `m ‚â§ m0`. Since measures in mathlib have to be trimmed to the measurable space, `Œº` itself
cannot be a measure on `m`, hence the definition of `Œº.trim hm`.

This notion is related to `outer_measure.trim`, see the lemma
`to_outer_measure_trim_eq_trim_to_outer_measure`. -/
def Measure.trim {m m0 : MeasurableSpace Œ±} (Œº : @Measure Œ± m0) (hm : m ‚â§ m0) : @Measure Œ± m :=
  @OuterMeasure.toMeasure Œ± m Œº.toOuterMeasure (hm.trans (le_toOuterMeasure_caratheodory Œº))
#align measure_theory.measure.trim MeasureTheory.Measure.trim
-/

#print MeasureTheory.trim_eq_self /-
@[simp]
theorem trim_eq_self [MeasurableSpace Œ±] {Œº : Measure Œ±} : Œº.trim le_rfl = Œº := by
  simp [measure.trim]
#align measure_theory.trim_eq_self MeasureTheory.trim_eq_self
-/

variable {m m0 : MeasurableSpace Œ±} {Œº : Measure Œ±} {s : Set Œ±}

#print MeasureTheory.toOuterMeasure_trim_eq_trim_toOuterMeasure /-
theorem toOuterMeasure_trim_eq_trim_toOuterMeasure (Œº : Measure Œ±) (hm : m ‚â§ m0) :
    @Measure.toOuterMeasure _ m (Œº.trim hm) = @OuterMeasure.trim _ m Œº.toOuterMeasure := by
  rw [measure.trim, to_measure_to_outer_measure]
#align measure_theory.to_outer_measure_trim_eq_trim_to_outer_measure MeasureTheory.toOuterMeasure_trim_eq_trim_toOuterMeasure
-/

#print MeasureTheory.zero_trim /-
@[simp]
theorem zero_trim (hm : m ‚â§ m0) : (0 : Measure Œ±).trim hm = (0 : @Measure Œ± m) := by
  simp [measure.trim, outer_measure.to_measure_zero]
#align measure_theory.zero_trim MeasureTheory.zero_trim
-/

#print MeasureTheory.trim_measurableSet_eq /-
theorem trim_measurableSet_eq (hm : m ‚â§ m0) (hs : @MeasurableSet Œ± m s) : Œº.trim hm s = Œº s := by
  simp [measure.trim, hs]
#align measure_theory.trim_measurable_set_eq MeasureTheory.trim_measurableSet_eq
-/

/- warning: measure_theory.le_trim -> MeasureTheory.le_trim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} (hm : LE.le.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.hasLe.{u1} Œ±) m m0), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) (MeasureTheory.Measure.trim.{u1} Œ± m m0 Œº hm) s)
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} (hm : LE.le.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instLEMeasurableSpace.{u1} Œ±) m m0), LE.le.{0} ENNReal (Preorder.toLE.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m (MeasureTheory.Measure.trim.{u1} Œ± m m0 Œº hm)) s)
Case conversion may be inaccurate. Consider using '#align measure_theory.le_trim MeasureTheory.le_trim‚Çì'. -/
theorem le_trim (hm : m ‚â§ m0) : Œº s ‚â§ Œº.trim hm s :=
  by
  simp_rw [measure.trim]
  exact @le_to_measure_apply _ m _ _ _
#align measure_theory.le_trim MeasureTheory.le_trim

/- warning: measure_theory.measure_eq_zero_of_trim_eq_zero -> MeasureTheory.measure_eq_zero_of_trim_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} (hm : LE.le.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.hasLe.{u1} Œ±) m m0), (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) (MeasureTheory.Measure.trim.{u1} Œ± m m0 Œº hm) s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} (hm : LE.le.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instLEMeasurableSpace.{u1} Œ±) m m0), (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m (MeasureTheory.Measure.trim.{u1} Œ± m m0 Œº hm)) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_eq_zero_of_trim_eq_zero MeasureTheory.measure_eq_zero_of_trim_eq_zero‚Çì'. -/
theorem measure_eq_zero_of_trim_eq_zero (hm : m ‚â§ m0) (h : Œº.trim hm s = 0) : Œº s = 0 :=
  le_antisymm ((le_trim hm).trans (le_of_eq h)) (zero_le _)
#align measure_theory.measure_eq_zero_of_trim_eq_zero MeasureTheory.measure_eq_zero_of_trim_eq_zero

/- warning: measure_theory.measure_trim_to_measurable_eq_zero -> MeasureTheory.measure_trim_toMeasurable_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {hm : LE.le.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.hasLe.{u1} Œ±) m m0}, (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) (MeasureTheory.Measure.trim.{u1} Œ± m m0 Œº hm) s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m0) (fun (_x : MeasureTheory.Measure.{u1} Œ± m0) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m0) Œº (MeasureTheory.toMeasurable.{u1} Œ± m (MeasureTheory.Measure.trim.{u1} Œ± m m0 Œº hm) s)) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} {m : MeasurableSpace.{u1} Œ±} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0} {s : Set.{u1} Œ±} {hm : LE.le.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instLEMeasurableSpace.{u1} Œ±) m m0}, (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m (MeasureTheory.Measure.trim.{u1} Œ± m m0 Œº hm)) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m0 Œº) (MeasureTheory.toMeasurable.{u1} Œ± m (MeasureTheory.Measure.trim.{u1} Œ± m m0 Œº hm) s)) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align measure_theory.measure_trim_to_measurable_eq_zero MeasureTheory.measure_trim_toMeasurable_eq_zero‚Çì'. -/
theorem measure_trim_toMeasurable_eq_zero {hm : m ‚â§ m0} (hs : Œº.trim hm s = 0) :
    Œº (@toMeasurable Œ± m (Œº.trim hm) s) = 0 :=
  measure_eq_zero_of_trim_eq_zero hm (by rwa [measure_to_measurable])
#align measure_theory.measure_trim_to_measurable_eq_zero MeasureTheory.measure_trim_toMeasurable_eq_zero

#print MeasureTheory.ae_of_ae_trim /-
theorem ae_of_ae_trim (hm : m ‚â§ m0) {Œº : Measure Œ±} {P : Œ± ‚Üí Prop} (h : ‚àÄ·µê x ‚àÇŒº.trim hm, P x) :
    ‚àÄ·µê x ‚àÇŒº, P x :=
  measure_eq_zero_of_trim_eq_zero hm h
#align measure_theory.ae_of_ae_trim MeasureTheory.ae_of_ae_trim
-/

#print MeasureTheory.ae_eq_of_ae_eq_trim /-
theorem ae_eq_of_ae_eq_trim {E} {hm : m ‚â§ m0} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E}
    (h12 : f‚ÇÅ =·∂†[@Measure.ae Œ± m (Œº.trim hm)] f‚ÇÇ) : f‚ÇÅ =·µê[Œº] f‚ÇÇ :=
  measure_eq_zero_of_trim_eq_zero hm h12
#align measure_theory.ae_eq_of_ae_eq_trim MeasureTheory.ae_eq_of_ae_eq_trim
-/

#print MeasureTheory.ae_le_of_ae_le_trim /-
theorem ae_le_of_ae_le_trim {E} [LE E] {hm : m ‚â§ m0} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E}
    (h12 : f‚ÇÅ ‚â§·∂†[@Measure.ae Œ± m (Œº.trim hm)] f‚ÇÇ) : f‚ÇÅ ‚â§·µê[Œº] f‚ÇÇ :=
  measure_eq_zero_of_trim_eq_zero hm h12
#align measure_theory.ae_le_of_ae_le_trim MeasureTheory.ae_le_of_ae_le_trim
-/

#print MeasureTheory.trim_trim /-
theorem trim_trim {m‚ÇÅ m‚ÇÇ : MeasurableSpace Œ±} {hm‚ÇÅ‚ÇÇ : m‚ÇÅ ‚â§ m‚ÇÇ} {hm‚ÇÇ : m‚ÇÇ ‚â§ m0} :
    (Œº.trim hm‚ÇÇ).trim hm‚ÇÅ‚ÇÇ = Œº.trim (hm‚ÇÅ‚ÇÇ.trans hm‚ÇÇ) :=
  by
  ext1 t ht
  rw [trim_measurable_set_eq hm‚ÇÅ‚ÇÇ ht, trim_measurable_set_eq (hm‚ÇÅ‚ÇÇ.trans hm‚ÇÇ) ht,
    trim_measurable_set_eq hm‚ÇÇ (hm‚ÇÅ‚ÇÇ t ht)]
#align measure_theory.trim_trim MeasureTheory.trim_trim
-/

#print MeasureTheory.restrict_trim /-
theorem restrict_trim (hm : m ‚â§ m0) (Œº : Measure Œ±) (hs : @MeasurableSet Œ± m s) :
    @Measure.restrict Œ± m (Œº.trim hm) s = (Œº.restrict s).trim hm :=
  by
  ext1 t ht
  rw [@measure.restrict_apply Œ± m _ _ _ ht, trim_measurable_set_eq hm ht,
    measure.restrict_apply (hm t ht),
    trim_measurable_set_eq hm (@MeasurableSet.inter Œ± m t s ht hs)]
#align measure_theory.restrict_trim MeasureTheory.restrict_trim
-/

#print MeasureTheory.finiteMeasure_trim /-
instance finiteMeasure_trim (hm : m ‚â§ m0) [FiniteMeasure Œº] : FiniteMeasure (Œº.trim hm)
    where measure_univ_lt_top :=
    by
    rw [trim_measurable_set_eq hm (@MeasurableSet.univ _ m)]
    exact measure_lt_top _ _
#align measure_theory.is_finite_measure_trim MeasureTheory.finiteMeasure_trim
-/

#print MeasureTheory.sigmaFiniteTrim_mono /-
theorem sigmaFiniteTrim_mono {m m‚ÇÇ m0 : MeasurableSpace Œ±} {Œº : Measure Œ±} (hm : m ‚â§ m0)
    (hm‚ÇÇ : m‚ÇÇ ‚â§ m) [SigmaFinite (Œº.trim (hm‚ÇÇ.trans hm))] : SigmaFinite (Œº.trim hm) :=
  by
  have h := measure.finite_spanning_sets_in (Œº.trim (hm‚ÇÇ.trans hm)) Set.univ
  refine' measure.finite_spanning_sets_in.sigma_finite _
  ¬∑ use Set.univ
  ¬∑ refine'
      { Set := spanning_sets (Œº.trim (hm‚ÇÇ.trans hm))
        set_mem := fun _ => Set.mem_univ _
        Finite := fun i => _
        -- This is the only one left to prove
        spanning := Union_spanning_sets _ }
    calc
      (Œº.trim hm) (spanning_sets (Œº.trim (hm‚ÇÇ.trans hm)) i) =
          ((Œº.trim hm).trim hm‚ÇÇ) (spanning_sets (Œº.trim (hm‚ÇÇ.trans hm)) i) :=
        by rw [@trim_measurable_set_eq Œ± m‚ÇÇ m (Œº.trim hm) _ hm‚ÇÇ (measurable_spanning_sets _ _)]
      _ = (Œº.trim (hm‚ÇÇ.trans hm)) (spanning_sets (Œº.trim (hm‚ÇÇ.trans hm)) i) := by
        rw [@trim_trim _ _ Œº _ _ hm‚ÇÇ hm]
      _ < ‚àû := measure_spanning_sets_lt_top _ _
      
#align measure_theory.sigma_finite_trim_mono MeasureTheory.sigmaFiniteTrim_mono
-/

/- warning: measure_theory.sigma_finite_trim_bot_iff -> MeasureTheory.sigmaFinite_trim_bot_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Iff (MeasureTheory.SigmaFinite.{u1} Œ± (Bot.bot.{u1} (MeasurableSpace.{u1} Œ±) (OrderBot.toHasBot.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.hasLe.{u1} Œ±) (BoundedOrder.toOrderBot.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.hasLe.{u1} Œ±) (CompleteLattice.toBoundedOrder.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.completeLattice.{u1} Œ±))))) (MeasureTheory.Measure.trim.{u1} Œ± (Bot.bot.{u1} (MeasurableSpace.{u1} Œ±) (OrderBot.toHasBot.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.hasLe.{u1} Œ±) (BoundedOrder.toOrderBot.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.hasLe.{u1} Œ±) (CompleteLattice.toBoundedOrder.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.completeLattice.{u1} Œ±))))) m0 Œº (bot_le.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.hasLe.{u1} Œ±) (BoundedOrder.toOrderBot.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.hasLe.{u1} Œ±) (CompleteLattice.toBoundedOrder.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.completeLattice.{u1} Œ±))) m0))) (MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº)
but is expected to have type
  forall {Œ± : Type.{u1}} {m0 : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m0}, Iff (MeasureTheory.SigmaFinite.{u1} Œ± (Bot.bot.{u1} (MeasurableSpace.{u1} Œ±) (OrderBot.toBot.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instLEMeasurableSpace.{u1} Œ±) (BoundedOrder.toOrderBot.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instLEMeasurableSpace.{u1} Œ±) (CompleteLattice.toBoundedOrder.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instCompleteLatticeMeasurableSpace.{u1} Œ±))))) (MeasureTheory.Measure.trim.{u1} Œ± (Bot.bot.{u1} (MeasurableSpace.{u1} Œ±) (OrderBot.toBot.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instLEMeasurableSpace.{u1} Œ±) (BoundedOrder.toOrderBot.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instLEMeasurableSpace.{u1} Œ±) (CompleteLattice.toBoundedOrder.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instCompleteLatticeMeasurableSpace.{u1} Œ±))))) m0 Œº (bot_le.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instLEMeasurableSpace.{u1} Œ±) (BoundedOrder.toOrderBot.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instLEMeasurableSpace.{u1} Œ±) (CompleteLattice.toBoundedOrder.{u1} (MeasurableSpace.{u1} Œ±) (MeasurableSpace.instCompleteLatticeMeasurableSpace.{u1} Œ±))) m0))) (MeasureTheory.FiniteMeasure.{u1} Œ± m0 Œº)
Case conversion may be inaccurate. Consider using '#align measure_theory.sigma_finite_trim_bot_iff MeasureTheory.sigmaFinite_trim_bot_iff‚Çì'. -/
theorem sigmaFinite_trim_bot_iff : SigmaFinite (Œº.trim bot_le) ‚Üî FiniteMeasure Œº :=
  by
  rw [sigma_finite_bot_iff]
  refine' ‚ü®fun h => ‚ü®_‚ü©, fun h => ‚ü®_‚ü©‚ü© <;> have h_univ := h.measure_univ_lt_top
  ¬∑ rwa [trim_measurable_set_eq bot_le MeasurableSet.univ] at h_univ
  ¬∑ rwa [trim_measurable_set_eq bot_le MeasurableSet.univ]
#align measure_theory.sigma_finite_trim_bot_iff MeasureTheory.sigmaFinite_trim_bot_iff

end Trim

end MeasureTheory

namespace IsCompact

variable [TopologicalSpace Œ±] [MeasurableSpace Œ±] {Œº : Measure Œ±} {s : Set Œ±}

/- warning: is_compact.exists_open_superset_measure_lt_top' -> IsCompact.exists_open_superset_measure_lt_top' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_2} {s : Set.{u1} Œ±}, (IsCompact.{u1} Œ± _inst_1 s) -> (forall (x : Œ±), (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± _inst_2 Œº (nhds.{u1} Œ± _inst_1 x))) -> (Exists.{succ u1} (Set.{u1} Œ±) (fun (U : Set.{u1} Œ±) => Exists.{0} (Superset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) U s) (fun (H : Superset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) U s) => And (IsOpen.{u1} Œ± _inst_1 U) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_2) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_2) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_2) Œº U) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_2} {s : Set.{u1} Œ±}, (IsCompact.{u1} Œ± _inst_1 s) -> (forall (x : Œ±), (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± _inst_2 Œº (nhds.{u1} Œ± _inst_1 x))) -> (Exists.{succ u1} (Set.{u1} Œ±) (fun (U : Set.{u1} Œ±) => Exists.{0} (Superset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) U s) (fun (H : Superset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) U s) => And (IsOpen.{u1} Œ± _inst_1 U) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_2 Œº) U) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))))))
Case conversion may be inaccurate. Consider using '#align is_compact.exists_open_superset_measure_lt_top' IsCompact.exists_open_superset_measure_lt_top'‚Çì'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (U ¬´expr ‚äá ¬ª s) -/
/-- If `s` is a compact set and `Œº` is finite at `ùìù x` for every `x ‚àà s`, then `s` admits an open
superset of finite measure. -/
theorem exists_open_superset_measure_lt_top' (h : IsCompact s)
    (hŒº : ‚àÄ x ‚àà s, Œº.FiniteAtFilter (ùìù x)) : ‚àÉ (U : _)(_ : U ‚äá s), IsOpen U ‚àß Œº U < ‚àû :=
  by
  refine' IsCompact.induction_on h _ _ _ _
  ¬∑ use ‚àÖ
    simp [Superset]
  ¬∑ rintro s t hst ‚ü®U, htU, hUo, hU‚ü©
    exact ‚ü®U, hst.trans htU, hUo, hU‚ü©
  ¬∑ rintro s t ‚ü®U, hsU, hUo, hU‚ü© ‚ü®V, htV, hVo, hV‚ü©
    refine'
      ‚ü®U ‚à™ V, union_subset_union hsU htV, hUo.union hVo,
        (measure_union_le _ _).trans_lt <| ENNReal.add_lt_top.2 ‚ü®hU, hV‚ü©‚ü©
  ¬∑ intro x hx
    rcases(hŒº x hx).exists_mem_basis (nhds_basis_opens _) with ‚ü®U, ‚ü®hx, hUo‚ü©, hU‚ü©
    exact ‚ü®U, nhdsWithin_le_nhds (hUo.mem_nhds hx), U, subset.rfl, hUo, hU‚ü©
#align is_compact.exists_open_superset_measure_lt_top' IsCompact.exists_open_superset_measure_lt_top'

/- warning: is_compact.exists_open_superset_measure_lt_top -> IsCompact.exists_open_superset_measure_lt_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] {s : Set.{u1} Œ±}, (IsCompact.{u1} Œ± _inst_1 s) -> (forall (Œº : MeasureTheory.Measure.{u1} Œ± _inst_2) [_inst_3 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± _inst_2 _inst_1 Œº], Exists.{succ u1} (Set.{u1} Œ±) (fun (U : Set.{u1} Œ±) => Exists.{0} (Superset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) U s) (fun (H : Superset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) U s) => And (IsOpen.{u1} Œ± _inst_1 U) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_2) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_2) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_2) Œº U) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] {s : Set.{u1} Œ±}, (IsCompact.{u1} Œ± _inst_1 s) -> (forall (Œº : MeasureTheory.Measure.{u1} Œ± _inst_2) [_inst_3 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± _inst_2 _inst_1 Œº], Exists.{succ u1} (Set.{u1} Œ±) (fun (U : Set.{u1} Œ±) => Exists.{0} (Superset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) U s) (fun (H : Superset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) U s) => And (IsOpen.{u1} Œ± _inst_1 U) (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_2 Œº) U) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))))))
Case conversion may be inaccurate. Consider using '#align is_compact.exists_open_superset_measure_lt_top IsCompact.exists_open_superset_measure_lt_top‚Çì'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (U ¬´expr ‚äá ¬ª s) -/
/-- If `s` is a compact set and `Œº` is a locally finite measure, then `s` admits an open superset of
finite measure. -/
theorem exists_open_superset_measure_lt_top (h : IsCompact s) (Œº : Measure Œ±)
    [LocallyFiniteMeasure Œº] : ‚àÉ (U : _)(_ : U ‚äá s), IsOpen U ‚àß Œº U < ‚àû :=
  h.exists_open_superset_measure_lt_top' fun x hx => Œº.finite_at_nhds x
#align is_compact.exists_open_superset_measure_lt_top IsCompact.exists_open_superset_measure_lt_top

/- warning: is_compact.measure_lt_top_of_nhds_within -> IsCompact.measure_lt_top_of_nhdsWithin is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_2} {s : Set.{u1} Œ±}, (IsCompact.{u1} Œ± _inst_1 s) -> (forall (x : Œ±), (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± _inst_2 Œº (nhdsWithin.{u1} Œ± _inst_1 x s))) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_2) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_2) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_2) Œº s) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_2} {s : Set.{u1} Œ±}, (IsCompact.{u1} Œ± _inst_1 s) -> (forall (x : Œ±), (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) -> (MeasureTheory.Measure.FiniteAtFilter.{u1} Œ± _inst_2 Œº (nhdsWithin.{u1} Œ± _inst_1 x s))) -> (LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_2 Œº) s) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))
Case conversion may be inaccurate. Consider using '#align is_compact.measure_lt_top_of_nhds_within IsCompact.measure_lt_top_of_nhdsWithin‚Çì'. -/
theorem measure_lt_top_of_nhdsWithin (h : IsCompact s) (hŒº : ‚àÄ x ‚àà s, Œº.FiniteAtFilter (ùìù[s] x)) :
    Œº s < ‚àû :=
  IsCompact.induction_on h (by simp) (fun s t hst ht => (measure_mono hst).trans_lt ht)
    (fun s t hs ht => (measure_union_le s t).trans_lt (ENNReal.add_lt_top.2 ‚ü®hs, ht‚ü©)) hŒº
#align is_compact.measure_lt_top_of_nhds_within IsCompact.measure_lt_top_of_nhdsWithin

/- warning: is_compact.measure_zero_of_nhds_within -> IsCompact.measure_zero_of_nhdsWithin is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_2} {s : Set.{u1} Œ±}, (IsCompact.{u1} Œ± _inst_1 s) -> (forall (a : Œ±), (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) a s) -> (Exists.{succ u1} (Set.{u1} Œ±) (fun (t : Set.{u1} Œ±) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) t (nhdsWithin.{u1} Œ± _inst_1 a s)) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) t (nhdsWithin.{u1} Œ± _inst_1 a s)) => Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_2) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_2) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_2) Œº t) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))))) -> (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_2) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_2) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_2) Œº s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_2} {s : Set.{u1} Œ±}, (IsCompact.{u1} Œ± _inst_1 s) -> (forall (a : Œ±), (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) a s) -> (Exists.{succ u1} (Set.{u1} Œ±) (fun (t : Set.{u1} Œ±) => And (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) t (nhdsWithin.{u1} Œ± _inst_1 a s)) (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_2 Œº) t) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))))) -> (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_2 Œº) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero)))
Case conversion may be inaccurate. Consider using '#align is_compact.measure_zero_of_nhds_within IsCompact.measure_zero_of_nhdsWithin‚Çì'. -/
theorem measure_zero_of_nhdsWithin (hs : IsCompact s) :
    (‚àÄ a ‚àà s, ‚àÉ t ‚àà ùìù[s] a, Œº t = 0) ‚Üí Œº s = 0 := by
  simpa only [‚Üê compl_mem_ae_iff] using hs.compl_mem_sets_of_nhds_within
#align is_compact.measure_zero_of_nhds_within IsCompact.measure_zero_of_nhdsWithin

end IsCompact

#print finiteMeasureOnCompacts_of_locallyFiniteMeasure /-
-- see Note [lower instance priority]
instance (priority := 100) finiteMeasureOnCompacts_of_locallyFiniteMeasure [TopologicalSpace Œ±]
    {m : MeasurableSpace Œ±} {Œº : Measure Œ±} [LocallyFiniteMeasure Œº] : FiniteMeasureOnCompacts Œº :=
  ‚ü®fun s hs => hs.measure_lt_top_of_nhdsWithin fun x hx => Œº.finiteAt_nhdsWithin _ _‚ü©
#align is_finite_measure_on_compacts_of_is_locally_finite_measure finiteMeasureOnCompacts_of_locallyFiniteMeasure
-/

#print finiteMeasure_iff_finiteMeasureOnCompacts_of_compactSpace /-
theorem finiteMeasure_iff_finiteMeasureOnCompacts_of_compactSpace [TopologicalSpace Œ±]
    [MeasurableSpace Œ±] {Œº : Measure Œ±} [CompactSpace Œ±] :
    FiniteMeasure Œº ‚Üî FiniteMeasureOnCompacts Œº :=
  by
  constructor <;> intros
  ¬∑ infer_instance
  ¬∑ exact compact_space.is_finite_measure
#align is_finite_measure_iff_is_finite_measure_on_compacts_of_compact_space finiteMeasure_iff_finiteMeasureOnCompacts_of_compactSpace
-/

#print MeasureTheory.Measure.finiteSpanningSetsInCompact /-
/-- Compact covering of a `œÉ`-compact topological space as
`measure_theory.measure.finite_spanning_sets_in`. -/
def MeasureTheory.Measure.finiteSpanningSetsInCompact [TopologicalSpace Œ±] [SigmaCompactSpace Œ±]
    {m : MeasurableSpace Œ±} (Œº : Measure Œ±) [LocallyFiniteMeasure Œº] :
    Œº.FiniteSpanningSetsIn { K | IsCompact K }
    where
  Set := compactCovering Œ±
  set_mem := isCompact_compactCovering Œ±
  Finite n := (isCompact_compactCovering Œ± n).measure_lt_top
  spanning := union·µ¢_compactCovering Œ±
#align measure_theory.measure.finite_spanning_sets_in_compact MeasureTheory.Measure.finiteSpanningSetsInCompact
-/

#print MeasureTheory.Measure.finiteSpanningSetsInOpen /-
/-- A locally finite measure on a `œÉ`-compact topological space admits a finite spanning sequence
of open sets. -/
def MeasureTheory.Measure.finiteSpanningSetsInOpen [TopologicalSpace Œ±] [SigmaCompactSpace Œ±]
    {m : MeasurableSpace Œ±} (Œº : Measure Œ±) [LocallyFiniteMeasure Œº] :
    Œº.FiniteSpanningSetsIn { K | IsOpen K }
    where
  Set n := ((isCompact_compactCovering Œ± n).exists_open_superset_measure_lt_top Œº).some
  set_mem n :=
    ((isCompact_compactCovering Œ± n).exists_open_superset_measure_lt_top Œº).choose_spec.snd.1
  Finite n :=
    ((isCompact_compactCovering Œ± n).exists_open_superset_measure_lt_top Œº).choose_spec.snd.2
  spanning :=
    eq_univ_of_subset
      (union·µ¢_mono fun n =>
        ((isCompact_compactCovering Œ± n).exists_open_superset_measure_lt_top Œº).choose_spec.fst)
      (union·µ¢_compactCovering Œ±)
#align measure_theory.measure.finite_spanning_sets_in_open MeasureTheory.Measure.finiteSpanningSetsInOpen
-/

open TopologicalSpace

#print MeasureTheory.Measure.finiteSpanningSetsInOpen' /-
/-- A locally finite measure on a second countable topological space admits a finite spanning
sequence of open sets. -/
irreducible_def MeasureTheory.Measure.finiteSpanningSetsInOpen' [TopologicalSpace Œ±]
  [SecondCountableTopology Œ±] {m : MeasurableSpace Œ±} (Œº : Measure Œ±) [LocallyFiniteMeasure Œº] :
  Œº.FiniteSpanningSetsIn { K | IsOpen K } :=
  by
  suffices H : Nonempty (Œº.finite_spanning_sets_in { K | IsOpen K })
  exact H.some
  cases isEmpty_or_nonempty Œ±
  ¬∑
    exact
      ‚ü®{  Set := fun n => ‚àÖ
          set_mem := fun n => by simp
          Finite := fun n => by simp
          spanning := by simp }‚ü©
  inhabit Œ±
  let S : Set (Set Œ±) := { s | IsOpen s ‚àß Œº s < ‚àû }
  obtain ‚ü®T, T_count, TS, hT‚ü© : ‚àÉ T : Set (Set Œ±), T.Countable ‚àß T ‚äÜ S ‚àß ‚ãÉ‚ÇÄ T = ‚ãÉ‚ÇÄ S :=
    is_open_sUnion_countable S fun s hs => hs.1
  rw [Œº.is_topological_basis_is_open_lt_top.sUnion_eq] at hT
  have T_ne : T.nonempty := by
    by_contra h'T
    simp only [not_nonempty_iff_eq_empty.1 h'T, sUnion_empty] at hT
    simpa only [‚Üê hT] using mem_univ (default : Œ±)
  obtain ‚ü®f, hf‚ü© : ‚àÉ f : ‚Ñï ‚Üí Set Œ±, T = range f
  exact T_count.exists_eq_range T_ne
  have fS : ‚àÄ n, f n ‚àà S := by
    intro n
    apply TS
    rw [hf]
    exact mem_range_self n
  refine'
    ‚ü®{  Set := f
        set_mem := fun n => (fS n).1
        Finite := fun n => (fS n).2
        spanning := _ }‚ü©
  apply eq_univ_of_forall fun x => _
  obtain ‚ü®t, tT, xt‚ü© : ‚àÉ t : Set Œ±, t ‚àà range f ‚àß x ‚àà t :=
    by
    have : x ‚àà ‚ãÉ‚ÇÄ T := by simp only [hT]
    simpa only [mem_sUnion, exists_prop, ‚Üê hf]
  obtain ‚ü®n, rfl‚ü© : ‚àÉ n : ‚Ñï, f n = t := by simpa only using tT
  exact mem_Union_of_mem _ xt
#align measure_theory.measure.finite_spanning_sets_in_open' MeasureTheory.Measure.finiteSpanningSetsInOpen'
-/

section MeasureIxx

variable [Preorder Œ±] [TopologicalSpace Œ±] [CompactIccSpace Œ±] {m : MeasurableSpace Œ±}
  {Œº : Measure Œ±} [LocallyFiniteMeasure Œº] {a b : Œ±}

/- warning: measure_Icc_lt_top -> measure_Icc_lt_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Preorder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : CompactIccSpace.{u1} Œ± _inst_2 _inst_1] {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_4 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m _inst_2 Œº] {a : Œ±} {b : Œ±}, LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.Icc.{u1} Œ± _inst_1 a b)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Preorder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : CompactIccSpace.{u1} Œ± _inst_2 _inst_1] {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_4 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m _inst_2 Œº] {a : Œ±} {b : Œ±}, LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.Icc.{u1} Œ± _inst_1 a b)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))
Case conversion may be inaccurate. Consider using '#align measure_Icc_lt_top measure_Icc_lt_top‚Çì'. -/
theorem measure_Icc_lt_top : Œº (Icc a b) < ‚àû :=
  isCompact_Icc.measure_lt_top
#align measure_Icc_lt_top measure_Icc_lt_top

/- warning: measure_Ico_lt_top -> measure_Ico_lt_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Preorder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : CompactIccSpace.{u1} Œ± _inst_2 _inst_1] {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_4 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m _inst_2 Œº] {a : Œ±} {b : Œ±}, LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.Ico.{u1} Œ± _inst_1 a b)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Preorder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : CompactIccSpace.{u1} Œ± _inst_2 _inst_1] {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_4 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m _inst_2 Œº] {a : Œ±} {b : Œ±}, LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.Ico.{u1} Œ± _inst_1 a b)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))
Case conversion may be inaccurate. Consider using '#align measure_Ico_lt_top measure_Ico_lt_top‚Çì'. -/
theorem measure_Ico_lt_top : Œº (Ico a b) < ‚àû :=
  (measure_mono Ico_subset_Icc_self).trans_lt measure_Icc_lt_top
#align measure_Ico_lt_top measure_Ico_lt_top

/- warning: measure_Ioc_lt_top -> measure_Ioc_lt_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Preorder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : CompactIccSpace.{u1} Œ± _inst_2 _inst_1] {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_4 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m _inst_2 Œº] {a : Œ±} {b : Œ±}, LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.Ioc.{u1} Œ± _inst_1 a b)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Preorder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : CompactIccSpace.{u1} Œ± _inst_2 _inst_1] {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_4 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m _inst_2 Œº] {a : Œ±} {b : Œ±}, LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.Ioc.{u1} Œ± _inst_1 a b)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))
Case conversion may be inaccurate. Consider using '#align measure_Ioc_lt_top measure_Ioc_lt_top‚Çì'. -/
theorem measure_Ioc_lt_top : Œº (Ioc a b) < ‚àû :=
  (measure_mono Ioc_subset_Icc_self).trans_lt measure_Icc_lt_top
#align measure_Ioc_lt_top measure_Ioc_lt_top

/- warning: measure_Ioo_lt_top -> measure_Ioo_lt_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : Preorder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : CompactIccSpace.{u1} Œ± _inst_2 _inst_1] {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_4 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m _inst_2 Œº] {a : Œ±} {b : Œ±}, LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (CompleteSemilatticeInf.toPartialOrder.{0} ENNReal (CompleteLattice.toCompleteSemilatticeInf.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder))))) (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± m) (fun (_x : MeasureTheory.Measure.{u1} Œ± m) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± m) Œº (Set.Ioo.{u1} Œ± _inst_1 a b)) (Top.top.{0} ENNReal (CompleteLattice.toHasTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.completeLinearOrder)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : Preorder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : CompactIccSpace.{u1} Œ± _inst_2 _inst_1] {m : MeasurableSpace.{u1} Œ±} {Œº : MeasureTheory.Measure.{u1} Œ± m} [_inst_4 : MeasureTheory.LocallyFiniteMeasure.{u1} Œ± m _inst_2 Œº] {a : Œ±} {b : Œ±}, LT.lt.{0} ENNReal (Preorder.toLT.{0} ENNReal (PartialOrder.toPreorder.{0} ENNReal (OmegaCompletePartialOrder.toPartialOrder.{0} ENNReal (CompleteLattice.instOmegaCompletePartialOrder.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal))))) (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± m Œº) (Set.Ioo.{u1} Œ± _inst_1 a b)) (Top.top.{0} ENNReal (CompleteLattice.toTop.{0} ENNReal (CompleteLinearOrder.toCompleteLattice.{0} ENNReal ENNReal.instCompleteLinearOrderENNReal)))
Case conversion may be inaccurate. Consider using '#align measure_Ioo_lt_top measure_Ioo_lt_top‚Çì'. -/
theorem measure_Ioo_lt_top : Œº (Ioo a b) < ‚àû :=
  (measure_mono Ioo_subset_Icc_self).trans_lt measure_Icc_lt_top
#align measure_Ioo_lt_top measure_Ioo_lt_top

end MeasureIxx

section Piecewise

variable [MeasurableSpace Œ±] {Œº : Measure Œ±} {s t : Set Œ±} {f g : Œ± ‚Üí Œ≤}

/- warning: piecewise_ae_eq_restrict -> piecewise_ae_eq_restrict is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} {s : Set.{u1} Œ±} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (MeasurableSet.{u1} Œ± _inst_1 s) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 (MeasureTheory.Measure.restrict.{u1} Œ± _inst_1 Œº s)) (Set.piecewise.{u1, succ u2} Œ± (fun (·æ∞ : Œ±) => Œ≤) s f g (fun (j : Œ±) => Classical.propDecidable (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) j s))) f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] {Œº : MeasureTheory.Measure.{u2} Œ± _inst_1} {s : Set.{u2} Œ±} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (MeasurableSet.{u2} Œ± _inst_1 s) -> (Filter.EventuallyEq.{u2, u1} Œ± Œ≤ (MeasureTheory.Measure.ae.{u2} Œ± _inst_1 (MeasureTheory.Measure.restrict.{u2} Œ± _inst_1 Œº s)) (Set.piecewise.{u2, succ u1} Œ± (fun (·æ∞ : Œ±) => Œ≤) s f g (fun (j : Œ±) => Classical.propDecidable (Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) j s))) f)
Case conversion may be inaccurate. Consider using '#align piecewise_ae_eq_restrict piecewise_ae_eq_restrict‚Çì'. -/
theorem piecewise_ae_eq_restrict (hs : MeasurableSet s) : piecewise s f g =·µê[Œº.restrict s] f :=
  by
  rw [ae_restrict_eq hs]
  exact (piecewise_eq_on s f g).EventuallyEq.filter_mono inf_le_right
#align piecewise_ae_eq_restrict piecewise_ae_eq_restrict

/- warning: piecewise_ae_eq_restrict_compl -> piecewise_ae_eq_restrict_compl is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} {s : Set.{u1} Œ±} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (MeasurableSet.{u1} Œ± _inst_1 s) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 (MeasureTheory.Measure.restrict.{u1} Œ± _inst_1 Œº (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s))) (Set.piecewise.{u1, succ u2} Œ± (fun (·æ∞ : Œ±) => Œ≤) s f g (fun (j : Œ±) => Classical.propDecidable (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) j s))) g)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] {Œº : MeasureTheory.Measure.{u2} Œ± _inst_1} {s : Set.{u2} Œ±} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (MeasurableSet.{u2} Œ± _inst_1 s) -> (Filter.EventuallyEq.{u2, u1} Œ± Œ≤ (MeasureTheory.Measure.ae.{u2} Œ± _inst_1 (MeasureTheory.Measure.restrict.{u2} Œ± _inst_1 Œº (HasCompl.compl.{u2} (Set.{u2} Œ±) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} Œ±) (Set.instBooleanAlgebraSet.{u2} Œ±)) s))) (Set.piecewise.{u2, succ u1} Œ± (fun (·æ∞ : Œ±) => Œ≤) s f g (fun (j : Œ±) => Classical.propDecidable (Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) j s))) g)
Case conversion may be inaccurate. Consider using '#align piecewise_ae_eq_restrict_compl piecewise_ae_eq_restrict_compl‚Çì'. -/
theorem piecewise_ae_eq_restrict_compl (hs : MeasurableSet s) :
    piecewise s f g =·µê[Œº.restrict (s·∂ú)] g :=
  by
  rw [ae_restrict_eq hs.compl]
  exact (piecewise_eq_on_compl s f g).EventuallyEq.filter_mono inf_le_right
#align piecewise_ae_eq_restrict_compl piecewise_ae_eq_restrict_compl

/- warning: piecewise_ae_eq_of_ae_eq_set -> piecewise_ae_eq_of_ae_eq_set is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 Œº) s t) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 Œº) (Set.piecewise.{u1, succ u2} Œ± (fun (·æ∞ : Œ±) => Œ≤) s f g (fun (j : Œ±) => Classical.propDecidable (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) j s))) (Set.piecewise.{u1, succ u2} Œ± (fun (·æ∞ : Œ±) => Œ≤) t f g (fun (j : Œ±) => Classical.propDecidable (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) j t))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] {Œº : MeasureTheory.Measure.{u2} Œ± _inst_1} {s : Set.{u2} Œ±} {t : Set.{u2} Œ±} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (Filter.EventuallyEq.{u2, 0} Œ± Prop (MeasureTheory.Measure.ae.{u2} Œ± _inst_1 Œº) s t) -> (Filter.EventuallyEq.{u2, u1} Œ± Œ≤ (MeasureTheory.Measure.ae.{u2} Œ± _inst_1 Œº) (Set.piecewise.{u2, succ u1} Œ± (fun (·æ∞ : Œ±) => Œ≤) s f g (fun (j : Œ±) => Classical.propDecidable (Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) j s))) (Set.piecewise.{u2, succ u1} Œ± (fun (·æ∞ : Œ±) => Œ≤) t f g (fun (j : Œ±) => Classical.propDecidable (Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) j t))))
Case conversion may be inaccurate. Consider using '#align piecewise_ae_eq_of_ae_eq_set piecewise_ae_eq_of_ae_eq_set‚Çì'. -/
theorem piecewise_ae_eq_of_ae_eq_set (hst : s =·µê[Œº] t) : s.piecewise f g =·µê[Œº] t.piecewise f g :=
  hst.mem_iff.mono fun x hx => by simp [piecewise, hx]
#align piecewise_ae_eq_of_ae_eq_set piecewise_ae_eq_of_ae_eq_set

end Piecewise

section IndicatorFunction

variable [MeasurableSpace Œ±] {Œº : Measure Œ±} {s t : Set Œ±} {f : Œ± ‚Üí Œ≤}

#print mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem /-
theorem mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem [Zero Œ≤] {t : Set Œ≤}
    (ht : (0 : Œ≤) ‚àà t) (hs : MeasurableSet s) :
    t ‚àà Filter.map (s.indicator f) Œº.ae ‚Üî t ‚àà Filter.map f (Œº.restrict s).ae :=
  by
  simp_rw [mem_map, mem_ae_iff]
  rw [measure.restrict_apply' hs, Set.indicator_preimage, Set.ite]
  simp_rw [Set.compl_union, Set.compl_inter]
  change Œº (((f ‚Åª¬π' t)·∂ú ‚à™ s·∂ú) ‚à© ((fun x => (0 : Œ≤)) ‚Åª¬π' t \ s)·∂ú) = 0 ‚Üî Œº ((f ‚Åª¬π' t)·∂ú ‚à© s) = 0
  simp only [ht, ‚Üê Set.compl_eq_univ_diff, compl_compl, Set.compl_union, if_true,
    Set.preimage_const]
  simp_rw [Set.union_inter_distrib_right, Set.compl_inter_self s, Set.union_empty]
#align mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem
-/

/- warning: mem_map_indicator_ae_iff_of_zero_nmem -> mem_map_indicator_ae_iff_of_zero_nmem is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} {s : Set.{u1} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u2} Œ≤] {t : Set.{u2} Œ≤}, (Not (Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) (OfNat.ofNat.{u2} Œ≤ 0 (OfNat.mk.{u2} Œ≤ 0 (Zero.zero.{u2} Œ≤ _inst_2))) t)) -> (Iff (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) t (Filter.map.{u1, u2} Œ± Œ≤ (Set.indicator.{u1, u2} Œ± Œ≤ _inst_2 s f) (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 Œº))) (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_1) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_1) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_1) Œº (Union.union.{u1} (Set.{u1} Œ±) (Set.hasUnion.{u1} Œ±) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) (Set.preimage.{u1, u2} Œ± Œ≤ f t)) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s))) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} {s : Set.{u1} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u2} Œ≤] {t : Set.{u2} Œ≤}, (Not (Membership.mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instMembershipSet.{u2} Œ≤) (OfNat.ofNat.{u2} Œ≤ 0 (Zero.toOfNat0.{u2} Œ≤ _inst_2)) t)) -> (Iff (Membership.mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (instMembershipSetFilter.{u2} Œ≤) t (Filter.map.{u1, u2} Œ± Œ≤ (Set.indicator.{u1, u2} Œ± Œ≤ _inst_2 s f) (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 Œº))) (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u1} Œ± (MeasureTheory.Measure.toOuterMeasure.{u1} Œ± _inst_1 Œº) (Union.union.{u1} (Set.{u1} Œ±) (Set.instUnionSet.{u1} Œ±) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) (Set.preimage.{u1, u2} Œ± Œ≤ f t)) (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.instBooleanAlgebraSet.{u1} Œ±)) s))) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))))
Case conversion may be inaccurate. Consider using '#align mem_map_indicator_ae_iff_of_zero_nmem mem_map_indicator_ae_iff_of_zero_nmem‚Çì'. -/
theorem mem_map_indicator_ae_iff_of_zero_nmem [Zero Œ≤] {t : Set Œ≤} (ht : (0 : Œ≤) ‚àâ t) :
    t ‚àà Filter.map (s.indicator f) Œº.ae ‚Üî Œº ((f ‚Åª¬π' t)·∂ú ‚à™ s·∂ú) = 0 :=
  by
  rw [mem_map, mem_ae_iff, Set.indicator_preimage, Set.ite, Set.compl_union, Set.compl_inter]
  change Œº (((f ‚Åª¬π' t)·∂ú ‚à™ s·∂ú) ‚à© ((fun x => (0 : Œ≤)) ‚Åª¬π' t \ s)·∂ú) = 0 ‚Üî Œº ((f ‚Åª¬π' t)·∂ú ‚à™ s·∂ú) = 0
  simp only [ht, if_false, Set.compl_empty, Set.empty_diff, Set.inter_univ, Set.preimage_const]
#align mem_map_indicator_ae_iff_of_zero_nmem mem_map_indicator_ae_iff_of_zero_nmem

/- warning: map_restrict_ae_le_map_indicator_ae -> map_restrict_ae_le_map_indicator_ae is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} {s : Set.{u1} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u2} Œ≤], (MeasurableSet.{u1} Œ± _inst_1 s) -> (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) (Filter.map.{u1, u2} Œ± Œ≤ f (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 (MeasureTheory.Measure.restrict.{u1} Œ± _inst_1 Œº s))) (Filter.map.{u1, u2} Œ± Œ≤ (Set.indicator.{u1, u2} Œ± Œ≤ _inst_2 s f) (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 Œº)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} {s : Set.{u1} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u2} Œ≤], (MeasurableSet.{u1} Œ± _inst_1 s) -> (LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.instPartialOrderFilter.{u2} Œ≤))) (Filter.map.{u1, u2} Œ± Œ≤ f (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 (MeasureTheory.Measure.restrict.{u1} Œ± _inst_1 Œº s))) (Filter.map.{u1, u2} Œ± Œ≤ (Set.indicator.{u1, u2} Œ± Œ≤ _inst_2 s f) (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 Œº)))
Case conversion may be inaccurate. Consider using '#align map_restrict_ae_le_map_indicator_ae map_restrict_ae_le_map_indicator_ae‚Çì'. -/
theorem map_restrict_ae_le_map_indicator_ae [Zero Œ≤] (hs : MeasurableSet s) :
    Filter.map f (Œº.restrict s).ae ‚â§ Filter.map (s.indicator f) Œº.ae :=
  by
  intro t
  by_cases ht : (0 : Œ≤) ‚àà t
  ¬∑ rw [mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem ht hs]
    exact id
  rw [mem_map_indicator_ae_iff_of_zero_nmem ht, mem_map_restrict_ae_iff hs]
  exact fun h => measure_mono_null ((Set.inter_subset_left _ _).trans (Set.subset_union_left _ _)) h
#align map_restrict_ae_le_map_indicator_ae map_restrict_ae_le_map_indicator_ae

variable [Zero Œ≤]

/- warning: indicator_ae_eq_restrict -> indicator_ae_eq_restrict is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} {s : Set.{u1} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u2} Œ≤], (MeasurableSet.{u1} Œ± _inst_1 s) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 (MeasureTheory.Measure.restrict.{u1} Œ± _inst_1 Œº s)) (Set.indicator.{u1, u2} Œ± Œ≤ _inst_2 s f) f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] {Œº : MeasureTheory.Measure.{u2} Œ± _inst_1} {s : Set.{u2} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u1} Œ≤], (MeasurableSet.{u2} Œ± _inst_1 s) -> (Filter.EventuallyEq.{u2, u1} Œ± Œ≤ (MeasureTheory.Measure.ae.{u2} Œ± _inst_1 (MeasureTheory.Measure.restrict.{u2} Œ± _inst_1 Œº s)) (Set.indicator.{u2, u1} Œ± Œ≤ _inst_2 s f) f)
Case conversion may be inaccurate. Consider using '#align indicator_ae_eq_restrict indicator_ae_eq_restrict‚Çì'. -/
theorem indicator_ae_eq_restrict (hs : MeasurableSet s) : indicator s f =·µê[Œº.restrict s] f :=
  piecewise_ae_eq_restrict hs
#align indicator_ae_eq_restrict indicator_ae_eq_restrict

/- warning: indicator_ae_eq_restrict_compl -> indicator_ae_eq_restrict_compl is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} {s : Set.{u1} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u2} Œ≤], (MeasurableSet.{u1} Œ± _inst_1 s) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 (MeasureTheory.Measure.restrict.{u1} Œ± _inst_1 Œº (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s))) (Set.indicator.{u1, u2} Œ± Œ≤ _inst_2 s f) (OfNat.ofNat.{max u1 u2} (Œ± -> Œ≤) 0 (OfNat.mk.{max u1 u2} (Œ± -> Œ≤) 0 (Zero.zero.{max u1 u2} (Œ± -> Œ≤) (Pi.instZero.{u1, u2} Œ± (fun (·æ∞ : Œ±) => Œ≤) (fun (i : Œ±) => _inst_2))))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] {Œº : MeasureTheory.Measure.{u2} Œ± _inst_1} {s : Set.{u2} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u1} Œ≤], (MeasurableSet.{u2} Œ± _inst_1 s) -> (Filter.EventuallyEq.{u2, u1} Œ± Œ≤ (MeasureTheory.Measure.ae.{u2} Œ± _inst_1 (MeasureTheory.Measure.restrict.{u2} Œ± _inst_1 Œº (HasCompl.compl.{u2} (Set.{u2} Œ±) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} Œ±) (Set.instBooleanAlgebraSet.{u2} Œ±)) s))) (Set.indicator.{u2, u1} Œ± Œ≤ _inst_2 s f) (OfNat.ofNat.{max u2 u1} (Œ± -> Œ≤) 0 (Zero.toOfNat0.{max u2 u1} (Œ± -> Œ≤) (Pi.instZero.{u2, u1} Œ± (fun (a._@.Mathlib.Order.Filter.Basic._hyg.19133 : Œ±) => Œ≤) (fun (i : Œ±) => _inst_2)))))
Case conversion may be inaccurate. Consider using '#align indicator_ae_eq_restrict_compl indicator_ae_eq_restrict_compl‚Çì'. -/
theorem indicator_ae_eq_restrict_compl (hs : MeasurableSet s) :
    indicator s f =·µê[Œº.restrict (s·∂ú)] 0 :=
  piecewise_ae_eq_restrict_compl hs
#align indicator_ae_eq_restrict_compl indicator_ae_eq_restrict_compl

/- warning: indicator_ae_eq_of_restrict_compl_ae_eq_zero -> indicator_ae_eq_of_restrict_compl_ae_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} {s : Set.{u1} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u2} Œ≤], (MeasurableSet.{u1} Œ± _inst_1 s) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 (MeasureTheory.Measure.restrict.{u1} Œ± _inst_1 Œº (HasCompl.compl.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±)) s))) f (OfNat.ofNat.{max u1 u2} (Œ± -> Œ≤) 0 (OfNat.mk.{max u1 u2} (Œ± -> Œ≤) 0 (Zero.zero.{max u1 u2} (Œ± -> Œ≤) (Pi.instZero.{u1, u2} Œ± (fun (·æ∞ : Œ±) => Œ≤) (fun (i : Œ±) => _inst_2)))))) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 Œº) (Set.indicator.{u1, u2} Œ± Œ≤ _inst_2 s f) f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] {Œº : MeasureTheory.Measure.{u2} Œ± _inst_1} {s : Set.{u2} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u1} Œ≤], (MeasurableSet.{u2} Œ± _inst_1 s) -> (Filter.EventuallyEq.{u2, u1} Œ± Œ≤ (MeasureTheory.Measure.ae.{u2} Œ± _inst_1 (MeasureTheory.Measure.restrict.{u2} Œ± _inst_1 Œº (HasCompl.compl.{u2} (Set.{u2} Œ±) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} Œ±) (Set.instBooleanAlgebraSet.{u2} Œ±)) s))) f (OfNat.ofNat.{max u2 u1} (Œ± -> Œ≤) 0 (Zero.toOfNat0.{max u2 u1} (Œ± -> Œ≤) (Pi.instZero.{u2, u1} Œ± (fun (a._@.Mathlib.Order.Filter.Basic._hyg.19133 : Œ±) => Œ≤) (fun (i : Œ±) => _inst_2))))) -> (Filter.EventuallyEq.{u2, u1} Œ± Œ≤ (MeasureTheory.Measure.ae.{u2} Œ± _inst_1 Œº) (Set.indicator.{u2, u1} Œ± Œ≤ _inst_2 s f) f)
Case conversion may be inaccurate. Consider using '#align indicator_ae_eq_of_restrict_compl_ae_eq_zero indicator_ae_eq_of_restrict_compl_ae_eq_zero‚Çì'. -/
theorem indicator_ae_eq_of_restrict_compl_ae_eq_zero (hs : MeasurableSet s)
    (hf : f =·µê[Œº.restrict (s·∂ú)] 0) : s.indicator f =·µê[Œº] f :=
  by
  rw [Filter.EventuallyEq, ae_restrict_iff' hs.compl] at hf
  filter_upwards [hf]with x hx
  by_cases hxs : x ‚àà s
  ¬∑ simp only [hxs, Set.indicator_of_mem]
  ¬∑ simp only [hx hxs, Pi.zero_apply, Set.indicator_apply_eq_zero, eq_self_iff_true, imp_true_iff]
#align indicator_ae_eq_of_restrict_compl_ae_eq_zero indicator_ae_eq_of_restrict_compl_ae_eq_zero

/- warning: indicator_ae_eq_zero_of_restrict_ae_eq_zero -> indicator_ae_eq_zero_of_restrict_ae_eq_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} {s : Set.{u1} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u2} Œ≤], (MeasurableSet.{u1} Œ± _inst_1 s) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 (MeasureTheory.Measure.restrict.{u1} Œ± _inst_1 Œº s)) f (OfNat.ofNat.{max u1 u2} (Œ± -> Œ≤) 0 (OfNat.mk.{max u1 u2} (Œ± -> Œ≤) 0 (Zero.zero.{max u1 u2} (Œ± -> Œ≤) (Pi.instZero.{u1, u2} Œ± (fun (·æ∞ : Œ±) => Œ≤) (fun (i : Œ±) => _inst_2)))))) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 Œº) (Set.indicator.{u1, u2} Œ± Œ≤ _inst_2 s f) (OfNat.ofNat.{max u1 u2} (Œ± -> Œ≤) 0 (OfNat.mk.{max u1 u2} (Œ± -> Œ≤) 0 (Zero.zero.{max u1 u2} (Œ± -> Œ≤) (Pi.instZero.{u1, u2} Œ± (fun (·æ∞ : Œ±) => Œ≤) (fun (i : Œ±) => _inst_2))))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] {Œº : MeasureTheory.Measure.{u2} Œ± _inst_1} {s : Set.{u2} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u1} Œ≤], (MeasurableSet.{u2} Œ± _inst_1 s) -> (Filter.EventuallyEq.{u2, u1} Œ± Œ≤ (MeasureTheory.Measure.ae.{u2} Œ± _inst_1 (MeasureTheory.Measure.restrict.{u2} Œ± _inst_1 Œº s)) f (OfNat.ofNat.{max u2 u1} (Œ± -> Œ≤) 0 (Zero.toOfNat0.{max u2 u1} (Œ± -> Œ≤) (Pi.instZero.{u2, u1} Œ± (fun (a._@.Mathlib.Order.Filter.Basic._hyg.19133 : Œ±) => Œ≤) (fun (i : Œ±) => _inst_2))))) -> (Filter.EventuallyEq.{u2, u1} Œ± Œ≤ (MeasureTheory.Measure.ae.{u2} Œ± _inst_1 Œº) (Set.indicator.{u2, u1} Œ± Œ≤ _inst_2 s f) (OfNat.ofNat.{max u2 u1} (Œ± -> Œ≤) 0 (Zero.toOfNat0.{max u2 u1} (Œ± -> Œ≤) (Pi.instZero.{u2, u1} Œ± (fun (a._@.Mathlib.Order.Filter.Basic._hyg.19133 : Œ±) => Œ≤) (fun (i : Œ±) => _inst_2)))))
Case conversion may be inaccurate. Consider using '#align indicator_ae_eq_zero_of_restrict_ae_eq_zero indicator_ae_eq_zero_of_restrict_ae_eq_zero‚Çì'. -/
theorem indicator_ae_eq_zero_of_restrict_ae_eq_zero (hs : MeasurableSet s)
    (hf : f =·µê[Œº.restrict s] 0) : s.indicator f =·µê[Œº] 0 :=
  by
  rw [Filter.EventuallyEq, ae_restrict_iff' hs] at hf
  filter_upwards [hf]with x hx
  by_cases hxs : x ‚àà s
  ¬∑ simp only [hxs, hx hxs, Set.indicator_of_mem]
  ¬∑ simp [hx, hxs]
#align indicator_ae_eq_zero_of_restrict_ae_eq_zero indicator_ae_eq_zero_of_restrict_ae_eq_zero

/- warning: indicator_ae_eq_of_ae_eq_set -> indicator_ae_eq_of_ae_eq_set is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} {s : Set.{u1} Œ±} {t : Set.{u1} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u2} Œ≤], (Filter.EventuallyEq.{u1, 0} Œ± Prop (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 Œº) s t) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 Œº) (Set.indicator.{u1, u2} Œ± Œ≤ _inst_2 s f) (Set.indicator.{u1, u2} Œ± Œ≤ _inst_2 t f))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] {Œº : MeasureTheory.Measure.{u2} Œ± _inst_1} {s : Set.{u2} Œ±} {t : Set.{u2} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u1} Œ≤], (Filter.EventuallyEq.{u2, 0} Œ± Prop (MeasureTheory.Measure.ae.{u2} Œ± _inst_1 Œº) s t) -> (Filter.EventuallyEq.{u2, u1} Œ± Œ≤ (MeasureTheory.Measure.ae.{u2} Œ± _inst_1 Œº) (Set.indicator.{u2, u1} Œ± Œ≤ _inst_2 s f) (Set.indicator.{u2, u1} Œ± Œ≤ _inst_2 t f))
Case conversion may be inaccurate. Consider using '#align indicator_ae_eq_of_ae_eq_set indicator_ae_eq_of_ae_eq_set‚Çì'. -/
theorem indicator_ae_eq_of_ae_eq_set (hst : s =·µê[Œº] t) : s.indicator f =·µê[Œº] t.indicator f :=
  piecewise_ae_eq_of_ae_eq_set hst
#align indicator_ae_eq_of_ae_eq_set indicator_ae_eq_of_ae_eq_set

/- warning: indicator_meas_zero -> indicator_meas_zero is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} {s : Set.{u1} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u2} Œ≤], (Eq.{1} ENNReal (coeFn.{succ u1, succ u1} (MeasureTheory.Measure.{u1} Œ± _inst_1) (fun (_x : MeasureTheory.Measure.{u1} Œ± _inst_1) => (Set.{u1} Œ±) -> ENNReal) (MeasureTheory.Measure.instCoeFun.{u1} Œ± _inst_1) Œº s) (OfNat.ofNat.{0} ENNReal 0 (OfNat.mk.{0} ENNReal 0 (Zero.zero.{0} ENNReal ENNReal.hasZero)))) -> (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 Œº) (Set.indicator.{u1, u2} Œ± Œ≤ _inst_2 s f) (OfNat.ofNat.{max u1 u2} (Œ± -> Œ≤) 0 (OfNat.mk.{max u1 u2} (Œ± -> Œ≤) 0 (Zero.zero.{max u1 u2} (Œ± -> Œ≤) (Pi.instZero.{u1, u2} Œ± (fun (·æ∞ : Œ±) => Œ≤) (fun (i : Œ±) => _inst_2))))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] {Œº : MeasureTheory.Measure.{u2} Œ± _inst_1} {s : Set.{u2} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u1} Œ≤], (Eq.{1} ENNReal (MeasureTheory.OuterMeasure.measureOf.{u2} Œ± (MeasureTheory.Measure.toOuterMeasure.{u2} Œ± _inst_1 Œº) s) (OfNat.ofNat.{0} ENNReal 0 (Zero.toOfNat0.{0} ENNReal instENNRealZero))) -> (Filter.EventuallyEq.{u2, u1} Œ± Œ≤ (MeasureTheory.Measure.ae.{u2} Œ± _inst_1 Œº) (Set.indicator.{u2, u1} Œ± Œ≤ _inst_2 s f) (OfNat.ofNat.{max u2 u1} (Œ± -> Œ≤) 0 (Zero.toOfNat0.{max u2 u1} (Œ± -> Œ≤) (Pi.instZero.{u2, u1} Œ± (fun (a._@.Mathlib.Order.Filter.Basic._hyg.19133 : Œ±) => Œ≤) (fun (i : Œ±) => _inst_2)))))
Case conversion may be inaccurate. Consider using '#align indicator_meas_zero indicator_meas_zero‚Çì'. -/
theorem indicator_meas_zero (hs : Œº s = 0) : indicator s f =·µê[Œº] 0 :=
  indicator_empty' f ‚ñ∏ indicator_ae_eq_of_ae_eq_set (ae_eq_empty.2 hs)
#align indicator_meas_zero indicator_meas_zero

/- warning: ae_eq_restrict_iff_indicator_ae_eq -> ae_eq_restrict_iff_indicator_ae_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : MeasurableSpace.{u1} Œ±] {Œº : MeasureTheory.Measure.{u1} Œ± _inst_1} {s : Set.{u1} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u2} Œ≤] {g : Œ± -> Œ≤}, (MeasurableSet.{u1} Œ± _inst_1 s) -> (Iff (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 (MeasureTheory.Measure.restrict.{u1} Œ± _inst_1 Œº s)) f g) (Filter.EventuallyEq.{u1, u2} Œ± Œ≤ (MeasureTheory.Measure.ae.{u1} Œ± _inst_1 Œº) (Set.indicator.{u1, u2} Œ± Œ≤ _inst_2 s f) (Set.indicator.{u1, u2} Œ± Œ≤ _inst_2 s g)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : MeasurableSpace.{u2} Œ±] {Œº : MeasureTheory.Measure.{u2} Œ± _inst_1} {s : Set.{u2} Œ±} {f : Œ± -> Œ≤} [_inst_2 : Zero.{u1} Œ≤] {g : Œ± -> Œ≤}, (MeasurableSet.{u2} Œ± _inst_1 s) -> (Iff (Filter.EventuallyEq.{u2, u1} Œ± Œ≤ (MeasureTheory.Measure.ae.{u2} Œ± _inst_1 (MeasureTheory.Measure.restrict.{u2} Œ± _inst_1 Œº s)) f g) (Filter.EventuallyEq.{u2, u1} Œ± Œ≤ (MeasureTheory.Measure.ae.{u2} Œ± _inst_1 Œº) (Set.indicator.{u2, u1} Œ± Œ≤ _inst_2 s f) (Set.indicator.{u2, u1} Œ± Œ≤ _inst_2 s g)))
Case conversion may be inaccurate. Consider using '#align ae_eq_restrict_iff_indicator_ae_eq ae_eq_restrict_iff_indicator_ae_eq‚Çì'. -/
theorem ae_eq_restrict_iff_indicator_ae_eq {g : Œ± ‚Üí Œ≤} (hs : MeasurableSet s) :
    f =·µê[Œº.restrict s] g ‚Üî s.indicator f =·µê[Œº] s.indicator g :=
  by
  rw [Filter.EventuallyEq, ae_restrict_iff' hs]
  refine' ‚ü®fun h => _, fun h => _‚ü© <;> filter_upwards [h]with x hx
  ¬∑ by_cases hxs : x ‚àà s
    ¬∑ simp [hxs, hx hxs]
    ¬∑ simp [hxs]
  ¬∑ intro hxs
    simpa [hxs] using hx
#align ae_eq_restrict_iff_indicator_ae_eq ae_eq_restrict_iff_indicator_ae_eq

end IndicatorFunction

