/-
Copyright (c) 2022 Jesse Reimann. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jesse Reimann, Kalle Kytölä

! This file was ported from Lean 3 source module measure_theory.integral.riesz_markov_kakutani
! leanprover-community/mathlib commit b2ff9a3d7a15fd5b0f060b135421d6a89a999c2f
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Topology.ContinuousFunction.Bounded
import Mathbin.Topology.Sets.Compacts

/-!
#  Riesz–Markov–Kakutani representation theorem

This file will prove different versions of the Riesz-Markov-Kakutani representation theorem.
The theorem is first proven for compact spaces, from which the statements about linear functionals
on bounded continuous functions or compactly supported functions on locally compact spaces follow.

To make use of the existing API, the measure is constructed from a content `λ` on the
compact subsets of the space X, rather than the usual construction of open sets in the literature.

## References

* [Walter Rudin, Real and Complex Analysis.][Rud87]

-/


noncomputable section

open BoundedContinuousFunction NNReal ENNReal

open Set Function TopologicalSpace

variable {X : Type _} [TopologicalSpace X]

variable (Λ : (X →ᵇ ℝ≥0) →ₗ[ℝ≥0] ℝ≥0)

/-! ### Construction of the content: -/


/- warning: riesz_content_aux -> rieszContentAux is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X], (LinearMap.{0, 0, u1, 0} NNReal NNReal NNReal.semiring NNReal.semiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) NNReal (BoundedContinuousFunction.addAddCommMonoid.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal NNReal.pseudoMetricSpace _inst_1 NNReal.pseudoMetricSpace NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (Semiring.toModule.{0} NNReal NNReal.semiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal NNReal.semiring)) -> (TopologicalSpace.Compacts.{u1} X _inst_1) -> NNReal
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X], (LinearMap.{0, 0, u1, 0} NNReal NNReal instNNRealSemiring instNNRealSemiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) NNReal (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal instPseudoMetricSpaceNNReal _inst_1 instPseudoMetricSpaceNNReal instNNRealSemiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (Semiring.toModule.{0} NNReal instNNRealSemiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal instNNRealSemiring)) -> (TopologicalSpace.Compacts.{u1} X _inst_1) -> NNReal
Case conversion may be inaccurate. Consider using '#align riesz_content_aux rieszContentAuxₓ'. -/
/-- Given a positive linear functional Λ on X, for `K ⊆ X` compact define
`λ(K) = inf {Λf | 1≤f on K}`. When X is a compact Hausdorff space, this will be shown to be a
content, and will be shown to agree with the Riesz measure on the compact subsets `K ⊆ X`. -/
def rieszContentAux : Compacts X → ℝ≥0 := fun K =>
  sInf (Λ '' { f : X →ᵇ ℝ≥0 | ∀ x ∈ K, (1 : ℝ≥0) ≤ f x })
#align riesz_content_aux rieszContentAux

section RieszMonotone

/- warning: riesz_content_aux_image_nonempty -> riesz_content_aux_image_nonempty is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] (Λ : LinearMap.{0, 0, u1, 0} NNReal NNReal NNReal.semiring NNReal.semiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) NNReal (BoundedContinuousFunction.addAddCommMonoid.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal NNReal.pseudoMetricSpace _inst_1 NNReal.pseudoMetricSpace NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (Semiring.toModule.{0} NNReal NNReal.semiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal NNReal.semiring)) (K : TopologicalSpace.Compacts.{u1} X _inst_1), Set.Nonempty.{0} NNReal (Set.image.{u1, 0} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) NNReal (coeFn.{succ u1, succ u1} (LinearMap.{0, 0, u1, 0} NNReal NNReal NNReal.semiring NNReal.semiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) NNReal (BoundedContinuousFunction.addAddCommMonoid.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal NNReal.pseudoMetricSpace _inst_1 NNReal.pseudoMetricSpace NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (Semiring.toModule.{0} NNReal NNReal.semiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal NNReal.semiring)) (fun (_x : LinearMap.{0, 0, u1, 0} NNReal NNReal NNReal.semiring NNReal.semiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) NNReal (BoundedContinuousFunction.addAddCommMonoid.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal NNReal.pseudoMetricSpace _inst_1 NNReal.pseudoMetricSpace NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (Semiring.toModule.{0} NNReal NNReal.semiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal NNReal.semiring)) => (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) -> NNReal) (LinearMap.hasCoeToFun.{0, 0, u1, 0} NNReal NNReal (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) NNReal NNReal.semiring NNReal.semiring (BoundedContinuousFunction.addAddCommMonoid.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal NNReal.pseudoMetricSpace _inst_1 NNReal.pseudoMetricSpace NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (Semiring.toModule.{0} NNReal NNReal.semiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal NNReal.semiring) (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) Λ) (setOf.{u1} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) (fun (f : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) => forall (x : X), (Membership.Mem.{u1, u1} X (TopologicalSpace.Compacts.{u1} X _inst_1) (SetLike.hasMem.{u1, u1} (TopologicalSpace.Compacts.{u1} X _inst_1) X (TopologicalSpace.Compacts.setLike.{u1} X _inst_1)) x K) -> (LE.le.{0} NNReal (Preorder.toHasLe.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (OfNat.ofNat.{0} NNReal 1 (OfNat.mk.{0} NNReal 1 (One.one.{0} NNReal (AddMonoidWithOne.toOne.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) => X -> NNReal) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) f x)))))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] (Λ : LinearMap.{0, 0, u1, 0} NNReal NNReal instNNRealSemiring instNNRealSemiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) NNReal (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal instPseudoMetricSpaceNNReal _inst_1 instPseudoMetricSpaceNNReal instNNRealSemiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (Semiring.toModule.{0} NNReal instNNRealSemiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal instNNRealSemiring)) (K : TopologicalSpace.Compacts.{u1} X _inst_1), Set.Nonempty.{0} NNReal (Set.image.{u1, 0} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) NNReal (FunLike.coe.{succ u1, succ u1, 1} (LinearMap.{0, 0, u1, 0} NNReal NNReal instNNRealSemiring instNNRealSemiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) NNReal (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal instPseudoMetricSpaceNNReal _inst_1 instPseudoMetricSpaceNNReal instNNRealSemiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (Semiring.toModule.{0} NNReal instNNRealSemiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal instNNRealSemiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) (fun (_x : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) => NNReal) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u1, 0} NNReal NNReal (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) NNReal instNNRealSemiring instNNRealSemiring (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal instPseudoMetricSpaceNNReal _inst_1 instPseudoMetricSpaceNNReal instNNRealSemiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (Semiring.toModule.{0} NNReal instNNRealSemiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal instNNRealSemiring) (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) Λ) (setOf.{u1} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) (fun (f : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) => forall (x : X), (Membership.mem.{u1, u1} X (TopologicalSpace.Compacts.{u1} X _inst_1) (SetLike.instMembership.{u1, u1} (TopologicalSpace.Compacts.{u1} X _inst_1) X (TopologicalSpace.Compacts.instSetLikeCompacts.{u1} X _inst_1)) x K) -> (LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (OfNat.ofNat.{0} NNReal 1 (One.toOfNat1.{0} NNReal instNNRealOne)) (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) X (fun (_x : X) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : X) => NNReal) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) X NNReal _inst_1 (UniformSpace.toTopologicalSpace.{0} NNReal (PseudoMetricSpace.toUniformSpace.{0} NNReal instPseudoMetricSpaceNNReal)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) X NNReal _inst_1 instPseudoMetricSpaceNNReal (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal))) f x)))))
Case conversion may be inaccurate. Consider using '#align riesz_content_aux_image_nonempty riesz_content_aux_image_nonemptyₓ'. -/
/-- For any compact subset `K ⊆ X`, there exist some bounded continuous nonnegative
functions f on X such that `f ≥ 1` on K. -/
theorem riesz_content_aux_image_nonempty (K : Compacts X) :
    (Λ '' { f : X →ᵇ ℝ≥0 | ∀ x ∈ K, (1 : ℝ≥0) ≤ f x }).Nonempty :=
  by
  rw [nonempty_image_iff]
  use (1 : X →ᵇ ℝ≥0)
  intro x x_in_K
  simp only [BoundedContinuousFunction.coe_one, Pi.one_apply]
#align riesz_content_aux_image_nonempty riesz_content_aux_image_nonempty

/- warning: riesz_content_aux_mono -> rieszContentAux_mono is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] (Λ : LinearMap.{0, 0, u1, 0} NNReal NNReal NNReal.semiring NNReal.semiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) NNReal (BoundedContinuousFunction.addAddCommMonoid.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal NNReal.pseudoMetricSpace _inst_1 NNReal.pseudoMetricSpace NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (Semiring.toModule.{0} NNReal NNReal.semiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal NNReal.semiring)) {K₁ : TopologicalSpace.Compacts.{u1} X _inst_1} {K₂ : TopologicalSpace.Compacts.{u1} X _inst_1}, (LE.le.{u1} (TopologicalSpace.Compacts.{u1} X _inst_1) (Preorder.toHasLe.{u1} (TopologicalSpace.Compacts.{u1} X _inst_1) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Compacts.{u1} X _inst_1) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Compacts.{u1} X _inst_1) X (TopologicalSpace.Compacts.setLike.{u1} X _inst_1)))) K₁ K₂) -> (LE.le.{0} NNReal (Preorder.toHasLe.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (rieszContentAux.{u1} X _inst_1 Λ K₁) (rieszContentAux.{u1} X _inst_1 Λ K₂))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] (Λ : LinearMap.{0, 0, u1, 0} NNReal NNReal instNNRealSemiring instNNRealSemiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) NNReal (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal instPseudoMetricSpaceNNReal _inst_1 instPseudoMetricSpaceNNReal instNNRealSemiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (Semiring.toModule.{0} NNReal instNNRealSemiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal instNNRealSemiring)) {K₁ : TopologicalSpace.Compacts.{u1} X _inst_1} {K₂ : TopologicalSpace.Compacts.{u1} X _inst_1}, (LE.le.{u1} (TopologicalSpace.Compacts.{u1} X _inst_1) (Preorder.toLE.{u1} (TopologicalSpace.Compacts.{u1} X _inst_1) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Compacts.{u1} X _inst_1) (SemilatticeSup.toPartialOrder.{u1} (TopologicalSpace.Compacts.{u1} X _inst_1) (TopologicalSpace.Compacts.instSemilatticeSupCompacts.{u1} X _inst_1)))) K₁ K₂) -> (LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (rieszContentAux.{u1} X _inst_1 Λ K₁) (rieszContentAux.{u1} X _inst_1 Λ K₂))
Case conversion may be inaccurate. Consider using '#align riesz_content_aux_mono rieszContentAux_monoₓ'. -/
/-- Riesz content λ (associated with a positive linear functional Λ) is
monotone: if `K₁ ⊆ K₂` are compact subsets in X, then `λ(K₁) ≤ λ(K₂)`. -/
theorem rieszContentAux_mono {K₁ K₂ : Compacts X} (h : K₁ ≤ K₂) :
    rieszContentAux Λ K₁ ≤ rieszContentAux Λ K₂ :=
  csInf_le_csInf (OrderBot.bddBelow _) (riesz_content_aux_image_nonempty Λ K₂)
    (image_subset Λ (setOf_subset_setOf.mpr fun f f_hyp x x_in_K₁ => f_hyp x (h x_in_K₁)))
#align riesz_content_aux_mono rieszContentAux_mono

end RieszMonotone

section RieszSubadditive

/- warning: riesz_content_aux_le -> rieszContentAux_le is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] (Λ : LinearMap.{0, 0, u1, 0} NNReal NNReal NNReal.semiring NNReal.semiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) NNReal (BoundedContinuousFunction.addAddCommMonoid.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal NNReal.pseudoMetricSpace _inst_1 NNReal.pseudoMetricSpace NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (Semiring.toModule.{0} NNReal NNReal.semiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal NNReal.semiring)) {K : TopologicalSpace.Compacts.{u1} X _inst_1} {f : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace}, (forall (x : X), (Membership.Mem.{u1, u1} X (TopologicalSpace.Compacts.{u1} X _inst_1) (SetLike.hasMem.{u1, u1} (TopologicalSpace.Compacts.{u1} X _inst_1) X (TopologicalSpace.Compacts.setLike.{u1} X _inst_1)) x K) -> (LE.le.{0} NNReal (Preorder.toHasLe.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (OfNat.ofNat.{0} NNReal 1 (OfNat.mk.{0} NNReal 1 (One.one.{0} NNReal (AddMonoidWithOne.toOne.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) => X -> NNReal) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) f x))) -> (LE.le.{0} NNReal (Preorder.toHasLe.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (rieszContentAux.{u1} X _inst_1 Λ K) (coeFn.{succ u1, succ u1} (LinearMap.{0, 0, u1, 0} NNReal NNReal NNReal.semiring NNReal.semiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) NNReal (BoundedContinuousFunction.addAddCommMonoid.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal NNReal.pseudoMetricSpace _inst_1 NNReal.pseudoMetricSpace NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (Semiring.toModule.{0} NNReal NNReal.semiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal NNReal.semiring)) (fun (_x : LinearMap.{0, 0, u1, 0} NNReal NNReal NNReal.semiring NNReal.semiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) NNReal (BoundedContinuousFunction.addAddCommMonoid.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal NNReal.pseudoMetricSpace _inst_1 NNReal.pseudoMetricSpace NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (Semiring.toModule.{0} NNReal NNReal.semiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal NNReal.semiring)) => (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) -> NNReal) (LinearMap.hasCoeToFun.{0, 0, u1, 0} NNReal NNReal (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) NNReal NNReal.semiring NNReal.semiring (BoundedContinuousFunction.addAddCommMonoid.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal NNReal.pseudoMetricSpace _inst_1 NNReal.pseudoMetricSpace NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (Semiring.toModule.{0} NNReal NNReal.semiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal NNReal.semiring) (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) Λ f))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] (Λ : LinearMap.{0, 0, u1, 0} NNReal NNReal instNNRealSemiring instNNRealSemiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) NNReal (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal instPseudoMetricSpaceNNReal _inst_1 instPseudoMetricSpaceNNReal instNNRealSemiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (Semiring.toModule.{0} NNReal instNNRealSemiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal instNNRealSemiring)) {K : TopologicalSpace.Compacts.{u1} X _inst_1} {f : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal}, (forall (x : X), (Membership.mem.{u1, u1} X (TopologicalSpace.Compacts.{u1} X _inst_1) (SetLike.instMembership.{u1, u1} (TopologicalSpace.Compacts.{u1} X _inst_1) X (TopologicalSpace.Compacts.instSetLikeCompacts.{u1} X _inst_1)) x K) -> (LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (OfNat.ofNat.{0} NNReal 1 (One.toOfNat1.{0} NNReal instNNRealOne)) (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) X (fun (_x : X) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : X) => NNReal) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) X NNReal _inst_1 (UniformSpace.toTopologicalSpace.{0} NNReal (PseudoMetricSpace.toUniformSpace.{0} NNReal instPseudoMetricSpaceNNReal)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) X NNReal _inst_1 instPseudoMetricSpaceNNReal (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal))) f x))) -> (LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (rieszContentAux.{u1} X _inst_1 Λ K) (FunLike.coe.{succ u1, succ u1, 1} (LinearMap.{0, 0, u1, 0} NNReal NNReal instNNRealSemiring instNNRealSemiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) NNReal (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal instPseudoMetricSpaceNNReal _inst_1 instPseudoMetricSpaceNNReal instNNRealSemiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (Semiring.toModule.{0} NNReal instNNRealSemiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal instNNRealSemiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) (fun (_x : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) => NNReal) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u1, 0} NNReal NNReal (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) NNReal instNNRealSemiring instNNRealSemiring (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal instPseudoMetricSpaceNNReal _inst_1 instPseudoMetricSpaceNNReal instNNRealSemiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (Semiring.toModule.{0} NNReal instNNRealSemiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal instNNRealSemiring) (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) Λ f))
Case conversion may be inaccurate. Consider using '#align riesz_content_aux_le rieszContentAux_leₓ'. -/
/-- Any bounded continuous nonnegative f such that `f ≥ 1` on K gives an upper bound on the
content of K; namely `λ(K) ≤ Λ f`. -/
theorem rieszContentAux_le {K : Compacts X} {f : X →ᵇ ℝ≥0} (h : ∀ x ∈ K, (1 : ℝ≥0) ≤ f x) :
    rieszContentAux Λ K ≤ Λ f :=
  csInf_le (OrderBot.bddBelow _) ⟨f, ⟨h, rfl⟩⟩
#align riesz_content_aux_le rieszContentAux_le

/- warning: exists_lt_riesz_content_aux_add_pos -> exists_lt_rieszContentAux_add_pos is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] (Λ : LinearMap.{0, 0, u1, 0} NNReal NNReal NNReal.semiring NNReal.semiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) NNReal (BoundedContinuousFunction.addAddCommMonoid.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal NNReal.pseudoMetricSpace _inst_1 NNReal.pseudoMetricSpace NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (Semiring.toModule.{0} NNReal NNReal.semiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal NNReal.semiring)) (K : TopologicalSpace.Compacts.{u1} X _inst_1) {ε : NNReal}, (LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (OfNat.ofNat.{0} NNReal 0 (OfNat.mk.{0} NNReal 0 (Zero.zero.{0} NNReal (MulZeroClass.toHasZero.{0} NNReal (NonUnitalNonAssocSemiring.toMulZeroClass.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) ε) -> (Exists.{succ u1} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) (fun (f : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) => And (forall (x : X), (Membership.Mem.{u1, u1} X (TopologicalSpace.Compacts.{u1} X _inst_1) (SetLike.hasMem.{u1, u1} (TopologicalSpace.Compacts.{u1} X _inst_1) X (TopologicalSpace.Compacts.setLike.{u1} X _inst_1)) x K) -> (LE.le.{0} NNReal (Preorder.toHasLe.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (OfNat.ofNat.{0} NNReal 1 (OfNat.mk.{0} NNReal 1 (One.one.{0} NNReal (AddMonoidWithOne.toOne.{0} NNReal (AddCommMonoidWithOne.toAddMonoidWithOne.{0} NNReal (NonAssocSemiring.toAddCommMonoidWithOne.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) (coeFn.{succ u1, succ u1} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) (fun (_x : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) => X -> NNReal) (BoundedContinuousFunction.hasCoeToFun.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) f x))) (LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (coeFn.{succ u1, succ u1} (LinearMap.{0, 0, u1, 0} NNReal NNReal NNReal.semiring NNReal.semiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) NNReal (BoundedContinuousFunction.addAddCommMonoid.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal NNReal.pseudoMetricSpace _inst_1 NNReal.pseudoMetricSpace NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (Semiring.toModule.{0} NNReal NNReal.semiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal NNReal.semiring)) (fun (_x : LinearMap.{0, 0, u1, 0} NNReal NNReal NNReal.semiring NNReal.semiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) NNReal (BoundedContinuousFunction.addAddCommMonoid.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal NNReal.pseudoMetricSpace _inst_1 NNReal.pseudoMetricSpace NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (Semiring.toModule.{0} NNReal NNReal.semiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal NNReal.semiring)) => (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) -> NNReal) (LinearMap.hasCoeToFun.{0, 0, u1, 0} NNReal NNReal (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) NNReal NNReal.semiring NNReal.semiring (BoundedContinuousFunction.addAddCommMonoid.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal NNReal.pseudoMetricSpace _inst_1 NNReal.pseudoMetricSpace NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (Semiring.toModule.{0} NNReal NNReal.semiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal NNReal.semiring) (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) Λ f) (HAdd.hAdd.{0, 0, 0} NNReal NNReal NNReal (instHAdd.{0} NNReal (Distrib.toHasAdd.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))) (rieszContentAux.{u1} X _inst_1 Λ K) ε))))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] (Λ : LinearMap.{0, 0, u1, 0} NNReal NNReal instNNRealSemiring instNNRealSemiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) NNReal (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal instPseudoMetricSpaceNNReal _inst_1 instPseudoMetricSpaceNNReal instNNRealSemiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (Semiring.toModule.{0} NNReal instNNRealSemiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal instNNRealSemiring)) (K : TopologicalSpace.Compacts.{u1} X _inst_1) {ε : NNReal}, (LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (OfNat.ofNat.{0} NNReal 0 (Zero.toOfNat0.{0} NNReal instNNRealZero)) ε) -> (Exists.{succ u1} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) (fun (f : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) => And (forall (x : X), (Membership.mem.{u1, u1} X (TopologicalSpace.Compacts.{u1} X _inst_1) (SetLike.instMembership.{u1, u1} (TopologicalSpace.Compacts.{u1} X _inst_1) X (TopologicalSpace.Compacts.instSetLikeCompacts.{u1} X _inst_1)) x K) -> (LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (OfNat.ofNat.{0} NNReal 1 (One.toOfNat1.{0} NNReal instNNRealOne)) (FunLike.coe.{succ u1, succ u1, 1} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) X (fun (_x : X) => (fun (a._@.Mathlib.Topology.ContinuousFunction.Bounded._hyg.904 : X) => NNReal) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) X NNReal _inst_1 (UniformSpace.toTopologicalSpace.{0} NNReal (PseudoMetricSpace.toUniformSpace.{0} NNReal instPseudoMetricSpaceNNReal)) (BoundedContinuousMapClass.toContinuousMapClass.{u1, u1, 0} (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) X NNReal _inst_1 instPseudoMetricSpaceNNReal (BoundedContinuousFunction.instBoundedContinuousMapClassBoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal))) f x))) (LT.lt.{0} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) => NNReal) f) (Preorder.toLT.{0} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) => NNReal) f) (PartialOrder.toPreorder.{0} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) => NNReal) f) (StrictOrderedSemiring.toPartialOrder.{0} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) => NNReal) f) instNNRealStrictOrderedSemiring))) (FunLike.coe.{succ u1, succ u1, 1} (LinearMap.{0, 0, u1, 0} NNReal NNReal instNNRealSemiring instNNRealSemiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) NNReal (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal instPseudoMetricSpaceNNReal _inst_1 instPseudoMetricSpaceNNReal instNNRealSemiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (Semiring.toModule.{0} NNReal instNNRealSemiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal instNNRealSemiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) (fun (_x : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) => NNReal) _x) (LinearMap.instFunLikeLinearMap.{0, 0, u1, 0} NNReal NNReal (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) NNReal instNNRealSemiring instNNRealSemiring (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal instPseudoMetricSpaceNNReal _inst_1 instPseudoMetricSpaceNNReal instNNRealSemiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (Semiring.toModule.{0} NNReal instNNRealSemiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal instNNRealSemiring) (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) Λ f) (HAdd.hAdd.{0, 0, 0} NNReal NNReal NNReal (instHAdd.{0} NNReal (Distrib.toAdd.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))))) (rieszContentAux.{u1} X _inst_1 Λ K) ε))))
Case conversion may be inaccurate. Consider using '#align exists_lt_riesz_content_aux_add_pos exists_lt_rieszContentAux_add_posₓ'. -/
/-- The Riesz content can be approximated arbitrarily well by evaluating the positive linear
functional on test functions: for any `ε > 0`, there exists a bounded continuous nonnegative
function f on X such that `f ≥ 1` on K and such that `λ(K) ≤ Λ f < λ(K) + ε`. -/
theorem exists_lt_rieszContentAux_add_pos (K : Compacts X) {ε : ℝ≥0} (εpos : 0 < ε) :
    ∃ f : X →ᵇ ℝ≥0, (∀ x ∈ K, (1 : ℝ≥0) ≤ f x) ∧ Λ f < rieszContentAux Λ K + ε :=
  by
  --choose a test function `f` s.t. `Λf = α < λ(K) + ε`
  obtain ⟨α, ⟨⟨f, f_hyp⟩, α_hyp⟩⟩ :=
    exists_lt_of_csInf_lt (riesz_content_aux_image_nonempty Λ K)
      (lt_add_of_pos_right (rieszContentAux Λ K) εpos)
  refine' ⟨f, f_hyp.left, _⟩
  rw [f_hyp.right]
  exact α_hyp
#align exists_lt_riesz_content_aux_add_pos exists_lt_rieszContentAux_add_pos

/- warning: riesz_content_aux_sup_le -> rieszContentAux_sup_le is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] (Λ : LinearMap.{0, 0, u1, 0} NNReal NNReal NNReal.semiring NNReal.semiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace) NNReal (BoundedContinuousFunction.addAddCommMonoid.{u1, 0} X NNReal _inst_1 NNReal.pseudoMetricSpace (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal NNReal.pseudoMetricSpace _inst_1 NNReal.pseudoMetricSpace NNReal.semiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))) (Semiring.toModule.{0} NNReal NNReal.semiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal NNReal.semiring)) (K1 : TopologicalSpace.Compacts.{u1} X _inst_1) (K2 : TopologicalSpace.Compacts.{u1} X _inst_1), LE.le.{0} NNReal (Preorder.toHasLe.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (rieszContentAux.{u1} X _inst_1 Λ (Sup.sup.{u1} (TopologicalSpace.Compacts.{u1} X _inst_1) (TopologicalSpace.Compacts.hasSup.{u1} X _inst_1) K1 K2)) (HAdd.hAdd.{0, 0, 0} NNReal NNReal NNReal (instHAdd.{0} NNReal (Distrib.toHasAdd.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))) (rieszContentAux.{u1} X _inst_1 Λ K1) (rieszContentAux.{u1} X _inst_1 Λ K2))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] (Λ : LinearMap.{0, 0, u1, 0} NNReal NNReal instNNRealSemiring instNNRealSemiring (RingHom.id.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring)) (BoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal) NNReal (BoundedContinuousFunction.instAddAddCommMonoidBoundedContinuousFunction.{u1, 0} X NNReal _inst_1 instPseudoMetricSpaceNNReal (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) NNReal.hasLipschitzAdd) (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (BoundedContinuousFunction.module.{u1, 0, 0} X NNReal NNReal instPseudoMetricSpaceNNReal _inst_1 instPseudoMetricSpaceNNReal instNNRealSemiring (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))) (Semiring.toModule.{0} NNReal instNNRealSemiring) NNReal.boundedSMul NNReal.hasLipschitzAdd) (Semiring.toModule.{0} NNReal instNNRealSemiring)) (K1 : TopologicalSpace.Compacts.{u1} X _inst_1) (K2 : TopologicalSpace.Compacts.{u1} X _inst_1), LE.le.{0} NNReal (Preorder.toLE.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (rieszContentAux.{u1} X _inst_1 Λ (Sup.sup.{u1} (TopologicalSpace.Compacts.{u1} X _inst_1) (TopologicalSpace.Compacts.instSupCompacts.{u1} X _inst_1) K1 K2)) (HAdd.hAdd.{0, 0, 0} NNReal NNReal NNReal (instHAdd.{0} NNReal (Distrib.toAdd.{0} NNReal (NonUnitalNonAssocSemiring.toDistrib.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal instNNRealSemiring))))) (rieszContentAux.{u1} X _inst_1 Λ K1) (rieszContentAux.{u1} X _inst_1 Λ K2))
Case conversion may be inaccurate. Consider using '#align riesz_content_aux_sup_le rieszContentAux_sup_leₓ'. -/
/-- The Riesz content λ associated to a given positive linear functional Λ is
finitely subadditive: `λ(K₁ ∪ K₂) ≤ λ(K₁) + λ(K₂)` for any compact subsets `K₁, K₂ ⊆ X`. -/
theorem rieszContentAux_sup_le (K1 K2 : Compacts X) :
    rieszContentAux Λ (K1 ⊔ K2) ≤ rieszContentAux Λ K1 + rieszContentAux Λ K2 :=
  by
  apply NNReal.le_of_forall_pos_le_add
  intro ε εpos
  --get test functions s.t. `λ(Ki) ≤ Λfi ≤ λ(Ki) + ε/2, i=1,2`
  obtain ⟨f1, f_test_function_K1⟩ := exists_lt_rieszContentAux_add_pos Λ K1 (half_pos εpos)
  obtain ⟨f2, f_test_function_K2⟩ := exists_lt_rieszContentAux_add_pos Λ K2 (half_pos εpos)
  --let `f := f1 + f2` test function for the content of `K`
  have f_test_function_union : ∀ x ∈ K1 ⊔ K2, (1 : ℝ≥0) ≤ (f1 + f2) x :=
    by
    rintro x (x_in_K1 | x_in_K2)
    · exact le_add_right (f_test_function_K1.left x x_in_K1)
    · exact le_add_left (f_test_function_K2.left x x_in_K2)
  --use that `Λf` is an upper bound for `λ(K1⊔K2)`
  apply (rieszContentAux_le Λ f_test_function_union).trans (le_of_lt _)
  rw [map_add]
  --use that `Λfi` are lower bounds for `λ(Ki) + ε/2`
  apply lt_of_lt_of_le (add_lt_add f_test_function_K1.right f_test_function_K2.right) (le_of_eq _)
  rw [add_assoc, add_comm (ε / 2), add_assoc, add_halves ε, add_assoc]
#align riesz_content_aux_sup_le rieszContentAux_sup_le

end RieszSubadditive

