import Mathbin.MeasureTheory.Constructions.Prod

/-!
# Product measures

In this file we define and prove properties about finite products of measures
(and at some point, countable products of measures).

## Main definition

* `measure_theory.measure.pi`: The product of finitely many σ-finite measures.
  Given `μ : Π i : ι, measure (α i)` for `[fintype ι]` it has type `measure (Π i : ι, α i)`.

To apply Fubini along some subset of the variables, use
`measure_theory.measure.map_pi_equiv_pi_subtype_prod` to reduce to the situation of a product
of two measures: this lemma states that the bijection `equiv.pi_equiv_pi_subtype_prod p α`
between `(Π i : ι, α i)` and `(Π i : {i // p i}, α i) × (Π i : {i // ¬ p i}, α i)` maps a product
measure to a direct product of product measures, to which one can apply the usual Fubini for
direct product of measures.

## Implementation Notes

We define `measure_theory.outer_measure.pi`, the product of finitely many outer measures, as the
maximal outer measure `n` with the property that `n (pi univ s) ≤ ∏ i, m i (s i)`,
where `pi univ s` is the product of the sets `{s i | i : ι}`.

We then show that this induces a product of measures, called `measure_theory.measure.pi`.
For a collection of σ-finite measures `μ` and a collection of measurable sets `s` we show that
`measure.pi μ (pi univ s) = ∏ i, m i (s i)`. To do this, we follow the following steps:
* We know that there is some ordering on `ι`, given by an element of `[encodable ι]`.
* Using this, we have an equivalence `measurable_equiv.pi_measurable_equiv_tprod` between
  `Π ι, α i` and an iterated product of `α i`, called `list.tprod α l` for some list `l`.
* On this iterated product we can easily define a product measure `measure_theory.measure.tprod`
  by iterating `measure_theory.measure.prod`
* Using the previous two steps we construct `measure_theory.measure.pi'` on `Π ι, α i` for encodable
  `ι`.
* We know that `measure_theory.measure.pi'` sends products of sets to products of measures, and
  since `measure_theory.measure.pi` is the maximal such measure (or at least, it comes from an outer
  measure which is the maximal such outer measure), we get the same rule for
  `measure_theory.measure.pi`.

## Tags

finitary product measure

-/


noncomputable theory

open Function Set MeasureTheory.OuterMeasure Filter MeasurableSpace Encodable

open_locale Classical BigOperators TopologicalSpace Ennreal

universe u v

variable{ι ι' : Type _}{α : ι → Type _}

/-! We start with some measurability properties -/


/-- Boxes formed by π-systems form a π-system. -/
theorem IsPiSystem.pi {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsPiSystem (C i)) : IsPiSystem (pi univ '' pi univ C) :=
  by 
    rintro _ _ ⟨s₁, hs₁, rfl⟩ ⟨s₂, hs₂, rfl⟩ hst 
    rw [←pi_inter_distrib] at hst⊢
    rw [univ_pi_nonempty_iff] at hst 
    exact mem_image_of_mem _ fun i _ => hC i _ _ (hs₁ i (mem_univ i)) (hs₂ i (mem_univ i)) (hst i)

/-- Boxes form a π-system. -/
theorem is_pi_system_pi [∀ i, MeasurableSpace (α i)] :
  IsPiSystem (pi univ '' pi univ fun i => { s:Set (α i) | MeasurableSet s }) :=
  IsPiSystem.pi fun i => is_pi_system_measurable_set

variable[Fintype ι][Fintype ι']

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Boxes of countably spanning sets are countably spanning. -/
theorem is_countably_spanning.pi
{C : ∀ i, set (set (α i))}
(hC : ∀ i, is_countably_spanning (C i)) : is_countably_spanning «expr '' »(pi univ, pi univ C) :=
begin
  choose [] [ident s] [ident h1s, ident h2s] ["using", expr hC],
  haveI [] [] [":=", expr fintype.encodable ι],
  let [ident e] [":", expr exprℕ() → ι → exprℕ()] [":=", expr λ n, (decode (ι → exprℕ()) n).iget],
  refine [expr ⟨λ n, pi univ (λ i, s i (e n i)), λ n, mem_image_of_mem _ (λ i _, h1s i _), _⟩],
  simp_rw ["[", expr (surjective_decode_iget (ι → exprℕ())).Union_comp (λ
    x, pi univ (λ i, s i (x i))), ",", expr Union_univ_pi s, ",", expr h2s, ",", expr pi_univ, "]"] []
end

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The product of generated σ-algebras is the one generated by boxes, if both generating sets
  are countably spanning. -/
theorem generate_from_pi_eq
{C : ∀ i, set (set (α i))}
(hC : ∀
 i, is_countably_spanning (C i)) : «expr = »(@measurable_space.pi _ _ (λ
  i, generate_from (C i)), generate_from «expr '' »(pi univ, pi univ C)) :=
begin
  haveI [] [] [":=", expr fintype.encodable ι],
  apply [expr le_antisymm],
  { refine [expr supr_le _],
    intro [ident i],
    rw ["[", expr comap_generate_from, "]"] [],
    apply [expr generate_from_le],
    rintro ["_", "⟨", ident s, ",", ident hs, ",", ident rfl, "⟩"],
    dsimp [] [] [] [],
    choose [] [ident t] [ident h1t, ident h2t] ["using", expr hC],
    simp_rw ["[", expr eval_preimage, ",", "<-", expr h2t, "]"] [],
    rw ["[", "<-", expr @Union_const _ exprℕ() _ s, "]"] [],
    have [] [":", expr «expr = »(pi univ (update (λ
        i' : ι, Union (t i')) i «expr⋃ , »((i' : exprℕ()), s)), pi univ (λ
       k, «expr⋃ , »((j : exprℕ()), @update ι (λ i', set (α i')) _ (λ i', t i' j) i s k)))] [],
    { ext [] [] [],
      simp_rw ["[", expr mem_univ_pi, "]"] [],
      apply [expr forall_congr],
      intro [ident i'],
      by_cases [expr «expr = »(i', i)],
      { subst [expr h],
        simp [] [] [] [] [] [] },
      { rw ["[", "<-", expr ne.def, "]"] ["at", ident h],
        simp [] [] [] ["[", expr h, "]"] [] [] } },
    rw ["[", expr this, ",", "<-", expr Union_univ_pi, "]"] [],
    apply [expr measurable_set.Union],
    intro [ident n],
    apply [expr measurable_set_generate_from],
    apply [expr mem_image_of_mem],
    intros [ident j, "_"],
    dsimp ["only"] [] [] [],
    by_cases [expr h, ":", expr «expr = »(j, i)],
    subst [expr h],
    rwa ["[", expr update_same, "]"] [],
    rw ["[", expr update_noteq h, "]"] [],
    apply [expr h1t] },
  { apply [expr generate_from_le],
    rintro ["_", "⟨", ident s, ",", ident hs, ",", ident rfl, "⟩"],
    rw ["[", expr univ_pi_eq_Inter, "]"] [],
    apply [expr measurable_set.Inter],
    intro [ident i],
    apply [expr measurable_pi_apply],
    exact [expr measurable_set_generate_from (hs i (mem_univ i))] }
end

/-- If `C` and `D` generate the σ-algebras on `α` resp. `β`, then rectangles formed by `C` and `D`
  generate the σ-algebra on `α × β`. -/
theorem generate_from_eq_pi [h : ∀ i, MeasurableSpace (α i)] {C : ∀ i, Set (Set (α i))}
  (hC : ∀ i, generate_from (C i) = h i) (h2C : ∀ i, IsCountablySpanning (C i)) :
  generate_from (pi univ '' pi univ C) = MeasurableSpace.pi :=
  by 
    rw [←funext hC, generate_from_pi_eq h2C]

/-- The product σ-algebra is generated from boxes, i.e. `s.prod t` for sets `s : set α` and
  `t : set β`. -/
theorem generate_from_pi [∀ i, MeasurableSpace (α i)] :
  generate_from (pi univ '' pi univ fun i => { s:Set (α i) | MeasurableSet s }) = MeasurableSpace.pi :=
  generate_from_eq_pi (fun i => generate_from_measurable_set) fun i => is_countably_spanning_measurable_set

namespace MeasureTheory

variable{m : ∀ i, outer_measure (α i)}

/-- An upper bound for the measure in a finite product space.
  It is defined to by taking the image of the set under all projections, and taking the product
  of the measures of these images.
  For measurable boxes it is equal to the correct measure. -/
@[simp]
def pi_premeasure (m : ∀ i, outer_measure (α i)) (s : Set (∀ i, α i)) : ℝ≥0∞ :=
  ∏i, m i (eval i '' s)

theorem pi_premeasure_pi {s : ∀ i, Set (α i)} (hs : (pi univ s).Nonempty) :
  pi_premeasure m (pi univ s) = ∏i, m i (s i) :=
  by 
    simp [hs]

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem pi_premeasure_pi'
[nonempty ι]
{s : ∀ i, set (α i)} : «expr = »(pi_premeasure m (pi univ s), «expr∏ , »((i), m i (s i))) :=
begin
  cases [expr (pi univ s).eq_empty_or_nonempty] ["with", ident h, ident h],
  { rcases [expr univ_pi_eq_empty_iff.mp h, "with", "⟨", ident i, ",", ident hi, "⟩"],
    have [] [":", expr «expr∃ , »((i), «expr = »(m i (s i), 0))] [":=", expr ⟨i, by simp [] [] [] ["[", expr hi, "]"] [] []⟩],
    simpa [] [] [] ["[", expr h, ",", expr finset.card_univ, ",", expr zero_pow (fintype.card_pos_iff.mpr «expr‹ ›»(_)), ",", expr @eq_comm _ (0 : «exprℝ≥0∞»()), ",", expr finset.prod_eq_zero_iff, "]"] [] [] },
  { simp [] [] [] ["[", expr h, "]"] [] [] }
end

theorem pi_premeasure_pi_mono {s t : Set (∀ i, α i)} (h : s ⊆ t) : pi_premeasure m s ≤ pi_premeasure m t :=
  Finset.prod_le_prod' fun i _ => (m i).mono' (image_subset _ h)

theorem pi_premeasure_pi_eval [Nonempty ι] {s : Set (∀ i, α i)} :
  pi_premeasure m (pi univ fun i => eval i '' s) = pi_premeasure m s :=
  by 
    simp [pi_premeasure_pi']

namespace OuterMeasure

/-- `outer_measure.pi m` is the finite product of the outer measures `{m i | i : ι}`.
  It is defined to be the maximal outer measure `n` with the property that
  `n (pi univ s) ≤ ∏ i, m i (s i)`, where `pi univ s` is the product of the sets
  `{s i | i : ι}`. -/
protected def pi (m : ∀ i, outer_measure (α i)) : outer_measure (∀ i, α i) :=
  bounded_by (pi_premeasure m)

theorem pi_pi_le (m : ∀ i, outer_measure (α i)) (s : ∀ i, Set (α i)) : outer_measure.pi m (pi univ s) ≤ ∏i, m i (s i) :=
  by 
    cases' (pi univ s).eq_empty_or_nonempty with h h 
    simp [h]
    exact (bounded_by_le _).trans_eq (pi_premeasure_pi h)

theorem le_pi {m : ∀ i, outer_measure (α i)} {n : outer_measure (∀ i, α i)} :
  n ≤ outer_measure.pi m ↔ ∀ (s : ∀ i, Set (α i)), (pi univ s).Nonempty → n (pi univ s) ≤ ∏i, m i (s i) :=
  by 
    rw [outer_measure.pi, le_bounded_by']
    split 
    ·
      intro h s hs 
      refine' (h _ hs).trans_eq (pi_premeasure_pi hs)
    ·
      intro h s hs 
      refine' le_transₓ (n.mono$ subset_pi_eval_image univ s) (h _ _)
      simp [univ_pi_nonempty_iff, hs]

end OuterMeasure

namespace Measureₓ

variable[∀ i, MeasurableSpace (α i)](μ : ∀ i, Measureₓ (α i))

section Tprod

open List

variable{δ : Type _}{π : δ → Type _}[∀ x, MeasurableSpace (π x)]

/-- A product of measures in `tprod α l`. -/
protected def tprod (l : List δ) (μ : ∀ i, Measureₓ (π i)) : Measureₓ (tprod π l) :=
  by 
    induction' l with i l ih 
    exact dirac PUnit.unit 
    exact (μ i).Prod ih

@[simp]
theorem tprod_nil (μ : ∀ i, Measureₓ (π i)) : measure.tprod [] μ = dirac PUnit.unit :=
  rfl

@[simp]
theorem tprod_cons (i : δ) (l : List δ) (μ : ∀ i, Measureₓ (π i)) :
  measure.tprod (i :: l) μ = (μ i).Prod (measure.tprod l μ) :=
  rfl

instance sigma_finite_tprod (l : List δ) (μ : ∀ i, Measureₓ (π i)) [∀ i, sigma_finite (μ i)] :
  sigma_finite (measure.tprod l μ) :=
  by 
    induction' l with i l ih
    ·
      rw [tprod_nil]
      infer_instance
    ·
      rw [tprod_cons]
      skip 
      infer_instance

theorem tprod_tprod (l : List δ) (μ : ∀ i, Measureₓ (π i)) [∀ i, sigma_finite (μ i)] (s : ∀ i, Set (π i)) :
  measure.tprod l μ (Set.Tprodₓ l s) = (l.map fun i => (μ i) (s i)).Prod :=
  by 
    induction' l with i l ih
    ·
      simp 
    rw [tprod_cons, Set.Tprodₓ, prod_prod, map_cons, prod_cons, ih]

end Tprod

section Encodable

open List MeasurableEquiv

variable[Encodable ι]

/-- The product measure on an encodable finite type, defined by mapping `measure.tprod` along the
  equivalence `measurable_equiv.pi_measurable_equiv_tprod`.
  The definition `measure_theory.measure.pi` should be used instead of this one. -/
def pi' : Measureₓ (∀ i, α i) :=
  measure.map (tprod.elim' mem_sorted_univ) (measure.tprod (sorted_univ ι) μ)

theorem pi'_pi [∀ i, sigma_finite (μ i)] (s : ∀ i, Set (α i)) : pi' μ (pi univ s) = ∏i, μ i (s i) :=
  by 
    rw [pi', ←MeasurableEquiv.pi_measurable_equiv_tprod_symm_apply, MeasurableEquiv.map_apply,
        MeasurableEquiv.pi_measurable_equiv_tprod_symm_apply, elim_preimage_pi, tprod_tprod _ μ, ←List.prod_to_finset,
        sorted_univ_to_finset] <;>
      exact sorted_univ_nodup ι

end Encodable

theorem pi_caratheodory : MeasurableSpace.pi ≤ (outer_measure.pi fun i => (μ i).toOuterMeasure).caratheodory :=
  by 
    refine' supr_le _ 
    intro i s hs 
    rw [MeasurableSpace.comap] at hs 
    rcases hs with ⟨s, hs, rfl⟩
    apply bounded_by_caratheodory 
    intro t 
    simpRw [pi_premeasure]
    refine' Finset.prod_add_prod_le' (Finset.mem_univ i) _ _ _
    ·
      simp [image_inter_preimage, image_diff_preimage, measure_inter_add_diff _ hs, le_reflₓ]
    ·
      rintro j - hj 
      apply mono' 
      apply image_subset 
      apply inter_subset_left
    ·
      rintro j - hj 
      apply mono' 
      apply image_subset 
      apply diff_subset

/-- `measure.pi μ` is the finite product of the measures `{μ i | i : ι}`.
  It is defined to be measure corresponding to `measure_theory.outer_measure.pi`. -/
@[irreducible]
protected def pi : Measureₓ (∀ i, α i) :=
  to_measure (outer_measure.pi fun i => (μ i).toOuterMeasure) (pi_caratheodory μ)

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem pi_pi_aux
[∀ i, sigma_finite (μ i)]
(s : ∀ i, set (α i))
(hs : ∀ i, measurable_set (s i)) : «expr = »(measure.pi μ (pi univ s), «expr∏ , »((i), μ i (s i))) :=
begin
  refine [expr le_antisymm _ _],
  { rw ["[", expr measure.pi, ",", expr to_measure_apply _ _ (measurable_set.pi_fintype (λ i _, hs i)), "]"] [],
    apply [expr outer_measure.pi_pi_le] },
  { haveI [] [":", expr encodable ι] [":=", expr fintype.encodable ι],
    rw ["[", "<-", expr pi'_pi μ s, "]"] [],
    simp_rw ["[", "<-", expr pi'_pi μ s, ",", expr measure.pi, ",", expr to_measure_apply _ _ (measurable_set.pi_fintype (λ
       i _, hs i)), ",", "<-", expr to_outer_measure_apply, "]"] [],
    suffices [] [":", expr «expr ≤ »((pi' μ).to_outer_measure, outer_measure.pi (λ i, (μ i).to_outer_measure))],
    { exact [expr this _] },
    clear [ident hs, ident s],
    rw ["[", expr outer_measure.le_pi, "]"] [],
    intros [ident s, ident hs],
    simp_rw ["[", expr to_outer_measure_apply, "]"] [],
    exact [expr (pi'_pi μ s).le] }
end

variable{μ}

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- `measure.pi μ` has finite spanning sets in rectangles of finite spanning sets. -/
def finite_spanning_sets_in.pi
{C : ∀ i, set (set (α i))}
(hμ : ∀
 i, (μ i).finite_spanning_sets_in (C i)) : (measure.pi μ).finite_spanning_sets_in «expr '' »(pi univ, pi univ C) :=
begin
  haveI [] [] [":=", expr λ i, (hμ i).sigma_finite],
  haveI [] [] [":=", expr fintype.encodable ι],
  let [ident e] [":", expr exprℕ() → ι → exprℕ()] [":=", expr λ n, (decode (ι → exprℕ()) n).iget],
  refine [expr ⟨λ n, pi univ (λ i, (hμ i).set (e n i)), λ n, _, λ n, _, _⟩],
  { refine [expr mem_image_of_mem _ (λ i _, (hμ i).set_mem _)] },
  { calc
      «expr ≤ »(measure.pi μ (pi univ (λ
         i, (hμ i).set (e n i))), measure.pi μ (pi univ (λ
         i, to_measurable (μ i) ((hμ i).set (e n i))))) : measure_mono «expr $ »(pi_mono, λ
       i hi, subset_to_measurable _ _)
      «expr = »(..., «expr∏ , »((i), μ i (to_measurable (μ i) ((hμ i).set (e n i))))) : pi_pi_aux μ _ (λ
       i, measurable_set_to_measurable _ _)
      «expr = »(..., «expr∏ , »((i), μ i ((hμ i).set (e n i)))) : by simp [] [] ["only"] ["[", expr measure_to_measurable, "]"] [] []
      «expr < »(..., «expr∞»()) : ennreal.prod_lt_top (λ i hi, ((hμ i).finite _).ne) },
  { simp_rw ["[", expr (surjective_decode_iget (ι → exprℕ())).Union_comp (λ
      x, pi univ (λ
       i, (hμ i).set (x i))), ",", expr Union_univ_pi (λ
      i, (hμ i).set), ",", expr (hμ _).spanning, ",", expr set.pi_univ, "]"] [] }
end

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- A measure on a finite product space equals the product measure if they are equal on rectangles
  with as sides sets that generate the corresponding σ-algebras. -/
theorem pi_eq_generate_from
{C : ∀ i, set (set (α i))}
(hC : ∀ i, «expr = »(generate_from (C i), _inst_3 i))
(h2C : ∀ i, is_pi_system (C i))
(h3C : ∀ i, (μ i).finite_spanning_sets_in (C i))
{μν : measure (∀ i, α i)}
(h₁ : ∀
 s : ∀
 i, set (α i), ∀
 i, «expr ∈ »(s i, C i) → «expr = »(μν (pi univ s), «expr∏ , »((i), μ i (s i)))) : «expr = »(measure.pi μ, μν) :=
begin
  have [ident h4C] [":", expr ∀ (i) (s : set (α i)), «expr ∈ »(s, C i) → measurable_set s] [],
  { intros [ident i, ident s, ident hs],
    rw ["[", "<-", expr hC, "]"] [],
    exact [expr measurable_set_generate_from hs] },
  refine [expr (finite_spanning_sets_in.pi h3C).ext (generate_from_eq_pi hC (λ
     i, (h3C i).is_countably_spanning)).symm (is_pi_system.pi h2C) _],
  rintro ["_", "⟨", ident s, ",", ident hs, ",", ident rfl, "⟩"],
  rw ["[", expr mem_univ_pi, "]"] ["at", ident hs],
  haveI [] [] [":=", expr λ i, (h3C i).sigma_finite],
  simp_rw ["[", expr h₁ s hs, ",", expr pi_pi_aux μ s (λ i, h4C i _ (hs i)), "]"] []
end

variable[∀ i, sigma_finite (μ i)]

/-- A measure on a finite product space equals the product measure if they are equal on
  rectangles. -/
theorem pi_eq {μ' : Measureₓ (∀ i, α i)}
  (h : ∀ (s : ∀ i, Set (α i)), (∀ i, MeasurableSet (s i)) → μ' (pi univ s) = ∏i, μ i (s i)) : measure.pi μ = μ' :=
  pi_eq_generate_from (fun i => generate_from_measurable_set) (fun i => is_pi_system_measurable_set)
    (fun i => (μ i).toFiniteSpanningSetsIn) h

variable(μ)

theorem pi'_eq_pi [Encodable ι] : pi' μ = measure.pi μ :=
  Eq.symm$ pi_eq$ fun s hs => pi'_pi μ s

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[simp] theorem pi_pi (s : ∀ i, set (α i)) : «expr = »(measure.pi μ (pi univ s), «expr∏ , »((i), μ i (s i))) :=
begin
  haveI [] [":", expr encodable ι] [":=", expr fintype.encodable ι],
  rw ["[", "<-", expr pi'_eq_pi, ",", expr pi'_pi, "]"] []
end

theorem pi_univ : measure.pi μ univ = ∏i, μ i univ :=
  by 
    rw [←pi_univ, pi_pi μ]

theorem pi_ball [∀ i, MetricSpace (α i)] (x : ∀ i, α i) {r : ℝ} (hr : 0 < r) :
  measure.pi μ (Metric.Ball x r) = ∏i, μ i (Metric.Ball (x i) r) :=
  by 
    rw [ball_pi _ hr, pi_pi]

theorem pi_closed_ball [∀ i, MetricSpace (α i)] (x : ∀ i, α i) {r : ℝ} (hr : 0 ≤ r) :
  measure.pi μ (Metric.ClosedBall x r) = ∏i, μ i (Metric.ClosedBall (x i) r) :=
  by 
    rw [closed_ball_pi _ hr, pi_pi]

instance pi.sigma_finite : sigma_finite (measure.pi μ) :=
  (finite_spanning_sets_in.pi fun i => (μ i).toFiniteSpanningSetsIn).SigmaFinite

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem pi_of_empty
{α : Type*}
[is_empty α]
{β : α → Type*}
{m : ∀ a, measurable_space (β a)}
(μ : ∀ a : α, measure (β a))
(x : ∀ a, β a := is_empty_elim) : «expr = »(measure.pi μ, dirac x) :=
begin
  haveI [] [":", expr ∀ a, sigma_finite (μ a)] [":=", expr is_empty_elim],
  refine [expr pi_eq (λ s hs, _)],
  rw ["[", expr fintype.prod_empty, ",", expr dirac_apply_of_mem, "]"] [],
  exact [expr is_empty_elim]
end

theorem pi_eval_preimage_null {i : ι} {s : Set (α i)} (hs : μ i s = 0) : measure.pi μ (eval i ⁻¹' s) = 0 :=
  by 
    rcases exists_measurable_superset_of_null hs with ⟨t, hst, htm, hμt⟩
    suffices  : measure.pi μ (eval i ⁻¹' t) = 0 
    exact measure_mono_null (preimage_mono hst) this 
    clear! s 
    rw [←univ_pi_update_univ, pi_pi]
    apply Finset.prod_eq_zero (Finset.mem_univ i)
    simp [hμt]

theorem pi_hyperplane (i : ι) [has_no_atoms (μ i)] (x : α i) : measure.pi μ { f:∀ i, α i | f i = x } = 0 :=
  show measure.pi μ (eval i ⁻¹' {x}) = 0 from pi_eval_preimage_null _ (measure_singleton x)

theorem ae_eval_ne (i : ι) [has_no_atoms (μ i)] (x : α i) : ∀ᵐy : ∀ i, α i ∂measure.pi μ, y i ≠ x :=
  compl_mem_ae_iff.2 (pi_hyperplane μ i x)

variable{μ}

theorem tendsto_eval_ae_ae {i : ι} : tendsto (eval i) (measure.pi μ).ae (μ i).ae :=
  fun s hs => pi_eval_preimage_null μ hs

theorem ae_pi_le_pi : (measure.pi μ).ae ≤ Filter.pi fun i => (μ i).ae :=
  le_infi$ fun i => tendsto_eval_ae_ae.le_comap

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem ae_eq_pi
{β : ι → Type*}
{f f' : ∀ i, α i → β i}
(h : ∀
 i, «expr =ᵐ[ ] »(f i, μ i, f' i)) : «expr =ᵐ[ ] »(λ (x : ∀ i, α i) (i), f i (x i), measure.pi μ, λ x i, f' i (x i)) :=
«expr $ »((eventually_all.2 (λ i, tendsto_eval_ae_ae.eventually (h i))).mono, λ x hx, funext hx)

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem ae_le_pi
{β : ι → Type*}
[∀ i, preorder (β i)]
{f f' : ∀ i, α i → β i}
(h : ∀
 i, «expr ≤ᵐ[ ] »(f i, μ i, f' i)) : «expr ≤ᵐ[ ] »(λ (x : ∀ i, α i) (i), f i (x i), measure.pi μ, λ x i, f' i (x i)) :=
«expr $ »((eventually_all.2 (λ i, tendsto_eval_ae_ae.eventually (h i))).mono, λ x hx, hx)

theorem ae_le_set_pi {I : Set ι} {s t : ∀ i, Set (α i)} (h : ∀ i (_ : i ∈ I), s i ≤ᵐ[μ i] t i) :
  Set.Pi I s ≤ᵐ[measure.pi μ] Set.Pi I t :=
  ((eventually_all_finite (finite.of_fintype I)).2 fun i hi => tendsto_eval_ae_ae.Eventually (h i hi)).mono$
    fun x hst hx i hi => hst i hi$ hx i hi

theorem ae_eq_set_pi {I : Set ι} {s t : ∀ i, Set (α i)} (h : ∀ i (_ : i ∈ I), s i =ᵐ[μ i] t i) :
  Set.Pi I s =ᵐ[measure.pi μ] Set.Pi I t :=
  (ae_le_set_pi fun i hi => (h i hi).le).antisymm (ae_le_set_pi fun i hi => (h i hi).symm.le)

section Intervals

variable{μ}[∀ i, PartialOrderₓ (α i)][∀ i, has_no_atoms (μ i)]

theorem pi_Iio_ae_eq_pi_Iic {s : Set ι} {f : ∀ i, α i} :
  (pi s fun i => Iio (f i)) =ᵐ[measure.pi μ] pi s fun i => Iic (f i) :=
  ae_eq_set_pi$ fun i hi => Iio_ae_eq_Iic

theorem pi_Ioi_ae_eq_pi_Ici {s : Set ι} {f : ∀ i, α i} :
  (pi s fun i => Ioi (f i)) =ᵐ[measure.pi μ] pi s fun i => Ici (f i) :=
  ae_eq_set_pi$ fun i hi => Ioi_ae_eq_Ici

theorem univ_pi_Iio_ae_eq_Iic {f : ∀ i, α i} : (pi univ fun i => Iio (f i)) =ᵐ[measure.pi μ] Iic f :=
  by 
    rw [←pi_univ_Iic]
    exact pi_Iio_ae_eq_pi_Iic

theorem univ_pi_Ioi_ae_eq_Ici {f : ∀ i, α i} : (pi univ fun i => Ioi (f i)) =ᵐ[measure.pi μ] Ici f :=
  by 
    rw [←pi_univ_Ici]
    exact pi_Ioi_ae_eq_pi_Ici

theorem pi_Ioo_ae_eq_pi_Icc {s : Set ι} {f g : ∀ i, α i} :
  (pi s fun i => Ioo (f i) (g i)) =ᵐ[measure.pi μ] pi s fun i => Icc (f i) (g i) :=
  ae_eq_set_pi$ fun i hi => Ioo_ae_eq_Icc

theorem univ_pi_Ioo_ae_eq_Icc {f g : ∀ i, α i} : (pi univ fun i => Ioo (f i) (g i)) =ᵐ[measure.pi μ] Icc f g :=
  by 
    rw [←pi_univ_Icc]
    exact pi_Ioo_ae_eq_pi_Icc

theorem pi_Ioc_ae_eq_pi_Icc {s : Set ι} {f g : ∀ i, α i} :
  (pi s fun i => Ioc (f i) (g i)) =ᵐ[measure.pi μ] pi s fun i => Icc (f i) (g i) :=
  ae_eq_set_pi$ fun i hi => Ioc_ae_eq_Icc

theorem univ_pi_Ioc_ae_eq_Icc {f g : ∀ i, α i} : (pi univ fun i => Ioc (f i) (g i)) =ᵐ[measure.pi μ] Icc f g :=
  by 
    rw [←pi_univ_Icc]
    exact pi_Ioc_ae_eq_pi_Icc

theorem pi_Ico_ae_eq_pi_Icc {s : Set ι} {f g : ∀ i, α i} :
  (pi s fun i => Ico (f i) (g i)) =ᵐ[measure.pi μ] pi s fun i => Icc (f i) (g i) :=
  ae_eq_set_pi$ fun i hi => Ico_ae_eq_Icc

theorem univ_pi_Ico_ae_eq_Icc {f g : ∀ i, α i} : (pi univ fun i => Ico (f i) (g i)) =ᵐ[measure.pi μ] Icc f g :=
  by 
    rw [←pi_univ_Icc]
    exact pi_Ico_ae_eq_pi_Icc

end Intervals

/-- If one of the measures `μ i` has no atoms, them `measure.pi µ`
has no atoms. The instance below assumes that all `μ i` have no atoms. -/
theorem pi_has_no_atoms (i : ι) [has_no_atoms (μ i)] : has_no_atoms (measure.pi μ) :=
  ⟨fun x => flip measure_mono_null (pi_hyperplane μ i (x i)) (singleton_subset_iff.2 rfl)⟩

instance  [h : Nonempty ι] [∀ i, has_no_atoms (μ i)] : has_no_atoms (measure.pi μ) :=
  h.elim$ fun i => pi_has_no_atoms i

instance  [∀ i, TopologicalSpace (α i)] [∀ i, is_locally_finite_measure (μ i)] :
  is_locally_finite_measure (measure.pi μ) :=
  by 
    refine' ⟨fun x => _⟩
    choose s hxs ho hμ using fun i => (μ i).exists_is_open_measure_lt_top (x i)
    refine' ⟨pi univ s, set_pi_mem_nhds finite_univ fun i hi => IsOpen.mem_nhds (ho i) (hxs i), _⟩
    rw [pi_pi]
    exact Ennreal.prod_lt_top fun i _ => (hμ i).Ne

variable(μ)

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Separating the indices into those that satisfy a predicate `p` and those that don't maps
a product measure to a product of product measures. This is useful to apply Fubini to some subset
of the variables. The converse is `measure_theory.measure.map_pi_equiv_pi_subtype_prod`. -/
theorem map_pi_equiv_pi_subtype_prod_symm
(p : ι → exprProp())
[decidable_pred p] : «expr = »(map (equiv.pi_equiv_pi_subtype_prod p α).symm (measure.prod (measure.pi (λ
    i, μ i)) (measure.pi (λ i, μ i))), measure.pi μ) :=
begin
  refine [expr (measure.pi_eq (λ s hs, _)).symm],
  have [ident A] [":", expr «expr = »(«expr ⁻¹' »((equiv.pi_equiv_pi_subtype_prod p α).symm, set.pi set.univ (λ
      i : ι, s i)), set.prod (set.pi set.univ (λ i, s i)) (set.pi set.univ (λ i, s i)))] [],
  { ext [] [ident x] [],
    simp [] [] ["only"] ["[", expr equiv.pi_equiv_pi_subtype_prod_symm_apply, ",", expr mem_prod, ",", expr mem_univ_pi, ",", expr mem_preimage, ",", expr subtype.forall, "]"] [] [],
    split,
    { exact [expr λ
       h, ⟨λ
        i
        hi, by simpa [] [] [] ["[", expr dif_pos hi, "]"] [] ["using", expr h i], λ
        i hi, by simpa [] [] [] ["[", expr dif_neg hi, "]"] [] ["using", expr h i]⟩] },
    { assume [binders (h i)],
      by_cases [expr hi, ":", expr p i],
      { simpa [] [] ["only"] ["[", expr dif_pos hi, "]"] [] ["using", expr h.1 i hi] },
      { simpa [] [] ["only"] ["[", expr dif_neg hi, "]"] [] ["using", expr h.2 i hi] } } },
  rw ["[", expr measure.map_apply (measurable_pi_equiv_pi_subtype_prod_symm _ p) (measurable_set.univ_pi_fintype hs), ",", expr A, ",", expr measure.prod_prod, ",", expr pi_pi, ",", expr pi_pi, ",", "<-", expr fintype.prod_subtype_mul_prod_subtype p (λ
    i, μ i (s i)), "]"] []
end

theorem map_pi_equiv_pi_subtype_prod (p : ι → Prop) [DecidablePred p] :
  map (Equiv.piEquivPiSubtypeProd p α) (measure.pi μ) =
    measure.prod (measure.pi fun i => μ i) (measure.pi fun i => μ i) :=
  by 
    rw [←map_pi_equiv_pi_subtype_prod_symm μ p,
      measure.map_map (measurable_pi_equiv_pi_subtype_prod _ p) (measurable_pi_equiv_pi_subtype_prod_symm _ p)]
    simp only [Equiv.self_comp_symm, map_id]

end Measureₓ

instance measure_space.pi [∀ i, measure_space (α i)] : measure_space (∀ i, α i) :=
  ⟨measure.pi fun i => volume⟩

theorem volume_pi [∀ i, measure_space (α i)] : (volume : Measureₓ (∀ i, α i)) = measure.pi fun i => volume :=
  rfl

theorem volume_pi_pi [∀ i, measure_space (α i)] [∀ i, sigma_finite (volume : Measureₓ (α i))] (s : ∀ i, Set (α i)) :
  volume (pi univ s) = ∏i, volume (s i) :=
  measure.pi_pi (fun i => volume) s

theorem volume_pi_ball [∀ i, measure_space (α i)] [∀ i, sigma_finite (volume : Measureₓ (α i))] [∀ i, MetricSpace (α i)]
  (x : ∀ i, α i) {r : ℝ} (hr : 0 < r) : volume (Metric.Ball x r) = ∏i, volume (Metric.Ball (x i) r) :=
  measure.pi_ball _ _ hr

theorem volume_pi_closed_ball [∀ i, measure_space (α i)] [∀ i, sigma_finite (volume : Measureₓ (α i))]
  [∀ i, MetricSpace (α i)] (x : ∀ i, α i) {r : ℝ} (hr : 0 ≤ r) :
  volume (Metric.ClosedBall x r) = ∏i, volume (Metric.ClosedBall (x i) r) :=
  measure.pi_closed_ball _ _ hr

/-!
### Measure preserving equivalences

In this section we prove that some measurable equivalences (e.g., between `fin 1 → α` and `α` or
between `fin 2 → α` and `α × α`) preserve measure or volume. These lemmas can be used to prove that
measures of corresponding sets (images or preimages) have equal measures and functions `f ∘ e` and
`f` have equal integrals, see lemmas in the `measure_theory.measure_preserving` prefix.
-/


section MeasurePreserving

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem measure_preserving_fun_unique
{β : Type u}
{m : measurable_space β}
(μ : measure β)
(α : Type v)
[unique α] : measure_preserving (measurable_equiv.fun_unique α β) (measure.pi (λ a : α, μ)) μ :=
begin
  set [] [ident e] [] [":="] [expr measurable_equiv.fun_unique α β] [],
  have [] [":", expr «expr = »(pi_premeasure (λ _ : α, μ.to_outer_measure), measure.map e.symm μ)] [],
  { ext1 [] [ident s],
    rw ["[", expr pi_premeasure, ",", expr fintype.prod_unique, ",", expr to_outer_measure_apply, ",", expr e.symm.map_apply, "]"] [],
    congr' [1] [],
    exact [expr e.to_equiv.image_eq_preimage s] },
  simp [] [] ["only"] ["[", expr measure.pi, ",", expr outer_measure.pi, ",", expr this, ",", expr bounded_by_measure, ",", expr to_outer_measure_to_measure, "]"] [] [],
  exact [expr ((measurable_equiv.fun_unique α β).symm.measurable.measure_preserving _).symm]
end

theorem volume_preserving_fun_unique (α : Type u) (β : Type v) [Unique α] [measure_space β] :
  measure_preserving (MeasurableEquiv.funUnique α β) volume volume :=
  measure_preserving_fun_unique volume α

theorem measure_preserving_pi_fin_two {α : Finₓ 2 → Type u} {m : ∀ i, MeasurableSpace (α i)} (μ : ∀ i, Measureₓ (α i))
  [∀ i, sigma_finite (μ i)] : measure_preserving (MeasurableEquiv.piFinTwo α) (measure.pi μ) ((μ 0).Prod (μ 1)) :=
  by 
    refine' ⟨MeasurableEquiv.measurable _, (measure.prod_eq$ fun s t hs ht => _).symm⟩
    rw [MeasurableEquiv.map_apply, MeasurableEquiv.pi_fin_two_apply, Finₓ.preimage_apply_01_prod, measure.pi_pi,
      Finₓ.prod_univ_two]
    rfl

theorem volume_preserving_pi_fin_two (α : Finₓ 2 → Type u) [∀ i, measure_space (α i)]
  [∀ i, sigma_finite (volume : Measureₓ (α i))] : measure_preserving (MeasurableEquiv.piFinTwo α) volume volume :=
  measure_preserving_pi_fin_two _

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:341:40: in haveI: ././Mathport/Syntax/Translate/Basic.lean:558:61: unsupported notation `«expr![ , ]»
theorem measure_preserving_fin_two_arrow_vec
{α : Type u}
{m : measurable_space α}
(μ ν : measure α)
[sigma_finite μ]
[sigma_finite ν] : measure_preserving measurable_equiv.fin_two_arrow (measure.pi «expr![ , ]»([μ, ν])) (μ.prod ν) :=
begin
  haveI [] [":", expr ∀
   i, sigma_finite («expr![ , ]»([μ, ν]) i)] [":=", expr fin.forall_fin_two.2 ⟨«expr‹ ›»(_), «expr‹ ›»(_)⟩],
  exact [expr measure_preserving_pi_fin_two _]
end

theorem measure_preserving_fin_two_arrow {α : Type u} {m : MeasurableSpace α} (μ : Measureₓ α) [sigma_finite μ] :
  measure_preserving MeasurableEquiv.finTwoArrow (measure.pi fun _ => μ) (μ.prod μ) :=
  by 
    simpa only [Matrix.vec_single_eq_const, Matrix.vec_cons_const] using measure_preserving_fin_two_arrow_vec μ μ

theorem volume_preserving_fin_two_arrow (α : Type u) [measure_space α] [sigma_finite (volume : Measureₓ α)] :
  measure_preserving (@MeasurableEquiv.finTwoArrow α _) volume volume :=
  measure_preserving_fin_two_arrow volume

theorem measure_preserving_pi_empty {ι : Type u} {α : ι → Type v} [IsEmpty ι] {m : ∀ i, MeasurableSpace (α i)}
  (μ : ∀ i, Measureₓ (α i)) :
  measure_preserving (MeasurableEquiv.ofUniqueOfUnique (∀ i, α i) Unit) (measure.pi μ) (measure.dirac ()) :=
  by 
    set e := MeasurableEquiv.ofUniqueOfUnique (∀ i, α i) Unit 
    refine' ⟨e.measurable, _⟩
    rw [measure.pi_of_empty, measure.map_dirac e.measurable]
    rfl

theorem volume_preserving_pi_empty {ι : Type u} (α : ι → Type v) [IsEmpty ι] [∀ i, measure_space (α i)] :
  measure_preserving (MeasurableEquiv.ofUniqueOfUnique (∀ i, α i) Unit) volume volume :=
  measure_preserving_pi_empty fun _ => volume

end MeasurePreserving

end MeasureTheory

