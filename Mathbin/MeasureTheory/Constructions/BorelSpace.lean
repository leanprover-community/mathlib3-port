import Mathbin.MeasureTheory.Function.AeMeasurableSequence 
import Mathbin.Analysis.Complex.Basic 
import Mathbin.Analysis.NormedSpace.FiniteDimension 
import Mathbin.MeasureTheory.Group.Arithmetic 
import Mathbin.Topology.Algebra.Ordered.LiminfLimsup 
import Mathbin.Topology.ContinuousFunction.Basic 
import Mathbin.Topology.Instances.Ereal 
import Mathbin.Topology.GDelta 
import Mathbin.Topology.Semicontinuous

/-!
# Borel (measurable) space

## Main definitions

* `borel α` : the least `σ`-algebra that contains all open sets;
* `class borel_space` : a space with `topological_space` and `measurable_space` structures
  such that `‹measurable_space α› = borel α`;
* `class opens_measurable_space` : a space with `topological_space` and `measurable_space`
  structures such that all open sets are measurable; equivalently, `borel α ≤ ‹measurable_space α›`.
* `borel_space` instances on `empty`, `unit`, `bool`, `nat`, `int`, `rat`;
* `measurable` and `borel_space` instances on `ℝ`, `ℝ≥0`, `ℝ≥0∞`.

## Main statements

* `is_open.measurable_set`, `is_closed.measurable_set`: open and closed sets are measurable;
* `continuous.measurable` : a continuous function is measurable;
* `continuous.measurable2` : if `f : α → β` and `g : α → γ` are measurable and `op : β × γ → δ`
  is continuous, then `λ x, op (f x, g y)` is measurable;
* `measurable.add` etc : dot notation for arithmetic operations on `measurable` predicates,
  and similarly for `dist` and `edist`;
* `ae_measurable.add` : similar dot notation for almost everywhere measurable functions;
* `measurable.ennreal*` : special cases for arithmetic operations on `ℝ≥0∞`.
-/


noncomputable theory

open Classical Set Filter MeasureTheory

open_locale Classical BigOperators TopologicalSpace Nnreal Ennreal Interval

universe u v w x y

variable{α β γ γ₂ δ : Type _}{ι : Sort y}{s t u : Set α}

open MeasurableSpace TopologicalSpace

/-- `measurable_space` structure generated by `topological_space`. -/
def borel (α : Type u) [TopologicalSpace α] : MeasurableSpace α :=
  generate_from { s:Set α | IsOpen s }

theorem borel_eq_top_of_discrete [TopologicalSpace α] [DiscreteTopology α] : borel α = ⊤ :=
  top_le_iff.1$ fun s hs => generate_measurable.basic s (is_open_discrete s)

theorem borel_eq_top_of_encodable [TopologicalSpace α] [T1Space α] [Encodable α] : borel α = ⊤ :=
  by 
    refine' top_le_iff.1$ fun s hs => bUnion_of_singleton s ▸ _ 
    apply MeasurableSet.bUnion s.countable_encodable 
    intro x hx 
    apply MeasurableSet.of_compl 
    apply generate_measurable.basic 
    exact is_closed_singleton.is_open_compl

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem borel_eq_generate_from_of_subbasis
{s : set (set α)}
[t : topological_space α]
[second_countable_topology α]
(hs : «expr = »(t, generate_from s)) : «expr = »(borel α, generate_from s) :=
le_antisymm «expr $ »(generate_from_le, assume (u) (hu : t.is_open u), begin
   rw ["[", expr hs, "]"] ["at", ident hu],
   induction [expr hu] [] [] [],
   case [ident generate_open.basic, ":", ident u, ident hu] { exact [expr generate_measurable.basic u hu] },
   case [ident generate_open.univ] { exact [expr @measurable_set.univ α (generate_from s)] },
   case [ident generate_open.inter, ":", ident s₁, ident s₂, "_", "_", ident hs₁, ident hs₂] { exact [expr @measurable_set.inter α (generate_from s) _ _ hs₁ hs₂] },
   case [ident generate_open.sUnion, ":", ident f, ident hf, ident ih] { rcases [expr is_open_sUnion_countable f (by rwa [expr hs] []), "with", "⟨", ident v, ",", ident hv, ",", ident vf, ",", ident vu, "⟩"],
     rw ["<-", expr vu] [],
     exact [expr @measurable_set.sUnion α (generate_from s) _ hv (λ x xv, ih _ (vf xv))] }
 end) «expr $ »(generate_from_le, assume
 u
 hu, «expr $ »(generate_measurable.basic _, show t.is_open u, by rw ["[", expr hs, "]"] []; exact [expr generate_open.basic _ hu]))

theorem TopologicalSpace.IsTopologicalBasis.borel_eq_generate_from [TopologicalSpace α] [second_countable_topology α]
  {s : Set (Set α)} (hs : is_topological_basis s) : borel α = generate_from s :=
  borel_eq_generate_from_of_subbasis hs.eq_generate_from

theorem is_pi_system_is_open [TopologicalSpace α] : IsPiSystem (IsOpen : Set α → Prop) :=
  fun s t hs ht hst => IsOpen.inter hs ht

theorem borel_eq_generate_from_is_closed [TopologicalSpace α] : borel α = generate_from { s | IsClosed s } :=
  le_antisymmₓ
    (generate_from_le$
      fun t ht =>
        @MeasurableSet.of_compl α _ (generate_from { s | IsClosed s })
          (generate_measurable.basic _$ is_closed_compl_iff.2 ht))
    (generate_from_le$
      fun t ht => @MeasurableSet.of_compl α _ (borel α) (generate_measurable.basic _$ is_open_compl_iff.2 ht))

section OrderTopology

variable(α)

variable[TopologicalSpace α][second_countable_topology α][LinearOrderₓ α][OrderTopology α]

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem borel_eq_generate_from_Iio : «expr = »(borel α, generate_from (range Iio)) :=
begin
  refine [expr le_antisymm _ (generate_from_le _)],
  { rw [expr borel_eq_generate_from_of_subbasis (@order_topology.topology_eq_generate_intervals α _ _ _)] [],
    letI [] [":", expr measurable_space α] [":=", expr measurable_space.generate_from (range Iio)],
    have [ident H] [":", expr ∀ a : α, measurable_set (Iio a)] [":=", expr λ a, generate_measurable.basic _ ⟨_, rfl⟩],
    refine [expr generate_from_le _],
    rintro ["_", "⟨", ident a, ",", ident rfl, "|", ident rfl, "⟩"]; [skip, apply [expr H]],
    by_cases [expr h, ":", expr «expr∃ , »((a'), ∀ b, «expr ↔ »(«expr < »(a, b), «expr ≤ »(a', b)))],
    { rcases [expr h, "with", "⟨", ident a', ",", ident ha', "⟩"],
      rw [expr (_ : «expr = »(Ioi a, «expr ᶜ»(Iio a')))] [],
      { exact [expr (H _).compl] },
      simp [] [] [] ["[", expr set.ext_iff, ",", expr ha', "]"] [] [] },
    { rcases [expr is_open_Union_countable (λ
        a' : {a' : α // «expr < »(a, a')}, {b | «expr < »(a'.1, b)}) (λ
        a', is_open_lt' _), "with", "⟨", ident v, ",", "⟨", ident hv, "⟩", ",", ident vu, "⟩"],
      simp [] [] [] ["[", expr set.ext_iff, "]"] [] ["at", ident vu],
      have [] [":", expr «expr = »(Ioi a, «expr⋃ , »((x : v), «expr ᶜ»(Iio x.1.1)))] [],
      { simp [] [] [] ["[", expr set.ext_iff, "]"] [] [],
        refine [expr λ x, ⟨λ ax, _, λ ⟨a', ⟨h, av⟩, ax⟩, lt_of_lt_of_le h ax⟩],
        rcases [expr (vu x).2 _, "with", "⟨", ident a', ",", ident h₁, ",", ident h₂, "⟩"],
        { exact [expr ⟨a', h₁, le_of_lt h₂⟩] },
        refine [expr not_imp_comm.1 (λ h, _) h],
        exact [expr ⟨x, λ b, ⟨λ ab, le_of_not_lt (λ h', h ⟨b, ab, h'⟩), lt_of_lt_of_le ax⟩⟩] },
      rw [expr this] [],
      resetI,
      apply [expr measurable_set.Union],
      exact [expr λ _, (H _).compl] } },
  { rw [expr forall_range_iff] [],
    intro [ident a],
    exact [expr generate_measurable.basic _ is_open_Iio] }
end

theorem borel_eq_generate_from_Ioi : borel α = generate_from (range Ioi) :=
  @borel_eq_generate_from_Iio (OrderDual α) _
    (by 
      infer_instance :
    second_countable_topology α)
    _ _

end OrderTopology

theorem borel_comap {f : α → β} {t : TopologicalSpace β} : @borel α (t.induced f) = (@borel β t).comap f :=
  comap_generate_from.symm

theorem Continuous.borel_measurable [TopologicalSpace α] [TopologicalSpace β] {f : α → β} (hf : Continuous f) :
  @Measurable α β (borel α) (borel β) f :=
  Measurable.of_le_map$ generate_from_le$ fun s hs => generate_measurable.basic (f ⁻¹' s) (hs.preimage hf)

/-- A space with `measurable_space` and `topological_space` structures such that
all open sets are measurable. -/
class OpensMeasurableSpace(α : Type _)[TopologicalSpace α][h : MeasurableSpace α] : Prop where 
  borel_le : borel α ≤ h

/-- A space with `measurable_space` and `topological_space` structures such that
the `σ`-algebra of measurable sets is exactly the `σ`-algebra generated by open sets. -/
class BorelSpace(α : Type _)[TopologicalSpace α][MeasurableSpace α] : Prop where 
  measurable_eq : ‹MeasurableSpace α› = borel α

/-- In a `borel_space` all open sets are measurable. -/
instance (priority := 100)BorelSpace.opens_measurable {α : Type _} [TopologicalSpace α] [MeasurableSpace α]
  [BorelSpace α] : OpensMeasurableSpace α :=
  ⟨ge_of_eq$ BorelSpace.measurable_eq⟩

instance Subtype.borel_space {α : Type _} [TopologicalSpace α] [MeasurableSpace α] [hα : BorelSpace α] (s : Set α) :
  BorelSpace s :=
  ⟨by 
      rw [hα.1, Subtype.measurableSpace, ←borel_comap]
      rfl⟩

instance Subtype.opens_measurable_space {α : Type _} [TopologicalSpace α] [MeasurableSpace α]
  [h : OpensMeasurableSpace α] (s : Set α) : OpensMeasurableSpace s :=
  ⟨by 
      rw [borel_comap]
      exact comap_mono h.1⟩

theorem _root_.measurable_set.induction_on_open [TopologicalSpace α] [MeasurableSpace α] [BorelSpace α]
  {C : Set α → Prop} (h_open : ∀ U, IsOpen U → C U) (h_compl : ∀ t, MeasurableSet t → C t → C («expr ᶜ» t))
  (h_union : ∀ (f : ℕ → Set α), Pairwise (Disjoint on f) → (∀ i, MeasurableSet (f i)) → (∀ i, C (f i)) → C (⋃i, f i)) :
  ∀ ⦃t⦄, MeasurableSet t → C t :=
  MeasurableSpace.induction_on_inter BorelSpace.measurable_eq is_pi_system_is_open (h_open _ is_open_empty) h_open
    h_compl h_union

section 

variable[TopologicalSpace
      α][MeasurableSpace
      α][OpensMeasurableSpace
      α][TopologicalSpace
      β][MeasurableSpace
      β][OpensMeasurableSpace
      β][TopologicalSpace
      γ][MeasurableSpace γ][BorelSpace γ][TopologicalSpace γ₂][MeasurableSpace γ₂][BorelSpace γ₂][MeasurableSpace δ]

theorem IsOpen.measurable_set (h : IsOpen s) : MeasurableSet s :=
  OpensMeasurableSpace.borel_le _$ generate_measurable.basic _ h

@[measurability]
theorem measurable_set_interior : MeasurableSet (Interior s) :=
  is_open_interior.MeasurableSet

theorem IsGδ.measurable_set (h : IsGδ s) : MeasurableSet s :=
  by 
    rcases h with ⟨S, hSo, hSc, rfl⟩
    exact MeasurableSet.sInter hSc fun t ht => (hSo t ht).MeasurableSet

theorem measurable_set_of_continuous_at {β} [EmetricSpace β] (f : α → β) : MeasurableSet { x | ContinuousAt f x } :=
  (is_Gδ_set_of_continuous_at f).MeasurableSet

theorem IsClosed.measurable_set (h : IsClosed s) : MeasurableSet s :=
  h.is_open_compl.measurable_set.of_compl

theorem IsCompact.measurable_set [T2Space α] (h : IsCompact s) : MeasurableSet s :=
  h.is_closed.measurable_set

@[measurability]
theorem measurable_set_closure : MeasurableSet (Closure s) :=
  is_closed_closure.MeasurableSet

theorem measurable_of_is_open {f : δ → γ} (hf : ∀ s, IsOpen s → MeasurableSet (f ⁻¹' s)) : Measurable f :=
  by 
    rw [‹BorelSpace γ›.measurable_eq]
    exact measurable_generate_from hf

theorem measurable_of_is_closed {f : δ → γ} (hf : ∀ s, IsClosed s → MeasurableSet (f ⁻¹' s)) : Measurable f :=
  by 
    apply measurable_of_is_open 
    intro s hs 
    rw [←MeasurableSet.compl_iff, ←preimage_compl]
    apply hf 
    rw [is_closed_compl_iff]
    exact hs

theorem measurable_of_is_closed' {f : δ → γ} (hf : ∀ s, IsClosed s → s.nonempty → s ≠ univ → MeasurableSet (f ⁻¹' s)) :
  Measurable f :=
  by 
    apply measurable_of_is_closed 
    intro s hs 
    cases' eq_empty_or_nonempty s with h1 h1
    ·
      simp [h1]
    byCases' h2 : s = univ
    ·
      simp [h2]
    exact hf s hs h1 h2

instance nhds_is_measurably_generated (a : α) : (𝓝 a).IsMeasurablyGenerated :=
  by 
    rw [nhds, infi_subtype']
    refine' @Filter.infi_is_measurably_generated _ _ _ _ fun i => _ 
    exact i.2.2.MeasurableSet.principal_is_measurably_generated

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- If `s` is a measurable set, then `𝓝[s] a` is a measurably generated filter for
each `a`. This cannot be an `instance` because it depends on a non-instance `hs : measurable_set s`.
-/
theorem measurable_set.nhds_within_is_measurably_generated
{s : set α}
(hs : measurable_set s)
(a : α) : «expr𝓝[ ] »(s, a).is_measurably_generated :=
by haveI [] [] [":=", expr hs.principal_is_measurably_generated]; exact [expr filter.inf_is_measurably_generated _ _]

instance (priority := 100)OpensMeasurableSpace.to_measurable_singleton_class [T1Space α] : MeasurableSingletonClass α :=
  ⟨fun x => is_closed_singleton.MeasurableSet⟩

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
instance pi.opens_measurable_space_encodable
{ι : Type*}
{π : ι → Type*}
[encodable ι]
[t' : ∀ i, topological_space (π i)]
[∀ i, measurable_space (π i)]
[∀ i, second_countable_topology (π i)]
[∀ i, opens_measurable_space (π i)] : opens_measurable_space (∀ i, π i) :=
begin
  constructor,
  have [] [":", expr «expr = »(Pi.topological_space, generate_from {t | «expr∃ , »((s : ∀ a, set (π a))
     (i : finset ι), «expr ∧ »(∀
      a «expr ∈ » i, «expr ∈ »(s a, countable_basis (π a)), «expr = »(t, pi «expr↑ »(i) s)))})] [],
  { rw ["[", expr funext (λ a, @eq_generate_from_countable_basis (π a) _ _), ",", expr pi_generate_from_eq, "]"] [] },
  rw ["[", expr borel_eq_generate_from_of_subbasis this, "]"] [],
  apply [expr generate_from_le],
  rintros ["_", "⟨", ident s, ",", ident i, ",", ident hi, ",", ident rfl, "⟩"],
  refine [expr measurable_set.pi i.countable_to_set (λ a ha, is_open.measurable_set _)],
  rw ["[", expr eq_generate_from_countable_basis (π a), "]"] [],
  exact [expr generate_open.basic _ (hi a ha)]
end

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
instance pi.opens_measurable_space_fintype
{ι : Type*}
{π : ι → Type*}
[fintype ι]
[t' : ∀ i, topological_space (π i)]
[∀ i, measurable_space (π i)]
[∀ i, second_countable_topology (π i)]
[∀ i, opens_measurable_space (π i)] : opens_measurable_space (∀ i, π i) :=
by { letI [] [] [":=", expr fintype.encodable ι],
  apply_instance }

instance Prod.opens_measurable_space [second_countable_topology α] [second_countable_topology β] :
  OpensMeasurableSpace (α × β) :=
  by 
    constructor 
    rw [((is_basis_countable_basis α).Prod (is_basis_countable_basis β)).borel_eq_generate_from]
    apply generate_from_le 
    rintro _ ⟨u, v, hu, hv, rfl⟩
    exact (is_open_of_mem_countable_basis hu).MeasurableSet.Prod (is_open_of_mem_countable_basis hv).MeasurableSet

variable{α' : Type _}[TopologicalSpace α'][MeasurableSpace α']

theorem measure_interior_of_null_bdry {μ : Measureₓ α'} {s : Set α'} (h_nullbdry : μ (Frontier s) = 0) :
  μ (Interior s) = μ s :=
  measure_eq_measure_smaller_of_between_null_diff interior_subset subset_closure h_nullbdry

theorem measure_closure_of_null_bdry {μ : Measureₓ α'} {s : Set α'} (h_nullbdry : μ (Frontier s) = 0) :
  μ (Closure s) = μ s :=
  (measure_eq_measure_larger_of_between_null_diff interior_subset subset_closure h_nullbdry).symm

section Preorderₓ

variable[Preorderₓ α][OrderClosedTopology α]{a b x : α}

@[simp, measurability]
theorem measurable_set_Ici : MeasurableSet (Ici a) :=
  is_closed_Ici.MeasurableSet

@[simp, measurability]
theorem measurable_set_Iic : MeasurableSet (Iic a) :=
  is_closed_Iic.MeasurableSet

@[simp, measurability]
theorem measurable_set_Icc : MeasurableSet (Icc a b) :=
  is_closed_Icc.MeasurableSet

instance nhds_within_Ici_is_measurably_generated : (𝓝[Ici b] a).IsMeasurablyGenerated :=
  measurable_set_Ici.nhds_within_is_measurably_generated _

instance nhds_within_Iic_is_measurably_generated : (𝓝[Iic b] a).IsMeasurablyGenerated :=
  measurable_set_Iic.nhds_within_is_measurably_generated _

instance nhds_within_Icc_is_measurably_generated : is_measurably_generated (𝓝[Icc a b] x) :=
  by 
    rw [←Ici_inter_Iic, nhds_within_inter]
    infer_instance

instance at_top_is_measurably_generated : (Filter.atTop : Filter α).IsMeasurablyGenerated :=
  @Filter.infi_is_measurably_generated _ _ _ _$
    fun a => (measurable_set_Ici : MeasurableSet (Ici a)).principal_is_measurably_generated

instance at_bot_is_measurably_generated : (Filter.atBot : Filter α).IsMeasurablyGenerated :=
  @Filter.infi_is_measurably_generated _ _ _ _$
    fun a => (measurable_set_Iic : MeasurableSet (Iic a)).principal_is_measurably_generated

theorem bsupr_measure_Iic {μ : Measureₓ α} {s : Set α} (hsc : countable s)
  (hst : ∀ (x : α), ∃ (y : _)(_ : y ∈ s), x ≤ y) (hdir : DirectedOn (· ≤ ·) s) :
  (⨆(x : _)(_ : x ∈ s), μ (Iic x)) = μ univ :=
  by 
    rw [←measure_bUnion_eq_supr hsc]
    ·
      congr 
      exact bUnion_eq_univ_iff.2 hst
    ·
      exact fun _ _ => measurable_set_Iic
    ·
      exact directed_on_iff_directed.2 (hdir.directed_coe.mono_comp _$ fun x y => Iic_subset_Iic.2)

end Preorderₓ

section PartialOrderₓ

variable[PartialOrderₓ α][OrderClosedTopology α][second_countable_topology α]{a b : α}

@[measurability]
theorem measurable_set_le' : MeasurableSet { p:α × α | p.1 ≤ p.2 } :=
  OrderClosedTopology.is_closed_le'.MeasurableSet

@[measurability]
theorem measurable_set_le {f g : δ → α} (hf : Measurable f) (hg : Measurable g) : MeasurableSet { a | f a ≤ g a } :=
  hf.prod_mk hg measurable_set_le'

end PartialOrderₓ

section LinearOrderₓ

variable[LinearOrderₓ α][OrderClosedTopology α]{a b x : α}

@[simp, measurability]
theorem measurable_set_Iio : MeasurableSet (Iio a) :=
  is_open_Iio.MeasurableSet

@[simp, measurability]
theorem measurable_set_Ioi : MeasurableSet (Ioi a) :=
  is_open_Ioi.MeasurableSet

@[simp, measurability]
theorem measurable_set_Ioo : MeasurableSet (Ioo a b) :=
  is_open_Ioo.MeasurableSet

@[simp, measurability]
theorem measurable_set_Ioc : MeasurableSet (Ioc a b) :=
  measurable_set_Ioi.inter measurable_set_Iic

@[simp, measurability]
theorem measurable_set_Ico : MeasurableSet (Ico a b) :=
  measurable_set_Ici.inter measurable_set_Iio

instance nhds_within_Ioi_is_measurably_generated : (𝓝[Ioi b] a).IsMeasurablyGenerated :=
  measurable_set_Ioi.nhds_within_is_measurably_generated _

instance nhds_within_Iio_is_measurably_generated : (𝓝[Iio b] a).IsMeasurablyGenerated :=
  measurable_set_Iio.nhds_within_is_measurably_generated _

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:546:47: unsupported (impossible)
instance nhds_within_interval_is_measurably_generated : is_measurably_generated «expr𝓝[ ] »(«expr[ , ]»(a, b), x) :=
nhds_within_Icc_is_measurably_generated

@[measurability]
theorem measurable_set_lt' [second_countable_topology α] : MeasurableSet { p:α × α | p.1 < p.2 } :=
  (is_open_lt continuous_fst continuous_snd).MeasurableSet

@[measurability]
theorem measurable_set_lt [second_countable_topology α] {f g : δ → α} (hf : Measurable f) (hg : Measurable g) :
  MeasurableSet { a | f a < g a } :=
  hf.prod_mk hg measurable_set_lt'

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem set.ord_connected.measurable_set (h : ord_connected s) : measurable_set s :=
begin
  let [ident u] [] [":=", expr «expr⋃ , »((x «expr ∈ » s) (y «expr ∈ » s), Ioo x y)],
  have [ident huopen] [":", expr is_open u] [":=", expr is_open_bUnion (λ x hx, is_open_bUnion (λ y hy, is_open_Ioo))],
  have [ident humeas] [":", expr measurable_set u] [":=", expr huopen.measurable_set],
  have [ident hfinite] [":", expr «expr \ »(s, u).finite] [],
  { refine [expr set.finite_of_forall_between_eq_endpoints «expr \ »(s, u) (λ x hx y hy z hz hxy hyz, _)],
    by_contra [ident h],
    push_neg ["at", ident h],
    exact [expr hy.2 (mem_bUnion_iff.mpr ⟨x, hx.1, mem_bUnion_iff.mpr ⟨z, hz.1, lt_of_le_of_ne hxy h.1, lt_of_le_of_ne hyz h.2⟩⟩)] },
  have [] [":", expr «expr ⊆ »(u, s)] [":=", expr bUnion_subset (λ
    x hx, bUnion_subset (λ y hy, Ioo_subset_Icc_self.trans (h.out hx hy)))],
  rw ["<-", expr union_diff_cancel this] [],
  exact [expr humeas.union hfinite.measurable_set]
end

theorem IsPreconnected.measurable_set (h : IsPreconnected s) : MeasurableSet s :=
  h.ord_connected.measurable_set

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem generate_from_Ico_mem_le_borel
{α : Type*}
[topological_space α]
[linear_order α]
[order_closed_topology α]
(s
 t : set α) : «expr ≤ »(measurable_space.generate_from {S | «expr∃ , »((l «expr ∈ » s)
  (u «expr ∈ » t)
  (h : «expr < »(l, u)), «expr = »(Ico l u, S))}, borel α) :=
begin
  apply [expr generate_from_le],
  letI [] [":", expr measurable_space α] [":=", expr borel α],
  haveI [] [":", expr borel_space α] [":=", expr ⟨rfl⟩],
  rintro ["_", "⟨", ident a, ",", "-", ",", ident b, ",", "-", ",", "-", ",", ident rfl, "⟩"],
  exact [expr measurable_set_Ico]
end

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem dense.borel_eq_generate_from_Ico_mem_aux
{α : Type*}
[topological_space α]
[linear_order α]
[order_topology α]
[second_countable_topology α]
{s : set α}
(hd : dense s)
(hbot : ∀ x, is_bot x → «expr ∈ »(x, s))
(hIoo : ∀
 x
 y : α, «expr < »(x, y) → «expr = »(Ioo x y, «expr∅»()) → «expr ∈ »(y, s)) : «expr = »(borel α, generate_from {S : set α | «expr∃ , »((l «expr ∈ » s)
  (u «expr ∈ » s)
  (h : «expr < »(l, u)), «expr = »(Ico l u, S))}) :=
begin
  set [] [ident S] [":", expr set (set α)] [":="] [expr {S | «expr∃ , »((l «expr ∈ » s)
    (u «expr ∈ » s)
    (h : «expr < »(l, u)), «expr = »(Ico l u, S))}] [],
  refine [expr le_antisymm _ (generate_from_Ico_mem_le_borel _ _)],
  letI [] [":", expr measurable_space α] [":=", expr generate_from S],
  rw [expr borel_eq_generate_from_Iio] [],
  refine [expr generate_from_le «expr $ »(forall_range_iff.2, λ a, _)],
  rcases [expr hd.exists_countable_dense_subset_bot_top, "with", "⟨", ident t, ",", ident hts, ",", ident hc, ",", ident htd, ",", ident htb, ",", ident htt, "⟩"],
  by_cases [expr ha, ":", expr ∀ b «expr < » a, (Ioo b a).nonempty],
  { convert_to [expr measurable_set «expr⋃ , »((l «expr ∈ » t)
      (u «expr ∈ » t)
      (hlu : «expr < »(l, u))
      (hu : «expr ≤ »(u, a)), Ico l u)] [],
    { ext [] [ident y] [],
      simp [] [] ["only"] ["[", expr mem_Union, ",", expr mem_Iio, ",", expr mem_Ico, "]"] [] [],
      split,
      { intro [ident hy],
        rcases [expr htd.exists_le' (λ
          b hb, htb _ hb (hbot b hb)) y, "with", "⟨", ident l, ",", ident hlt, ",", ident hly, "⟩"],
        rcases [expr htd.exists_mem_open is_open_Ioo (ha y hy), "with", "⟨", ident u, ",", ident hut, ",", ident hyu, ",", ident hua, "⟩"],
        exact [expr ⟨l, hlt, u, hut, hly.trans_lt hyu, hua.le, hly, hyu⟩] },
      { rintro ["⟨", ident l, ",", "-", ",", ident u, ",", "-", ",", "-", ",", ident hua, ",", "-", ",", ident hyu, "⟩"],
        exact [expr hyu.trans_le hua] } },
    { refine [expr measurable_set.bUnion hc (λ a ha, «expr $ »(measurable_set.bUnion hc, λ b hb, _))],
      refine [expr measurable_set.Union_Prop (λ hab, «expr $ »(measurable_set.Union_Prop, λ hb', _))],
      exact [expr generate_measurable.basic _ ⟨a, hts ha, b, hts hb, hab, mem_singleton _⟩] } },
  { simp [] [] ["only"] ["[", expr not_forall, ",", expr not_nonempty_iff_eq_empty, "]"] [] ["at", ident ha],
    replace [ident ha] [":", expr «expr ∈ »(a, s)] [":=", expr hIoo ha.some a ha.some_spec.fst ha.some_spec.snd],
    convert_to [expr measurable_set «expr⋃ , »((l «expr ∈ » t) (hl : «expr < »(l, a)), Ico l a)] [],
    { symmetry,
      simp [] [] ["only"] ["[", "<-", expr Ici_inter_Iio, ",", "<-", expr Union_inter, ",", expr inter_eq_right_iff_subset, ",", expr subset_def, ",", expr mem_Union, ",", expr mem_Ici, ",", expr mem_Iio, "]"] [] [],
      intros [ident x, ident hx],
      rcases [expr htd.exists_le' (λ
        b hb, htb _ hb (hbot b hb)) x, "with", "⟨", ident z, ",", ident hzt, ",", ident hzx, "⟩"],
      exact [expr ⟨z, hzt, hzx.trans_lt hx, hzx⟩] },
    { refine [expr measurable_set.bUnion hc (λ x hx, «expr $ »(measurable_set.Union_Prop, λ hlt, _))],
      exact [expr generate_measurable.basic _ ⟨x, hts hx, a, ha, hlt, mem_singleton _⟩] } }
end

theorem Dense.borel_eq_generate_from_Ico_mem {α : Type _} [TopologicalSpace α] [LinearOrderₓ α] [OrderTopology α]
  [second_countable_topology α] [DenselyOrdered α] [NoBotOrder α] {s : Set α} (hd : Dense s) :
  borel α = generate_from { S:Set α | ∃ (l : _)(_ : l ∈ s)(u : _)(_ : u ∈ s)(h : l < u), Ico l u = S } :=
  hd.borel_eq_generate_from_Ico_mem_aux
      (by 
        simp )$
    fun x y hxy H => ((nonempty_Ioo.2 hxy).ne_empty H).elim

theorem borel_eq_generate_from_Ico (α : Type _) [TopologicalSpace α] [second_countable_topology α] [LinearOrderₓ α]
  [OrderTopology α] : borel α = generate_from { S:Set α | ∃ (l u : _)(h : l < u), Ico l u = S } :=
  by 
    simpa only [exists_prop, mem_univ, true_andₓ] using
      (@dense_univ α _).borel_eq_generate_from_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ => mem_univ _

theorem Dense.borel_eq_generate_from_Ioc_mem_aux {α : Type _} [TopologicalSpace α] [LinearOrderₓ α] [OrderTopology α]
  [second_countable_topology α] {s : Set α} (hd : Dense s) (hbot : ∀ x, IsTop x → x ∈ s)
  (hIoo : ∀ (x y : α), x < y → Ioo x y = ∅ → x ∈ s) :
  borel α = generate_from { S:Set α | ∃ (l : _)(_ : l ∈ s)(u : _)(_ : u ∈ s)(h : l < u), Ioc l u = S } :=
  by 
    convert hd.order_dual.borel_eq_generate_from_Ico_mem_aux hbot fun x y hlt he => hIoo y x hlt _
    ·
      ext s 
      split  <;> rintro ⟨l, hl, u, hu, hlt, rfl⟩
      exacts[⟨u, hu, l, hl, hlt, dual_Ico⟩, ⟨u, hu, l, hl, hlt, dual_Ioc⟩]
    ·
      erw [dual_Ioo]
      exact he

theorem Dense.borel_eq_generate_from_Ioc_mem {α : Type _} [TopologicalSpace α] [LinearOrderₓ α] [OrderTopology α]
  [second_countable_topology α] [DenselyOrdered α] [NoTopOrder α] {s : Set α} (hd : Dense s) :
  borel α = generate_from { S:Set α | ∃ (l : _)(_ : l ∈ s)(u : _)(_ : u ∈ s)(h : l < u), Ioc l u = S } :=
  hd.borel_eq_generate_from_Ioc_mem_aux
      (by 
        simp )$
    fun x y hxy H => ((nonempty_Ioo.2 hxy).ne_empty H).elim

theorem borel_eq_generate_from_Ioc (α : Type _) [TopologicalSpace α] [second_countable_topology α] [LinearOrderₓ α]
  [OrderTopology α] : borel α = generate_from { S:Set α | ∃ (l u : _)(h : l < u), Ioc l u = S } :=
  by 
    simpa only [exists_prop, mem_univ, true_andₓ] using
      (@dense_univ α _).borel_eq_generate_from_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ => mem_univ _

namespace MeasureTheory.Measure

/-- Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If
`α` is a conditionally complete linear order with no top element,
`measure_theory.measure..ext_of_Ico` is an extensionality lemma with weaker assumptions on `μ` and
`ν`. -/
theorem ext_of_Ico_finite {α : Type _} [TopologicalSpace α] {m : MeasurableSpace α} [second_countable_topology α]
  [LinearOrderₓ α] [OrderTopology α] [BorelSpace α] (μ ν : Measureₓ α) [is_finite_measure μ] (hμν : μ univ = ν univ)
  (h : ∀ ⦃a b⦄, a < b → μ (Ico a b) = ν (Ico a b)) : μ = ν :=
  by 
    refine'
      ext_of_generate_finite _ (borel_space.measurable_eq.trans (borel_eq_generate_from_Ico α))
        (is_pi_system_Ico (id : α → α) id) _ hμν
    ·
      rintro - ⟨a, b, hlt, rfl⟩
      exact h hlt

/-- Two finite measures on a Borel space are equal if they agree on all open-closed intervals.  If
`α` is a conditionally complete linear order with no top element,
`measure_theory.measure..ext_of_Ioc` is an extensionality lemma with weaker assumptions on `μ` and
`ν`. -/
theorem ext_of_Ioc_finite {α : Type _} [TopologicalSpace α] {m : MeasurableSpace α} [second_countable_topology α]
  [LinearOrderₓ α] [OrderTopology α] [BorelSpace α] (μ ν : Measureₓ α) [is_finite_measure μ] (hμν : μ univ = ν univ)
  (h : ∀ ⦃a b⦄, a < b → μ (Ioc a b) = ν (Ioc a b)) : μ = ν :=
  by 
    refine' @ext_of_Ico_finite (OrderDual α) _ _ _ _ _ ‹_› μ ν _ hμν fun a b hab => _ 
    erw [dual_Ico]
    exact h hab

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Two measures which are finite on closed-open intervals are equal if the agree on all
closed-open intervals. -/
theorem ext_of_Ico'
{α : Type*}
[topological_space α]
{m : measurable_space α}
[second_countable_topology α]
[linear_order α]
[order_topology α]
[borel_space α]
[no_top_order α]
(μ ν : measure α)
(hμ : ∀ {{a b}}, «expr < »(a, b) → «expr ≠ »(μ (Ico a b), «expr∞»()))
(h : ∀ {{a b}}, «expr < »(a, b) → «expr = »(μ (Ico a b), ν (Ico a b))) : «expr = »(μ, ν) :=
begin
  rcases [expr exists_countable_dense_bot_top α, "with", "⟨", ident s, ",", ident hsc, ",", ident hsd, ",", ident hsb, ",", ident hst, "⟩"],
  have [] [":", expr countable («expr⋃ , »((l «expr ∈ » s)
    (u «expr ∈ » s)
    (h : «expr < »(l, u)), {Ico l u}) : set (set α))] [],
  from [expr hsc.bUnion (λ l hl, hsc.bUnion (λ u hu, «expr $ »(countable_Union_Prop, λ _, countable_singleton _)))],
  simp [] [] ["only"] ["[", "<-", expr set_of_eq_eq_singleton, ",", "<-", expr set_of_exists, "]"] [] ["at", ident this],
  refine [expr measure.ext_of_generate_from_of_cover_subset (borel_space.measurable_eq.trans (borel_eq_generate_from_Ico α)) (is_pi_system_Ico id id) _ this _ _ _],
  { rintro ["_", "⟨", ident l, ",", "-", ",", ident u, ",", "-", ",", ident h, ",", ident rfl, "⟩"],
    exact [expr ⟨l, u, h, rfl⟩] },
  { refine [expr sUnion_eq_univ_iff.2 (λ x, _)],
    rcases [expr hsd.exists_le' hsb x, "with", "⟨", ident l, ",", ident hls, ",", ident hlx, "⟩"],
    rcases [expr hsd.exists_gt x, "with", "⟨", ident u, ",", ident hus, ",", ident hxu, "⟩"],
    exact [expr ⟨_, ⟨l, hls, u, hus, hlx.trans_lt hxu, rfl⟩, hlx, hxu⟩] },
  { rintro ["_", "⟨", ident l, ",", "-", ",", ident u, ",", "-", ",", ident hlt, ",", ident rfl, "⟩"],
    exact [expr hμ hlt] },
  { rintro ["_", "⟨", ident l, ",", ident u, ",", ident hlt, ",", ident rfl, "⟩"],
    exact [expr h hlt] }
end

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
open-closed intervals. -/
theorem ext_of_Ioc' {α : Type _} [TopologicalSpace α] {m : MeasurableSpace α} [second_countable_topology α]
  [LinearOrderₓ α] [OrderTopology α] [BorelSpace α] [NoBotOrder α] (μ ν : Measureₓ α)
  (hμ : ∀ ⦃a b⦄, a < b → μ (Ioc a b) ≠ ∞) (h : ∀ ⦃a b⦄, a < b → μ (Ioc a b) = ν (Ioc a b)) : μ = ν :=
  by 
    refine' @ext_of_Ico' (OrderDual α) _ _ _ _ _ ‹_› _ μ ν _ _ <;> intro a b hab <;> erw [dual_Ico]
    exacts[hμ hab, h hab]

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
closed-open intervals. -/
theorem ext_of_Ico {α : Type _} [TopologicalSpace α] {m : MeasurableSpace α} [second_countable_topology α]
  [ConditionallyCompleteLinearOrder α] [OrderTopology α] [BorelSpace α] [NoTopOrder α] (μ ν : Measureₓ α)
  [is_locally_finite_measure μ] (h : ∀ ⦃a b⦄, a < b → μ (Ico a b) = ν (Ico a b)) : μ = ν :=
  μ.ext_of_Ico' ν (fun a b hab => measure_Ico_lt_top.Ne) h

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
open-closed intervals. -/
theorem ext_of_Ioc {α : Type _} [TopologicalSpace α] {m : MeasurableSpace α} [second_countable_topology α]
  [ConditionallyCompleteLinearOrder α] [OrderTopology α] [BorelSpace α] [NoBotOrder α] (μ ν : Measureₓ α)
  [is_locally_finite_measure μ] (h : ∀ ⦃a b⦄, a < b → μ (Ioc a b) = ν (Ioc a b)) : μ = ν :=
  μ.ext_of_Ioc' ν (fun a b hab => measure_Ioc_lt_top.Ne) h

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed
intervals. -/
theorem ext_of_Iic
{α : Type*}
[topological_space α]
{m : measurable_space α}
[second_countable_topology α]
[linear_order α]
[order_topology α]
[borel_space α]
(μ ν : measure α)
[is_finite_measure μ]
(h : ∀ a, «expr = »(μ (Iic a), ν (Iic a))) : «expr = »(μ, ν) :=
begin
  refine [expr ext_of_Ioc_finite μ ν _ (λ a b hlt, _)],
  { rcases [expr exists_countable_dense_bot_top α, "with", "⟨", ident s, ",", ident hsc, ",", ident hsd, ",", "-", ",", ident hst, "⟩"],
    have [] [":", expr directed_on ((«expr ≤ »)) s] [],
    from [expr directed_on_iff_directed.2 «expr $ »(directed_of_sup, λ _ _, id)],
    simp [] [] ["only"] ["[", "<-", expr bsupr_measure_Iic hsc (hsd.exists_ge' hst) this, ",", expr h, "]"] [] [] },
  rw ["[", "<-", expr Iic_diff_Iic, ",", expr measure_diff (Iic_subset_Iic.2 hlt.le) measurable_set_Iic measurable_set_Iic, ",", expr measure_diff (Iic_subset_Iic.2 hlt.le) measurable_set_Iic measurable_set_Iic, ",", expr h a, ",", expr h b, "]"] [],
  { rw ["<-", expr h a] [],
    exact [expr (measure_lt_top μ _).ne] },
  { exact [expr (measure_lt_top μ _).ne] }
end

/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite
intervals. -/
theorem ext_of_Ici {α : Type _} [TopologicalSpace α] {m : MeasurableSpace α} [second_countable_topology α]
  [LinearOrderₓ α] [OrderTopology α] [BorelSpace α] (μ ν : Measureₓ α) [is_finite_measure μ]
  (h : ∀ a, μ (Ici a) = ν (Ici a)) : μ = ν :=
  @ext_of_Iic (OrderDual α) _ _ _ _ _ ‹_› _ _ _ h

end MeasureTheory.Measure

end LinearOrderₓ

section LinearOrderₓ

variable[LinearOrderₓ α][OrderClosedTopology α]

@[measurability]
theorem measurable_set_interval {a b : α} : MeasurableSet (interval a b) :=
  measurable_set_Icc

@[measurability]
theorem measurable_set_interval_oc {a b : α} : MeasurableSet (interval_oc a b) :=
  measurable_set_Ioc

variable[second_countable_topology α]

@[measurability]
theorem Measurable.max {f g : δ → α} (hf : Measurable f) (hg : Measurable g) : Measurable fun a => max (f a) (g a) :=
  by 
    simpa only [max_def] using hf.piecewise (measurable_set_le hg hf) hg

@[measurability]
theorem AeMeasurable.max {f g : δ → α} {μ : Measureₓ δ} (hf : AeMeasurable f μ) (hg : AeMeasurable g μ) :
  AeMeasurable (fun a => max (f a) (g a)) μ :=
  ⟨fun a => max (hf.mk f a) (hg.mk g a), hf.measurable_mk.max hg.measurable_mk,
    eventually_eq.comp₂ hf.ae_eq_mk _ hg.ae_eq_mk⟩

@[measurability]
theorem Measurable.min {f g : δ → α} (hf : Measurable f) (hg : Measurable g) : Measurable fun a => min (f a) (g a) :=
  by 
    simpa only [min_def] using hf.piecewise (measurable_set_le hf hg) hg

@[measurability]
theorem AeMeasurable.min {f g : δ → α} {μ : Measureₓ δ} (hf : AeMeasurable f μ) (hg : AeMeasurable g μ) :
  AeMeasurable (fun a => min (f a) (g a)) μ :=
  ⟨fun a => min (hf.mk f a) (hg.mk g a), hf.measurable_mk.min hg.measurable_mk,
    eventually_eq.comp₂ hf.ae_eq_mk _ hg.ae_eq_mk⟩

end LinearOrderₓ

/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is measurable. -/
theorem Continuous.measurable {f : α → γ} (hf : Continuous f) : Measurable f :=
  hf.borel_measurable.mono OpensMeasurableSpace.borel_le (le_of_eqₓ$ BorelSpace.measurable_eq)

/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is ae-measurable. -/
theorem Continuous.ae_measurable {f : α → γ} (h : Continuous f) (μ : Measureₓ α) : AeMeasurable f μ :=
  h.measurable.ae_measurable

theorem ClosedEmbedding.measurable {f : α → γ} (hf : ClosedEmbedding f) : Measurable f :=
  hf.continuous.measurable

@[toAdditive]
instance (priority := 100)HasContinuousMul.has_measurable_mul [Mul γ] [HasContinuousMul γ] : HasMeasurableMul γ :=
  { measurable_const_mul := fun c => (continuous_const.mul continuous_id).Measurable,
    measurable_mul_const := fun c => (continuous_id.mul continuous_const).Measurable }

instance (priority := 100)HasContinuousSub.has_measurable_sub [Sub γ] [HasContinuousSub γ] : HasMeasurableSub γ :=
  { measurable_const_sub := fun c => (continuous_const.sub continuous_id).Measurable,
    measurable_sub_const := fun c => (continuous_id.sub continuous_const).Measurable }

@[toAdditive]
instance (priority := 100)TopologicalGroup.has_measurable_inv [Groupₓ γ] [TopologicalGroup γ] : HasMeasurableInv γ :=
  ⟨continuous_inv.Measurable⟩

instance (priority := 100)HasContinuousSmul.has_measurable_smul {M α} [TopologicalSpace M] [TopologicalSpace α]
  [MeasurableSpace M] [MeasurableSpace α] [OpensMeasurableSpace M] [BorelSpace α] [HasScalar M α]
  [HasContinuousSmul M α] : HasMeasurableSmul M α :=
  ⟨fun c => (continuous_const.smul continuous_id).Measurable, fun y => (continuous_id.smul continuous_const).Measurable⟩

section Homeomorph

@[measurability]
protected theorem Homeomorph.measurable (h : α ≃ₜ γ) : Measurable h :=
  h.continuous.measurable

/-- A homeomorphism between two Borel spaces is a measurable equivalence.-/
def Homeomorph.toMeasurableEquiv (h : γ ≃ₜ γ₂) : γ ≃ᵐ γ₂ :=
  { measurable_to_fun := h.measurable, measurable_inv_fun := h.symm.measurable, toEquiv := h.to_equiv }

@[simp]
theorem Homeomorph.to_measurable_equiv_coe (h : γ ≃ₜ γ₂) : (h.to_measurable_equiv : γ → γ₂) = h :=
  rfl

@[simp]
theorem Homeomorph.to_measurable_equiv_symm_coe (h : γ ≃ₜ γ₂) : (h.to_measurable_equiv.symm : γ₂ → γ) = h.symm :=
  rfl

end Homeomorph

@[measurability]
theorem ContinuousMap.measurable (f : C(α, γ)) : Measurable f :=
  f.continuous.measurable

theorem measurable_of_continuous_on_compl_singleton [T1Space α] {f : α → γ} (a : α)
  (hf : ContinuousOn f («expr ᶜ» {a})) : Measurable f :=
  measurable_of_measurable_on_compl_singleton a (continuous_on_iff_continuous_restrict.1 hf).Measurable

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem continuous.measurable2
[second_countable_topology α]
[second_countable_topology β]
{f : δ → α}
{g : δ → β}
{c : α → β → γ}
(h : continuous (λ p : «expr × »(α, β), c p.1 p.2))
(hf : measurable f)
(hg : measurable g) : measurable (λ a, c (f a) (g a)) :=
h.measurable.comp (hf.prod_mk hg)

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem continuous.ae_measurable2
[second_countable_topology α]
[second_countable_topology β]
{f : δ → α}
{g : δ → β}
{c : α → β → γ}
{μ : measure δ}
(h : continuous (λ p : «expr × »(α, β), c p.1 p.2))
(hf : ae_measurable f μ)
(hg : ae_measurable g μ) : ae_measurable (λ a, c (f a) (g a)) μ :=
h.measurable.comp_ae_measurable (hf.prod_mk hg)

instance (priority := 100)HasContinuousInv₀.has_measurable_inv [GroupWithZeroₓ γ] [T1Space γ] [HasContinuousInv₀ γ] :
  HasMeasurableInv γ :=
  ⟨measurable_of_continuous_on_compl_singleton 0 continuous_on_inv₀⟩

@[toAdditive]
instance (priority := 100)HasContinuousMul.has_measurable_mul₂ [second_countable_topology γ] [Mul γ]
  [HasContinuousMul γ] : HasMeasurableMul₂ γ :=
  ⟨continuous_mul.Measurable⟩

instance (priority := 100)HasContinuousSub.has_measurable_sub₂ [second_countable_topology γ] [Sub γ]
  [HasContinuousSub γ] : HasMeasurableSub₂ γ :=
  ⟨continuous_sub.Measurable⟩

instance (priority := 100)HasContinuousSmul.has_measurable_smul₂ {M α} [TopologicalSpace M]
  [second_countable_topology M] [MeasurableSpace M] [OpensMeasurableSpace M] [TopologicalSpace α]
  [second_countable_topology α] [MeasurableSpace α] [BorelSpace α] [HasScalar M α] [HasContinuousSmul M α] :
  HasMeasurableSmul₂ M α :=
  ⟨continuous_smul.Measurable⟩

end 

section BorelSpace

variable[TopologicalSpace
      α][MeasurableSpace
      α][BorelSpace
      α][TopologicalSpace
      β][MeasurableSpace β][BorelSpace β][TopologicalSpace γ][MeasurableSpace γ][BorelSpace γ][MeasurableSpace δ]

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem pi_le_borel_pi
{ι : Type*}
{π : ι → Type*}
[∀ i, topological_space (π i)]
[∀ i, measurable_space (π i)]
[∀ i, borel_space (π i)] : «expr ≤ »(measurable_space.pi, borel (∀ i, π i)) :=
begin
  have [] [":", expr «expr = »(«expr‹ ›»(∀
     i, measurable_space (π i)), λ i, borel (π i))] [":=", expr funext (λ i, borel_space.measurable_eq)],
  rw ["[", expr this, "]"] [],
  exact [expr supr_le (λ i, «expr $ »(comap_le_iff_le_map.2, (continuous_apply i).borel_measurable))]
end

theorem prod_le_borel_prod : Prod.measurableSpace ≤ borel (α × β) :=
  by 
    rw [‹BorelSpace α›.measurable_eq, ‹BorelSpace β›.measurable_eq]
    refine' sup_le _ _
    ·
      exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable
    ·
      exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable

instance Pi.borel_space_fintype_encodable {ι : Type _} {π : ι → Type _} [Encodable ι] [t' : ∀ i, TopologicalSpace (π i)]
  [∀ i, MeasurableSpace (π i)] [∀ i, second_countable_topology (π i)] [∀ i, BorelSpace (π i)] : BorelSpace (∀ i, π i) :=
  ⟨le_antisymmₓ pi_le_borel_pi OpensMeasurableSpace.borel_le⟩

instance Pi.borel_space_fintype {ι : Type _} {π : ι → Type _} [Fintype ι] [t' : ∀ i, TopologicalSpace (π i)]
  [∀ i, MeasurableSpace (π i)] [∀ i, second_countable_topology (π i)] [∀ i, BorelSpace (π i)] : BorelSpace (∀ i, π i) :=
  ⟨le_antisymmₓ pi_le_borel_pi OpensMeasurableSpace.borel_le⟩

instance Prod.borel_space [second_countable_topology α] [second_countable_topology β] : BorelSpace (α × β) :=
  ⟨le_antisymmₓ prod_le_borel_prod OpensMeasurableSpace.borel_le⟩

protected theorem Embedding.measurable_embedding {f : α → β} (h₁ : Embedding f) (h₂ : MeasurableSet (range f)) :
  MeasurableEmbedding f :=
  show MeasurableEmbedding (coeₓ ∘ (Homeomorph.ofEmbedding f h₁).toMeasurableEquiv) from
    (MeasurableEmbedding.subtype_coe h₂).comp (MeasurableEquiv.measurable_embedding _)

protected theorem ClosedEmbedding.measurable_embedding {f : α → β} (h : ClosedEmbedding f) : MeasurableEmbedding f :=
  h.to_embedding.measurable_embedding h.closed_range.measurable_set

protected theorem OpenEmbedding.measurable_embedding {f : α → β} (h : OpenEmbedding f) : MeasurableEmbedding f :=
  h.to_embedding.measurable_embedding h.open_range.measurable_set

section LinearOrderₓ

variable[LinearOrderₓ α][OrderTopology α][second_countable_topology α]

theorem measurable_of_Iio {f : δ → α} (hf : ∀ x, MeasurableSet (f ⁻¹' Iio x)) : Measurable f :=
  by 
    convert measurable_generate_from _ 
    exact borel_space.measurable_eq.trans (borel_eq_generate_from_Iio _)
    rintro _ ⟨x, rfl⟩
    exact hf x

theorem UpperSemicontinuous.measurable [TopologicalSpace δ] [OpensMeasurableSpace δ] {f : δ → α}
  (hf : UpperSemicontinuous f) : Measurable f :=
  measurable_of_Iio fun y => (hf.is_open_preimage y).MeasurableSet

theorem measurable_of_Ioi {f : δ → α} (hf : ∀ x, MeasurableSet (f ⁻¹' Ioi x)) : Measurable f :=
  by 
    convert measurable_generate_from _ 
    exact borel_space.measurable_eq.trans (borel_eq_generate_from_Ioi _)
    rintro _ ⟨x, rfl⟩
    exact hf x

theorem LowerSemicontinuous.measurable [TopologicalSpace δ] [OpensMeasurableSpace δ] {f : δ → α}
  (hf : LowerSemicontinuous f) : Measurable f :=
  measurable_of_Ioi fun y => (hf.is_open_preimage y).MeasurableSet

theorem measurable_of_Iic {f : δ → α} (hf : ∀ x, MeasurableSet (f ⁻¹' Iic x)) : Measurable f :=
  by 
    apply measurable_of_Ioi 
    simpRw [←compl_Iic, preimage_compl, MeasurableSet.compl_iff]
    assumption

theorem measurable_of_Ici {f : δ → α} (hf : ∀ x, MeasurableSet (f ⁻¹' Ici x)) : Measurable f :=
  by 
    apply measurable_of_Iio 
    simpRw [←compl_Ici, preimage_compl, MeasurableSet.compl_iff]
    assumption

theorem Measurable.is_lub {ι} [Encodable ι] {f : ι → δ → α} {g : δ → α} (hf : ∀ i, Measurable (f i))
  (hg : ∀ b, IsLub { a | ∃ i, f i b = a } (g b)) : Measurable g :=
  by 
    change ∀ b, IsLub (range$ fun i => f i b) (g b) at hg 
    rw [‹BorelSpace α›.measurable_eq, borel_eq_generate_from_Ioi α]
    apply measurable_generate_from 
    rintro _ ⟨a, rfl⟩
    simpRw [Set.Preimage, mem_Ioi, lt_is_lub_iff (hg _), exists_range_iff, set_of_exists]
    exact MeasurableSet.Union fun i => hf i (is_open_lt' _).MeasurableSet

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
private
theorem ae_measurable.is_lub_of_nonempty
{ι}
(hι : nonempty ι)
{μ : measure δ}
[encodable ι]
{f : ι → δ → α}
{g : δ → α}
(hf : ∀ i, ae_measurable (f i) μ)
(hg : «expr∀ᵐ ∂ , »((b), μ, is_lub {a | «expr∃ , »((i), «expr = »(f i b, a))} (g b))) : ae_measurable g μ :=
begin
  let [ident p] [":", expr δ → (ι → α) → exprProp()] [":=", expr λ
   x f', is_lub {a | «expr∃ , »((i), «expr = »(f' i, a))} (g x)],
  let [ident g_seq] [] [":=", expr λ x, ite «expr ∈ »(x, ae_seq_set hf p) (g x) (⟨g x⟩ : nonempty α).some],
  have [ident hg_seq] [":", expr ∀ b, is_lub {a | «expr∃ , »((i), «expr = »(ae_seq hf p i b, a))} (g_seq b)] [],
  { intro [ident b],
    haveI [ident hα] [":", expr nonempty α] [":=", expr nonempty.map g ⟨b⟩],
    simp [] [] ["only"] ["[", expr ae_seq, ",", expr g_seq, "]"] [] [],
    split_ifs [] [],
    { have [ident h_set_eq] [":", expr «expr = »({a : α | «expr∃ , »((i : ι), «expr = »((hf i).mk (f i) b, a))}, {a : α | «expr∃ , »((i : ι), «expr = »(f i b, a))})] [],
      { ext [] [ident x] [],
        simp_rw ["[", expr set.mem_set_of_eq, ",", expr ae_seq.mk_eq_fun_of_mem_ae_seq_set hf h, "]"] [] },
      rw [expr h_set_eq] [],
      exact [expr ae_seq.fun_prop_of_mem_ae_seq_set hf h] },
    { have [ident h_singleton] [":", expr «expr = »({a : α | «expr∃ , »((i : ι), «expr = »(hα.some, a))}, {hα.some})] [],
      { ext1 [] [ident x],
        exact [expr ⟨λ hx, hx.some_spec.symm, λ hx, ⟨hι.some, hx.symm⟩⟩] },
      rw [expr h_singleton] [],
      exact [expr is_lub_singleton] } },
  refine [expr ⟨g_seq, measurable.is_lub (ae_seq.measurable hf p) hg_seq, _⟩],
  exact [expr (ite_ae_eq_of_measure_compl_zero g (λ
     x, (⟨g x⟩ : nonempty α).some) (ae_seq_set hf p) (ae_seq.measure_compl_ae_seq_set_eq_zero hf hg)).symm]
end

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem ae_measurable.is_lub
{ι}
{μ : measure δ}
[encodable ι]
{f : ι → δ → α}
{g : δ → α}
(hf : ∀ i, ae_measurable (f i) μ)
(hg : «expr∀ᵐ ∂ , »((b), μ, is_lub {a | «expr∃ , »((i), «expr = »(f i b, a))} (g b))) : ae_measurable g μ :=
begin
  by_cases [expr hμ, ":", expr «expr = »(μ, 0)],
  { rw [expr hμ] [],
    exact [expr ae_measurable_zero_measure] },
  haveI [] [":", expr μ.ae.ne_bot] [],
  { simpa [] [] [] ["[", expr ne_bot_iff, "]"] [] [] },
  by_cases [expr hι, ":", expr nonempty ι],
  { exact [expr ae_measurable.is_lub_of_nonempty hι hf hg] },
  suffices [] [":", expr «expr∃ , »((x), «expr =ᵐ[ ] »(g, μ, λ y, g x))],
  by { exact [expr ⟨λ y, g this.some, measurable_const, this.some_spec⟩] },
  have [ident h_empty] [":", expr ∀ x, «expr = »({a : α | «expr∃ , »((i : ι), «expr = »(f i x, a))}, «expr∅»())] [],
  { intro [ident x],
    ext1 [] [ident y],
    rw ["[", expr set.mem_set_of_eq, ",", expr set.mem_empty_eq, ",", expr iff_false, "]"] [],
    exact [expr λ hi, hι (nonempty_of_exists hi)] },
  simp_rw [expr h_empty] ["at", ident hg],
  exact [expr ⟨hg.exists.some, hg.mono (λ y hy, is_lub.unique hy hg.exists.some_spec)⟩]
end

theorem Measurable.is_glb {ι} [Encodable ι] {f : ι → δ → α} {g : δ → α} (hf : ∀ i, Measurable (f i))
  (hg : ∀ b, IsGlb { a | ∃ i, f i b = a } (g b)) : Measurable g :=
  by 
    change ∀ b, IsGlb (range$ fun i => f i b) (g b) at hg 
    rw [‹BorelSpace α›.measurable_eq, borel_eq_generate_from_Iio α]
    apply measurable_generate_from 
    rintro _ ⟨a, rfl⟩
    simpRw [Set.Preimage, mem_Iio, is_glb_lt_iff (hg _), exists_range_iff, set_of_exists]
    exact MeasurableSet.Union fun i => hf i (is_open_gt' _).MeasurableSet

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
private
theorem ae_measurable.is_glb_of_nonempty
{ι}
(hι : nonempty ι)
{μ : measure δ}
[encodable ι]
{f : ι → δ → α}
{g : δ → α}
(hf : ∀ i, ae_measurable (f i) μ)
(hg : «expr∀ᵐ ∂ , »((b), μ, is_glb {a | «expr∃ , »((i), «expr = »(f i b, a))} (g b))) : ae_measurable g μ :=
begin
  let [ident p] [":", expr δ → (ι → α) → exprProp()] [":=", expr λ
   x f', is_glb {a | «expr∃ , »((i), «expr = »(f' i, a))} (g x)],
  let [ident g_seq] [] [":=", expr λ x, ite «expr ∈ »(x, ae_seq_set hf p) (g x) (⟨g x⟩ : nonempty α).some],
  have [ident hg_seq] [":", expr ∀ b, is_glb {a | «expr∃ , »((i), «expr = »(ae_seq hf p i b, a))} (g_seq b)] [],
  { intro [ident b],
    haveI [ident hα] [":", expr nonempty α] [":=", expr nonempty.map g ⟨b⟩],
    simp [] [] ["only"] ["[", expr ae_seq, ",", expr g_seq, "]"] [] [],
    split_ifs [] [],
    { have [ident h_set_eq] [":", expr «expr = »({a : α | «expr∃ , »((i : ι), «expr = »((hf i).mk (f i) b, a))}, {a : α | «expr∃ , »((i : ι), «expr = »(f i b, a))})] [],
      { ext [] [ident x] [],
        simp_rw ["[", expr set.mem_set_of_eq, ",", expr ae_seq.mk_eq_fun_of_mem_ae_seq_set hf h, "]"] [] },
      rw [expr h_set_eq] [],
      exact [expr ae_seq.fun_prop_of_mem_ae_seq_set hf h] },
    { have [ident h_singleton] [":", expr «expr = »({a : α | «expr∃ , »((i : ι), «expr = »(hα.some, a))}, {hα.some})] [],
      { ext1 [] [ident x],
        exact [expr ⟨λ hx, hx.some_spec.symm, λ hx, ⟨hι.some, hx.symm⟩⟩] },
      rw [expr h_singleton] [],
      exact [expr is_glb_singleton] } },
  refine [expr ⟨g_seq, measurable.is_glb (ae_seq.measurable hf p) hg_seq, _⟩],
  exact [expr (ite_ae_eq_of_measure_compl_zero g (λ
     x, (⟨g x⟩ : nonempty α).some) (ae_seq_set hf p) (ae_seq.measure_compl_ae_seq_set_eq_zero hf hg)).symm]
end

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem ae_measurable.is_glb
{ι}
{μ : measure δ}
[encodable ι]
{f : ι → δ → α}
{g : δ → α}
(hf : ∀ i, ae_measurable (f i) μ)
(hg : «expr∀ᵐ ∂ , »((b), μ, is_glb {a | «expr∃ , »((i), «expr = »(f i b, a))} (g b))) : ae_measurable g μ :=
begin
  by_cases [expr hμ, ":", expr «expr = »(μ, 0)],
  { rw [expr hμ] [],
    exact [expr ae_measurable_zero_measure] },
  haveI [] [":", expr μ.ae.ne_bot] [],
  { simpa [] [] [] ["[", expr ne_bot_iff, "]"] [] [] },
  by_cases [expr hι, ":", expr nonempty ι],
  { exact [expr ae_measurable.is_glb_of_nonempty hι hf hg] },
  suffices [] [":", expr «expr∃ , »((x), «expr =ᵐ[ ] »(g, μ, λ y, g x))],
  by { exact [expr ⟨λ y, g this.some, measurable_const, this.some_spec⟩] },
  have [ident h_empty] [":", expr ∀ x, «expr = »({a : α | «expr∃ , »((i : ι), «expr = »(f i x, a))}, «expr∅»())] [],
  { intro [ident x],
    ext1 [] [ident y],
    rw ["[", expr set.mem_set_of_eq, ",", expr set.mem_empty_eq, ",", expr iff_false, "]"] [],
    exact [expr λ hi, hι (nonempty_of_exists hi)] },
  simp_rw [expr h_empty] ["at", ident hg],
  exact [expr ⟨hg.exists.some, hg.mono (λ y hy, is_glb.unique hy hg.exists.some_spec)⟩]
end

protected theorem Monotone.measurable [LinearOrderₓ β] [OrderClosedTopology β] {f : β → α} (hf : Monotone f) :
  Measurable f :=
  suffices h : ∀ x, ord_connected (f ⁻¹' Ioi x) from measurable_of_Ioi fun x => (h x).MeasurableSet 
  fun x => ord_connected_def.mpr fun a ha b hb c hc => lt_of_lt_of_leₓ ha (hf hc.1)

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem ae_measurable_restrict_of_monotone_on
[linear_order β]
[order_closed_topology β]
{μ : measure β}
{s : set β}
(hs : measurable_set s)
{f : β → α}
(hf : monotone_on f s) : ae_measurable f (μ.restrict s) :=
have this : monotone («expr ∘ »(f, coe) : s → α), from λ ⟨x, hx⟩ ⟨y, hy⟩ (hxy : «expr ≤ »(x, y)), hf hx hy hxy,
ae_measurable_restrict_of_measurable_subtype hs this.measurable

protected theorem Antitone.measurable [LinearOrderₓ β] [OrderClosedTopology β] {f : β → α} (hf : Antitone f) :
  Measurable f :=
  @Monotone.measurable (OrderDual α) β _ _ ‹_› _ _ _ _ _ ‹_› _ _ _ hf

theorem ae_measurable_restrict_of_antitone_on [LinearOrderₓ β] [OrderClosedTopology β] {μ : Measureₓ β} {s : Set β}
  (hs : MeasurableSet s) {f : β → α} (hf : AntitoneOn f s) : AeMeasurable f (μ.restrict s) :=
  @ae_measurable_restrict_of_monotone_on (OrderDual α) β _ _ ‹_› _ _ _ _ _ ‹_› _ _ _ _ hs _ hf

end LinearOrderₓ

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[measurability #[]]
theorem measurable.supr_Prop
{α}
[measurable_space α]
[complete_lattice α]
(p : exprProp())
{f : δ → α}
(hf : measurable f) : measurable (λ b, «expr⨆ , »((h : p), f b)) :=
classical.by_cases (assume h : p, begin
   convert [] [expr hf] [],
   funext [],
   exact [expr supr_pos h]
 end) (assume h : «expr¬ »(p), begin convert [] [expr measurable_const] [], funext [], exact [expr supr_neg h] end)

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[measurability #[]]
theorem measurable.infi_Prop
{α}
[measurable_space α]
[complete_lattice α]
(p : exprProp())
{f : δ → α}
(hf : measurable f) : measurable (λ b, «expr⨅ , »((h : p), f b)) :=
classical.by_cases (assume h : p, begin
   convert [] [expr hf] [],
   funext [],
   exact [expr infi_pos h]
 end) (assume h : «expr¬ »(p), begin convert [] [expr measurable_const] [], funext [], exact [expr infi_neg h] end)

section CompleteLinearOrder

variable[CompleteLinearOrder α][OrderTopology α][second_countable_topology α]

@[measurability]
theorem measurable_supr {ι} [Encodable ι] {f : ι → δ → α} (hf : ∀ i, Measurable (f i)) :
  Measurable fun b => ⨆i, f i b :=
  Measurable.is_lub hf$ fun b => is_lub_supr

@[measurability]
theorem ae_measurable_supr {ι} {μ : Measureₓ δ} [Encodable ι] {f : ι → δ → α} (hf : ∀ i, AeMeasurable (f i) μ) :
  AeMeasurable (fun b => ⨆i, f i b) μ :=
  AeMeasurable.is_lub hf$ ae_of_all μ fun b => is_lub_supr

@[measurability]
theorem measurable_infi {ι} [Encodable ι] {f : ι → δ → α} (hf : ∀ i, Measurable (f i)) :
  Measurable fun b => ⨅i, f i b :=
  Measurable.is_glb hf$ fun b => is_glb_infi

@[measurability]
theorem ae_measurable_infi {ι} {μ : Measureₓ δ} [Encodable ι] {f : ι → δ → α} (hf : ∀ i, AeMeasurable (f i) μ) :
  AeMeasurable (fun b => ⨅i, f i b) μ :=
  AeMeasurable.is_glb hf$ ae_of_all μ fun b => is_glb_infi

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem measurable_bsupr
{ι}
(s : set ι)
{f : ι → δ → α}
(hs : countable s)
(hf : ∀ i, measurable (f i)) : measurable (λ b, «expr⨆ , »((i «expr ∈ » s), f i b)) :=
by { haveI [] [":", expr encodable s] [":=", expr hs.to_encodable],
  simp [] [] ["only"] ["[", expr supr_subtype', "]"] [] [],
  exact [expr measurable_supr (λ i, hf i)] }

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem ae_measurable_bsupr
{ι}
{μ : measure δ}
(s : set ι)
{f : ι → δ → α}
(hs : countable s)
(hf : ∀ i, ae_measurable (f i) μ) : ae_measurable (λ b, «expr⨆ , »((i «expr ∈ » s), f i b)) μ :=
begin
  haveI [] [":", expr encodable s] [":=", expr hs.to_encodable],
  simp [] [] ["only"] ["[", expr supr_subtype', "]"] [] [],
  exact [expr ae_measurable_supr (λ i, hf i)]
end

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem measurable_binfi
{ι}
(s : set ι)
{f : ι → δ → α}
(hs : countable s)
(hf : ∀ i, measurable (f i)) : measurable (λ b, «expr⨅ , »((i «expr ∈ » s), f i b)) :=
by { haveI [] [":", expr encodable s] [":=", expr hs.to_encodable],
  simp [] [] ["only"] ["[", expr infi_subtype', "]"] [] [],
  exact [expr measurable_infi (λ i, hf i)] }

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem ae_measurable_binfi
{ι}
{μ : measure δ}
(s : set ι)
{f : ι → δ → α}
(hs : countable s)
(hf : ∀ i, ae_measurable (f i) μ) : ae_measurable (λ b, «expr⨅ , »((i «expr ∈ » s), f i b)) μ :=
begin
  haveI [] [":", expr encodable s] [":=", expr hs.to_encodable],
  simp [] [] ["only"] ["[", expr infi_subtype', "]"] [] [],
  exact [expr ae_measurable_infi (λ i, hf i)]
end

/-- `liminf` over a general filter is measurable. See `measurable_liminf` for the version over `ℕ`.
-/
theorem measurable_liminf' {ι ι'} {f : ι → δ → α} {u : Filter ι} (hf : ∀ i, Measurable (f i)) {p : ι' → Prop}
  {s : ι' → Set ι} (hu : u.has_countable_basis p s) (hs : ∀ i, (s i).Countable) :
  Measurable fun x => liminf u fun i => f i x :=
  by 
    simpRw [hu.to_has_basis.liminf_eq_supr_infi]
    refine' measurable_bsupr _ hu.countable _ 
    exact fun i => measurable_binfi _ (hs i) hf

/-- `limsup` over a general filter is measurable. See `measurable_limsup` for the version over `ℕ`.
-/
theorem measurable_limsup' {ι ι'} {f : ι → δ → α} {u : Filter ι} (hf : ∀ i, Measurable (f i)) {p : ι' → Prop}
  {s : ι' → Set ι} (hu : u.has_countable_basis p s) (hs : ∀ i, (s i).Countable) :
  Measurable fun x => limsup u fun i => f i x :=
  by 
    simpRw [hu.to_has_basis.limsup_eq_infi_supr]
    refine' measurable_binfi _ hu.countable _ 
    exact fun i => measurable_bsupr _ (hs i) hf

/-- `liminf` over `ℕ` is measurable. See `measurable_liminf'` for a version with a general filter.
-/
@[measurability]
theorem measurable_liminf {f : ℕ → δ → α} (hf : ∀ i, Measurable (f i)) :
  Measurable fun x => liminf at_top fun i => f i x :=
  measurable_liminf' hf at_top_countable_basis fun i => countable_encodable _

/-- `limsup` over `ℕ` is measurable. See `measurable_limsup'` for a version with a general filter.
-/
@[measurability]
theorem measurable_limsup {f : ℕ → δ → α} (hf : ∀ i, Measurable (f i)) :
  Measurable fun x => limsup at_top fun i => f i x :=
  measurable_limsup' hf at_top_countable_basis fun i => countable_encodable _

end CompleteLinearOrder

section ConditionallyCompleteLinearOrder

variable[ConditionallyCompleteLinearOrder α][OrderTopology α][second_countable_topology α]

theorem measurable_cSup {ι} {f : ι → δ → α} {s : Set ι} (hs : s.countable) (hf : ∀ i, Measurable (f i))
  (bdd : ∀ x, BddAbove ((fun i => f i x) '' s)) : Measurable fun x => Sup ((fun i => f i x) '' s) :=
  by 
    cases' eq_empty_or_nonempty s with h2s h2s
    ·
      simp [h2s, measurable_const]
    ·
      apply measurable_of_Iic 
      intro y 
      simpRw [preimage, mem_Iic, cSup_le_iff (bdd _) (h2s.image _), ball_image_iff, set_of_forall]
      exact MeasurableSet.bInter hs fun i hi => measurable_set_le (hf i) measurable_const

end ConditionallyCompleteLinearOrder

/-- Convert a `homeomorph` to a `measurable_equiv`. -/
def Homemorph.toMeasurableEquiv (h : α ≃ₜ β) : α ≃ᵐ β :=
  { toEquiv := h.to_equiv, measurable_to_fun := h.continuous_to_fun.measurable,
    measurable_inv_fun := h.continuous_inv_fun.measurable }

end BorelSpace

instance Empty.borel_space : BorelSpace Empty :=
  ⟨borel_eq_top_of_discrete.symm⟩

instance Unit.borel_space : BorelSpace Unit :=
  ⟨borel_eq_top_of_discrete.symm⟩

instance Bool.borel_space : BorelSpace Bool :=
  ⟨borel_eq_top_of_discrete.symm⟩

instance Nat.borel_space : BorelSpace ℕ :=
  ⟨borel_eq_top_of_discrete.symm⟩

instance Int.borel_space : BorelSpace ℤ :=
  ⟨borel_eq_top_of_discrete.symm⟩

instance Rat.borel_space : BorelSpace ℚ :=
  ⟨borel_eq_top_of_encodable.symm⟩

instance (priority := 900)IsROrC.measurableSpace {𝕜 : Type _} [IsROrC 𝕜] : MeasurableSpace 𝕜 :=
  borel 𝕜

instance (priority := 900)IsROrC.borel_space {𝕜 : Type _} [IsROrC 𝕜] : BorelSpace 𝕜 :=
  ⟨rfl⟩

instance Real.measurableSpace : MeasurableSpace ℝ :=
  borel ℝ

instance Real.borel_space : BorelSpace ℝ :=
  ⟨rfl⟩

instance Nnreal.measurableSpace : MeasurableSpace ℝ≥0  :=
  Subtype.measurableSpace

instance Nnreal.borel_space : BorelSpace ℝ≥0  :=
  Subtype.borel_space _

instance Ennreal.measurableSpace : MeasurableSpace ℝ≥0∞ :=
  borel ℝ≥0∞

instance Ennreal.borel_space : BorelSpace ℝ≥0∞ :=
  ⟨rfl⟩

instance Ereal.measurableSpace : MeasurableSpace Ereal :=
  borel Ereal

instance Ereal.borel_space : BorelSpace Ereal :=
  ⟨rfl⟩

instance Complex.measurableSpace : MeasurableSpace ℂ :=
  borel ℂ

instance Complex.borel_space : BorelSpace ℂ :=
  ⟨rfl⟩

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- One can cut out `ℝ≥0∞` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : ℤ` and `{∞}`. This
gives a way to compute the measure of a set in terms of sets on which a given function `f` does not
fluctuate by more than `t`. -/
theorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow
[measurable_space α]
(μ : measure α)
{f : α → «exprℝ≥0∞»()}
(hf : measurable f)
{s : set α}
(hs : measurable_set s)
{t : «exprℝ≥0»()}
(ht : «expr < »(1, t)) : «expr = »(μ s, «expr + »(«expr + »(μ «expr ∩ »(s, «expr ⁻¹' »(f, {0})), μ «expr ∩ »(s, «expr ⁻¹' »(f, {«expr∞»()}))), «expr∑' , »((n : exprℤ()), μ «expr ∩ »(s, «expr ⁻¹' »(f, Ico «expr ^ »(t, n) «expr ^ »(t, «expr + »(n, 1))))))) :=
begin
  have [ident A] [":", expr «expr = »(μ s, «expr + »(μ «expr ∩ »(s, «expr ⁻¹' »(f, {0})), μ «expr ∩ »(s, «expr ⁻¹' »(f, Ioi 0))))] [],
  { rw ["<-", expr measure_union] [],
    { congr' [1] [],
      ext [] [ident x] [],
      have [] [":", expr «expr ∨ »(«expr = »(0, f x), «expr < »(0, f x))] [":=", expr eq_or_lt_of_le bot_le],
      rw [expr eq_comm] ["at", ident this],
      simp [] [] ["only"] ["[", "<-", expr and_or_distrib_left, ",", expr this, ",", expr mem_singleton_iff, ",", expr mem_inter_eq, ",", expr and_true, ",", expr mem_union_eq, ",", expr mem_Ioi, ",", expr mem_preimage, "]"] [] [] },
    { apply [expr disjoint_left.2 (λ x hx h'x, _)],
      have [] [":", expr «expr < »(0, f x)] [":=", expr h'x.2],
      exact [expr lt_irrefl 0 (this.trans_le hx.2.le)] },
    { exact [expr hs.inter (hf (measurable_set_singleton _))] },
    { exact [expr hs.inter (hf measurable_set_Ioi)] } },
  have [ident B] [":", expr «expr = »(μ «expr ∩ »(s, «expr ⁻¹' »(f, Ioi 0)), «expr + »(μ «expr ∩ »(s, «expr ⁻¹' »(f, {«expr∞»()})), μ «expr ∩ »(s, «expr ⁻¹' »(f, Ioo 0 «expr∞»()))))] [],
  { rw ["<-", expr measure_union] [],
    { rw ["<-", expr inter_union_distrib_left] [],
      congr,
      ext [] [ident x] [],
      simp [] [] ["only"] ["[", expr mem_singleton_iff, ",", expr mem_union_eq, ",", expr mem_Ioo, ",", expr mem_Ioi, ",", expr mem_preimage, "]"] [] [],
      have [ident H] [":", expr «expr ∨ »(«expr = »(f x, «expr∞»()), «expr < »(f x, «expr∞»()))] [":=", expr eq_or_lt_of_le le_top],
      cases [expr H] [],
      { simp [] [] ["only"] ["[", expr H, ",", expr eq_self_iff_true, ",", expr or_false, ",", expr with_top.zero_lt_top, ",", expr not_top_lt, ",", expr and_false, "]"] [] [] },
      { simp [] [] ["only"] ["[", expr H, ",", expr H.ne, ",", expr and_true, ",", expr false_or, "]"] [] [] } },
    { apply [expr disjoint_left.2 (λ x hx h'x, _)],
      have [] [":", expr «expr < »(f x, «expr∞»())] [":=", expr h'x.2.2],
      exact [expr lt_irrefl _ (this.trans_le (le_of_eq hx.2.symm))] },
    { exact [expr hs.inter (hf (measurable_set_singleton _))] },
    { exact [expr hs.inter (hf measurable_set_Ioo)] } },
  have [ident C] [":", expr «expr = »(μ «expr ∩ »(s, «expr ⁻¹' »(f, Ioo 0 «expr∞»())), «expr∑' , »((n : exprℤ()), μ «expr ∩ »(s, «expr ⁻¹' »(f, Ico «expr ^ »(t, n) «expr ^ »(t, «expr + »(n, 1))))))] [],
  { rw ["[", "<-", expr measure_Union, ",", expr ennreal.Ioo_zero_top_eq_Union_Ico_zpow (ennreal.one_lt_coe_iff.2 ht) ennreal.coe_ne_top, ",", expr preimage_Union, ",", expr inter_Union, "]"] [],
    { assume [binders (i j)],
      simp [] [] ["only"] ["[", expr function.on_fun, "]"] [] [],
      wlog [ident h] [":", expr «expr ≤ »(i, j)] [":=", expr le_total i j] ["using", "[", ident i, ident j, ",", ident j, ident i, "]"] tactic.skip,
      { assume [binders (hij)],
        replace [ident hij] [":", expr «expr ≤ »(«expr + »(i, 1), j)] [":=", expr lt_of_le_of_ne h hij],
        apply [expr disjoint_left.2 (λ x hx h'x, lt_irrefl (f x) _)],
        calc
          «expr < »(f x, «expr ^ »(t, «expr + »(i, 1))) : hx.2.2
          «expr ≤ »(..., «expr ^ »(t, j)) : ennreal.zpow_le_of_le (ennreal.one_le_coe_iff.2 ht.le) hij
          «expr ≤ »(..., f x) : h'x.2.1 },
      { assume [binders (hij)],
        rw [expr disjoint.comm] [],
        exact [expr this hij.symm] } },
    { assume [binders (n)],
      exact [expr hs.inter (hf measurable_set_Ico)] } },
  rw ["[", expr A, ",", expr B, ",", expr C, ",", expr add_assoc, "]"] []
end

section MetricSpace

variable[MetricSpace α][MeasurableSpace α][OpensMeasurableSpace α]

variable[MeasurableSpace β]{x : α}{ε : ℝ}

open Metric

@[measurability]
theorem measurable_set_ball : MeasurableSet (Metric.Ball x ε) :=
  Metric.is_open_ball.MeasurableSet

@[measurability]
theorem measurable_set_closed_ball : MeasurableSet (Metric.ClosedBall x ε) :=
  Metric.is_closed_ball.MeasurableSet

@[measurability]
theorem measurable_inf_dist {s : Set α} : Measurable fun x => inf_dist x s :=
  (continuous_inf_dist_pt s).Measurable

@[measurability]
theorem Measurable.inf_dist {f : β → α} (hf : Measurable f) {s : Set α} : Measurable fun x => inf_dist (f x) s :=
  measurable_inf_dist.comp hf

@[measurability]
theorem measurable_inf_nndist {s : Set α} : Measurable fun x => inf_nndist x s :=
  (continuous_inf_nndist_pt s).Measurable

@[measurability]
theorem Measurable.inf_nndist {f : β → α} (hf : Measurable f) {s : Set α} : Measurable fun x => inf_nndist (f x) s :=
  measurable_inf_nndist.comp hf

variable[second_countable_topology α]

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[measurability #[]] theorem measurable_dist : measurable (λ p : «expr × »(α, α), dist p.1 p.2) :=
continuous_dist.measurable

@[measurability]
theorem Measurable.dist {f g : β → α} (hf : Measurable f) (hg : Measurable g) : Measurable fun b => dist (f b) (g b) :=
  (@continuous_dist α _).measurable2 hf hg

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[measurability #[]] theorem measurable_nndist : measurable (λ p : «expr × »(α, α), nndist p.1 p.2) :=
continuous_nndist.measurable

@[measurability]
theorem Measurable.nndist {f g : β → α} (hf : Measurable f) (hg : Measurable g) :
  Measurable fun b => nndist (f b) (g b) :=
  (@continuous_nndist α _).measurable2 hf hg

end MetricSpace

section EmetricSpace

variable[EmetricSpace α][MeasurableSpace α][OpensMeasurableSpace α]

variable[MeasurableSpace β]{x : α}{ε : ℝ≥0∞}

open Emetric

@[measurability]
theorem measurable_set_eball : MeasurableSet (Emetric.Ball x ε) :=
  Emetric.is_open_ball.MeasurableSet

@[measurability]
theorem measurable_edist_right : Measurable (edist x) :=
  (continuous_const.edist continuous_id).Measurable

@[measurability]
theorem measurable_edist_left : Measurable fun y => edist y x :=
  (continuous_id.edist continuous_const).Measurable

@[measurability]
theorem measurable_inf_edist {s : Set α} : Measurable fun x => inf_edist x s :=
  continuous_inf_edist.Measurable

@[measurability]
theorem Measurable.inf_edist {f : β → α} (hf : Measurable f) {s : Set α} : Measurable fun x => inf_edist (f x) s :=
  measurable_inf_edist.comp hf

variable[second_countable_topology α]

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[measurability #[]] theorem measurable_edist : measurable (λ p : «expr × »(α, α), edist p.1 p.2) :=
continuous_edist.measurable

@[measurability]
theorem Measurable.edist {f g : β → α} (hf : Measurable f) (hg : Measurable g) :
  Measurable fun b => edist (f b) (g b) :=
  (@continuous_edist α _).measurable2 hf hg

@[measurability]
theorem AeMeasurable.edist {f g : β → α} {μ : Measureₓ β} (hf : AeMeasurable f μ) (hg : AeMeasurable g μ) :
  AeMeasurable (fun a => edist (f a) (g a)) μ :=
  (@continuous_edist α _).ae_measurable2 hf hg

end EmetricSpace

namespace Real

open MeasurableSpace MeasureTheory

theorem borel_eq_generate_from_Ioo_rat : borel ℝ = generate_from (⋃(a b : ℚ)(h : a < b), {Ioo a b}) :=
  is_topological_basis_Ioo_rat.borel_eq_generate_from

theorem is_pi_system_Ioo_rat : @IsPiSystem ℝ (⋃(a b : ℚ)(h : a < b), {Ioo a b}) :=
  by 
    convert is_pi_system_Ioo (coeₓ : ℚ → ℝ) (coeₓ : ℚ → ℝ)
    ext x 
    simp [eq_comm]

/-- The intervals `(-(n + 1), (n + 1))` form a finite spanning sets in the set of open intervals
with rational endpoints for a locally finite measure `μ` on `ℝ`. -/
def finite_spanning_sets_in_Ioo_rat (μ : Measureₓ ℝ) [is_locally_finite_measure μ] :
  μ.finite_spanning_sets_in (⋃(a b : ℚ)(h : a < b), {Ioo a b}) :=
  { Set := fun n => Ioo (-n+1) (n+1),
    set_mem :=
      fun n =>
        by 
          simp only [mem_Union, mem_singleton_iff]
          refine'
            ⟨-n+1, n+1, _,
              by 
                normCast⟩
          exact (neg_nonpos.2 (@Nat.cast_nonneg ℚ _ (n+1))).trans_lt n.cast_add_one_pos,
    Finite := fun n => measure_Ioo_lt_top,
    spanning :=
      Union_eq_univ_iff.2$
        fun x =>
          ⟨⌊|x|⌋₊, neg_lt.1 ((neg_le_abs_self x).trans_lt (Nat.lt_floor_add_one _)),
            (le_abs_self x).trans_lt (Nat.lt_floor_add_one _)⟩ }

theorem measure_ext_Ioo_rat {μ ν : Measureₓ ℝ} [is_locally_finite_measure μ]
  (h : ∀ (a b : ℚ), μ (Ioo a b) = ν (Ioo a b)) : μ = ν :=
  (finite_spanning_sets_in_Ioo_rat μ).ext borel_eq_generate_from_Ioo_rat is_pi_system_Ioo_rat$
    by 
      simp only [mem_Union, mem_singleton_iff]
      rintro _ ⟨a, b, -, rfl⟩
      apply h

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem borel_eq_generate_from_Iio_rat : «expr = »(borel exprℝ(), generate_from «expr⋃ , »((a : exprℚ()), {Iio a})) :=
begin
  let [ident g] [":", expr measurable_space exprℝ()] [":=", expr generate_from «expr⋃ , »((a : exprℚ()), {Iio a})],
  refine [expr le_antisymm _ _],
  { rw [expr borel_eq_generate_from_Ioo_rat] [],
    refine [expr generate_from_le (λ t, _)],
    simp [] [] ["only"] ["[", expr mem_Union, ",", expr mem_singleton_iff, "]"] [] [],
    rintro ["⟨", ident a, ",", ident b, ",", ident h, ",", ident rfl, "⟩"],
    rw [expr (set.ext (λ
      x, _) : «expr = »(Ioo (a : exprℝ()) b, «expr ∩ »(«expr⋃ , »((c «expr > » a), «expr ᶜ»(Iio c)), Iio b)))] [],
    { have [ident hg] [":", expr ∀
       q : exprℚ(), g.measurable_set' (Iio q)] [":=", expr λ
       q, generate_measurable.basic (Iio q) (by { simp [] [] [] [] [] [], exact [expr ⟨_, rfl⟩] })],
      refine [expr @measurable_set.inter _ g _ _ _ (hg _)],
      refine [expr @measurable_set.bUnion _ _ g _ _ (countable_encodable _) (λ c h, _)],
      exact [expr @measurable_set.compl _ _ g (hg _)] },
    { suffices [] [":", expr «expr < »(x, «expr↑ »(b)) → «expr ↔ »(«expr < »(«expr↑ »(a), x), «expr∃ , »((i : exprℚ()), «expr ∧ »(«expr < »(a, i), «expr ≤ »(«expr↑ »(i), x))))],
      by simpa [] [] [] [] [] [],
      refine [expr λ _, ⟨λ h, _, λ ⟨i, hai, hix⟩, (rat.cast_lt.2 hai).trans_le hix⟩],
      rcases [expr exists_rat_btwn h, "with", "⟨", ident c, ",", ident ac, ",", ident cx, "⟩"],
      exact [expr ⟨c, rat.cast_lt.1 ac, cx.le⟩] } },
  { refine [expr measurable_space.generate_from_le (λ _, _)],
    simp [] [] ["only"] ["[", expr mem_Union, ",", expr mem_singleton_iff, "]"] [] [],
    rintro ["⟨", ident r, ",", ident rfl, "⟩"],
    exact [expr measurable_set_Iio] }
end

end Real

variable[MeasurableSpace α]

@[measurability]
theorem measurable_real_to_nnreal : Measurable Real.toNnreal :=
  Nnreal.continuous_of_real.Measurable

@[measurability]
theorem Measurable.real_to_nnreal {f : α → ℝ} (hf : Measurable f) : Measurable fun x => Real.toNnreal (f x) :=
  measurable_real_to_nnreal.comp hf

@[measurability]
theorem AeMeasurable.real_to_nnreal {f : α → ℝ} {μ : Measureₓ α} (hf : AeMeasurable f μ) :
  AeMeasurable (fun x => Real.toNnreal (f x)) μ :=
  measurable_real_to_nnreal.comp_ae_measurable hf

@[measurability]
theorem measurable_coe_nnreal_real : Measurable (coeₓ :  ℝ≥0  → ℝ) :=
  Nnreal.continuous_coe.Measurable

@[measurability]
theorem Measurable.coe_nnreal_real {f : α →  ℝ≥0 } (hf : Measurable f) : Measurable fun x => (f x : ℝ) :=
  measurable_coe_nnreal_real.comp hf

@[measurability]
theorem AeMeasurable.coe_nnreal_real {f : α →  ℝ≥0 } {μ : Measureₓ α} (hf : AeMeasurable f μ) :
  AeMeasurable (fun x => (f x : ℝ)) μ :=
  measurable_coe_nnreal_real.comp_ae_measurable hf

@[measurability]
theorem measurable_coe_nnreal_ennreal : Measurable (coeₓ :  ℝ≥0  → ℝ≥0∞) :=
  Ennreal.continuous_coe.Measurable

@[measurability]
theorem Measurable.coe_nnreal_ennreal {f : α →  ℝ≥0 } (hf : Measurable f) : Measurable fun x => (f x : ℝ≥0∞) :=
  Ennreal.continuous_coe.Measurable.comp hf

@[measurability]
theorem AeMeasurable.coe_nnreal_ennreal {f : α →  ℝ≥0 } {μ : Measureₓ α} (hf : AeMeasurable f μ) :
  AeMeasurable (fun x => (f x : ℝ≥0∞)) μ :=
  Ennreal.continuous_coe.Measurable.comp_ae_measurable hf

@[measurability]
theorem Measurable.ennreal_of_real {f : α → ℝ} (hf : Measurable f) : Measurable fun x => Ennreal.ofReal (f x) :=
  Ennreal.continuous_of_real.Measurable.comp hf

/-- The set of finite `ℝ≥0∞` numbers is `measurable_equiv` to `ℝ≥0`. -/
def MeasurableEquiv.ennrealEquivNnreal : { r:ℝ≥0∞ | r ≠ ∞ } ≃ᵐ  ℝ≥0  :=
  Ennreal.neTopHomeomorphNnreal.toMeasurableEquiv

namespace Ennreal

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem measurable_of_measurable_nnreal
{f : «exprℝ≥0∞»() → α}
(h : measurable (λ p : «exprℝ≥0»(), f p)) : measurable f :=
measurable_of_measurable_on_compl_singleton «expr∞»() (measurable_equiv.ennreal_equiv_nnreal.symm.measurable_comp_iff.1 h)

/-- `ℝ≥0∞` is `measurable_equiv` to `ℝ≥0 ⊕ unit`. -/
def ennreal_equiv_sum : ℝ≥0∞ ≃ᵐ Sum ℝ≥0  Unit :=
  { Equiv.optionEquivSumPunit ℝ≥0  with measurable_to_fun := measurable_of_measurable_nnreal measurable_inl,
    measurable_inv_fun := measurable_sum measurable_coe_nnreal_ennreal (@measurable_const ℝ≥0∞ Unit _ _ ∞) }

open function(uncurry)

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem measurable_of_measurable_nnreal_prod
[measurable_space β]
[measurable_space γ]
{f : «expr × »(«exprℝ≥0∞»(), β) → γ}
(H₁ : measurable (λ p : «expr × »(«exprℝ≥0»(), β), f (p.1, p.2)))
(H₂ : measurable (λ x, f («expr∞»(), x))) : measurable f :=
let e : «expr ≃ᵐ »(«expr × »(«exprℝ≥0∞»(), β), «expr ⊕ »(«expr × »(«exprℝ≥0»(), β), «expr × »(unit, β))) := (ennreal_equiv_sum.prod_congr (measurable_equiv.refl β)).trans (measurable_equiv.sum_prod_distrib _ _ _) in
«expr $ »(e.symm.measurable_comp_iff.1, measurable_sum H₁ (H₂.comp measurable_id.snd))

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem measurable_of_measurable_nnreal_nnreal
[measurable_space β]
{f : «expr × »(«exprℝ≥0∞»(), «exprℝ≥0∞»()) → β}
(h₁ : measurable (λ p : «expr × »(«exprℝ≥0»(), «exprℝ≥0»()), f (p.1, p.2)))
(h₂ : measurable (λ r : «exprℝ≥0»(), f («expr∞»(), r)))
(h₃ : measurable (λ r : «exprℝ≥0»(), f (r, «expr∞»()))) : measurable f :=
measurable_of_measurable_nnreal_prod «expr $ »(measurable_swap_iff.1, measurable_of_measurable_nnreal_prod (h₁.comp measurable_swap) h₃) (measurable_of_measurable_nnreal h₂)

@[measurability]
theorem measurable_of_real : Measurable Ennreal.ofReal :=
  Ennreal.continuous_of_real.Measurable

@[measurability]
theorem measurable_to_real : Measurable Ennreal.toReal :=
  Ennreal.measurable_of_measurable_nnreal measurable_coe_nnreal_real

@[measurability]
theorem measurable_to_nnreal : Measurable Ennreal.toNnreal :=
  Ennreal.measurable_of_measurable_nnreal measurable_id

instance  : HasMeasurableMul₂ ℝ≥0∞ :=
  by 
    refine' ⟨measurable_of_measurable_nnreal_nnreal _ _ _⟩
    ·
      simp only [←Ennreal.coe_mul, measurable_mul.coe_nnreal_ennreal]
    ·
      simp only [Ennreal.top_mul, Ennreal.coe_eq_zero]
      exact measurable_const.piecewise (measurable_set_singleton _) measurable_const
    ·
      simp only [Ennreal.mul_top, Ennreal.coe_eq_zero]
      exact measurable_const.piecewise (measurable_set_singleton _) measurable_const

instance  : HasMeasurableSub₂ ℝ≥0∞ :=
  ⟨by 
      apply measurable_of_measurable_nnreal_nnreal <;>
        simp [←WithTop.coe_sub, continuous_sub.measurable.coe_nnreal_ennreal]⟩

instance  : HasMeasurableInv ℝ≥0∞ :=
  ⟨Ennreal.continuous_inv.Measurable⟩

end Ennreal

@[measurability]
theorem Measurable.ennreal_to_nnreal {f : α → ℝ≥0∞} (hf : Measurable f) : Measurable fun x => (f x).toNnreal :=
  Ennreal.measurable_to_nnreal.comp hf

@[measurability]
theorem AeMeasurable.ennreal_to_nnreal {f : α → ℝ≥0∞} {μ : Measureₓ α} (hf : AeMeasurable f μ) :
  AeMeasurable (fun x => (f x).toNnreal) μ :=
  Ennreal.measurable_to_nnreal.comp_ae_measurable hf

theorem measurable_coe_nnreal_ennreal_iff {f : α →  ℝ≥0 } : (Measurable fun x => (f x : ℝ≥0∞)) ↔ Measurable f :=
  ⟨fun h => h.ennreal_to_nnreal, fun h => h.coe_nnreal_ennreal⟩

@[measurability]
theorem Measurable.ennreal_to_real {f : α → ℝ≥0∞} (hf : Measurable f) : Measurable fun x => Ennreal.toReal (f x) :=
  Ennreal.measurable_to_real.comp hf

@[measurability]
theorem AeMeasurable.ennreal_to_real {f : α → ℝ≥0∞} {μ : Measureₓ α} (hf : AeMeasurable f μ) :
  AeMeasurable (fun x => Ennreal.toReal (f x)) μ :=
  Ennreal.measurable_to_real.comp_ae_measurable hf

/-- note: `ℝ≥0∞` can probably be generalized in a future version of this lemma. -/
@[measurability]
theorem Measurable.ennreal_tsum {ι} [Encodable ι] {f : ι → α → ℝ≥0∞} (h : ∀ i, Measurable (f i)) :
  Measurable fun x => ∑'i, f i x :=
  by 
    simpRw [Ennreal.tsum_eq_supr_sum]
    apply measurable_supr 
    exact fun s => s.measurable_sum fun i _ => h i

@[measurability]
theorem Measurable.ennreal_tsum' {ι} [Encodable ι] {f : ι → α → ℝ≥0∞} (h : ∀ i, Measurable (f i)) :
  Measurable (∑'i, f i) :=
  by 
    convert Measurable.ennreal_tsum h 
    ext1 x 
    exact tsum_apply (Pi.summable.2 fun _ => Ennreal.summable)

@[measurability]
theorem Measurable.nnreal_tsum {ι} [Encodable ι] {f : ι → α →  ℝ≥0 } (h : ∀ i, Measurable (f i)) :
  Measurable fun x => ∑'i, f i x :=
  by 
    simpRw [Nnreal.tsum_eq_to_nnreal_tsum]
    exact (Measurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_to_nnreal

@[measurability]
theorem AeMeasurable.ennreal_tsum {ι} [Encodable ι] {f : ι → α → ℝ≥0∞} {μ : Measureₓ α}
  (h : ∀ i, AeMeasurable (f i) μ) : AeMeasurable (fun x => ∑'i, f i x) μ :=
  by 
    simpRw [Ennreal.tsum_eq_supr_sum]
    apply ae_measurable_supr 
    exact fun s => Finset.ae_measurable_sum s fun i _ => h i

@[measurability]
theorem measurable_coe_real_ereal : Measurable (coeₓ : ℝ → Ereal) :=
  continuous_coe_real_ereal.Measurable

@[measurability]
theorem Measurable.coe_real_ereal {f : α → ℝ} (hf : Measurable f) : Measurable fun x => (f x : Ereal) :=
  measurable_coe_real_ereal.comp hf

@[measurability]
theorem AeMeasurable.coe_real_ereal {f : α → ℝ} {μ : Measureₓ α} (hf : AeMeasurable f μ) :
  AeMeasurable (fun x => (f x : Ereal)) μ :=
  measurable_coe_real_ereal.comp_ae_measurable hf

/-- The set of finite `ereal` numbers is `measurable_equiv` to `ℝ`. -/
def MeasurableEquiv.erealEquivReal : ({⊥, ⊤} : Set Ereal).Compl ≃ᵐ ℝ :=
  Ereal.neBotTopHomeomorphReal.toMeasurableEquiv

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem ereal.measurable_of_measurable_real {f : ereal → α} (h : measurable (λ p : exprℝ(), f p)) : measurable f :=
measurable_of_measurable_on_compl_finite {«expr⊥»(), «expr⊤»()} (by simp [] [] [] [] [] []) (measurable_equiv.ereal_equiv_real.symm.measurable_comp_iff.1 h)

@[measurability]
theorem measurable_ereal_to_real : Measurable Ereal.toReal :=
  Ereal.measurable_of_measurable_real
    (by 
      simpa using measurable_id)

@[measurability]
theorem Measurable.ereal_to_real {f : α → Ereal} (hf : Measurable f) : Measurable fun x => (f x).toReal :=
  measurable_ereal_to_real.comp hf

@[measurability]
theorem AeMeasurable.ereal_to_real {f : α → Ereal} {μ : Measureₓ α} (hf : AeMeasurable f μ) :
  AeMeasurable (fun x => (f x).toReal) μ :=
  measurable_ereal_to_real.comp_ae_measurable hf

@[measurability]
theorem measurable_coe_ennreal_ereal : Measurable (coeₓ : ℝ≥0∞ → Ereal) :=
  continuous_coe_ennreal_ereal.Measurable

@[measurability]
theorem Measurable.coe_ereal_ennreal {f : α → ℝ≥0∞} (hf : Measurable f) : Measurable fun x => (f x : Ereal) :=
  measurable_coe_ennreal_ereal.comp hf

@[measurability]
theorem AeMeasurable.coe_ereal_ennreal {f : α → ℝ≥0∞} {μ : Measureₓ α} (hf : AeMeasurable f μ) :
  AeMeasurable (fun x => (f x : Ereal)) μ :=
  measurable_coe_ennreal_ereal.comp_ae_measurable hf

section NormedGroup

variable[NormedGroup α][OpensMeasurableSpace α][MeasurableSpace β]

@[measurability]
theorem measurable_norm : Measurable (norm : α → ℝ) :=
  continuous_norm.Measurable

@[measurability]
theorem Measurable.norm {f : β → α} (hf : Measurable f) : Measurable fun a => norm (f a) :=
  measurable_norm.comp hf

@[measurability]
theorem AeMeasurable.norm {f : β → α} {μ : Measureₓ β} (hf : AeMeasurable f μ) : AeMeasurable (fun a => norm (f a)) μ :=
  measurable_norm.comp_ae_measurable hf

@[measurability]
theorem measurable_nnnorm : Measurable (nnnorm : α →  ℝ≥0 ) :=
  continuous_nnnorm.Measurable

@[measurability]
theorem Measurable.nnnorm {f : β → α} (hf : Measurable f) : Measurable fun a => nnnorm (f a) :=
  measurable_nnnorm.comp hf

@[measurability]
theorem AeMeasurable.nnnorm {f : β → α} {μ : Measureₓ β} (hf : AeMeasurable f μ) :
  AeMeasurable (fun a => nnnorm (f a)) μ :=
  measurable_nnnorm.comp_ae_measurable hf

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[measurability #[]] theorem measurable_ennnorm : measurable (λ x : α, (nnnorm x : «exprℝ≥0∞»())) :=
measurable_nnnorm.coe_nnreal_ennreal

@[measurability]
theorem Measurable.ennnorm {f : β → α} (hf : Measurable f) : Measurable fun a => (nnnorm (f a) : ℝ≥0∞) :=
  hf.nnnorm.coe_nnreal_ennreal

@[measurability]
theorem AeMeasurable.ennnorm {f : β → α} {μ : Measureₓ β} (hf : AeMeasurable f μ) :
  AeMeasurable (fun a => (nnnorm (f a) : ℝ≥0∞)) μ :=
  measurable_ennnorm.comp_ae_measurable hf

end NormedGroup

section Limits

variable[MeasurableSpace β][MetricSpace β][BorelSpace β]

open Metric

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- A limit (over a general filter) of measurable `ℝ≥0` valued functions is measurable. -/
theorem measurable_of_tendsto_nnreal'
{ι}
{f : ι → α → «exprℝ≥0»()}
{g : α → «exprℝ≥0»()}
(u : filter ι)
[ne_bot u]
[is_countably_generated u]
(hf : ∀ i, measurable (f i))
(lim : tendsto f u (expr𝓝() g)) : measurable g :=
begin
  rcases [expr u.exists_seq_tendsto, "with", "⟨", ident x, ",", ident hx, "⟩"],
  rw ["[", expr tendsto_pi_nhds, "]"] ["at", ident lim],
  rw ["[", "<-", expr measurable_coe_nnreal_ennreal_iff, "]"] [],
  have [] [":", expr ∀
   y, «expr = »(liminf at_top (λ
     n, (f (x n) y : «exprℝ≥0∞»())), (g y : «exprℝ≥0∞»()))] [":=", expr λ
   y, «expr $ »((ennreal.continuous_coe.tendsto (g y)).comp, (lim y).comp hx).liminf_eq],
  simp [] [] ["only"] ["[", "<-", expr this, "]"] [] [],
  show [expr measurable (λ y, liminf at_top (λ n, (f (x n) y : «exprℝ≥0∞»())))],
  exact [expr measurable_liminf (λ n, (hf (x n)).coe_nnreal_ennreal)]
end

/-- A sequential limit of measurable `ℝ≥0` valued functions is measurable. -/
theorem measurable_of_tendsto_nnreal {f : ℕ → α →  ℝ≥0 } {g : α →  ℝ≥0 } (hf : ∀ i, Measurable (f i))
  (lim : tendsto f at_top (𝓝 g)) : Measurable g :=
  measurable_of_tendsto_nnreal' at_top hf limₓ

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- A limit (over a general filter) of measurable functions valued in a metric space is measurable.
The assumption `hs` can be dropped using `filter.is_countably_generated.has_antitone_basis`, but we
don't need that case yet. -/
theorem measurable_of_tendsto_metric'
{ι}
{f : ι → α → β}
{g : α → β}
(u : filter ι)
[ne_bot u]
[is_countably_generated u]
(hf : ∀ i, measurable (f i))
(lim : tendsto f u (expr𝓝() g)) : measurable g :=
begin
  apply [expr measurable_of_is_closed'],
  intros [ident s, ident h1s, ident h2s, ident h3s],
  have [] [":", expr measurable (λ x, inf_nndist (g x) s)] [],
  { suffices [] [":", expr tendsto (λ i x, inf_nndist (f i x) s) u (expr𝓝() (λ x, inf_nndist (g x) s))],
    from [expr measurable_of_tendsto_nnreal' u (λ i, (hf i).inf_nndist) this],
    rw ["[", expr tendsto_pi_nhds, "]"] ["at", ident lim, "⊢"],
    intro [ident x],
    exact [expr ((continuous_inf_nndist_pt s).tendsto (g x)).comp (lim x)] },
  have [ident h4s] [":", expr «expr = »(«expr ⁻¹' »(g, s), «expr ⁻¹' »(λ x, inf_nndist (g x) s, {0}))] [],
  { ext [] [ident x] [],
    simp [] [] [] ["[", expr h1s, ",", "<-", expr h1s.mem_iff_inf_dist_zero h2s, ",", "<-", expr nnreal.coe_eq_zero, "]"] [] [] },
  rw ["[", expr h4s, "]"] [],
  exact [expr this (measurable_set_singleton 0)]
end

/-- A sequential limit of measurable functions valued in a metric space is measurable. -/
theorem measurable_of_tendsto_metric {f : ℕ → α → β} {g : α → β} (hf : ∀ i, Measurable (f i))
  (lim : tendsto f at_top (𝓝 g)) : Measurable g :=
  measurable_of_tendsto_metric' at_top hf limₓ

theorem ae_measurable_of_tendsto_metric_ae {μ : Measureₓ α} {f : ℕ → α → β} {g : α → β} (hf : ∀ n, AeMeasurable (f n) μ)
  (h_ae_tendsto : ∀ᵐx ∂μ, tendsto (fun n => f n x) at_top (𝓝 (g x))) : AeMeasurable g μ :=
  by 
    let p : α → (ℕ → β) → Prop := fun x f' => filter.at_top.tendsto (fun n => f' n) (𝓝 (g x))
    let hp : ∀ᵐx ∂μ, p x fun n => f n x 
    exact h_ae_tendsto 
    let ae_seq_lim := fun x => ite (x ∈ AeSeqSet hf p) (g x) (⟨f 0 x⟩ : Nonempty β).some 
    refine'
      ⟨ae_seq_lim, _,
        (ite_ae_eq_of_measure_compl_zero g (fun x => (⟨f 0 x⟩ : Nonempty β).some) (AeSeqSet hf p)
            (aeSeq.measure_compl_ae_seq_set_eq_zero hf hp)).symm⟩
    refine' measurable_of_tendsto_metric (@aeSeq.measurable α β _ _ _ f μ hf p) _ 
    refine' tendsto_pi_nhds.mpr fun x => _ 
    simpRw [aeSeq, ae_seq_lim]
    splitIfs with hx
    ·
      simpRw [aeSeq.mk_eq_fun_of_mem_ae_seq_set hf hx]
      exact @aeSeq.fun_prop_of_mem_ae_seq_set α β _ _ _ _ _ _ hf x hx
    ·
      exact tendsto_const_nhds

theorem measurable_of_tendsto_metric_ae {μ : Measureₓ α} [μ.is_complete] {f : ℕ → α → β} {g : α → β}
  (hf : ∀ n, Measurable (f n)) (h_ae_tendsto : ∀ᵐx ∂μ, Filter.atTop.Tendsto (fun n => f n x) (𝓝 (g x))) :
  Measurable g :=
  ae_measurable_iff_measurable.mp (ae_measurable_of_tendsto_metric_ae (fun i => (hf i).AeMeasurable) h_ae_tendsto)

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem measurable_limit_of_tendsto_metric_ae
{μ : measure α}
{f : exprℕ() → α → β}
(hf : ∀ n, ae_measurable (f n) μ)
(h_ae_tendsto : «expr∀ᵐ ∂ , »((x), μ, «expr∃ , »((l : β), filter.at_top.tendsto (λ
    n, f n x) (expr𝓝() l)))) : «expr∃ , »((f_lim : α → β)
 (hf_lim_meas : measurable f_lim), «expr∀ᵐ ∂ , »((x), μ, filter.at_top.tendsto (λ n, f n x) (expr𝓝() (f_lim x)))) :=
begin
  let [ident p] [":", expr α → (exprℕ() → β) → exprProp()] [":=", expr λ
   x f', «expr∃ , »((l : β), filter.at_top.tendsto (λ n, f' n) (expr𝓝() l))],
  have [ident hp_mem] [":", expr ∀ x, «expr ∈ »(x, ae_seq_set hf p) → p x (λ n, f n x)] [],
  from [expr λ x hx, ae_seq.fun_prop_of_mem_ae_seq_set hf hx],
  have [ident hμ_compl] [":", expr «expr = »(μ «expr ᶜ»(ae_seq_set hf p), 0)] [],
  from [expr ae_seq.measure_compl_ae_seq_set_eq_zero hf h_ae_tendsto],
  let [ident f_lim] [":", expr α → β] [":=", expr λ
   x, dite «expr ∈ »(x, ae_seq_set hf p) (λ h, (hp_mem x h).some) (λ h, (⟨f 0 x⟩ : nonempty β).some)],
  have [ident hf_lim_conv] [":", expr ∀
   x, «expr ∈ »(x, ae_seq_set hf p) → filter.at_top.tendsto (λ n, f n x) (expr𝓝() (f_lim x))] [],
  { intros [ident x, ident hx_conv],
    simp [] [] ["only"] ["[", expr f_lim, ",", expr hx_conv, ",", expr dif_pos, "]"] [] [],
    exact [expr (hp_mem x hx_conv).some_spec] },
  have [ident hf_lim] [":", expr ∀ x, filter.at_top.tendsto (λ n, ae_seq hf p n x) (expr𝓝() (f_lim x))] [],
  { intros [ident x],
    simp [] [] ["only"] ["[", expr f_lim, ",", expr ae_seq, "]"] [] [],
    split_ifs [] [],
    { rw [expr funext (λ n, ae_seq.mk_eq_fun_of_mem_ae_seq_set hf h n)] [],
      exact [expr (hp_mem x h).some_spec] },
    { exact [expr tendsto_const_nhds] } },
  have [ident h_ae_tendsto_f_lim] [":", expr «expr∀ᵐ ∂ , »((x), μ, filter.at_top.tendsto (λ
     n, f n x) (expr𝓝() (f_lim x)))] [],
  { refine [expr le_antisymm (le_of_eq (measure_mono_null _ hμ_compl)) (zero_le _)],
    exact [expr set.compl_subset_compl.mpr (λ x hx, hf_lim_conv x hx)] },
  have [ident h_f_lim_meas] [":", expr measurable f_lim] [],
  from [expr measurable_of_tendsto_metric (ae_seq.measurable hf p) (tendsto_pi_nhds.mpr (λ x, hf_lim x))],
  exact [expr ⟨f_lim, h_f_lim_meas, h_ae_tendsto_f_lim⟩]
end

end Limits

namespace ContinuousLinearMap

variable{𝕜 : Type _}[NormedField 𝕜]

variable{E : Type _}[NormedGroup E][NormedSpace 𝕜 E][MeasurableSpace E]

variable[OpensMeasurableSpace E]

variable{F : Type _}[NormedGroup F][NormedSpace 𝕜 F][MeasurableSpace F][BorelSpace F]

@[measurability]
protected theorem Measurable (L : E →L[𝕜] F) : Measurable L :=
  L.continuous.measurable

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem measurable_comp
(L : «expr →L[ ] »(E, 𝕜, F))
{φ : α → E}
(φ_meas : measurable φ) : measurable (λ a : α, L (φ a)) :=
L.measurable.comp φ_meas

end ContinuousLinearMap

namespace ContinuousLinearMap

variable{𝕜 : Type _}[NondiscreteNormedField 𝕜]

variable{E : Type _}[NormedGroup E][NormedSpace 𝕜 E]{F : Type _}[NormedGroup F][NormedSpace 𝕜 F]

instance  : MeasurableSpace (E →L[𝕜] F) :=
  borel _

instance  : BorelSpace (E →L[𝕜] F) :=
  ⟨rfl⟩

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[measurability #[]]
theorem measurable_apply
[measurable_space F]
[borel_space F]
(x : E) : measurable (λ f : «expr →L[ ] »(E, 𝕜, F), f x) :=
(apply 𝕜 F x).continuous.measurable

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[measurability #[]]
theorem measurable_apply'
[measurable_space E]
[opens_measurable_space E]
[measurable_space F]
[borel_space F] : measurable (λ (x : E) (f : «expr →L[ ] »(E, 𝕜, F)), f x) :=
«expr $ »(measurable_pi_lambda _, λ f, f.measurable)

-- error in MeasureTheory.Constructions.BorelSpace: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[measurability #[]]
theorem measurable_coe
[measurable_space F]
[borel_space F] : measurable (λ (f : «expr →L[ ] »(E, 𝕜, F)) (x : E), f x) :=
measurable_pi_lambda _ measurable_apply

end ContinuousLinearMap

section ContinuousLinearMapNondiscreteNormedField

variable{𝕜 : Type _}[NondiscreteNormedField 𝕜]

variable{E : Type _}[NormedGroup E][NormedSpace 𝕜 E][MeasurableSpace E][BorelSpace E]

variable{F : Type _}[NormedGroup F][NormedSpace 𝕜 F]

@[measurability]
theorem Measurable.apply_continuous_linear_map {φ : α → F →L[𝕜] E} (hφ : Measurable φ) (v : F) :
  Measurable fun a => φ a v :=
  (ContinuousLinearMap.apply 𝕜 E v).Measurable.comp hφ

@[measurability]
theorem AeMeasurable.apply_continuous_linear_map {φ : α → F →L[𝕜] E} {μ : Measureₓ α} (hφ : AeMeasurable φ μ) (v : F) :
  AeMeasurable (fun a => φ a v) μ :=
  (ContinuousLinearMap.apply 𝕜 E v).Measurable.comp_ae_measurable hφ

end ContinuousLinearMapNondiscreteNormedField

section NormedSpace

variable{𝕜 : Type _}[NondiscreteNormedField 𝕜][CompleteSpace 𝕜][MeasurableSpace 𝕜]

variable[BorelSpace 𝕜]

variable{E : Type _}[NormedGroup E][NormedSpace 𝕜 E][MeasurableSpace E][BorelSpace E]

theorem measurable_smul_const {f : α → 𝕜} {c : E} (hc : c ≠ 0) : (Measurable fun x => f x • c) ↔ Measurable f :=
  (closed_embedding_smul_left hc).MeasurableEmbedding.measurable_comp_iff

theorem ae_measurable_smul_const {f : α → 𝕜} {μ : Measureₓ α} {c : E} (hc : c ≠ 0) :
  AeMeasurable (fun x => f x • c) μ ↔ AeMeasurable f μ :=
  (closed_embedding_smul_left hc).MeasurableEmbedding.ae_measurable_comp_iff

end NormedSpace

