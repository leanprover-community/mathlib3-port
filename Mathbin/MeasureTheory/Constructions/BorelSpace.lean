/-
Copyright (c) 2017 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Yury Kudryashov
-/
import Mathbin.Analysis.Complex.Basic
import Mathbin.Analysis.NormedSpace.FiniteDimension
import Mathbin.MeasureTheory.Function.AeMeasurableSequence
import Mathbin.MeasureTheory.Group.Arithmetic
import Mathbin.MeasureTheory.Lattice
import Mathbin.MeasureTheory.Measure.OpenPos
import Mathbin.Topology.Algebra.Order.LiminfLimsup
import Mathbin.Topology.ContinuousFunction.Basic
import Mathbin.Topology.Instances.AddCircle
import Mathbin.Topology.Instances.Ereal
import Mathbin.Topology.GDelta
import Mathbin.Topology.Order.Lattice
import Mathbin.Topology.Semicontinuous
import Mathbin.Topology.MetricSpace.Metrizable

/-!
# Borel (measurable) space

## Main definitions

* `borel α` : the least `σ`-algebra that contains all open sets;
* `class borel_space` : a space with `topological_space` and `measurable_space` structures
  such that `‹measurable_space α› = borel α`;
* `class opens_measurable_space` : a space with `topological_space` and `measurable_space`
  structures such that all open sets are measurable; equivalently, `borel α ≤ ‹measurable_space α›`.
* `borel_space` instances on `empty`, `unit`, `bool`, `nat`, `int`, `rat`;
* `measurable` and `borel_space` instances on `ℝ`, `ℝ≥0`, `ℝ≥0∞`.

## Main statements

* `is_open.measurable_set`, `is_closed.measurable_set`: open and closed sets are measurable;
* `continuous.measurable` : a continuous function is measurable;
* `continuous.measurable2` : if `f : α → β` and `g : α → γ` are measurable and `op : β × γ → δ`
  is continuous, then `λ x, op (f x, g y)` is measurable;
* `measurable.add` etc : dot notation for arithmetic operations on `measurable` predicates,
  and similarly for `dist` and `edist`;
* `ae_measurable.add` : similar dot notation for almost everywhere measurable functions;
* `measurable.ennreal*` : special cases for arithmetic operations on `ℝ≥0∞`.
-/


noncomputable section

open Classical Set Filter MeasureTheory

open Classical BigOperators TopologicalSpace Nnreal Ennreal MeasureTheory

universe u v w x y

variable {α β γ γ₂ δ : Type _} {ι : Sort y} {s t u : Set α}

open MeasurableSpace TopologicalSpace

/-- `measurable_space` structure generated by `topological_space`. -/
def borel (α : Type u) [TopologicalSpace α] : MeasurableSpace α :=
  generateFrom { s : Set α | IsOpen s }

theorem borel_eq_top_of_discrete [TopologicalSpace α] [DiscreteTopology α] : borel α = ⊤ :=
  top_le_iff.1 fun s hs => GenerateMeasurable.basic s (is_open_discrete s)

theorem borel_eq_top_of_countable [TopologicalSpace α] [T1Space α] [Countable α] : borel α = ⊤ := by
  refine' top_le_iff.1 fun s hs => bUnion_of_singleton s ▸ _
  apply MeasurableSet.bUnion s.to_countable
  intro x hx
  apply MeasurableSet.ofCompl
  apply generate_measurable.basic
  exact is_closed_singleton.is_open_compl

theorem borel_eq_generate_from_of_subbasis {s : Set (Set α)} [t : TopologicalSpace α] [SecondCountableTopology α]
    (hs : t = generateFrom s) : borel α = generateFrom s :=
  le_antisymm
    (generate_from_le fun u (hu : t.IsOpen u) => by
      rw [hs] at hu
      induction hu
      case basic u hu => exact generate_measurable.basic u hu
      case univ => exact @MeasurableSet.univ α (generate_from s)
      case inter s₁ s₂ _ _ hs₁ hs₂ => exact @MeasurableSet.inter α (generate_from s) _ _ hs₁ hs₂
      case sUnion f hf ih =>
      rcases is_open_sUnion_countable f (by rwa [hs]) with ⟨v, hv, vf, vu⟩
      rw [← vu]
      exact @MeasurableSet.sUnion α (generate_from s) _ hv fun x xv => ih _ (vf xv))
    (generate_from_le fun u hu =>
      GenerateMeasurable.basic _ <| show t.IsOpen u by rw [hs] <;> exact generate_open.basic _ hu)

theorem TopologicalSpace.IsTopologicalBasis.borel_eq_generate_from [TopologicalSpace α] [SecondCountableTopology α]
    {s : Set (Set α)} (hs : IsTopologicalBasis s) : borel α = generateFrom s :=
  borel_eq_generate_from_of_subbasis hs.eq_generate_from

theorem is_pi_system_is_open [TopologicalSpace α] : IsPiSystem (IsOpen : Set α → Prop) := fun s hs t ht hst =>
  IsOpen.inter hs ht

theorem borel_eq_generate_from_is_closed [TopologicalSpace α] : borel α = generateFrom { s | IsClosed s } :=
  le_antisymm
    (generate_from_le fun t ht =>
      @MeasurableSet.ofCompl α _ (generateFrom { s | IsClosed s })
        (GenerateMeasurable.basic _ <| is_closed_compl_iff.2 ht))
    (generate_from_le fun t ht =>
      @MeasurableSet.ofCompl α _ (borel α) (GenerateMeasurable.basic _ <| is_open_compl_iff.2 ht))

section OrderTopology

variable (α)

variable [TopologicalSpace α] [SecondCountableTopology α] [LinearOrder α] [OrderTopology α]

theorem borel_eq_generate_from_Iio : borel α = generateFrom (Range IioCat) := by
  refine' le_antisymm _ (generate_from_le _)
  · rw [borel_eq_generate_from_of_subbasis (@OrderTopology.topology_eq_generate_intervals α _ _ _)]
    letI : MeasurableSpace α := MeasurableSpace.generateFrom (range Iio)
    have H : ∀ a : α, MeasurableSet (Iio a) := fun a => generate_measurable.basic _ ⟨_, rfl⟩
    refine' generate_from_le _
    rintro _ ⟨a, rfl | rfl⟩ <;> [skip, apply H]
    by_cases h:∃ a', ∀ b, a < b ↔ a' ≤ b
    · rcases h with ⟨a', ha'⟩
      rw [(_ : Ioi a = Iio a'ᶜ)]
      · exact (H _).compl
        
      simp [Set.ext_iff, ha']
      
    · rcases is_open_Union_countable (fun a' : { a' : α // a < a' } => { b | a'.1 < b }) fun a' => is_open_lt' _ with
        ⟨v, ⟨hv⟩, vu⟩
      simp [Set.ext_iff] at vu
      have : Ioi a = ⋃ x : v, Iio x.1.1ᶜ := by
        simp [Set.ext_iff]
        refine' fun x => ⟨fun ax => _, fun ⟨a', ⟨h, av⟩, ax⟩ => lt_of_lt_of_le h ax⟩
        rcases(vu x).2 _ with ⟨a', h₁, h₂⟩
        · exact ⟨a', h₁, le_of_lt h₂⟩
          
        refine' not_imp_comm.1 (fun h => _) h
        exact ⟨x, fun b => ⟨fun ab => le_of_not_lt fun h' => h ⟨b, ab, h'⟩, lt_of_lt_of_le ax⟩⟩
      rw [this]
      skip
      apply MeasurableSet.union
      exact fun _ => (H _).compl
      
    
  · rw [forall_range_iff]
    intro a
    exact generate_measurable.basic _ is_open_Iio
    

theorem borel_eq_generate_from_Ioi : borel α = generateFrom (Range IoiCat) :=
  @borel_eq_generate_from_Iio αᵒᵈ _ (by infer_instance : SecondCountableTopology α) _ _

end OrderTopology

theorem borel_comap {f : α → β} {t : TopologicalSpace β} : @borel α (t.induced f) = (@borel β t).comap f :=
  comap_generate_from.symm

theorem Continuous.borelMeasurable [TopologicalSpace α] [TopologicalSpace β] {f : α → β} (hf : Continuous f) :
    @Measurable α β (borel α) (borel β) f :=
  Measurable.ofLeMap <| generate_from_le fun s hs => GenerateMeasurable.basic (f ⁻¹' s) (hs.Preimage hf)

/-- A space with `measurable_space` and `topological_space` structures such that
all open sets are measurable. -/
class OpensMeasurableSpace (α : Type _) [TopologicalSpace α] [h : MeasurableSpace α] : Prop where
  borel_le : borel α ≤ h

/-- A space with `measurable_space` and `topological_space` structures such that
the `σ`-algebra of measurable sets is exactly the `σ`-algebra generated by open sets. -/
class BorelSpace (α : Type _) [TopologicalSpace α] [MeasurableSpace α] : Prop where
  measurable_eq : ‹MeasurableSpace α› = borel α

namespace Tactic

/-- Add instances `borel α : measurable_space α` and `⟨rfl⟩ : borel_space α`. -/
unsafe def add_borel_instance (α : expr) : tactic Unit := do
  let n1 ← get_unused_name "_inst"
  to_expr (pquote.1 (borel (%%ₓα))) >>= pose n1
  reset_instance_cache
  let n2 ← get_unused_name "_inst"
  let v ← to_expr (pquote.1 (BorelSpace.mk rfl : BorelSpace (%%ₓα)))
  note n2 none v
  reset_instance_cache

/-- Given a type `α`, an assumption `i : measurable_space α`, and an instance `[borel_space α]`,
replace `i` with `borel α`. -/
unsafe def borel_to_refl (α i : expr) : tactic Unit := do
  let n ← get_unused_name "h"
  to_expr (pquote.1 ((%%ₓi) = borel (%%ₓα))) >>= assert n
  applyc `borel_space.measurable_eq
  unfreezing (tactic.subst i)
  let n1 ← get_unused_name "_inst"
  to_expr (pquote.1 (borel (%%ₓα))) >>= pose n1
  reset_instance_cache

/-- Given a type `α`, if there is an assumption `[i : measurable_space α]`, then try to prove
`[borel_space α]` and replace `i` with `borel α`. Otherwise, add instances
`borel α : measurable_space α` and `⟨rfl⟩ : borel_space α`. -/
unsafe def borelize (α : expr) : tactic Unit := do
  let i ← optional (to_expr (pquote.1 (MeasurableSpace (%%ₓα))) >>= find_assumption)
  i (add_borel_instance α) (borel_to_refl α)

namespace Interactive

setup_tactic_parser

/-- The behaviour of `borelize α` depends on the existing assumptions on `α`.

- if `α` is a topological space with instances `[measurable_space α] [borel_space α]`, then
  `borelize α` replaces the former instance by `borel α`;
- otherwise, `borelize α` adds instances `borel α : measurable_space α` and `⟨rfl⟩ : borel_space α`.

Finally, `borelize [α, β, γ]` runs `borelize α, borelize β, borelize γ`.
-/
unsafe def borelize (ts : parse pexpr_list_or_texpr) : tactic Unit :=
  mmap' (fun t => to_expr t >>= tactic.borelize) ts

add_tactic_doc
  { Name := "borelize", category := DocCategory.tactic, declNames := [`tactic.interactive.borelize],
    tags := ["type class"] }

end Interactive

end Tactic

instance (priority := 100) OrderDual.opensMeasurableSpace {α : Type _} [TopologicalSpace α] [MeasurableSpace α]
    [h : OpensMeasurableSpace α] : OpensMeasurableSpace αᵒᵈ where borel_le := h.borel_le

instance (priority := 100) OrderDual.borelSpace {α : Type _} [TopologicalSpace α] [MeasurableSpace α]
    [h : BorelSpace α] : BorelSpace αᵒᵈ where measurable_eq := h.measurable_eq

/-- In a `borel_space` all open sets are measurable. -/
instance (priority := 100) BorelSpace.opensMeasurable {α : Type _} [TopologicalSpace α] [MeasurableSpace α]
    [BorelSpace α] : OpensMeasurableSpace α :=
  ⟨ge_of_eq <| BorelSpace.measurable_eq⟩

instance Subtype.borelSpace {α : Type _} [TopologicalSpace α] [MeasurableSpace α] [hα : BorelSpace α] (s : Set α) :
    BorelSpace s :=
  ⟨by
    rw [hα.1, Subtype.measurableSpace, ← borel_comap]
    rfl⟩

instance Subtype.opensMeasurableSpace {α : Type _} [TopologicalSpace α] [MeasurableSpace α] [h : OpensMeasurableSpace α]
    (s : Set α) : OpensMeasurableSpace s :=
  ⟨by
    rw [borel_comap]
    exact comap_mono h.1⟩

theorem _root_.measurable_set.induction_on_open [TopologicalSpace α] [MeasurableSpace α] [BorelSpace α]
    {C : Set α → Prop} (h_open : ∀ U, IsOpen U → C U) (h_compl : ∀ t, MeasurableSet t → C t → C (tᶜ))
    (h_union : ∀ f : ℕ → Set α, Pairwise (Disjoint on f) → (∀ i, MeasurableSet (f i)) → (∀ i, C (f i)) → C (⋃ i, f i)) :
    ∀ ⦃t⦄, MeasurableSet t → C t :=
  MeasurableSpace.inductionOnInter BorelSpace.measurable_eq is_pi_system_is_open (h_open _ is_open_empty) h_open h_compl
    h_union

section

variable [TopologicalSpace α] [MeasurableSpace α] [OpensMeasurableSpace α] [TopologicalSpace β] [MeasurableSpace β]
  [OpensMeasurableSpace β] [TopologicalSpace γ] [MeasurableSpace γ] [BorelSpace γ] [TopologicalSpace γ₂]
  [MeasurableSpace γ₂] [BorelSpace γ₂] [MeasurableSpace δ]

theorem IsOpen.measurableSet (h : IsOpen s) : MeasurableSet s :=
  OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ h

@[measurability]
theorem measurableSetInterior : MeasurableSet (Interior s) :=
  is_open_interior.MeasurableSet

theorem IsGδ.measurableSet (h : IsGδ s) : MeasurableSet s := by
  rcases h with ⟨S, hSo, hSc, rfl⟩
  exact MeasurableSet.sInter hSc fun t ht => (hSo t ht).MeasurableSet

theorem measurableSetOfContinuousAt {β} [EmetricSpace β] (f : α → β) : MeasurableSet { x | ContinuousAt f x } :=
  (is_Gδ_set_of_continuous_at f).MeasurableSet

theorem IsClosed.measurableSet (h : IsClosed s) : MeasurableSet s :=
  h.is_open_compl.MeasurableSet.ofCompl

theorem IsCompact.measurableSet [T2Space α] (h : IsCompact s) : MeasurableSet s :=
  h.IsClosed.MeasurableSet

@[measurability]
theorem measurableSetClosure : MeasurableSet (Closure s) :=
  isClosedClosure.MeasurableSet

theorem measurableOfIsOpen {f : δ → γ} (hf : ∀ s, IsOpen s → MeasurableSet (f ⁻¹' s)) : Measurable f := by
  rw [‹BorelSpace γ›.measurable_eq]
  exact measurableGenerateFrom hf

theorem measurableOfIsClosed {f : δ → γ} (hf : ∀ s, IsClosed s → MeasurableSet (f ⁻¹' s)) : Measurable f := by
  apply measurableOfIsOpen
  intro s hs
  rw [← MeasurableSet.compl_iff, ← preimage_compl]
  apply hf
  rw [is_closed_compl_iff]
  exact hs

theorem measurableOfIsClosed' {f : δ → γ} (hf : ∀ s, IsClosed s → s.Nonempty → s ≠ univ → MeasurableSet (f ⁻¹' s)) :
    Measurable f := by
  apply measurableOfIsClosed
  intro s hs
  cases' eq_empty_or_nonempty s with h1 h1
  · simp [h1]
    
  by_cases h2:s = univ
  · simp [h2]
    
  exact hf s hs h1 h2

instance nhdsIsMeasurablyGenerated (a : α) : (𝓝 a).IsMeasurablyGenerated := by
  rw [nhds, infi_subtype']
  refine' @Filter.infiIsMeasurablyGenerated _ _ _ _ fun i => _
  exact i.2.2.MeasurableSet.principalIsMeasurablyGenerated

/-- If `s` is a measurable set, then `𝓝[s] a` is a measurably generated filter for
each `a`. This cannot be an `instance` because it depends on a non-instance `hs : measurable_set s`.
-/
theorem MeasurableSet.nhdsWithinIsMeasurablyGenerated {s : Set α} (hs : MeasurableSet s) (a : α) :
    (𝓝[s] a).IsMeasurablyGenerated :=
  haveI := hs.principal_is_measurably_generated
  Filter.infIsMeasurablyGenerated _ _

-- see Note [lower instance priority]
instance (priority := 100) OpensMeasurableSpace.toMeasurableSingletonClass [T1Space α] : MeasurableSingletonClass α :=
  ⟨fun x => isClosedSingleton.MeasurableSet⟩

instance Pi.opensMeasurableSpace {ι : Type _} {π : ι → Type _} [Countable ι] [t' : ∀ i, TopologicalSpace (π i)]
    [∀ i, MeasurableSpace (π i)] [∀ i, SecondCountableTopology (π i)] [∀ i, OpensMeasurableSpace (π i)] :
    OpensMeasurableSpace (∀ i, π i) := by
  constructor
  have :
    PiCat.topologicalSpace =
      generate_from
        { t | ∃ (s : ∀ a, Set (π a))(i : Finset ι), (∀ a ∈ i, s a ∈ countable_basis (π a)) ∧ t = pi (↑i) s } :=
    by rw [funext fun a => @eq_generate_from_countable_basis (π a) _ _, pi_generate_from_eq]
  rw [borel_eq_generate_from_of_subbasis this]
  apply generate_from_le
  rintro _ ⟨s, i, hi, rfl⟩
  refine' MeasurableSet.pi i.countable_to_set fun a ha => IsOpen.measurableSet _
  rw [eq_generate_from_countable_basis (π a)]
  exact generate_open.basic _ (hi a ha)

instance Prod.opensMeasurableSpace [SecondCountableTopology α] [SecondCountableTopology β] :
    OpensMeasurableSpace (α × β) := by
  constructor
  rw [((is_basis_countable_basis α).Prod (is_basis_countable_basis β)).borel_eq_generate_from]
  apply generate_from_le
  rintro _ ⟨u, v, hu, hv, rfl⟩
  exact (is_open_of_mem_countable_basis hu).MeasurableSet.Prod (is_open_of_mem_countable_basis hv).MeasurableSet

variable {α' : Type _} [TopologicalSpace α'] [MeasurableSpace α']

theorem interior_ae_eq_of_null_frontier {μ : Measure α'} {s : Set α'} (h : μ (Frontier s) = 0) : Interior s =ᵐ[μ] s :=
  interior_subset.EventuallyLe.antisymm <| subset_closure.EventuallyLe.trans (ae_le_set.2 h)

theorem measure_interior_of_null_frontier {μ : Measure α'} {s : Set α'} (h : μ (Frontier s) = 0) :
    μ (Interior s) = μ s :=
  measure_congr (interior_ae_eq_of_null_frontier h)

theorem nullMeasurableSetOfNullFrontier {s : Set α} {μ : Measure α} (h : μ (Frontier s) = 0) : NullMeasurableSet s μ :=
  ⟨Interior s, is_open_interior.MeasurableSet, (interior_ae_eq_of_null_frontier h).symm⟩

theorem closure_ae_eq_of_null_frontier {μ : Measure α'} {s : Set α'} (h : μ (Frontier s) = 0) : Closure s =ᵐ[μ] s :=
  ((ae_le_set.2 h).trans interior_subset.EventuallyLe).antisymm <| subset_closure.EventuallyLe

theorem measure_closure_of_null_frontier {μ : Measure α'} {s : Set α'} (h : μ (Frontier s) = 0) : μ (Closure s) = μ s :=
  measure_congr (closure_ae_eq_of_null_frontier h)

section Preorder

variable [Preorder α] [OrderClosedTopology α] {a b x : α}

@[simp, measurability]
theorem measurableSetIci : MeasurableSet (IciCat a) :=
  isClosedIci.MeasurableSet

@[simp, measurability]
theorem measurableSetIic : MeasurableSet (IicCat a) :=
  isClosedIic.MeasurableSet

@[simp, measurability]
theorem measurableSetIcc : MeasurableSet (IccCat a b) :=
  isClosedIcc.MeasurableSet

instance nhdsWithinIciIsMeasurablyGenerated : (𝓝[IciCat b] a).IsMeasurablyGenerated :=
  measurableSetIci.nhdsWithinIsMeasurablyGenerated _

instance nhdsWithinIicIsMeasurablyGenerated : (𝓝[IicCat b] a).IsMeasurablyGenerated :=
  measurableSetIic.nhdsWithinIsMeasurablyGenerated _

instance nhdsWithinIccIsMeasurablyGenerated : IsMeasurablyGenerated (𝓝[IccCat a b] x) := by
  rw [← Ici_inter_Iic, nhds_within_inter]
  infer_instance

instance atTopIsMeasurablyGenerated : (Filter.atTop : Filter α).IsMeasurablyGenerated :=
  (@Filter.infiIsMeasurablyGenerated _ _ _ _) fun a =>
    (measurableSetIci : MeasurableSet (IciCat a)).principalIsMeasurablyGenerated

instance atBotIsMeasurablyGenerated : (Filter.atBot : Filter α).IsMeasurablyGenerated :=
  (@Filter.infiIsMeasurablyGenerated _ _ _ _) fun a =>
    (measurableSetIic : MeasurableSet (IicCat a)).principalIsMeasurablyGenerated

end Preorder

section PartialOrder

variable [PartialOrder α] [OrderClosedTopology α] [SecondCountableTopology α] {a b : α}

@[measurability]
theorem measurableSetLe' : MeasurableSet { p : α × α | p.1 ≤ p.2 } :=
  OrderClosedTopology.isClosedLe'.MeasurableSet

@[measurability]
theorem measurableSetLe {f g : δ → α} (hf : Measurable f) (hg : Measurable g) : MeasurableSet { a | f a ≤ g a } :=
  hf.prod_mk hg measurableSetLe'

end PartialOrder

section LinearOrder

variable [LinearOrder α] [OrderClosedTopology α] {a b x : α}

-- we open this locale only here to avoid issues with list being treated as intervals above
open Interval

@[simp, measurability]
theorem measurableSetIio : MeasurableSet (IioCat a) :=
  is_open_Iio.MeasurableSet

@[simp, measurability]
theorem measurableSetIoi : MeasurableSet (IoiCat a) :=
  is_open_Ioi.MeasurableSet

@[simp, measurability]
theorem measurableSetIoo : MeasurableSet (IooCat a b) :=
  is_open_Ioo.MeasurableSet

@[simp, measurability]
theorem measurableSetIoc : MeasurableSet (IocCat a b) :=
  measurableSetIoi.inter measurableSetIic

@[simp, measurability]
theorem measurableSetIco : MeasurableSet (IcoCat a b) :=
  measurableSetIci.inter measurableSetIio

instance nhdsWithinIoiIsMeasurablyGenerated : (𝓝[IoiCat b] a).IsMeasurablyGenerated :=
  measurableSetIoi.nhdsWithinIsMeasurablyGenerated _

instance nhdsWithinIioIsMeasurablyGenerated : (𝓝[IioCat b] a).IsMeasurablyGenerated :=
  measurableSetIio.nhdsWithinIsMeasurablyGenerated _

instance nhdsWithinIntervalIsMeasurablyGenerated : IsMeasurablyGenerated (𝓝[[a, b]] x) :=
  nhdsWithinIccIsMeasurablyGenerated

@[measurability]
theorem measurableSetLt' [SecondCountableTopology α] : MeasurableSet { p : α × α | p.1 < p.2 } :=
  (is_open_lt continuous_fst continuous_snd).MeasurableSet

@[measurability]
theorem measurableSetLt [SecondCountableTopology α] {f g : δ → α} (hf : Measurable f) (hg : Measurable g) :
    MeasurableSet { a | f a < g a } :=
  hf.prod_mk hg measurableSetLt'

theorem Set.OrdConnected.measurableSet (h : OrdConnected s) : MeasurableSet s := by
  let u := ⋃ (x ∈ s) (y ∈ s), Ioo x y
  have huopen : IsOpen u := is_open_bUnion fun x hx => is_open_bUnion fun y hy => is_open_Ioo
  have humeas : MeasurableSet u := huopen.measurable_set
  have hfinite : (s \ u).Finite := by
    refine' Set.finite_of_forall_between_eq_endpoints (s \ u) fun x hx y hy z hz hxy hyz => _
    by_contra' h
    exact hy.2 (mem_Union₂.mpr ⟨x, hx.1, mem_Union₂.mpr ⟨z, hz.1, lt_of_le_of_ne hxy h.1, lt_of_le_of_ne hyz h.2⟩⟩)
  have : u ⊆ s := Union₂_subset fun x hx => Union₂_subset fun y hy => Ioo_subset_Icc_self.trans (h.out hx hy)
  rw [← union_diff_cancel this]
  exact humeas.union hfinite.measurable_set

theorem IsPreconnected.measurableSet (h : IsPreconnected s) : MeasurableSet s :=
  h.OrdConnected.MeasurableSet

/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:66:14: unsupported tactic `borelize #[[expr α]] -/
theorem generate_from_Ico_mem_le_borel {α : Type _} [TopologicalSpace α] [LinearOrder α] [OrderClosedTopology α]
    (s t : Set α) : MeasurableSpace.generateFrom { S | ∃ l ∈ s, ∃ u ∈ t, ∃ h : l < u, IcoCat l u = S } ≤ borel α := by
  apply generate_from_le
  trace "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:66:14: unsupported tactic `borelize #[[expr α]]"
  rintro _ ⟨a, -, b, -, -, rfl⟩
  exact measurableSetIco

theorem Dense.borel_eq_generate_from_Ico_mem_aux {α : Type _} [TopologicalSpace α] [LinearOrder α] [OrderTopology α]
    [SecondCountableTopology α] {s : Set α} (hd : Dense s) (hbot : ∀ x, IsBot x → x ∈ s)
    (hIoo : ∀ x y : α, x < y → IooCat x y = ∅ → y ∈ s) :
    borel α = generateFrom { S : Set α | ∃ l ∈ s, ∃ u ∈ s, ∃ h : l < u, IcoCat l u = S } := by
  set S : Set (Set α) := { S | ∃ l ∈ s, ∃ u ∈ s, ∃ h : l < u, Ico l u = S }
  refine' le_antisymm _ (generate_from_Ico_mem_le_borel _ _)
  letI : MeasurableSpace α := generate_from S
  rw [borel_eq_generate_from_Iio]
  refine' generate_from_le (forall_range_iff.2 fun a => _)
  rcases hd.exists_countable_dense_subset_bot_top with ⟨t, hts, hc, htd, htb, htt⟩
  by_cases ha:∀ b < a, (Ioo b a).Nonempty
  · convert_to MeasurableSet (⋃ (l ∈ t) (u ∈ t) (hlu : l < u) (hu : u ≤ a), Ico l u)
    · ext y
      simp only [mem_Union, mem_Iio, mem_Ico]
      constructor
      · intro hy
        rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) y with ⟨l, hlt, hly⟩
        rcases htd.exists_mem_open is_open_Ioo (ha y hy) with ⟨u, hut, hyu, hua⟩
        exact ⟨l, hlt, u, hut, hly.trans_lt hyu, hua.le, hly, hyu⟩
        
      · rintro ⟨l, -, u, -, -, hua, -, hyu⟩
        exact hyu.trans_le hua
        
      
    · refine' MeasurableSet.bUnion hc fun a ha => (MeasurableSet.bUnion hc) fun b hb => _
      refine' MeasurableSet.union fun hab => MeasurableSet.union fun hb' => _
      exact generate_measurable.basic _ ⟨a, hts ha, b, hts hb, hab, mem_singleton _⟩
      
    
  · simp only [not_forall, not_nonempty_iff_eq_empty] at ha
    replace ha : a ∈ s := hIoo ha.some a ha.some_spec.fst ha.some_spec.snd
    convert_to MeasurableSet (⋃ (l ∈ t) (hl : l < a), Ico l a)
    · symm
      simp only [← Ici_inter_Iio, ← Union_inter, inter_eq_right_iff_subset, subset_def, mem_Union, mem_Ici, mem_Iio]
      intro x hx
      rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) x with ⟨z, hzt, hzx⟩
      exact ⟨z, hzt, hzx.trans_lt hx, hzx⟩
      
    · refine' MeasurableSet.bUnion hc fun x hx => MeasurableSet.union fun hlt => _
      exact generate_measurable.basic _ ⟨x, hts hx, a, ha, hlt, mem_singleton _⟩
      
    

theorem Dense.borel_eq_generate_from_Ico_mem {α : Type _} [TopologicalSpace α] [LinearOrder α] [OrderTopology α]
    [SecondCountableTopology α] [DenselyOrdered α] [NoMinOrder α] {s : Set α} (hd : Dense s) :
    borel α = generateFrom { S : Set α | ∃ l ∈ s, ∃ u ∈ s, ∃ h : l < u, IcoCat l u = S } :=
  (hd.borel_eq_generate_from_Ico_mem_aux (by simp)) fun x y hxy H => ((nonempty_Ioo.2 hxy).ne_empty H).elim

theorem borel_eq_generate_from_Ico (α : Type _) [TopologicalSpace α] [SecondCountableTopology α] [LinearOrder α]
    [OrderTopology α] : borel α = generateFrom { S : Set α | ∃ (l u : _)(h : l < u), IcoCat l u = S } := by
  simpa only [exists_prop, mem_univ, true_and_iff] using
    (@dense_univ α _).borel_eq_generate_from_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ => mem_univ _

theorem Dense.borel_eq_generate_from_Ioc_mem_aux {α : Type _} [TopologicalSpace α] [LinearOrder α] [OrderTopology α]
    [SecondCountableTopology α] {s : Set α} (hd : Dense s) (hbot : ∀ x, IsTop x → x ∈ s)
    (hIoo : ∀ x y : α, x < y → IooCat x y = ∅ → x ∈ s) :
    borel α = generateFrom { S : Set α | ∃ l ∈ s, ∃ u ∈ s, ∃ h : l < u, IocCat l u = S } := by
  convert hd.order_dual.borel_eq_generate_from_Ico_mem_aux hbot fun x y hlt he => hIoo y x hlt _
  · ext s
    constructor <;> rintro ⟨l, hl, u, hu, hlt, rfl⟩
    exacts[⟨u, hu, l, hl, hlt, dual_Ico⟩, ⟨u, hu, l, hl, hlt, dual_Ioc⟩]
    
  · erw [dual_Ioo]
    exact he
    

theorem Dense.borel_eq_generate_from_Ioc_mem {α : Type _} [TopologicalSpace α] [LinearOrder α] [OrderTopology α]
    [SecondCountableTopology α] [DenselyOrdered α] [NoMaxOrder α] {s : Set α} (hd : Dense s) :
    borel α = generateFrom { S : Set α | ∃ l ∈ s, ∃ u ∈ s, ∃ h : l < u, IocCat l u = S } :=
  (hd.borel_eq_generate_from_Ioc_mem_aux (by simp)) fun x y hxy H => ((nonempty_Ioo.2 hxy).ne_empty H).elim

theorem borel_eq_generate_from_Ioc (α : Type _) [TopologicalSpace α] [SecondCountableTopology α] [LinearOrder α]
    [OrderTopology α] : borel α = generateFrom { S : Set α | ∃ (l u : _)(h : l < u), IocCat l u = S } := by
  simpa only [exists_prop, mem_univ, true_and_iff] using
    (@dense_univ α _).borel_eq_generate_from_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ => mem_univ _

namespace MeasureTheory.Measure

/-- Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If
`α` is a conditionally complete linear order with no top element,
`measure_theory.measure..ext_of_Ico` is an extensionality lemma with weaker assumptions on `μ` and
`ν`. -/
theorem ext_of_Ico_finite {α : Type _} [TopologicalSpace α] {m : MeasurableSpace α} [SecondCountableTopology α]
    [LinearOrder α] [OrderTopology α] [BorelSpace α] (μ ν : Measure α) [IsFiniteMeasure μ] (hμν : μ Univ = ν Univ)
    (h : ∀ ⦃a b⦄, a < b → μ (IcoCat a b) = ν (IcoCat a b)) : μ = ν := by
  refine'
    ext_of_generate_finite _ (borel_space.measurable_eq.trans (borel_eq_generate_from_Ico α))
      (is_pi_system_Ico (id : α → α) id) _ hμν
  · rintro - ⟨a, b, hlt, rfl⟩
    exact h hlt
    

/-- Two finite measures on a Borel space are equal if they agree on all open-closed intervals.  If
`α` is a conditionally complete linear order with no top element,
`measure_theory.measure..ext_of_Ioc` is an extensionality lemma with weaker assumptions on `μ` and
`ν`. -/
theorem ext_of_Ioc_finite {α : Type _} [TopologicalSpace α] {m : MeasurableSpace α} [SecondCountableTopology α]
    [LinearOrder α] [OrderTopology α] [BorelSpace α] (μ ν : Measure α) [IsFiniteMeasure μ] (hμν : μ Univ = ν Univ)
    (h : ∀ ⦃a b⦄, a < b → μ (IocCat a b) = ν (IocCat a b)) : μ = ν := by
  refine' @ext_of_Ico_finite αᵒᵈ _ _ _ _ _ ‹_› μ ν _ hμν fun a b hab => _
  erw [dual_Ico]
  exact h hab

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
closed-open intervals. -/
theorem ext_of_Ico' {α : Type _} [TopologicalSpace α] {m : MeasurableSpace α} [SecondCountableTopology α]
    [LinearOrder α] [OrderTopology α] [BorelSpace α] [NoMaxOrder α] (μ ν : Measure α)
    (hμ : ∀ ⦃a b⦄, a < b → μ (IcoCat a b) ≠ ∞) (h : ∀ ⦃a b⦄, a < b → μ (IcoCat a b) = ν (IcoCat a b)) : μ = ν := by
  rcases exists_countable_dense_bot_top α with ⟨s, hsc, hsd, hsb, hst⟩
  have : (⋃ (l ∈ s) (u ∈ s) (h : l < u), {Ico l u} : Set (Set α)).Countable :=
    hsc.bUnion fun l hl => hsc.bUnion fun u hu => countable_Union fun _ => countable_singleton _
  simp only [← set_of_eq_eq_singleton, ← set_of_exists] at this
  refine'
    measure.ext_of_generate_from_of_cover_subset (borel_space.measurable_eq.trans (borel_eq_generate_from_Ico α))
      (is_pi_system_Ico id id) _ this _ _ _
  · rintro _ ⟨l, -, u, -, h, rfl⟩
    exact ⟨l, u, h, rfl⟩
    
  · refine' sUnion_eq_univ_iff.2 fun x => _
    rcases hsd.exists_le' hsb x with ⟨l, hls, hlx⟩
    rcases hsd.exists_gt x with ⟨u, hus, hxu⟩
    exact ⟨_, ⟨l, hls, u, hus, hlx.trans_lt hxu, rfl⟩, hlx, hxu⟩
    
  · rintro _ ⟨l, -, u, -, hlt, rfl⟩
    exact hμ hlt
    
  · rintro _ ⟨l, u, hlt, rfl⟩
    exact h hlt
    

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
open-closed intervals. -/
theorem ext_of_Ioc' {α : Type _} [TopologicalSpace α] {m : MeasurableSpace α} [SecondCountableTopology α]
    [LinearOrder α] [OrderTopology α] [BorelSpace α] [NoMinOrder α] (μ ν : Measure α)
    (hμ : ∀ ⦃a b⦄, a < b → μ (IocCat a b) ≠ ∞) (h : ∀ ⦃a b⦄, a < b → μ (IocCat a b) = ν (IocCat a b)) : μ = ν := by
  refine' @ext_of_Ico' αᵒᵈ _ _ _ _ _ ‹_› _ μ ν _ _ <;> intro a b hab <;> erw [dual_Ico]
  exacts[hμ hab, h hab]

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
closed-open intervals. -/
theorem ext_of_Ico {α : Type _} [TopologicalSpace α] {m : MeasurableSpace α} [SecondCountableTopology α]
    [ConditionallyCompleteLinearOrder α] [OrderTopology α] [BorelSpace α] [NoMaxOrder α] (μ ν : Measure α)
    [IsLocallyFiniteMeasure μ] (h : ∀ ⦃a b⦄, a < b → μ (IcoCat a b) = ν (IcoCat a b)) : μ = ν :=
  μ.ext_of_Ico' ν (fun a b hab => measure_Ico_lt_top.Ne) h

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
open-closed intervals. -/
theorem ext_of_Ioc {α : Type _} [TopologicalSpace α] {m : MeasurableSpace α} [SecondCountableTopology α]
    [ConditionallyCompleteLinearOrder α] [OrderTopology α] [BorelSpace α] [NoMinOrder α] (μ ν : Measure α)
    [IsLocallyFiniteMeasure μ] (h : ∀ ⦃a b⦄, a < b → μ (IocCat a b) = ν (IocCat a b)) : μ = ν :=
  μ.ext_of_Ioc' ν (fun a b hab => measure_Ioc_lt_top.Ne) h

/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed
intervals. -/
theorem ext_of_Iic {α : Type _} [TopologicalSpace α] {m : MeasurableSpace α} [SecondCountableTopology α] [LinearOrder α]
    [OrderTopology α] [BorelSpace α] (μ ν : Measure α) [IsFiniteMeasure μ] (h : ∀ a, μ (IicCat a) = ν (IicCat a)) :
    μ = ν := by
  refine' ext_of_Ioc_finite μ ν _ fun a b hlt => _
  · rcases exists_countable_dense_bot_top α with ⟨s, hsc, hsd, -, hst⟩
    have : DirectedOn (· ≤ ·) s := directed_on_iff_directed.2 (directed_of_sup fun _ _ => id)
    simp only [← bsupr_measure_Iic hsc (hsd.exists_ge' hst) this, h]
    
  rw [← Iic_diff_Iic, measure_diff (Iic_subset_Iic.2 hlt.le) measurableSetIic,
    measure_diff (Iic_subset_Iic.2 hlt.le) measurableSetIic, h a, h b]
  · rw [← h a]
    exact (measure_lt_top μ _).Ne
    
  · exact (measure_lt_top μ _).Ne
    

/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite
intervals. -/
theorem ext_of_Ici {α : Type _} [TopologicalSpace α] {m : MeasurableSpace α} [SecondCountableTopology α] [LinearOrder α]
    [OrderTopology α] [BorelSpace α] (μ ν : Measure α) [IsFiniteMeasure μ] (h : ∀ a, μ (IciCat a) = ν (IciCat a)) :
    μ = ν :=
  @ext_of_Iic αᵒᵈ _ _ _ _ _ ‹_› _ _ _ h

end MeasureTheory.Measure

end LinearOrder

section LinearOrder

variable [LinearOrder α] [OrderClosedTopology α]

@[measurability]
theorem measurableSetInterval {a b : α} : MeasurableSet (Interval a b) :=
  measurableSetIcc

@[measurability]
theorem measurableSetIntervalOc {a b : α} : MeasurableSet (IntervalOc a b) :=
  measurableSetIoc

variable [SecondCountableTopology α]

@[measurability]
theorem Measurable.max {f g : δ → α} (hf : Measurable f) (hg : Measurable g) : Measurable fun a => max (f a) (g a) := by
  simpa only [max_def] using hf.piecewise (measurableSetLe hg hf) hg

@[measurability]
theorem AeMeasurable.max {f g : δ → α} {μ : Measure δ} (hf : AeMeasurable f μ) (hg : AeMeasurable g μ) :
    AeMeasurable (fun a => max (f a) (g a)) μ :=
  ⟨fun a => max (hf.mk f a) (hg.mk g a), hf.measurableMk.max hg.measurableMk,
    EventuallyEq.comp₂ hf.ae_eq_mk _ hg.ae_eq_mk⟩

@[measurability]
theorem Measurable.min {f g : δ → α} (hf : Measurable f) (hg : Measurable g) : Measurable fun a => min (f a) (g a) := by
  simpa only [min_def] using hf.piecewise (measurableSetLe hf hg) hg

@[measurability]
theorem AeMeasurable.min {f g : δ → α} {μ : Measure δ} (hf : AeMeasurable f μ) (hg : AeMeasurable g μ) :
    AeMeasurable (fun a => min (f a) (g a)) μ :=
  ⟨fun a => min (hf.mk f a) (hg.mk g a), hf.measurableMk.min hg.measurableMk,
    EventuallyEq.comp₂ hf.ae_eq_mk _ hg.ae_eq_mk⟩

end LinearOrder

/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is measurable. -/
theorem Continuous.measurable {f : α → γ} (hf : Continuous f) : Measurable f :=
  hf.borelMeasurable.mono OpensMeasurableSpace.borel_le (le_of_eq <| BorelSpace.measurable_eq)

/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is ae-measurable. -/
theorem Continuous.aeMeasurable {f : α → γ} (h : Continuous f) {μ : Measure α} : AeMeasurable f μ :=
  h.Measurable.AeMeasurable

theorem ClosedEmbedding.measurable {f : α → γ} (hf : ClosedEmbedding f) : Measurable f :=
  hf.Continuous.Measurable

theorem Continuous.isOpenPosMeasureMap {f : β → γ} (hf : Continuous f) (hf_surj : Function.Surjective f) {μ : Measure β}
    [μ.IsOpenPosMeasure] : (Measure.map f μ).IsOpenPosMeasure := by
  refine' ⟨fun U hUo hUne => _⟩
  rw [measure.map_apply hf.measurable hUo.measurable_set]
  exact (hUo.preimage hf).measure_ne_zero μ (hf_surj.nonempty_preimage.mpr hUne)

/-- If a function is defined piecewise in terms of functions which are continuous on their
respective pieces, then it is measurable. -/
theorem ContinuousOn.measurablePiecewise {f g : α → γ} {s : Set α} [∀ j : α, Decidable (j ∈ s)] (hf : ContinuousOn f s)
    (hg : ContinuousOn g (sᶜ)) (hs : MeasurableSet s) : Measurable (s.piecewise f g) := by
  refine' measurableOfIsOpen fun t ht => _
  rw [piecewise_preimage, Set.Ite]
  apply MeasurableSet.union
  · rcases _root_.continuous_on_iff'.1 hf t ht with ⟨u, u_open, hu⟩
    rw [hu]
    exact u_open.measurable_set.inter hs
    
  · rcases _root_.continuous_on_iff'.1 hg t ht with ⟨u, u_open, hu⟩
    rw [diff_eq_compl_inter, inter_comm, hu]
    exact u_open.measurable_set.inter hs.compl
    

@[to_additive]
instance (priority := 100) HasContinuousMul.hasMeasurableMul [Mul γ] [HasContinuousMul γ] : HasMeasurableMul γ where
  measurableConstMul c := (continuous_const.mul continuous_id).Measurable
  measurableMulConst c := (continuous_id.mul continuous_const).Measurable

instance (priority := 100) HasContinuousSub.hasMeasurableSub [Sub γ] [HasContinuousSub γ] : HasMeasurableSub γ where
  measurableConstSub c := (continuous_const.sub continuous_id).Measurable
  measurableSubConst c := (continuous_id.sub continuous_const).Measurable

@[to_additive]
instance (priority := 100) TopologicalGroup.hasMeasurableInv [Group γ] [TopologicalGroup γ] : HasMeasurableInv γ :=
  ⟨continuous_inv.Measurable⟩

instance (priority := 100) HasContinuousSmul.hasMeasurableSmul {M α} [TopologicalSpace M] [TopologicalSpace α]
    [MeasurableSpace M] [MeasurableSpace α] [OpensMeasurableSpace M] [BorelSpace α] [HasSmul M α]
    [HasContinuousSmul M α] : HasMeasurableSmul M α :=
  ⟨fun c => (continuous_const_smul _).Measurable, fun y => (continuous_id.smul continuous_const).Measurable⟩

section Lattice

instance (priority := 100) HasContinuousSup.hasMeasurableSup [HasSup γ] [HasContinuousSup γ] : HasMeasurableSup γ where
  measurableConstSup c := (continuous_const.sup continuous_id).Measurable
  measurableSupConst c := (continuous_id.sup continuous_const).Measurable

instance (priority := 100) HasContinuousSup.hasMeasurableSup₂ [SecondCountableTopology γ] [HasSup γ]
    [HasContinuousSup γ] : HasMeasurableSup₂ γ :=
  ⟨continuous_sup.Measurable⟩

instance (priority := 100) HasContinuousInf.hasMeasurableInf [HasInf γ] [HasContinuousInf γ] : HasMeasurableInf γ where
  measurableConstInf c := (continuous_const.inf continuous_id).Measurable
  measurableInfConst c := (continuous_id.inf continuous_const).Measurable

instance (priority := 100) HasContinuousInf.hasMeasurableInf₂ [SecondCountableTopology γ] [HasInf γ]
    [HasContinuousInf γ] : HasMeasurableInf₂ γ :=
  ⟨continuous_inf.Measurable⟩

end Lattice

section Homeomorph

@[measurability]
protected theorem Homeomorph.measurable (h : α ≃ₜ γ) : Measurable h :=
  h.Continuous.Measurable

/-- A homeomorphism between two Borel spaces is a measurable equivalence.-/
def Homeomorph.toMeasurableEquiv (h : γ ≃ₜ γ₂) : γ ≃ᵐ γ₂ where
  measurableToFun := h.Measurable
  measurableInvFun := h.symm.Measurable
  toEquiv := h.toEquiv

@[simp]
theorem Homeomorph.to_measurable_equiv_coe (h : γ ≃ₜ γ₂) : (h.toMeasurableEquiv : γ → γ₂) = h :=
  rfl

@[simp]
theorem Homeomorph.to_measurable_equiv_symm_coe (h : γ ≃ₜ γ₂) : (h.toMeasurableEquiv.symm : γ₂ → γ) = h.symm :=
  rfl

end Homeomorph

@[measurability]
theorem ContinuousMap.measurable (f : C(α, γ)) : Measurable f :=
  f.Continuous.Measurable

theorem measurableOfContinuousOnComplSingleton [T1Space α] {f : α → γ} (a : α) (hf : ContinuousOn f ({a}ᶜ)) :
    Measurable f :=
  measurableOfMeasurableOnComplSingleton a (continuous_on_iff_continuous_restrict.1 hf).Measurable

theorem Continuous.measurable2 [SecondCountableTopology α] [SecondCountableTopology β] {f : δ → α} {g : δ → β}
    {c : α → β → γ} (h : Continuous fun p : α × β => c p.1 p.2) (hf : Measurable f) (hg : Measurable g) :
    Measurable fun a => c (f a) (g a) :=
  h.Measurable.comp (hf.prod_mk hg)

theorem Continuous.aeMeasurable2 [SecondCountableTopology α] [SecondCountableTopology β] {f : δ → α} {g : δ → β}
    {c : α → β → γ} {μ : Measure δ} (h : Continuous fun p : α × β => c p.1 p.2) (hf : AeMeasurable f μ)
    (hg : AeMeasurable g μ) : AeMeasurable (fun a => c (f a) (g a)) μ :=
  h.Measurable.compAeMeasurable (hf.prod_mk hg)

instance (priority := 100) HasContinuousInv₀.hasMeasurableInv [GroupWithZero γ] [T1Space γ] [HasContinuousInv₀ γ] :
    HasMeasurableInv γ :=
  ⟨measurableOfContinuousOnComplSingleton 0 continuous_on_inv₀⟩

@[to_additive]
instance (priority := 100) HasContinuousMul.hasMeasurableMul₂ [SecondCountableTopology γ] [Mul γ] [HasContinuousMul γ] :
    HasMeasurableMul₂ γ :=
  ⟨continuous_mul.Measurable⟩

instance (priority := 100) HasContinuousSub.hasMeasurableSub₂ [SecondCountableTopology γ] [Sub γ] [HasContinuousSub γ] :
    HasMeasurableSub₂ γ :=
  ⟨continuous_sub.Measurable⟩

instance (priority := 100) HasContinuousSmul.hasMeasurableSmul₂ {M α} [TopologicalSpace M] [SecondCountableTopology M]
    [MeasurableSpace M] [OpensMeasurableSpace M] [TopologicalSpace α] [SecondCountableTopology α] [MeasurableSpace α]
    [BorelSpace α] [HasSmul M α] [HasContinuousSmul M α] : HasMeasurableSmul₂ M α :=
  ⟨continuous_smul.Measurable⟩

end

section BorelSpace

variable [TopologicalSpace α] [MeasurableSpace α] [BorelSpace α] [TopologicalSpace β] [MeasurableSpace β] [BorelSpace β]
  [TopologicalSpace γ] [MeasurableSpace γ] [BorelSpace γ] [MeasurableSpace δ]

theorem pi_le_borel_pi {ι : Type _} {π : ι → Type _} [∀ i, TopologicalSpace (π i)] [∀ i, MeasurableSpace (π i)]
    [∀ i, BorelSpace (π i)] : MeasurableSpace.pi ≤ borel (∀ i, π i) := by
  have : ‹∀ i, MeasurableSpace (π i)› = fun i => borel (π i) := funext fun i => BorelSpace.measurable_eq
  rw [this]
  exact supr_le fun i => comap_le_iff_le_map.2 <| (continuous_apply i).borelMeasurable

theorem prod_le_borel_prod : Prod.measurableSpace ≤ borel (α × β) := by
  rw [‹BorelSpace α›.measurable_eq, ‹BorelSpace β›.measurable_eq]
  refine' sup_le _ _
  · exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable
    
  · exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable
    

instance Pi.borelSpace {ι : Type _} {π : ι → Type _} [Countable ι] [∀ i, TopologicalSpace (π i)]
    [∀ i, MeasurableSpace (π i)] [∀ i, SecondCountableTopology (π i)] [∀ i, BorelSpace (π i)] : BorelSpace (∀ i, π i) :=
  ⟨le_antisymm pi_le_borel_pi OpensMeasurableSpace.borel_le⟩

instance Prod.borelSpace [SecondCountableTopology α] [SecondCountableTopology β] : BorelSpace (α × β) :=
  ⟨le_antisymm prod_le_borel_prod OpensMeasurableSpace.borel_le⟩

protected theorem Embedding.measurableEmbedding {f : α → β} (h₁ : Embedding f) (h₂ : MeasurableSet (Range f)) :
    MeasurableEmbedding f :=
  show MeasurableEmbedding (coe ∘ (Homeomorph.ofEmbedding f h₁).toMeasurableEquiv) from
    (MeasurableEmbedding.subtypeCoe h₂).comp (MeasurableEquiv.measurableEmbedding _)

protected theorem ClosedEmbedding.measurableEmbedding {f : α → β} (h : ClosedEmbedding f) : MeasurableEmbedding f :=
  h.toEmbedding.MeasurableEmbedding h.closedRange.MeasurableSet

protected theorem OpenEmbedding.measurableEmbedding {f : α → β} (h : OpenEmbedding f) : MeasurableEmbedding f :=
  h.toEmbedding.MeasurableEmbedding h.open_range.MeasurableSet

section LinearOrder

variable [LinearOrder α] [OrderTopology α] [SecondCountableTopology α]

theorem measurableOfIio {f : δ → α} (hf : ∀ x, MeasurableSet (f ⁻¹' IioCat x)) : Measurable f := by
  convert measurableGenerateFrom _
  exact borel_space.measurable_eq.trans (borel_eq_generate_from_Iio _)
  rintro _ ⟨x, rfl⟩
  exact hf x

theorem UpperSemicontinuous.measurable [TopologicalSpace δ] [OpensMeasurableSpace δ] {f : δ → α}
    (hf : UpperSemicontinuous f) : Measurable f :=
  measurableOfIio fun y => (hf.is_open_preimage y).MeasurableSet

theorem measurableOfIoi {f : δ → α} (hf : ∀ x, MeasurableSet (f ⁻¹' IoiCat x)) : Measurable f := by
  convert measurableGenerateFrom _
  exact borel_space.measurable_eq.trans (borel_eq_generate_from_Ioi _)
  rintro _ ⟨x, rfl⟩
  exact hf x

theorem LowerSemicontinuous.measurable [TopologicalSpace δ] [OpensMeasurableSpace δ] {f : δ → α}
    (hf : LowerSemicontinuous f) : Measurable f :=
  measurableOfIoi fun y => (hf.is_open_preimage y).MeasurableSet

theorem measurableOfIic {f : δ → α} (hf : ∀ x, MeasurableSet (f ⁻¹' IicCat x)) : Measurable f := by
  apply measurableOfIoi
  simp_rw [← compl_Iic, preimage_compl, MeasurableSet.compl_iff]
  assumption

theorem measurableOfIci {f : δ → α} (hf : ∀ x, MeasurableSet (f ⁻¹' IciCat x)) : Measurable f := by
  apply measurableOfIio
  simp_rw [← compl_Ici, preimage_compl, MeasurableSet.compl_iff]
  assumption

theorem Measurable.isLub {ι} [Countable ι] {f : ι → δ → α} {g : δ → α} (hf : ∀ i, Measurable (f i))
    (hg : ∀ b, IsLub { a | ∃ i, f i b = a } (g b)) : Measurable g := by
  change ∀ b, IsLub (range fun i => f i b) (g b) at hg
  rw [‹BorelSpace α›.measurable_eq, borel_eq_generate_from_Ioi α]
  apply measurableGenerateFrom
  rintro _ ⟨a, rfl⟩
  simp_rw [Set.Preimage, mem_Ioi, lt_is_lub_iff (hg _), exists_range_iff, set_of_exists]
  exact MeasurableSet.union fun i => hf i (is_open_lt' _).MeasurableSet

private theorem ae_measurable.is_lub_of_nonempty {ι} (hι : Nonempty ι) {μ : Measure δ} [Countable ι] {f : ι → δ → α}
    {g : δ → α} (hf : ∀ i, AeMeasurable (f i) μ) (hg : ∀ᵐ b ∂μ, IsLub { a | ∃ i, f i b = a } (g b)) :
    AeMeasurable g μ := by
  let p : δ → (ι → α) → Prop := fun x f' => IsLub { a | ∃ i, f' i = a } (g x)
  let g_seq x := ite (x ∈ AeSeqSet hf p) (g x) (⟨g x⟩ : Nonempty α).some
  have hg_seq : ∀ b, IsLub { a | ∃ i, aeSeq hf p i b = a } (g_seq b) := by
    intro b
    haveI hα : Nonempty α := Nonempty.map g ⟨b⟩
    simp only [aeSeq, g_seq]
    split_ifs
    · have h_set_eq : { a : α | ∃ i : ι, (hf i).mk (f i) b = a } = { a : α | ∃ i : ι, f i b = a } := by
        ext x
        simp_rw [Set.mem_set_of_eq, aeSeq.mk_eq_fun_of_mem_ae_seq_set hf h]
      rw [h_set_eq]
      exact aeSeq.funPropOfMemAeSeqSet hf h
      
    · have h_singleton : { a : α | ∃ i : ι, hα.some = a } = {hα.some} := by
        ext1 x
        exact ⟨fun hx => hx.some_spec.symm, fun hx => ⟨hι.some, hx.symm⟩⟩
      rw [h_singleton]
      exact is_lub_singleton
      
  refine' ⟨g_seq, Measurable.isLub (aeSeq.measurable hf p) hg_seq, _⟩
  exact
    (ite_ae_eq_of_measure_compl_zero g (fun x => (⟨g x⟩ : Nonempty α).some) (AeSeqSet hf p)
        (aeSeq.measure_compl_ae_seq_set_eq_zero hf hg)).symm

theorem AeMeasurable.isLub {ι} {μ : Measure δ} [Countable ι] {f : ι → δ → α} {g : δ → α}
    (hf : ∀ i, AeMeasurable (f i) μ) (hg : ∀ᵐ b ∂μ, IsLub { a | ∃ i, f i b = a } (g b)) : AeMeasurable g μ := by
  by_cases hμ:μ = 0
  · rw [hμ]
    exact aeMeasurableZeroMeasure
    
  have : μ.ae.ne_bot := by simpa [ne_bot_iff]
  by_cases hι:Nonempty ι
  · exact ae_measurable.is_lub_of_nonempty hι hf hg
    
  suffices ∃ x, g =ᵐ[μ] fun y => g x by exact ⟨fun y => g this.some, measurableConst, this.some_spec⟩
  have h_empty : ∀ x, { a : α | ∃ i : ι, f i x = a } = ∅ := by
    intro x
    ext1 y
    rw [Set.mem_set_of_eq, Set.mem_empty_iff_false, iff_false_iff]
    exact fun hi => hι (nonempty_of_exists hi)
  simp_rw [h_empty] at hg
  exact ⟨hg.exists.some, hg.mono fun y hy => IsLub.unique hy hg.exists.some_spec⟩

theorem Measurable.isGlb {ι} [Countable ι] {f : ι → δ → α} {g : δ → α} (hf : ∀ i, Measurable (f i))
    (hg : ∀ b, IsGlb { a | ∃ i, f i b = a } (g b)) : Measurable g := by
  change ∀ b, IsGlb (range fun i => f i b) (g b) at hg
  rw [‹BorelSpace α›.measurable_eq, borel_eq_generate_from_Iio α]
  apply measurableGenerateFrom
  rintro _ ⟨a, rfl⟩
  simp_rw [Set.Preimage, mem_Iio, is_glb_lt_iff (hg _), exists_range_iff, set_of_exists]
  exact MeasurableSet.union fun i => hf i (is_open_gt' _).MeasurableSet

private theorem ae_measurable.is_glb_of_nonempty {ι} (hι : Nonempty ι) {μ : Measure δ} [Countable ι] {f : ι → δ → α}
    {g : δ → α} (hf : ∀ i, AeMeasurable (f i) μ) (hg : ∀ᵐ b ∂μ, IsGlb { a | ∃ i, f i b = a } (g b)) :
    AeMeasurable g μ := by
  let p : δ → (ι → α) → Prop := fun x f' => IsGlb { a | ∃ i, f' i = a } (g x)
  let g_seq x := ite (x ∈ AeSeqSet hf p) (g x) (⟨g x⟩ : Nonempty α).some
  have hg_seq : ∀ b, IsGlb { a | ∃ i, aeSeq hf p i b = a } (g_seq b) := by
    intro b
    haveI hα : Nonempty α := Nonempty.map g ⟨b⟩
    simp only [aeSeq, g_seq]
    split_ifs
    · have h_set_eq : { a : α | ∃ i : ι, (hf i).mk (f i) b = a } = { a : α | ∃ i : ι, f i b = a } := by
        ext x
        simp_rw [Set.mem_set_of_eq, aeSeq.mk_eq_fun_of_mem_ae_seq_set hf h]
      rw [h_set_eq]
      exact aeSeq.funPropOfMemAeSeqSet hf h
      
    · have h_singleton : { a : α | ∃ i : ι, hα.some = a } = {hα.some} := by
        ext1 x
        exact ⟨fun hx => hx.some_spec.symm, fun hx => ⟨hι.some, hx.symm⟩⟩
      rw [h_singleton]
      exact is_glb_singleton
      
  refine' ⟨g_seq, Measurable.isGlb (aeSeq.measurable hf p) hg_seq, _⟩
  exact
    (ite_ae_eq_of_measure_compl_zero g (fun x => (⟨g x⟩ : Nonempty α).some) (AeSeqSet hf p)
        (aeSeq.measure_compl_ae_seq_set_eq_zero hf hg)).symm

theorem AeMeasurable.isGlb {ι} {μ : Measure δ} [Countable ι] {f : ι → δ → α} {g : δ → α}
    (hf : ∀ i, AeMeasurable (f i) μ) (hg : ∀ᵐ b ∂μ, IsGlb { a | ∃ i, f i b = a } (g b)) : AeMeasurable g μ := by
  by_cases hμ:μ = 0
  · rw [hμ]
    exact aeMeasurableZeroMeasure
    
  have : μ.ae.ne_bot := by simpa [ne_bot_iff]
  by_cases hι:Nonempty ι
  · exact ae_measurable.is_glb_of_nonempty hι hf hg
    
  suffices ∃ x, g =ᵐ[μ] fun y => g x by exact ⟨fun y => g this.some, measurableConst, this.some_spec⟩
  have h_empty : ∀ x, { a : α | ∃ i : ι, f i x = a } = ∅ := by
    intro x
    ext1 y
    rw [Set.mem_set_of_eq, Set.mem_empty_iff_false, iff_false_iff]
    exact fun hi => hι (nonempty_of_exists hi)
  simp_rw [h_empty] at hg
  exact ⟨hg.exists.some, hg.mono fun y hy => IsGlb.unique hy hg.exists.some_spec⟩

protected theorem Monotone.measurable [LinearOrder β] [OrderClosedTopology β] {f : β → α} (hf : Monotone f) :
    Measurable f :=
  suffices h : ∀ x, OrdConnected (f ⁻¹' IoiCat x) from measurableOfIoi fun x => (h x).MeasurableSet
  fun x => ord_connected_def.mpr fun a ha b hb c hc => lt_of_lt_of_le ha (hf hc.1)

theorem aeMeasurableRestrictOfMonotoneOn [LinearOrder β] [OrderClosedTopology β] {μ : Measure β} {s : Set β}
    (hs : MeasurableSet s) {f : β → α} (hf : MonotoneOn f s) : AeMeasurable f (μ.restrict s) :=
  have this : Monotone (f ∘ coe : s → α) := fun ⟨x, hx⟩ ⟨y, hy⟩ (hxy : x ≤ y) => hf hx hy hxy
  aeMeasurableRestrictOfMeasurableSubtype hs this.Measurable

protected theorem Antitone.measurable [LinearOrder β] [OrderClosedTopology β] {f : β → α} (hf : Antitone f) :
    Measurable f :=
  @Monotone.measurable αᵒᵈ β _ _ ‹_› _ _ _ _ _ ‹_› _ _ _ hf

theorem aeMeasurableRestrictOfAntitoneOn [LinearOrder β] [OrderClosedTopology β] {μ : Measure β} {s : Set β}
    (hs : MeasurableSet s) {f : β → α} (hf : AntitoneOn f s) : AeMeasurable f (μ.restrict s) :=
  @aeMeasurableRestrictOfMonotoneOn αᵒᵈ β _ _ ‹_› _ _ _ _ _ ‹_› _ _ _ _ hs _ hf

theorem measurableSetOfMemNhdsWithinIoiAux {s : Set α} (h : ∀ x ∈ s, s ∈ 𝓝[>] x) (h' : ∀ x ∈ s, ∃ y, x < y) :
    MeasurableSet s := by
  choose! M hM using h'
  suffices H : (s \ Interior s).Countable
  · have : s = Interior s ∪ s \ Interior s := by rw [union_diff_cancel interior_subset]
    rw [this]
    exact is_open_interior.measurable_set.union H.measurable_set
    
  have A : ∀ x ∈ s, ∃ y ∈ Ioi x, Ioo x y ⊆ s := fun x hx =>
    (mem_nhds_within_Ioi_iff_exists_Ioo_subset' (hM x hx)).1 (h x hx)
  choose! y hy h'y using A
  have B : Set.PairwiseDisjoint (s \ Interior s) fun x => Ioo x (y x) := by
    intro x hx x' hx' hxx'
    rcases lt_or_gt_of_ne hxx' with (h' | h')
    · apply disjoint_left.2 fun z hz h'z => _
      have : x' ∈ Interior s := mem_interior.2 ⟨Ioo x (y x), h'y _ hx.1, is_open_Ioo, ⟨h', h'z.1.trans hz.2⟩⟩
      exact False.elim (hx'.2 this)
      
    · apply disjoint_left.2 fun z hz h'z => _
      have : x ∈ Interior s := mem_interior.2 ⟨Ioo x' (y x'), h'y _ hx'.1, is_open_Ioo, ⟨h', hz.1.trans h'z.2⟩⟩
      exact False.elim (hx.2 this)
      
  exact B.countable_of_Ioo fun x hx => hy x hx.1

/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/
theorem measurableSetOfMemNhdsWithinIoi {s : Set α} (h : ∀ x ∈ s, s ∈ 𝓝[>] x) : MeasurableSet s := by
  by_cases H:∃ x ∈ s, IsTop x
  · rcases H with ⟨x₀, x₀s, h₀⟩
    have : s = {x₀} ∪ s \ {x₀} := by rw [union_diff_cancel (singleton_subset_iff.2 x₀s)]
    rw [this]
    refine' (measurable_set_singleton _).union _
    have A : ∀ x ∈ s \ {x₀}, x < x₀ := fun x hx => lt_of_le_of_ne (h₀ _) (by simpa using hx.2)
    refine' measurableSetOfMemNhdsWithinIoiAux (fun x hx => _) fun x hx => ⟨x₀, A x hx⟩
    obtain ⟨u, hu, us⟩ : ∃ (u : α)(H : u ∈ Ioi x), Ioo x u ⊆ s :=
      (mem_nhds_within_Ioi_iff_exists_Ioo_subset' (A x hx)).1 (h x hx.1)
    refine' (mem_nhds_within_Ioi_iff_exists_Ioo_subset' (A x hx)).2 ⟨u, hu, fun y hy => ⟨us hy, _⟩⟩
    exact ne_of_lt (hy.2.trans_le (h₀ _))
    
  · apply measurableSetOfMemNhdsWithinIoiAux h
    simp only [IsTop] at H
    push_neg  at H
    exact H
    

end LinearOrder

@[measurability]
theorem Measurable.suprProp {α} [MeasurableSpace α] [CompleteLattice α] (p : Prop) {f : δ → α} (hf : Measurable f) :
    Measurable fun b => ⨆ h : p, f b :=
  Classical.by_cases
    (fun h : p => by
      convert hf
      funext
      exact supr_pos h)
    fun h : ¬p => by
    convert measurableConst
    funext
    exact supr_neg h

@[measurability]
theorem Measurable.infiProp {α} [MeasurableSpace α] [CompleteLattice α] (p : Prop) {f : δ → α} (hf : Measurable f) :
    Measurable fun b => ⨅ h : p, f b :=
  Classical.by_cases
    (fun h : p => by
      convert hf
      funext
      exact infi_pos h)
    fun h : ¬p => by
    convert measurableConst
    funext
    exact infi_neg h

section CompleteLinearOrder

variable [CompleteLinearOrder α] [OrderTopology α] [SecondCountableTopology α]

@[measurability]
theorem measurableSupr {ι} [Countable ι] {f : ι → δ → α} (hf : ∀ i, Measurable (f i)) :
    Measurable fun b => ⨆ i, f i b :=
  (Measurable.isLub hf) fun b => is_lub_supr

@[measurability]
theorem aeMeasurableSupr {ι} {μ : Measure δ} [Countable ι] {f : ι → δ → α} (hf : ∀ i, AeMeasurable (f i) μ) :
    AeMeasurable (fun b => ⨆ i, f i b) μ :=
  AeMeasurable.isLub hf <| ae_of_all μ fun b => is_lub_supr

@[measurability]
theorem measurableInfi {ι} [Countable ι] {f : ι → δ → α} (hf : ∀ i, Measurable (f i)) :
    Measurable fun b => ⨅ i, f i b :=
  (Measurable.isGlb hf) fun b => is_glb_infi

@[measurability]
theorem aeMeasurableInfi {ι} {μ : Measure δ} [Countable ι] {f : ι → δ → α} (hf : ∀ i, AeMeasurable (f i) μ) :
    AeMeasurable (fun b => ⨅ i, f i b) μ :=
  AeMeasurable.isGlb hf <| ae_of_all μ fun b => is_glb_infi

theorem measurableBsupr {ι} (s : Set ι) {f : ι → δ → α} (hs : s.Countable) (hf : ∀ i, Measurable (f i)) :
    Measurable fun b => ⨆ i ∈ s, f i b := by
  haveI : Encodable s := hs.to_encodable
  simp only [supr_subtype']
  exact measurableSupr fun i => hf i

theorem aeMeasurableBsupr {ι} {μ : Measure δ} (s : Set ι) {f : ι → δ → α} (hs : s.Countable)
    (hf : ∀ i, AeMeasurable (f i) μ) : AeMeasurable (fun b => ⨆ i ∈ s, f i b) μ := by
  haveI : Encodable s := hs.to_encodable
  simp only [supr_subtype']
  exact aeMeasurableSupr fun i => hf i

theorem measurableBinfi {ι} (s : Set ι) {f : ι → δ → α} (hs : s.Countable) (hf : ∀ i, Measurable (f i)) :
    Measurable fun b => ⨅ i ∈ s, f i b := by
  haveI : Encodable s := hs.to_encodable
  simp only [infi_subtype']
  exact measurableInfi fun i => hf i

theorem aeMeasurableBinfi {ι} {μ : Measure δ} (s : Set ι) {f : ι → δ → α} (hs : s.Countable)
    (hf : ∀ i, AeMeasurable (f i) μ) : AeMeasurable (fun b => ⨅ i ∈ s, f i b) μ := by
  haveI : Encodable s := hs.to_encodable
  simp only [infi_subtype']
  exact aeMeasurableInfi fun i => hf i

/-- `liminf` over a general filter is measurable. See `measurable_liminf` for the version over `ℕ`.
-/
theorem measurableLiminf' {ι ι'} {f : ι → δ → α} {u : Filter ι} (hf : ∀ i, Measurable (f i)) {p : ι' → Prop}
    {s : ι' → Set ι} (hu : u.HasCountableBasis p s) (hs : ∀ i, (s i).Countable) :
    Measurable fun x => liminf (fun i => f i x) u := by
  simp_rw [hu.to_has_basis.liminf_eq_supr_infi]
  refine' measurableBsupr _ hu.countable _
  exact fun i => measurableBinfi _ (hs i) hf

/-- `limsup` over a general filter is measurable. See `measurable_limsup` for the version over `ℕ`.
-/
theorem measurableLimsup' {ι ι'} {f : ι → δ → α} {u : Filter ι} (hf : ∀ i, Measurable (f i)) {p : ι' → Prop}
    {s : ι' → Set ι} (hu : u.HasCountableBasis p s) (hs : ∀ i, (s i).Countable) :
    Measurable fun x => limsup (fun i => f i x) u := by
  simp_rw [hu.to_has_basis.limsup_eq_infi_supr]
  refine' measurableBinfi _ hu.countable _
  exact fun i => measurableBsupr _ (hs i) hf

/-- `liminf` over `ℕ` is measurable. See `measurable_liminf'` for a version with a general filter.
-/
@[measurability]
theorem measurableLiminf {f : ℕ → δ → α} (hf : ∀ i, Measurable (f i)) :
    Measurable fun x => liminf (fun i => f i x) atTop :=
  measurableLiminf' hf at_top_countable_basis fun i => to_countable _

/-- `limsup` over `ℕ` is measurable. See `measurable_limsup'` for a version with a general filter.
-/
@[measurability]
theorem measurableLimsup {f : ℕ → δ → α} (hf : ∀ i, Measurable (f i)) :
    Measurable fun x => limsup (fun i => f i x) atTop :=
  measurableLimsup' hf at_top_countable_basis fun i => to_countable _

end CompleteLinearOrder

section ConditionallyCompleteLinearOrder

variable [ConditionallyCompleteLinearOrder α] [OrderTopology α] [SecondCountableTopology α]

theorem measurableCSup {ι} {f : ι → δ → α} {s : Set ι} (hs : s.Countable) (hf : ∀ i, Measurable (f i))
    (bdd : ∀ x, BddAbove ((fun i => f i x) '' s)) : Measurable fun x => sup ((fun i => f i x) '' s) := by
  cases' eq_empty_or_nonempty s with h2s h2s
  · simp [h2s, measurableConst]
    
  · apply measurableOfIic
    intro y
    simp_rw [preimage, mem_Iic, cSup_le_iff (bdd _) (h2s.image _), ball_image_iff, set_of_forall]
    exact MeasurableSet.bInter hs fun i hi => measurableSetLe (hf i) measurableConst
    

end ConditionallyCompleteLinearOrder

/-- Convert a `homeomorph` to a `measurable_equiv`. -/
def Homemorph.toMeasurableEquiv (h : α ≃ₜ β) : α ≃ᵐ β where
  toEquiv := h.toEquiv
  measurableToFun := h.continuous_to_fun.Measurable
  measurableInvFun := h.continuous_inv_fun.Measurable

protected theorem IsFiniteMeasureOnCompacts.map {α : Type _} {m0 : MeasurableSpace α} [TopologicalSpace α]
    [OpensMeasurableSpace α] {β : Type _} [MeasurableSpace β] [TopologicalSpace β] [BorelSpace β] [T2Space β]
    (μ : Measure α) [IsFiniteMeasureOnCompacts μ] (f : α ≃ₜ β) : IsFiniteMeasureOnCompacts (Measure.map f μ) :=
  ⟨by
    intro K hK
    rw [measure.map_apply f.measurable hK.measurable_set]
    apply IsCompact.measure_lt_top
    rwa [f.compact_preimage]⟩

end BorelSpace

instance Empty.borelSpace : BorelSpace Empty :=
  ⟨borel_eq_top_of_discrete.symm⟩

instance Unit.borelSpace : BorelSpace Unit :=
  ⟨borel_eq_top_of_discrete.symm⟩

instance Bool.borelSpace : BorelSpace Bool :=
  ⟨borel_eq_top_of_discrete.symm⟩

instance Nat.borelSpace : BorelSpace ℕ :=
  ⟨borel_eq_top_of_discrete.symm⟩

instance Int.borelSpace : BorelSpace ℤ :=
  ⟨borel_eq_top_of_discrete.symm⟩

instance Rat.borelSpace : BorelSpace ℚ :=
  ⟨borel_eq_top_of_countable.symm⟩

instance (priority := 900) IsROrC.measurableSpace {𝕜 : Type _} [IsROrC 𝕜] : MeasurableSpace 𝕜 :=
  borel 𝕜

instance (priority := 900) IsROrC.borelSpace {𝕜 : Type _} [IsROrC 𝕜] : BorelSpace 𝕜 :=
  ⟨rfl⟩

/- Instances on `real` and `complex` are special cases of `is_R_or_C` but without these instances,
Lean fails to prove `borel_space (ι → ℝ)`, so we leave them here. -/
instance Real.measurableSpace : MeasurableSpace ℝ :=
  borel ℝ

instance Real.borelSpace : BorelSpace ℝ :=
  ⟨rfl⟩

instance Nnreal.measurableSpace : MeasurableSpace ℝ≥0 :=
  Subtype.measurableSpace

instance Nnreal.borelSpace : BorelSpace ℝ≥0 :=
  Subtype.borelSpace _

instance Ennreal.measurableSpace : MeasurableSpace ℝ≥0∞ :=
  borel ℝ≥0∞

instance Ennreal.borelSpace : BorelSpace ℝ≥0∞ :=
  ⟨rfl⟩

instance Ereal.measurableSpace : MeasurableSpace Ereal :=
  borel Ereal

instance Ereal.borelSpace : BorelSpace Ereal :=
  ⟨rfl⟩

instance Complex.measurableSpace : MeasurableSpace ℂ :=
  borel ℂ

instance Complex.borelSpace : BorelSpace ℂ :=
  ⟨rfl⟩

instance AddCircle.measurableSpace {a : ℝ} : MeasurableSpace (AddCircle a) :=
  borel (AddCircle a)

instance AddCircle.borelSpace {a : ℝ} : BorelSpace (AddCircle a) :=
  ⟨rfl⟩

@[measurability]
protected theorem AddCircle.measurableMk' {a : ℝ} : Measurable (coe : ℝ → AddCircle a) :=
  Continuous.measurable <| AddCircle.continuous_mk' a

/-- One can cut out `ℝ≥0∞` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : ℤ` and `{∞}`. This
gives a way to compute the measure of a set in terms of sets on which a given function `f` does not
fluctuate by more than `t`. -/
theorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow [MeasurableSpace α] (μ : Measure α) {f : α → ℝ≥0∞}
    (hf : Measurable f) {s : Set α} (hs : MeasurableSet s) {t : ℝ≥0} (ht : 1 < t) :
    μ s = μ (s ∩ f ⁻¹' {0}) + μ (s ∩ f ⁻¹' {∞}) + ∑' n : ℤ, μ (s ∩ f ⁻¹' IcoCat (t ^ n) (t ^ (n + 1))) := by
  have A : μ s = μ (s ∩ f ⁻¹' {0}) + μ (s ∩ f ⁻¹' Ioi 0) := by
    rw [← measure_union]
    · congr 1
      ext x
      have : 0 = f x ∨ 0 < f x := eq_or_lt_of_le bot_le
      rw [eq_comm] at this
      simp only [← and_or_left, this, mem_singleton_iff, mem_inter_iff, and_true_iff, mem_union, mem_Ioi, mem_preimage]
      
    · apply disjoint_left.2 fun x hx h'x => _
      have : 0 < f x := h'x.2
      exact lt_irrefl 0 (this.trans_le hx.2.le)
      
    · exact hs.inter (hf measurableSetIoi)
      
  have B : μ (s ∩ f ⁻¹' Ioi 0) = μ (s ∩ f ⁻¹' {∞}) + μ (s ∩ f ⁻¹' Ioo 0 ∞) := by
    rw [← measure_union]
    · rw [← inter_union_distrib_left]
      congr
      ext x
      simp only [mem_singleton_iff, mem_union, mem_Ioo, mem_Ioi, mem_preimage]
      have H : f x = ∞ ∨ f x < ∞ := eq_or_lt_of_le le_top
      cases H
      · simp only [H, eq_self_iff_true, or_false_iff, WithTop.zero_lt_top, not_top_lt, and_false_iff]
        
      · simp only [H, H.ne, and_true_iff, false_or_iff]
        
      
    · apply disjoint_left.2 fun x hx h'x => _
      have : f x < ∞ := h'x.2.2
      exact lt_irrefl _ (this.trans_le (le_of_eq hx.2.symm))
      
    · exact hs.inter (hf measurableSetIoo)
      
  have C : μ (s ∩ f ⁻¹' Ioo 0 ∞) = ∑' n : ℤ, μ (s ∩ f ⁻¹' Ico (t ^ n) (t ^ (n + 1))) := by
    rw [← measure_Union, Ennreal.Ioo_zero_top_eq_Union_Ico_zpow (Ennreal.one_lt_coe_iff.2 ht) Ennreal.coe_ne_top,
      preimage_Union, inter_Union]
    · intro i j
      simp only [Function.onFun]
      wlog (discharger := tactic.skip) h : i ≤ j := le_total i j using i j, j i
      · intro hij
        replace hij : i + 1 ≤ j := lt_of_le_of_ne h hij
        apply disjoint_left.2 fun x hx h'x => lt_irrefl (f x) _
        calc
          f x < t ^ (i + 1) := hx.2.2
          _ ≤ t ^ j := Ennreal.zpow_le_of_le (Ennreal.one_le_coe_iff.2 ht.le) hij
          _ ≤ f x := h'x.2.1
          
        
      · intro hij
        rw [Disjoint.comm]
        exact this hij.symm
        
      
    · intro n
      exact hs.inter (hf measurableSetIco)
      
  rw [A, B, C, add_assoc]

section PseudoMetricSpace

variable [PseudoMetricSpace α] [MeasurableSpace α] [OpensMeasurableSpace α]

variable [MeasurableSpace β] {x : α} {ε : ℝ}

open Metric

@[measurability]
theorem measurableSetBall : MeasurableSet (Metric.Ball x ε) :=
  Metric.is_open_ball.MeasurableSet

@[measurability]
theorem measurableSetClosedBall : MeasurableSet (Metric.ClosedBall x ε) :=
  Metric.isClosedBall.MeasurableSet

@[measurability]
theorem measurableInfDist {s : Set α} : Measurable fun x => infDist x s :=
  (continuous_inf_dist_pt s).Measurable

@[measurability]
theorem Measurable.infDist {f : β → α} (hf : Measurable f) {s : Set α} : Measurable fun x => infDist (f x) s :=
  measurableInfDist.comp hf

@[measurability]
theorem measurableInfNndist {s : Set α} : Measurable fun x => infNndist x s :=
  (continuous_inf_nndist_pt s).Measurable

@[measurability]
theorem Measurable.infNndist {f : β → α} (hf : Measurable f) {s : Set α} : Measurable fun x => infNndist (f x) s :=
  measurableInfNndist.comp hf

section

variable [SecondCountableTopology α]

@[measurability]
theorem measurableDist : Measurable fun p : α × α => dist p.1 p.2 :=
  continuous_dist.Measurable

@[measurability]
theorem Measurable.dist {f g : β → α} (hf : Measurable f) (hg : Measurable g) : Measurable fun b => dist (f b) (g b) :=
  (@continuous_dist α _).measurable2 hf hg

@[measurability]
theorem measurableNndist : Measurable fun p : α × α => nndist p.1 p.2 :=
  continuous_nndist.Measurable

@[measurability]
theorem Measurable.nndist {f g : β → α} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => nndist (f b) (g b) :=
  (@continuous_nndist α _).measurable2 hf hg

end

/-- If a set has a closed thickening with finite measure, then the measure of its `r`-closed
thickenings converges to the measure of its closure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening {μ : Measure α} {s : Set α} (hs : ∃ R > 0, μ (Cthickening R s) ≠ ∞) :
    Tendsto (fun r => μ (Cthickening r s)) (𝓝 0) (𝓝 (μ (Closure s))) := by
  have A : tendsto (fun r => μ (cthickening r s)) (𝓝[Ioi 0] 0) (𝓝 (μ (Closure s))) := by
    rw [closure_eq_Inter_cthickening]
    exact
      tendsto_measure_bInter_gt (fun r hr => is_closed_cthickening.measurable_set)
        (fun i j ipos ij => cthickening_mono ij _) hs
  have B : tendsto (fun r => μ (cthickening r s)) (𝓝[Iic 0] 0) (𝓝 (μ (Closure s))) := by
    apply tendsto.congr' _ tendsto_const_nhds
    filter_upwards [self_mem_nhds_within] with _ hr
    rw [cthickening_of_nonpos hr]
  convert B.sup A
  exact (nhds_left_sup_nhds_right' 0).symm

/-- If a closed set has a closed thickening with finite measure, then the measure of its `r`-closed
thickenings converges to its measure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening_of_is_closed {μ : Measure α} {s : Set α} (hs : ∃ R > 0, μ (Cthickening R s) ≠ ∞)
    (h's : IsClosed s) : Tendsto (fun r => μ (Cthickening r s)) (𝓝 0) (𝓝 (μ s)) := by
  convert tendsto_measure_cthickening hs
  exact h's.closure_eq.symm

end PseudoMetricSpace

/-- Given a compact set in a proper space, the measure of its `r`-closed thickenings converges to
its measure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening_of_is_compact [MetricSpace α] [MeasurableSpace α] [OpensMeasurableSpace α]
    [ProperSpace α] {μ : Measure α} [IsFiniteMeasureOnCompacts μ] {s : Set α} (hs : IsCompact s) :
    Tendsto (fun r => μ (Metric.Cthickening r s)) (𝓝 0) (𝓝 (μ s)) :=
  tendsto_measure_cthickening_of_is_closed ⟨1, zero_lt_one, hs.Bounded.Cthickening.measure_lt_top.Ne⟩ hs.IsClosed

section PseudoEmetricSpace

variable [PseudoEmetricSpace α] [MeasurableSpace α] [OpensMeasurableSpace α]

variable [MeasurableSpace β] {x : α} {ε : ℝ≥0∞}

open Emetric

@[measurability]
theorem measurableSetEball : MeasurableSet (Emetric.Ball x ε) :=
  Emetric.is_open_ball.MeasurableSet

@[measurability]
theorem measurableEdistRight : Measurable (edist x) :=
  (continuous_const.edist continuous_id).Measurable

@[measurability]
theorem measurableEdistLeft : Measurable fun y => edist y x :=
  (continuous_id.edist continuous_const).Measurable

@[measurability]
theorem measurableInfEdist {s : Set α} : Measurable fun x => infEdist x s :=
  continuous_inf_edist.Measurable

@[measurability]
theorem Measurable.infEdist {f : β → α} (hf : Measurable f) {s : Set α} : Measurable fun x => infEdist (f x) s :=
  measurableInfEdist.comp hf

variable [SecondCountableTopology α]

@[measurability]
theorem measurableEdist : Measurable fun p : α × α => edist p.1 p.2 :=
  continuous_edist.Measurable

@[measurability]
theorem Measurable.edist {f g : β → α} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => edist (f b) (g b) :=
  (@continuous_edist α _).measurable2 hf hg

@[measurability]
theorem AeMeasurable.edist {f g : β → α} {μ : Measure β} (hf : AeMeasurable f μ) (hg : AeMeasurable g μ) :
    AeMeasurable (fun a => edist (f a) (g a)) μ :=
  (@continuous_edist α _).aeMeasurable2 hf hg

end PseudoEmetricSpace

namespace Real

open MeasurableSpace MeasureTheory

/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (a b) -/
theorem borel_eq_generate_from_Ioo_rat : borel ℝ = generateFrom (⋃ (a : ℚ) (b : ℚ) (h : a < b), {IooCat a b}) :=
  is_topological_basis_Ioo_rat.borel_eq_generate_from

/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (a b) -/
theorem is_pi_system_Ioo_rat : @IsPiSystem ℝ (⋃ (a : ℚ) (b : ℚ) (h : a < b), {IooCat a b}) := by
  convert is_pi_system_Ioo (coe : ℚ → ℝ) (coe : ℚ → ℝ)
  ext x
  simp [eq_comm]

/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (a b) -/
/-- The intervals `(-(n + 1), (n + 1))` form a finite spanning sets in the set of open intervals
with rational endpoints for a locally finite measure `μ` on `ℝ`. -/
def finiteSpanningSetsInIooRat (μ : Measure ℝ) [IsLocallyFiniteMeasure μ] :
    μ.FiniteSpanningSetsIn (⋃ (a : ℚ) (b : ℚ) (h : a < b), {IooCat a b}) where
  Set n := IooCat (-(n + 1)) (n + 1)
  set_mem n := by
    simp only [mem_Union, mem_singleton_iff]
    refine' ⟨-(n + 1 : ℕ), n + 1, _, by simp⟩
    -- TODO: norm_cast fails here?
    exact (neg_nonpos.2 (@Nat.cast_nonneg ℚ _ (n + 1))).trans_lt n.cast_add_one_pos
  Finite n := measure_Ioo_lt_top
  spanning :=
    Union_eq_univ_iff.2 fun x =>
      ⟨⌊abs x⌋₊, neg_lt.1 ((neg_le_abs_self x).trans_lt (Nat.lt_floor_add_one _)),
        (le_abs_self x).trans_lt (Nat.lt_floor_add_one _)⟩

theorem measure_ext_Ioo_rat {μ ν : Measure ℝ} [IsLocallyFiniteMeasure μ]
    (h : ∀ a b : ℚ, μ (IooCat a b) = ν (IooCat a b)) : μ = ν :=
  (finiteSpanningSetsInIooRat μ).ext borel_eq_generate_from_Ioo_rat is_pi_system_Ioo_rat <| by
    simp only [mem_Union, mem_singleton_iff]
    rintro _ ⟨a, b, -, rfl⟩
    apply h

theorem borel_eq_generate_from_Iio_rat : borel ℝ = generateFrom (⋃ a : ℚ, {IioCat a}) := by
  let g : MeasurableSpace ℝ := generate_from (⋃ a : ℚ, {Iio a})
  refine' le_antisymm _ _
  · rw [borel_eq_generate_from_Ioo_rat]
    refine' generate_from_le fun t => _
    simp only [mem_Union, mem_singleton_iff]
    rintro ⟨a, b, h, rfl⟩
    rw [(Set.ext fun x => _ : Ioo (a : ℝ) b = (⋃ c > a, Iio cᶜ) ∩ Iio b)]
    · have hg : ∀ q : ℚ, measurable_set[g] (Iio q) := fun q => generate_measurable.basic (Iio q) (by simp)
      refine' @MeasurableSet.inter _ g _ _ _ (hg _)
      refine' @MeasurableSet.bUnion _ _ g _ _ (to_countable _) fun c h => _
      exact @MeasurableSet.compl _ _ g (hg _)
      
    · suffices x < ↑b → (↑a < x ↔ ∃ i : ℚ, a < i ∧ ↑i ≤ x) by simpa
      refine' fun _ => ⟨fun h => _, fun ⟨i, hai, hix⟩ => (Rat.cast_lt.2 hai).trans_le hix⟩
      rcases exists_rat_btwn h with ⟨c, ac, cx⟩
      exact ⟨c, Rat.cast_lt.1 ac, cx.le⟩
      
    
  · refine' MeasurableSpace.generate_from_le fun _ => _
    simp only [mem_Union, mem_singleton_iff]
    rintro ⟨r, rfl⟩
    exact measurableSetIio
    

end Real

variable [MeasurableSpace α]

@[measurability]
theorem measurableRealToNnreal : Measurable Real.toNnreal :=
  continuous_real_to_nnreal.Measurable

@[measurability]
theorem Measurable.realToNnreal {f : α → ℝ} (hf : Measurable f) : Measurable fun x => Real.toNnreal (f x) :=
  measurableRealToNnreal.comp hf

@[measurability]
theorem AeMeasurable.realToNnreal {f : α → ℝ} {μ : Measure α} (hf : AeMeasurable f μ) :
    AeMeasurable (fun x => Real.toNnreal (f x)) μ :=
  measurableRealToNnreal.compAeMeasurable hf

@[measurability]
theorem measurableCoeNnrealReal : Measurable (coe : ℝ≥0 → ℝ) :=
  Nnreal.continuous_coe.Measurable

@[measurability]
theorem Measurable.coeNnrealReal {f : α → ℝ≥0} (hf : Measurable f) : Measurable fun x => (f x : ℝ) :=
  measurableCoeNnrealReal.comp hf

@[measurability]
theorem AeMeasurable.coeNnrealReal {f : α → ℝ≥0} {μ : Measure α} (hf : AeMeasurable f μ) :
    AeMeasurable (fun x => (f x : ℝ)) μ :=
  measurableCoeNnrealReal.compAeMeasurable hf

@[measurability]
theorem measurableCoeNnrealEnnreal : Measurable (coe : ℝ≥0 → ℝ≥0∞) :=
  Ennreal.continuous_coe.Measurable

@[measurability]
theorem Measurable.coeNnrealEnnreal {f : α → ℝ≥0} (hf : Measurable f) : Measurable fun x => (f x : ℝ≥0∞) :=
  Ennreal.continuous_coe.Measurable.comp hf

@[measurability]
theorem AeMeasurable.coeNnrealEnnreal {f : α → ℝ≥0} {μ : Measure α} (hf : AeMeasurable f μ) :
    AeMeasurable (fun x => (f x : ℝ≥0∞)) μ :=
  Ennreal.continuous_coe.Measurable.compAeMeasurable hf

@[measurability]
theorem Measurable.ennrealOfReal {f : α → ℝ} (hf : Measurable f) : Measurable fun x => Ennreal.ofReal (f x) :=
  Ennreal.continuous_of_real.Measurable.comp hf

@[simp, norm_cast]
theorem measurable_coe_nnreal_real_iff {f : α → ℝ≥0} : Measurable (fun x => f x : α → ℝ) ↔ Measurable f :=
  ⟨fun h => by simpa only [Real.to_nnreal_coe] using h.real_to_nnreal, Measurable.coeNnrealReal⟩

@[simp, norm_cast]
theorem ae_measurable_coe_nnreal_real_iff {f : α → ℝ≥0} {μ : Measure α} :
    AeMeasurable (fun x => f x : α → ℝ) μ ↔ AeMeasurable f μ :=
  ⟨fun h => by simpa only [Real.to_nnreal_coe] using h.real_to_nnreal, AeMeasurable.coeNnrealReal⟩

/-- The set of finite `ℝ≥0∞` numbers is `measurable_equiv` to `ℝ≥0`. -/
def MeasurableEquiv.ennrealEquivNnreal : { r : ℝ≥0∞ | r ≠ ∞ } ≃ᵐ ℝ≥0 :=
  Ennreal.neTopHomeomorphNnreal.toMeasurableEquiv

namespace Ennreal

theorem measurableOfMeasurableNnreal {f : ℝ≥0∞ → α} (h : Measurable fun p : ℝ≥0 => f p) : Measurable f :=
  measurableOfMeasurableOnComplSingleton ∞ (MeasurableEquiv.ennrealEquivNnreal.symm.measurable_comp_iff.1 h)

/-- `ℝ≥0∞` is `measurable_equiv` to `ℝ≥0 ⊕ unit`. -/
def ennrealEquivSum : ℝ≥0∞ ≃ᵐ Sum ℝ≥0 Unit :=
  { Equiv.optionEquivSumPunit ℝ≥0 with measurableToFun := measurableOfMeasurableNnreal measurableInl,
    measurableInvFun := measurableSum measurableCoeNnrealEnnreal (@measurableConst ℝ≥0∞ Unit _ _ ∞) }

open Function (uncurry)

theorem measurableOfMeasurableNnrealProd [MeasurableSpace β] [MeasurableSpace γ] {f : ℝ≥0∞ × β → γ}
    (H₁ : Measurable fun p : ℝ≥0 × β => f (p.1, p.2)) (H₂ : Measurable fun x => f (∞, x)) : Measurable f :=
  let e : ℝ≥0∞ × β ≃ᵐ Sum (ℝ≥0 × β) (Unit × β) :=
    (ennrealEquivSum.prodCongr (MeasurableEquiv.refl β)).trans (MeasurableEquiv.sumProdDistrib _ _ _)
  e.symm.measurable_comp_iff.1 <| measurableSum H₁ (H₂.comp measurableId.snd)

theorem measurableOfMeasurableNnrealNnreal [MeasurableSpace β] {f : ℝ≥0∞ × ℝ≥0∞ → β}
    (h₁ : Measurable fun p : ℝ≥0 × ℝ≥0 => f (p.1, p.2)) (h₂ : Measurable fun r : ℝ≥0 => f (∞, r))
    (h₃ : Measurable fun r : ℝ≥0 => f (r, ∞)) : Measurable f :=
  measurableOfMeasurableNnrealProd
    (measurable_swap_iff.1 <| measurableOfMeasurableNnrealProd (h₁.comp measurableSwap) h₃)
    (measurableOfMeasurableNnreal h₂)

@[measurability]
theorem measurableOfReal : Measurable Ennreal.ofReal :=
  Ennreal.continuous_of_real.Measurable

@[measurability]
theorem measurableToReal : Measurable Ennreal.toReal :=
  Ennreal.measurableOfMeasurableNnreal measurableCoeNnrealReal

@[measurability]
theorem measurableToNnreal : Measurable Ennreal.toNnreal :=
  Ennreal.measurableOfMeasurableNnreal measurableId

instance : HasMeasurableMul₂ ℝ≥0∞ := by
  refine' ⟨measurable_of_measurable_nnreal_nnreal _ _ _⟩
  · simp only [← Ennreal.coe_mul, measurable_mul.coe_nnreal_ennreal]
    
  · simp only [Ennreal.top_mul, Ennreal.coe_eq_zero]
    exact measurable_const.piecewise (measurable_set_singleton _) measurableConst
    
  · simp only [Ennreal.mul_top, Ennreal.coe_eq_zero]
    exact measurable_const.piecewise (measurable_set_singleton _) measurableConst
    

instance : HasMeasurableSub₂ ℝ≥0∞ :=
  ⟨by
    apply measurable_of_measurable_nnreal_nnreal <;>
      simp [← WithTop.coe_sub, continuous_sub.measurable.coe_nnreal_ennreal]⟩

instance : HasMeasurableInv ℝ≥0∞ :=
  ⟨continuous_inv.Measurable⟩

end Ennreal

@[measurability]
theorem Measurable.ennrealToNnreal {f : α → ℝ≥0∞} (hf : Measurable f) : Measurable fun x => (f x).toNnreal :=
  Ennreal.measurableToNnreal.comp hf

@[measurability]
theorem AeMeasurable.ennrealToNnreal {f : α → ℝ≥0∞} {μ : Measure α} (hf : AeMeasurable f μ) :
    AeMeasurable (fun x => (f x).toNnreal) μ :=
  Ennreal.measurableToNnreal.compAeMeasurable hf

@[simp, norm_cast]
theorem measurable_coe_nnreal_ennreal_iff {f : α → ℝ≥0} : (Measurable fun x => (f x : ℝ≥0∞)) ↔ Measurable f :=
  ⟨fun h => h.ennrealToNnreal, fun h => h.coeNnrealEnnreal⟩

@[simp, norm_cast]
theorem ae_measurable_coe_nnreal_ennreal_iff {f : α → ℝ≥0} {μ : Measure α} :
    AeMeasurable (fun x => (f x : ℝ≥0∞)) μ ↔ AeMeasurable f μ :=
  ⟨fun h => h.ennrealToNnreal, fun h => h.coeNnrealEnnreal⟩

@[measurability]
theorem Measurable.ennrealToReal {f : α → ℝ≥0∞} (hf : Measurable f) : Measurable fun x => Ennreal.toReal (f x) :=
  Ennreal.measurableToReal.comp hf

@[measurability]
theorem AeMeasurable.ennrealToReal {f : α → ℝ≥0∞} {μ : Measure α} (hf : AeMeasurable f μ) :
    AeMeasurable (fun x => Ennreal.toReal (f x)) μ :=
  Ennreal.measurableToReal.compAeMeasurable hf

/-- note: `ℝ≥0∞` can probably be generalized in a future version of this lemma. -/
@[measurability]
theorem Measurable.ennrealTsum {ι} [Countable ι] {f : ι → α → ℝ≥0∞} (h : ∀ i, Measurable (f i)) :
    Measurable fun x => ∑' i, f i x := by
  simp_rw [Ennreal.tsum_eq_supr_sum]
  apply measurableSupr
  exact fun s => s.measurableSum fun i _ => h i

@[measurability]
theorem Measurable.ennrealTsum' {ι} [Countable ι] {f : ι → α → ℝ≥0∞} (h : ∀ i, Measurable (f i)) :
    Measurable (∑' i, f i) := by
  convert Measurable.ennrealTsum h
  ext1 x
  exact tsum_apply (Pi.summable.2 fun _ => Ennreal.summable)

@[measurability]
theorem Measurable.nnrealTsum {ι} [Countable ι] {f : ι → α → ℝ≥0} (h : ∀ i, Measurable (f i)) :
    Measurable fun x => ∑' i, f i x := by
  simp_rw [Nnreal.tsum_eq_to_nnreal_tsum]
  exact (Measurable.ennrealTsum fun i => (h i).coeNnrealEnnreal).ennrealToNnreal

@[measurability]
theorem AeMeasurable.ennrealTsum {ι} [Countable ι] {f : ι → α → ℝ≥0∞} {μ : Measure α} (h : ∀ i, AeMeasurable (f i) μ) :
    AeMeasurable (fun x => ∑' i, f i x) μ := by
  simp_rw [Ennreal.tsum_eq_supr_sum]
  apply aeMeasurableSupr
  exact fun s => Finset.aeMeasurableSum s fun i _ => h i

@[measurability]
theorem measurableCoeRealEreal : Measurable (coe : ℝ → Ereal) :=
  continuous_coe_real_ereal.Measurable

@[measurability]
theorem Measurable.coeRealEreal {f : α → ℝ} (hf : Measurable f) : Measurable fun x => (f x : Ereal) :=
  measurableCoeRealEreal.comp hf

@[measurability]
theorem AeMeasurable.coeRealEreal {f : α → ℝ} {μ : Measure α} (hf : AeMeasurable f μ) :
    AeMeasurable (fun x => (f x : Ereal)) μ :=
  measurableCoeRealEreal.compAeMeasurable hf

/-- The set of finite `ereal` numbers is `measurable_equiv` to `ℝ`. -/
def MeasurableEquiv.erealEquivReal : ({⊥, ⊤}ᶜ : Set Ereal) ≃ᵐ ℝ :=
  Ereal.neBotTopHomeomorphReal.toMeasurableEquiv

theorem Ereal.measurableOfMeasurableReal {f : Ereal → α} (h : Measurable fun p : ℝ => f p) : Measurable f :=
  measurableOfMeasurableOnComplFinite {⊥, ⊤} (by simp) (MeasurableEquiv.erealEquivReal.symm.measurable_comp_iff.1 h)

@[measurability]
theorem measurableErealToReal : Measurable Ereal.toReal :=
  Ereal.measurableOfMeasurableReal (by simpa using measurableId)

@[measurability]
theorem Measurable.erealToReal {f : α → Ereal} (hf : Measurable f) : Measurable fun x => (f x).toReal :=
  measurableErealToReal.comp hf

@[measurability]
theorem AeMeasurable.erealToReal {f : α → Ereal} {μ : Measure α} (hf : AeMeasurable f μ) :
    AeMeasurable (fun x => (f x).toReal) μ :=
  measurableErealToReal.compAeMeasurable hf

@[measurability]
theorem measurableCoeEnnrealEreal : Measurable (coe : ℝ≥0∞ → Ereal) :=
  continuous_coe_ennreal_ereal.Measurable

@[measurability]
theorem Measurable.coeErealEnnreal {f : α → ℝ≥0∞} (hf : Measurable f) : Measurable fun x => (f x : Ereal) :=
  measurableCoeEnnrealEreal.comp hf

@[measurability]
theorem AeMeasurable.coeErealEnnreal {f : α → ℝ≥0∞} {μ : Measure α} (hf : AeMeasurable f μ) :
    AeMeasurable (fun x => (f x : Ereal)) μ :=
  measurableCoeEnnrealEreal.compAeMeasurable hf

section NormedAddCommGroup

variable [NormedAddCommGroup α] [OpensMeasurableSpace α] [MeasurableSpace β]

@[measurability]
theorem measurableNorm : Measurable (norm : α → ℝ) :=
  continuous_norm.Measurable

@[measurability]
theorem Measurable.norm {f : β → α} (hf : Measurable f) : Measurable fun a => norm (f a) :=
  measurableNorm.comp hf

@[measurability]
theorem AeMeasurable.norm {f : β → α} {μ : Measure β} (hf : AeMeasurable f μ) : AeMeasurable (fun a => norm (f a)) μ :=
  measurableNorm.compAeMeasurable hf

@[measurability]
theorem measurableNnnorm : Measurable (nnnorm : α → ℝ≥0) :=
  continuous_nnnorm.Measurable

@[measurability]
theorem Measurable.nnnorm {f : β → α} (hf : Measurable f) : Measurable fun a => ∥f a∥₊ :=
  measurableNnnorm.comp hf

@[measurability]
theorem AeMeasurable.nnnorm {f : β → α} {μ : Measure β} (hf : AeMeasurable f μ) : AeMeasurable (fun a => ∥f a∥₊) μ :=
  measurableNnnorm.compAeMeasurable hf

@[measurability]
theorem measurableEnnnorm : Measurable fun x : α => (∥x∥₊ : ℝ≥0∞) :=
  measurableNnnorm.coeNnrealEnnreal

@[measurability]
theorem Measurable.ennnorm {f : β → α} (hf : Measurable f) : Measurable fun a => (∥f a∥₊ : ℝ≥0∞) :=
  hf.nnnorm.coeNnrealEnnreal

@[measurability]
theorem AeMeasurable.ennnorm {f : β → α} {μ : Measure β} (hf : AeMeasurable f μ) :
    AeMeasurable (fun a => (∥f a∥₊ : ℝ≥0∞)) μ :=
  measurableEnnnorm.compAeMeasurable hf

end NormedAddCommGroup

section Limits

variable [TopologicalSpace β] [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]

open Metric

/-- A limit (over a general filter) of measurable `ℝ≥0∞` valued functions is measurable. -/
theorem measurableOfTendstoEnnreal' {ι} {f : ι → α → ℝ≥0∞} {g : α → ℝ≥0∞} (u : Filter ι) [NeBot u]
    [IsCountablyGenerated u] (hf : ∀ i, Measurable (f i)) (lim : Tendsto f u (𝓝 g)) : Measurable g := by
  rcases u.exists_seq_tendsto with ⟨x, hx⟩
  rw [tendsto_pi_nhds] at lim
  have : (fun y => liminf (fun n => (f (x n) y : ℝ≥0∞)) at_top) = g := by
    ext1 y
    exact ((lim y).comp hx).liminf_eq
  rw [← this]
  show Measurable fun y => liminf (fun n => (f (x n) y : ℝ≥0∞)) at_top
  exact measurableLiminf fun n => hf (x n)

/-- A sequential limit of measurable `ℝ≥0∞` valued functions is measurable. -/
theorem measurableOfTendstoEnnreal {f : ℕ → α → ℝ≥0∞} {g : α → ℝ≥0∞} (hf : ∀ i, Measurable (f i))
    (lim : Tendsto f atTop (𝓝 g)) : Measurable g :=
  measurableOfTendstoEnnreal' atTop hf lim

/-- A limit (over a general filter) of measurable `ℝ≥0` valued functions is measurable. -/
theorem measurableOfTendstoNnreal' {ι} {f : ι → α → ℝ≥0} {g : α → ℝ≥0} (u : Filter ι) [NeBot u] [IsCountablyGenerated u]
    (hf : ∀ i, Measurable (f i)) (lim : Tendsto f u (𝓝 g)) : Measurable g := by
  simp_rw [← measurable_coe_nnreal_ennreal_iff] at hf⊢
  refine' measurableOfTendstoEnnreal' u hf _
  rw [tendsto_pi_nhds] at lim⊢
  exact fun x => (ennreal.continuous_coe.tendsto (g x)).comp (lim x)

/-- A sequential limit of measurable `ℝ≥0` valued functions is measurable. -/
theorem measurableOfTendstoNnreal {f : ℕ → α → ℝ≥0} {g : α → ℝ≥0} (hf : ∀ i, Measurable (f i))
    (lim : Tendsto f atTop (𝓝 g)) : Measurable g :=
  measurableOfTendstoNnreal' atTop hf lim

/-- A limit (over a general filter) of measurable functions valued in a (pseudo) metrizable space is
measurable. -/
theorem measurableOfTendstoMetrizable' {ι} {f : ι → α → β} {g : α → β} (u : Filter ι) [NeBot u] [IsCountablyGenerated u]
    (hf : ∀ i, Measurable (f i)) (lim : Tendsto f u (𝓝 g)) : Measurable g := by
  letI : PseudoMetricSpace β := pseudo_metrizable_space_pseudo_metric β
  apply measurableOfIsClosed'
  intro s h1s h2s h3s
  have : Measurable fun x => inf_nndist (g x) s := by
    suffices : tendsto (fun i x => inf_nndist (f i x) s) u (𝓝 fun x => inf_nndist (g x) s)
    exact measurableOfTendstoNnreal' u (fun i => (hf i).infNndist) this
    rw [tendsto_pi_nhds] at lim⊢
    intro x
    exact ((continuous_inf_nndist_pt s).Tendsto (g x)).comp (lim x)
  have h4s : g ⁻¹' s = (fun x => inf_nndist (g x) s) ⁻¹' {0} := by
    ext x
    simp [h1s, ← h1s.mem_iff_inf_dist_zero h2s, ← Nnreal.coe_eq_zero]
  rw [h4s]
  exact this (measurable_set_singleton 0)

/-- A sequential limit of measurable functions valued in a (pseudo) metrizable space is
measurable. -/
theorem measurableOfTendstoMetrizable {f : ℕ → α → β} {g : α → β} (hf : ∀ i, Measurable (f i))
    (lim : Tendsto f atTop (𝓝 g)) : Measurable g :=
  measurableOfTendstoMetrizable' atTop hf lim

theorem aeMeasurableOfTendstoMetrizableAe {ι} {μ : Measure α} {f : ι → α → β} {g : α → β} (u : Filter ι) [hu : NeBot u]
    [IsCountablyGenerated u] (hf : ∀ n, AeMeasurable (f n) μ)
    (h_tendsto : ∀ᵐ x ∂μ, Tendsto (fun n => f n x) u (𝓝 (g x))) : AeMeasurable g μ := by
  rcases u.exists_seq_tendsto with ⟨v, hv⟩
  have h'f : ∀ n, AeMeasurable (f (v n)) μ := fun n => hf (v n)
  set p : α → (ℕ → β) → Prop := fun x f' => tendsto (fun n => f' n) at_top (𝓝 (g x))
  have hp : ∀ᵐ x ∂μ, p x fun n => f (v n) x := by filter_upwards [h_tendsto] with x hx using hx.comp hv
  set ae_seq_lim := fun x => ite (x ∈ AeSeqSet h'f p) (g x) (⟨f (v 0) x⟩ : Nonempty β).some with hs
  refine'
    ⟨ae_seq_lim, measurableOfTendstoMetrizable' at_top (aeSeq.measurable h'f p) (tendsto_pi_nhds.mpr fun x => _), _⟩
  · simp_rw [aeSeq, ae_seq_lim]
    split_ifs with hx
    · simp_rw [aeSeq.mk_eq_fun_of_mem_ae_seq_set h'f hx]
      exact @aeSeq.funPropOfMemAeSeqSet _ α β _ _ _ _ _ h'f x hx
      
    · exact tendsto_const_nhds
      
    
  · exact
      (ite_ae_eq_of_measure_compl_zero g (fun x => (⟨f (v 0) x⟩ : Nonempty β).some) (AeSeqSet h'f p)
          (aeSeq.measure_compl_ae_seq_set_eq_zero h'f hp)).symm
    

theorem aeMeasurableOfTendstoMetrizableAe' {μ : Measure α} {f : ℕ → α → β} {g : α → β} (hf : ∀ n, AeMeasurable (f n) μ)
    (h_ae_tendsto : ∀ᵐ x ∂μ, Tendsto (fun n => f n x) atTop (𝓝 (g x))) : AeMeasurable g μ :=
  aeMeasurableOfTendstoMetrizableAe atTop hf h_ae_tendsto

theorem aeMeasurableOfUnifApprox {β} [MeasurableSpace β] [PseudoMetricSpace β] [BorelSpace β] {μ : Measure α}
    {g : α → β} (hf : ∀ ε > (0 : ℝ), ∃ f : α → β, AeMeasurable f μ ∧ ∀ᵐ x ∂μ, dist (f x) (g x) ≤ ε) :
    AeMeasurable g μ := by
  obtain ⟨u, u_anti, u_pos, u_lim⟩ : ∃ u : ℕ → ℝ, StrictAnti u ∧ (∀ n : ℕ, 0 < u n) ∧ tendsto u at_top (𝓝 0) :=
    exists_seq_strict_anti_tendsto (0 : ℝ)
  choose f Hf using fun n : ℕ => hf (u n) (u_pos n)
  have : ∀ᵐ x ∂μ, tendsto (fun n => f n x) at_top (𝓝 (g x)) := by
    have : ∀ᵐ x ∂μ, ∀ n, dist (f n x) (g x) ≤ u n := ae_all_iff.2 fun n => (Hf n).2
    filter_upwards [this]
    intro x hx
    rw [tendsto_iff_dist_tendsto_zero]
    exact squeeze_zero (fun n => dist_nonneg) hx u_lim
  exact aeMeasurableOfTendstoMetrizableAe' (fun n => (Hf n).1) this

theorem measurableOfTendstoMetrizableAe {μ : Measure α} [μ.IsComplete] {f : ℕ → α → β} {g : α → β}
    (hf : ∀ n, Measurable (f n)) (h_ae_tendsto : ∀ᵐ x ∂μ, Tendsto (fun n => f n x) atTop (𝓝 (g x))) : Measurable g :=
  ae_measurable_iff_measurable.mp (aeMeasurableOfTendstoMetrizableAe' (fun i => (hf i).AeMeasurable) h_ae_tendsto)

theorem measurable_limit_of_tendsto_metrizable_ae {ι} [Countable ι] [Nonempty ι] {μ : Measure α} {f : ι → α → β}
    {L : Filter ι} [L.IsCountablyGenerated] (hf : ∀ n, AeMeasurable (f n) μ)
    (h_ae_tendsto : ∀ᵐ x ∂μ, ∃ l : β, Tendsto (fun n => f n x) L (𝓝 l)) :
    ∃ (f_lim : α → β)(hf_lim_meas : Measurable f_lim), ∀ᵐ x ∂μ, Tendsto (fun n => f n x) L (𝓝 (f_lim x)) := by
  inhabit ι
  rcases eq_or_ne L ⊥ with (rfl | hL)
  · exact ⟨(hf default).mk _, (hf default).measurableMk, eventually_of_forall fun x => tendsto_bot⟩
    
  haveI : ne_bot L := ⟨hL⟩
  let p : α → (ι → β) → Prop := fun x f' => ∃ l : β, tendsto (fun n => f' n) L (𝓝 l)
  have hp_mem : ∀ x ∈ AeSeqSet hf p, p x fun n => f n x := fun x hx => aeSeq.funPropOfMemAeSeqSet hf hx
  have h_ae_eq : ∀ᵐ x ∂μ, ∀ n, aeSeq hf p n x = f n x := aeSeq.ae_seq_eq_fun_ae hf h_ae_tendsto
  let f_lim : α → β := fun x =>
    dite (x ∈ AeSeqSet hf p) (fun h => (hp_mem x h).some) fun h => (⟨f default x⟩ : Nonempty β).some
  have hf_lim : ∀ x, tendsto (fun n => aeSeq hf p n x) L (𝓝 (f_lim x)) := by
    intro x
    simp only [f_lim, aeSeq]
    split_ifs
    · refine' (hp_mem x h).some_spec.congr fun n => _
      exact (aeSeq.mk_eq_fun_of_mem_ae_seq_set hf h n).symm
      
    · exact tendsto_const_nhds
      
  have h_ae_tendsto_f_lim : ∀ᵐ x ∂μ, tendsto (fun n => f n x) L (𝓝 (f_lim x)) :=
    h_ae_eq.mono fun x hx => (hf_lim x).congr hx
  have h_f_lim_meas : Measurable f_lim :=
    measurableOfTendstoMetrizable' L (aeSeq.measurable hf p) (tendsto_pi_nhds.mpr fun x => hf_lim x)
  exact ⟨f_lim, h_f_lim_meas, h_ae_tendsto_f_lim⟩

end Limits

namespace ContinuousLinearMap

variable {𝕜 : Type _} [NormedField 𝕜]

variable {E : Type _} [NormedAddCommGroup E] [NormedSpace 𝕜 E] [MeasurableSpace E] [OpensMeasurableSpace E] {F : Type _}
  [NormedAddCommGroup F] [NormedSpace 𝕜 F] [MeasurableSpace F] [BorelSpace F]

@[measurability]
protected theorem measurable (L : E →L[𝕜] F) : Measurable L :=
  L.Continuous.Measurable

theorem measurableComp (L : E →L[𝕜] F) {φ : α → E} (φ_meas : Measurable φ) : Measurable fun a : α => L (φ a) :=
  L.Measurable.comp φ_meas

end ContinuousLinearMap

namespace ContinuousLinearMap

variable {𝕜 : Type _} [NontriviallyNormedField 𝕜]

variable {E : Type _} [NormedAddCommGroup E] [NormedSpace 𝕜 E] {F : Type _} [NormedAddCommGroup F] [NormedSpace 𝕜 F]

instance : MeasurableSpace (E →L[𝕜] F) :=
  borel _

instance : BorelSpace (E →L[𝕜] F) :=
  ⟨rfl⟩

@[measurability]
theorem measurableApply [MeasurableSpace F] [BorelSpace F] (x : E) : Measurable fun f : E →L[𝕜] F => f x :=
  (apply 𝕜 F x).Continuous.Measurable

@[measurability]
theorem measurableApply' [MeasurableSpace E] [OpensMeasurableSpace E] [MeasurableSpace F] [BorelSpace F] :
    Measurable fun (x : E) (f : E →L[𝕜] F) => f x :=
  (measurablePiLambda _) fun f => f.Measurable

@[measurability]
theorem measurableCoe [MeasurableSpace F] [BorelSpace F] : Measurable fun (f : E →L[𝕜] F) (x : E) => f x :=
  measurablePiLambda _ measurableApply

end ContinuousLinearMap

section ContinuousLinearMapNontriviallyNormedField

variable {𝕜 : Type _} [NontriviallyNormedField 𝕜]

variable {E : Type _} [NormedAddCommGroup E] [NormedSpace 𝕜 E] [MeasurableSpace E] [BorelSpace E] {F : Type _}
  [NormedAddCommGroup F] [NormedSpace 𝕜 F]

@[measurability]
theorem Measurable.applyContinuousLinearMap {φ : α → F →L[𝕜] E} (hφ : Measurable φ) (v : F) :
    Measurable fun a => φ a v :=
  (ContinuousLinearMap.apply 𝕜 E v).Measurable.comp hφ

@[measurability]
theorem AeMeasurable.applyContinuousLinearMap {φ : α → F →L[𝕜] E} {μ : Measure α} (hφ : AeMeasurable φ μ) (v : F) :
    AeMeasurable (fun a => φ a v) μ :=
  (ContinuousLinearMap.apply 𝕜 E v).Measurable.compAeMeasurable hφ

end ContinuousLinearMapNontriviallyNormedField

section NormedSpace

variable {𝕜 : Type _} [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [MeasurableSpace 𝕜]

variable [BorelSpace 𝕜] {E : Type _} [NormedAddCommGroup E] [NormedSpace 𝕜 E] [MeasurableSpace E] [BorelSpace E]

theorem measurable_smul_const {f : α → 𝕜} {c : E} (hc : c ≠ 0) : (Measurable fun x => f x • c) ↔ Measurable f :=
  (closedEmbeddingSmulLeft hc).MeasurableEmbedding.measurable_comp_iff

theorem ae_measurable_smul_const {f : α → 𝕜} {μ : Measure α} {c : E} (hc : c ≠ 0) :
    AeMeasurable (fun x => f x • c) μ ↔ AeMeasurable f μ :=
  (closedEmbeddingSmulLeft hc).MeasurableEmbedding.ae_measurable_comp_iff

end NormedSpace

