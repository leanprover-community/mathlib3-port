import Mathbin.MeasureTheory.Measure.GiryMonad 
import Mathbin.Dynamics.Ergodic.MeasurePreserving 
import Mathbin.MeasureTheory.Integral.SetIntegral

/-!
# The product measure

In this file we define and prove properties about the binary product measure. If `α` and `β` have
σ-finite measures `μ` resp. `ν` then `α × β` can be equipped with a σ-finite measure `μ.prod ν` that
satisfies `(μ.prod ν) s = ∫⁻ x, ν {y | (x, y) ∈ s} ∂μ`.
We also have `(μ.prod ν) (s.prod t) = μ s * ν t`, i.e. the measure of a rectangle is the product of
the measures of the sides.

We also prove Tonelli's theorem and Fubini's theorem.

## Main definition

* `measure_theory.measure.prod`: The product of two measures.

## Main results

* `measure_theory.measure.prod_apply` states `μ.prod ν s = ∫⁻ x, ν {y | (x, y) ∈ s} ∂μ`
  for measurable `s`. `measure_theory.measure.prod_apply_symm` is the reversed version.
* `measure_theory.measure.prod_prod` states `μ.prod ν (s.prod t) = μ s * ν t` for measurable sets
  `s` and `t`.
* `measure_theory.lintegral_prod`: Tonelli's theorem. It states that for a measurable function
  `α × β → ℝ≥0∞` we have `∫⁻ z, f z ∂(μ.prod ν) = ∫⁻ x, ∫⁻ y, f (x, y) ∂ν ∂μ`. The version
  for functions `α → β → ℝ≥0∞` is reversed, and called `lintegral_lintegral`. Both versions have
  a variant with `_symm` appended, where the order of integration is reversed.
  The lemma `measurable.lintegral_prod_right'` states that the inner integral of the right-hand side
  is measurable.
* `measure_theory.integrable_prod_iff` states that a binary function is integrable iff both
  * `y ↦ f (x, y)` is integrable for almost every `x`, and
  * the function `x ↦ ∫ ∥f (x, y)∥ dy` is integrable.
* `measure_theory.integral_prod`: Fubini's theorem. It states that for a integrable function
  `α × β → E` (where `E` is a second countable Banach space) we have
  `∫ z, f z ∂(μ.prod ν) = ∫ x, ∫ y, f (x, y) ∂ν ∂μ`. This theorem has the same variants as
  Tonelli's theorem. The lemma `measure_theory.integrable.integral_prod_right` states that the
  inner integral of the right-hand side is integrable.

## Implementation Notes

Many results are proven twice, once for functions in curried form (`α → β → γ`) and one for
functions in uncurried form (`α × β → γ`). The former often has an assumption
`measurable (uncurry f)`, which could be inconvenient to discharge, but for the latter it is more
common that the function has to be given explicitly, since Lean cannot synthesize the function by
itself. We name the lemmas about the uncurried form with a prime.
Tonelli's theorem and Fubini's theorem have a different naming scheme, since the version for the
uncurried version is reversed.

## Tags

product measure, Fubini's theorem, Tonelli's theorem, Fubini-Tonelli theorem
-/


noncomputable theory

open_locale Classical TopologicalSpace Ennreal MeasureTheory

open Set Function Real Ennreal

open MeasureTheory MeasurableSpace MeasureTheory.Measure

open TopologicalSpace hiding generateFrom

open Filter hiding prod_eq map

variable {α α' β β' γ E : Type _}

/-- Rectangles formed by π-systems form a π-system. -/
theorem IsPiSystem.prod {C : Set (Set α)} {D : Set (Set β)} (hC : IsPiSystem C) (hD : IsPiSystem D) :
  IsPiSystem (image2 Set.Prod C D) :=
  by 
    rintro _ _ ⟨s₁, t₁, hs₁, ht₁, rfl⟩ ⟨s₂, t₂, hs₂, ht₂, rfl⟩ hst 
    rw [prod_inter_prod] at hst⊢
    rw [prod_nonempty_iff] at hst 
    exact mem_image2_of_mem (hC _ _ hs₁ hs₂ hst.1) (hD _ _ ht₁ ht₂ hst.2)

/-- Rectangles of countably spanning sets are countably spanning. -/
theorem IsCountablySpanning.prod {C : Set (Set α)} {D : Set (Set β)} (hC : IsCountablySpanning C)
  (hD : IsCountablySpanning D) : IsCountablySpanning (image2 Set.Prod C D) :=
  by 
    rcases hC, hD with ⟨⟨s, h1s, h2s⟩, t, h1t, h2t⟩
    refine' ⟨fun n => (s n.unpair.1).Prod (t n.unpair.2), fun n => mem_image2_of_mem (h1s _) (h1t _), _⟩
    rw [Union_unpair_prod, h2s, h2t, univ_prod_univ]

variable [MeasurableSpace α] [MeasurableSpace α'] [MeasurableSpace β] [MeasurableSpace β']

variable [MeasurableSpace γ]

variable {μ : Measureₓ α} {ν : Measureₓ β} {τ : Measureₓ γ}

variable [NormedGroup E] [MeasurableSpace E]

/-! ### Measurability

Before we define the product measure, we can talk about the measurability of operations on binary
functions. We show that if `f` is a binary measurable function, then the function that integrates
along one of the variables (using either the Lebesgue or Bochner integral) is measurable.
-/


/-- The product of generated σ-algebras is the one generated by rectangles, if both generating sets
  are countably spanning. -/
theorem generate_from_prod_eq {α β} {C : Set (Set α)} {D : Set (Set β)} (hC : IsCountablySpanning C)
  (hD : IsCountablySpanning D) :
  @Prod.measurableSpace _ _ (generate_from C) (generate_from D) = generate_from (image2 Set.Prod C D) :=
  by 
    apply le_antisymmₓ
    ·
      refine' sup_le _ _ <;> rw [comap_generate_from] <;> apply generate_from_le <;> rintro _ ⟨s, hs, rfl⟩
      ·
        rcases hD with ⟨t, h1t, h2t⟩
        rw [←prod_univ, ←h2t, prod_Union]
        apply MeasurableSet.Union 
        intro n 
        apply measurable_set_generate_from 
        exact ⟨s, t n, hs, h1t n, rfl⟩
      ·
        rcases hC with ⟨t, h1t, h2t⟩
        rw [←univ_prod, ←h2t, Union_prod_const]
        apply MeasurableSet.Union 
        rintro n 
        apply measurable_set_generate_from 
        exact mem_image2_of_mem (h1t n) hs
    ·
      apply generate_from_le 
      rintro _ ⟨s, t, hs, ht, rfl⟩
      rw [prod_eq]
      apply (measurable_fst _).inter (measurable_snd _)
      ·
        exact measurable_set_generate_from hs
      ·
        exact measurable_set_generate_from ht

/-- If `C` and `D` generate the σ-algebras on `α` resp. `β`, then rectangles formed by `C` and `D`
  generate the σ-algebra on `α × β`. -/
theorem generate_from_eq_prod {C : Set (Set α)} {D : Set (Set β)} (hC : generate_from C = ‹_›)
  (hD : generate_from D = ‹_›) (h2C : IsCountablySpanning C) (h2D : IsCountablySpanning D) :
  generate_from (image2 Set.Prod C D) = Prod.measurableSpace :=
  by 
    rw [←hC, ←hD, generate_from_prod_eq h2C h2D]

/-- The product σ-algebra is generated from boxes, i.e. `s.prod t` for sets `s : set α` and
  `t : set β`. -/
theorem generate_from_prod :
  generate_from (image2 Set.Prod { s:Set α | MeasurableSet s } { t:Set β | MeasurableSet t }) = Prod.measurableSpace :=
  generate_from_eq_prod generate_from_measurable_set generate_from_measurable_set is_countably_spanning_measurable_set
    is_countably_spanning_measurable_set

/-- Rectangles form a π-system. -/
theorem is_pi_system_prod : IsPiSystem (image2 Set.Prod { s:Set α | MeasurableSet s } { t:Set β | MeasurableSet t }) :=
  is_pi_system_measurable_set.Prod is_pi_system_measurable_set

-- error in MeasureTheory.Constructions.Prod: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- If `ν` is a finite measure, and `s ⊆ α × β` is measurable, then `x ↦ ν { y | (x, y) ∈ s }` is
  a measurable function. `measurable_measure_prod_mk_left` is strictly more general. -/
theorem measurable_measure_prod_mk_left_finite
[is_finite_measure ν]
{s : set «expr × »(α, β)}
(hs : measurable_set s) : measurable (λ x, ν «expr ⁻¹' »(prod.mk x, s)) :=
begin
  refine [expr induction_on_inter generate_from_prod.symm is_pi_system_prod _ _ _ _ hs],
  { simp [] [] [] ["[", expr measurable_zero, ",", expr const_def, "]"] [] [] },
  { rintro ["_", "⟨", ident s, ",", ident t, ",", ident hs, ",", ident ht, ",", ident rfl, "⟩"],
    simp [] [] ["only"] ["[", expr mk_preimage_prod_right_eq_if, ",", expr measure_if, "]"] [] [],
    exact [expr measurable_const.indicator hs] },
  { intros [ident t, ident ht, ident h2t],
    simp_rw ["[", expr preimage_compl, ",", expr measure_compl (measurable_prod_mk_left ht) (measure_ne_top ν _), "]"] [],
    exact [expr h2t.const_sub _] },
  { intros [ident f, ident h1f, ident h2f, ident h3f],
    simp_rw ["[", expr preimage_Union, "]"] [],
    have [] [":", expr ∀
     b, «expr = »(ν «expr⋃ , »((i), «expr ⁻¹' »(prod.mk b, f i)), «expr∑' , »((i), ν «expr ⁻¹' »(prod.mk b, f i)))] [":=", expr λ
     b, measure_Union (λ i j hij, disjoint.preimage _ (h1f i j hij)) (λ i, measurable_prod_mk_left (h2f i))],
    simp_rw ["[", expr this, "]"] [],
    apply [expr measurable.ennreal_tsum h3f] }
end

-- error in MeasureTheory.Constructions.Prod: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- If `ν` is a σ-finite measure, and `s ⊆ α × β` is measurable, then `x ↦ ν { y | (x, y) ∈ s }` is
  a measurable function. -/
theorem measurable_measure_prod_mk_left
[sigma_finite ν]
{s : set «expr × »(α, β)}
(hs : measurable_set s) : measurable (λ x, ν «expr ⁻¹' »(prod.mk x, s)) :=
begin
  have [] [":", expr ∀ x, measurable_set «expr ⁻¹' »(prod.mk x, s)] [":=", expr λ x, measurable_prod_mk_left hs],
  simp [] [] ["only"] ["[", "<-", expr @supr_restrict_spanning_sets _ _ ν, ",", expr this, "]"] [] [],
  apply [expr measurable_supr],
  intro [ident i],
  haveI [] [] [":=", expr fact.mk (measure_spanning_sets_lt_top ν i)],
  exact [expr measurable_measure_prod_mk_left_finite hs]
end

/-- If `μ` is a σ-finite measure, and `s ⊆ α × β` is measurable, then `y ↦ μ { x | (x, y) ∈ s }` is
  a measurable function. -/
theorem measurable_measure_prod_mk_right {μ : Measureₓ α} [sigma_finite μ] {s : Set (α × β)} (hs : MeasurableSet s) :
  Measurable fun y => μ ((fun x => (x, y)) ⁻¹' s) :=
  measurable_measure_prod_mk_left (measurable_set_swap_iff.mpr hs)

theorem Measurable.map_prod_mk_left [sigma_finite ν] : Measurable fun x : α => map (Prod.mk x) ν :=
  by 
    apply measurable_of_measurable_coe 
    intro s hs 
    simpRw [map_apply measurable_prod_mk_left hs]
    exact measurable_measure_prod_mk_left hs

theorem Measurable.map_prod_mk_right {μ : Measureₓ α} [sigma_finite μ] :
  Measurable fun y : β => map (fun x : α => (x, y)) μ :=
  by 
    apply measurable_of_measurable_coe 
    intro s hs 
    simpRw [map_apply measurable_prod_mk_right hs]
    exact measurable_measure_prod_mk_right hs

-- error in MeasureTheory.Constructions.Prod: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  Tonelli's theorem is measurable. -/
theorem measurable.lintegral_prod_right'
[sigma_finite ν] : ∀
{f : «expr × »(α, β) → «exprℝ≥0∞»()}
(hf : measurable f), measurable (λ x, «expr∫⁻ , ∂ »((y), f (x, y), ν)) :=
begin
  have [ident m] [] [":=", expr @measurable_prod_mk_left],
  refine [expr measurable.ennreal_induction _ _ _],
  { intros [ident c, ident s, ident hs],
    simp [] [] ["only"] ["[", "<-", expr indicator_comp_right, "]"] [] [],
    suffices [] [":", expr measurable (λ x, «expr * »(c, ν «expr ⁻¹' »(prod.mk x, s)))],
    { simpa [] [] [] ["[", expr lintegral_indicator _ (m hs), "]"] [] [] },
    exact [expr (measurable_measure_prod_mk_left hs).const_mul _] },
  { rintro [ident f, ident g, "-", ident hf, ident hg, ident h2f, ident h2g],
    simp_rw ["[", expr pi.add_apply, ",", expr lintegral_add (hf.comp m) (hg.comp m), "]"] [],
    exact [expr h2f.add h2g] },
  { intros [ident f, ident hf, ident h2f, ident h3f],
    have [] [] [":=", expr measurable_supr h3f],
    have [] [":", expr ∀ x, monotone (λ n y, f n (x, y))] [":=", expr λ x i j hij y, h2f hij (x, y)],
    simpa [] [] [] ["[", expr lintegral_supr (λ n, (hf n).comp m), ",", expr this, "]"] [] [] }
end

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  Tonelli's theorem is measurable.
  This version has the argument `f` in curried form. -/
theorem Measurable.lintegral_prod_right [sigma_finite ν] {f : α → β → ℝ≥0∞} (hf : Measurable (uncurry f)) :
  Measurable fun x => ∫⁻y, f x y ∂ν :=
  hf.lintegral_prod_right'

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Tonelli's theorem is measurable. -/
theorem Measurable.lintegral_prod_left' [sigma_finite μ] {f : α × β → ℝ≥0∞} (hf : Measurable f) :
  Measurable fun y => ∫⁻x, f (x, y) ∂μ :=
  (measurable_swap_iff.mpr hf).lintegral_prod_right'

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Tonelli's theorem is measurable.
  This version has the argument `f` in curried form. -/
theorem Measurable.lintegral_prod_left [sigma_finite μ] {f : α → β → ℝ≥0∞} (hf : Measurable (uncurry f)) :
  Measurable fun y => ∫⁻x, f x y ∂μ :=
  hf.lintegral_prod_left'

theorem measurable_set_integrable [sigma_finite ν] [OpensMeasurableSpace E] ⦃f : α → β → E⦄
  (hf : Measurable (uncurry f)) : MeasurableSet { x | integrable (f x) ν } :=
  by 
    simpRw [integrable, hf.of_uncurry_left.ae_measurable, true_andₓ]
    exact measurable_set_lt (Measurable.lintegral_prod_right hf.ennnorm) measurable_const

section 

variable [second_countable_topology E] [NormedSpace ℝ E] [CompleteSpace E] [BorelSpace E]

-- error in MeasureTheory.Constructions.Prod: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  Fubini's theorem is measurable.
  This version has `f` in curried form. -/
theorem measurable.integral_prod_right
[sigma_finite ν]
{{f : α → β → E}}
(hf : measurable (uncurry f)) : measurable (λ x, «expr∫ , ∂ »((y), f x y, ν)) :=
begin
  let [ident s] [":", expr exprℕ() → simple_func «expr × »(α, β) E] [":=", expr simple_func.approx_on _ hf univ _ (mem_univ 0)],
  let [ident s'] [":", expr exprℕ() → α → simple_func β E] [":=", expr λ
   n x, (s n).comp (prod.mk x) measurable_prod_mk_left],
  let [ident f'] [":", expr exprℕ() → α → E] [":=", expr λ
   n, {x | integrable (f x) ν}.indicator (λ x, (s' n x).integral ν)],
  have [ident hf'] [":", expr ∀ n, measurable (f' n)] [],
  { intro [ident n],
    refine [expr measurable.indicator _ (measurable_set_integrable hf)],
    have [] [":", expr ∀ x, «expr ⊆ »((s' n x).range.filter (λ x, «expr ≠ »(x, 0)), (s n).range)] [],
    { intros [ident x],
      refine [expr finset.subset.trans (finset.filter_subset _ _) _],
      intro [ident y],
      simp_rw ["[", expr simple_func.mem_range, "]"] [],
      rintro ["⟨", ident z, ",", ident rfl, "⟩"],
      exact [expr ⟨(x, z), rfl⟩] },
    simp [] [] ["only"] ["[", expr simple_func.integral_eq_sum_of_subset (this _), "]"] [] [],
    refine [expr finset.measurable_sum _ (λ x _, _)],
    refine [expr (measurable.ennreal_to_real _).smul_const _],
    simp [] [] ["only"] ["[", expr simple_func.coe_comp, ",", expr preimage_comp, "]"] [] [] { single_pass := tt },
    apply [expr measurable_measure_prod_mk_left],
    exact [expr (s n).measurable_set_fiber x] },
  have [ident h2f'] [":", expr tendsto f' at_top (expr𝓝() (λ x : α, «expr∫ , ∂ »((y : β), f x y, ν)))] [],
  { rw ["[", expr tendsto_pi_nhds, "]"] [],
    intro [ident x],
    by_cases [expr hfx, ":", expr integrable (f x) ν],
    { have [] [":", expr ∀ n, integrable (s' n x) ν] [],
      { intro [ident n],
        apply [expr (hfx.norm.add hfx.norm).mono' (s' n x).measurable.ae_measurable],
        apply [expr eventually_of_forall],
        intro [ident y],
        simp_rw ["[", expr s', ",", expr simple_func.coe_comp, "]"] [],
        exact [expr simple_func.norm_approx_on_zero_le _ _ (x, y) n] },
      simp [] [] ["only"] ["[", expr f', ",", expr hfx, ",", expr simple_func.integral_eq_integral _ (this _), ",", expr indicator_of_mem, ",", expr mem_set_of_eq, "]"] [] [],
      refine [expr tendsto_integral_of_dominated_convergence (λ
        y, «expr + »(«expr∥ ∥»(f x y), «expr∥ ∥»(f x y))) (λ n, (s' n x).ae_measurable) (hfx.norm.add hfx.norm) _ _],
      { exact [expr λ n, eventually_of_forall (λ y, simple_func.norm_approx_on_zero_le _ _ (x, y) n)] },
      { exact [expr eventually_of_forall (λ y, simple_func.tendsto_approx_on _ _ (by simp [] [] [] [] [] []))] } },
    { simpa [] [] [] ["[", expr f', ",", expr hfx, ",", expr integral_undef, "]"] [] ["using", expr @tendsto_const_nhds _ _ _ (0 : E) _] } },
  exact [expr measurable_of_tendsto_metric hf' h2f']
end

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  Fubini's theorem is measurable. -/
theorem Measurable.integral_prod_right' [sigma_finite ν] ⦃f : α × β → E⦄ (hf : Measurable f) :
  Measurable fun x => ∫y, f (x, y) ∂ν :=
  by 
    rw [←uncurry_curry f] at hf 
    exact hf.integral_prod_right

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Fubini's theorem is measurable.
  This version has `f` in curried form. -/
theorem Measurable.integral_prod_left [sigma_finite μ] ⦃f : α → β → E⦄ (hf : Measurable (uncurry f)) :
  Measurable fun y => ∫x, f x y ∂μ :=
  (hf.comp measurable_swap).integral_prod_right'

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Fubini's theorem is measurable. -/
theorem Measurable.integral_prod_left' [sigma_finite μ] ⦃f : α × β → E⦄ (hf : Measurable f) :
  Measurable fun y => ∫x, f (x, y) ∂μ :=
  (hf.comp measurable_swap).integral_prod_right'

end 

/-! ### The product measure -/


namespace MeasureTheory

namespace Measureₓ

/-- The binary product of measures. They are defined for arbitrary measures, but we basically
  prove all properties under the assumption that at least one of them is σ-finite. -/
protected irreducible_def Prod (μ : Measureₓ α) (ν : Measureₓ β) : Measureₓ (α × β) :=
  bind μ$ fun x : α => map (Prod.mk x) ν

instance prod.measure_space {α β} [measure_space α] [measure_space β] : measure_space (α × β) :=
  { volume := volume.Prod volume }

variable {μ ν} [sigma_finite ν]

theorem volume_eq_prod α β [measure_space α] [measure_space β] :
  (volume : Measureₓ (α × β)) = (volume : Measureₓ α).Prod (volume : Measureₓ β) :=
  rfl

theorem prod_apply {s : Set (α × β)} (hs : MeasurableSet s) : μ.prod ν s = ∫⁻x, ν (Prod.mk x ⁻¹' s) ∂μ :=
  by 
    simpRw [measure.prod, bind_apply hs Measurable.map_prod_mk_left, map_apply measurable_prod_mk_left hs]

-- error in MeasureTheory.Constructions.Prod: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The product measure of the product of two sets is the product of their measures. Note that we
do not need the sets to be measurable. -/
@[simp]
theorem prod_prod (s : set α) (t : set β) : «expr = »(μ.prod ν (s.prod t), «expr * »(μ s, ν t)) :=
begin
  apply [expr le_antisymm],
  { set [] [ident ST] [] [":="] [expr (to_measurable μ s).prod (to_measurable ν t)] [],
    have [ident hSTm] [":", expr measurable_set ST] [":=", expr (measurable_set_to_measurable _ _).prod (measurable_set_to_measurable _ _)],
    calc
      «expr ≤ »(μ.prod ν (s.prod t), μ.prod ν ST) : «expr $ »(measure_mono, set.prod_mono (subset_to_measurable _ _) (subset_to_measurable _ _))
      «expr = »(..., «expr * »(μ (to_measurable μ s), ν (to_measurable ν t))) : by simp_rw ["[", expr prod_apply hSTm, ",", expr mk_preimage_prod_right_eq_if, ",", expr measure_if, ",", expr lintegral_indicator _ (measurable_set_to_measurable _ _), ",", expr lintegral_const, ",", expr restrict_apply_univ, ",", expr mul_comm, "]"] []
      «expr = »(..., «expr * »(μ s, ν t)) : by rw ["[", expr measure_to_measurable, ",", expr measure_to_measurable, "]"] [] },
  { set [] [ident ST] [] [":="] [expr to_measurable (μ.prod ν) (s.prod t)] [],
    have [ident hSTm] [":", expr measurable_set ST] [":=", expr measurable_set_to_measurable _ _],
    have [ident hST] [":", expr «expr ⊆ »(s.prod t, ST)] [":=", expr subset_to_measurable _ _],
    set [] [ident f] [":", expr α → «exprℝ≥0∞»()] [":="] [expr λ x, ν «expr ⁻¹' »(prod.mk x, ST)] [],
    have [ident hfm] [":", expr measurable f] [":=", expr measurable_measure_prod_mk_left hSTm],
    set [] [ident s'] [":", expr set α] [":="] [expr {x | «expr ≤ »(ν t, f x)}] [],
    have [ident hss'] [":", expr «expr ⊆ »(s, s')] [":=", expr λ
     x hx, measure_mono (λ y hy, «expr $ »(hST, mk_mem_prod hx hy))],
    calc
      «expr ≤ »(«expr * »(μ s, ν t), «expr * »(μ s', ν t)) : mul_le_mul_right' (measure_mono hss') _
      «expr = »(..., «expr∫⁻ in , ∂ »((x), s', ν t, μ)) : by rw ["[", expr set_lintegral_const, ",", expr mul_comm, "]"] []
      «expr ≤ »(..., «expr∫⁻ in , ∂ »((x), s', f x, μ)) : set_lintegral_mono measurable_const hfm (λ x, id)
      «expr ≤ »(..., «expr∫⁻ , ∂ »((x), f x, μ)) : lintegral_mono' restrict_le_self le_rfl
      «expr = »(..., μ.prod ν ST) : (prod_apply hSTm).symm
      «expr = »(..., μ.prod ν (s.prod t)) : measure_to_measurable _ }
end

theorem ae_measure_lt_top {s : Set (α × β)} (hs : MeasurableSet s) (h2s : (μ.prod ν) s ≠ ∞) :
  ∀ᵐx ∂μ, ν (Prod.mk x ⁻¹' s) < ∞ :=
  by 
    simpRw [prod_apply hs]  at h2s 
    refine' ae_lt_top (measurable_measure_prod_mk_left hs) h2s

theorem integrable_measure_prod_mk_left {s : Set (α × β)} (hs : MeasurableSet s) (h2s : (μ.prod ν) s ≠ ∞) :
  integrable (fun x => (ν (Prod.mk x ⁻¹' s)).toReal) μ :=
  by 
    refine' ⟨(measurable_measure_prod_mk_left hs).ennreal_to_real.AeMeasurable, _⟩
    simpRw [has_finite_integral, ennnorm_eq_of_real to_real_nonneg]
    convert h2s.lt_top using 1
    simpRw [prod_apply hs]
    apply lintegral_congr_ae 
    refine' (ae_measure_lt_top hs h2s).mp _ 
    apply eventually_of_forall 
    intro x hx 
    rw [lt_top_iff_ne_top] at hx 
    simp [of_real_to_real, hx]

/-- Note: the assumption `hs` cannot be dropped. For a counterexample, see
  Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
theorem measure_prod_null {s : Set (α × β)} (hs : MeasurableSet s) :
  μ.prod ν s = 0 ↔ (fun x => ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 :=
  by 
    simpRw [prod_apply hs, lintegral_eq_zero_iff (measurable_measure_prod_mk_left hs)]

/-- Note: the converse is not true without assuming that `s` is measurable. For a counterexample,
  see Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
theorem measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) : (fun x => ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 :=
  by 
    obtain ⟨t, hst, mt, ht⟩ := exists_measurable_superset_of_null h 
    simpRw [measure_prod_null mt]  at ht 
    rw [eventually_le_antisymm_iff]
    exact
      ⟨eventually_le.trans_eq (eventually_of_forall$ fun x => (measure_mono (preimage_mono hst) : _)) ht,
        eventually_of_forall$ fun x => zero_le _⟩

/-- Note: the converse is not true. For a counterexample, see
  Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
theorem ae_ae_of_ae_prod {p : α × β → Prop} (h : ∀ᵐz ∂μ.prod ν, p z) : ∀ᵐx ∂μ, ∀ᵐy ∂ν, p (x, y) :=
  measure_ae_null_of_prod_null h

-- error in MeasureTheory.Constructions.Prod: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- `μ.prod ν` has finite spanning sets in rectangles of finite spanning sets. -/
def finite_spanning_sets_in.prod
{ν : measure β}
{C : set (set α)}
{D : set (set β)}
(hμ : μ.finite_spanning_sets_in C)
(hν : ν.finite_spanning_sets_in D) : (μ.prod ν).finite_spanning_sets_in (image2 set.prod C D) :=
begin
  haveI [] [] [":=", expr hν.sigma_finite],
  refine [expr ⟨λ
    n, (hμ.set n.unpair.1).prod (hν.set n.unpair.2), λ n, mem_image2_of_mem (hμ.set_mem _) (hν.set_mem _), λ n, _, _⟩],
  { rw ["[", expr prod_prod, "]"] [],
    exact [expr mul_lt_top (hμ.finite _).ne (hν.finite _).ne] },
  { simp_rw ["[", expr Union_unpair_prod, ",", expr hμ.spanning, ",", expr hν.spanning, ",", expr univ_prod_univ, "]"] [] }
end

theorem prod_fst_absolutely_continuous : map Prod.fst (μ.prod ν) ≪ μ :=
  by 
    refine' absolutely_continuous.mk fun s hs h2s => _ 
    rw [map_apply measurable_fst hs, ←prod_univ, prod_prod, h2s, zero_mul]

theorem prod_snd_absolutely_continuous : map Prod.snd (μ.prod ν) ≪ ν :=
  by 
    refine' absolutely_continuous.mk fun s hs h2s => _ 
    rw [map_apply measurable_snd hs, ←univ_prod, prod_prod, h2s, mul_zero]

variable [sigma_finite μ]

instance prod.sigma_finite : sigma_finite (μ.prod ν) :=
  (μ.to_finite_spanning_sets_in.prod ν.to_finite_spanning_sets_in).SigmaFinite

-- error in MeasureTheory.Constructions.Prod: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- A measure on a product space equals the product measure if they are equal on rectangles
  with as sides sets that generate the corresponding σ-algebras. -/
theorem prod_eq_generate_from
{μ : measure α}
{ν : measure β}
{C : set (set α)}
{D : set (set β)}
(hC : «expr = »(generate_from C, «expr‹ ›»(_)))
(hD : «expr = »(generate_from D, «expr‹ ›»(_)))
(h2C : is_pi_system C)
(h2D : is_pi_system D)
(h3C : μ.finite_spanning_sets_in C)
(h3D : ν.finite_spanning_sets_in D)
{μν : measure «expr × »(α, β)}
(h₁ : ∀ (s «expr ∈ » C) (t «expr ∈ » D), «expr = »(μν (set.prod s t), «expr * »(μ s, ν t))) : «expr = »(μ.prod ν, μν) :=
begin
  refine [expr (h3C.prod h3D).ext (generate_from_eq_prod hC hD h3C.is_countably_spanning h3D.is_countably_spanning).symm (h2C.prod h2D) _],
  { rintro ["_", "⟨", ident s, ",", ident t, ",", ident hs, ",", ident ht, ",", ident rfl, "⟩"],
    haveI [] [] [":=", expr h3D.sigma_finite],
    rw ["[", expr h₁ s hs t ht, ",", expr prod_prod, "]"] [] }
end

/-- A measure on a product space equals the product measure if they are equal on rectangles. -/
theorem prod_eq {μν : Measureₓ (α × β)} (h : ∀ s t, MeasurableSet s → MeasurableSet t → μν (s.prod t) = μ s*ν t) :
  μ.prod ν = μν :=
  prod_eq_generate_from generate_from_measurable_set generate_from_measurable_set is_pi_system_measurable_set
    is_pi_system_measurable_set μ.to_finite_spanning_sets_in ν.to_finite_spanning_sets_in fun s hs t ht => h s t hs ht

theorem prod_swap : map Prod.swap (μ.prod ν) = ν.prod μ :=
  by 
    refine' (prod_eq _).symm 
    intro s t hs ht 
    simpRw [map_apply measurable_swap (hs.prod ht), preimage_swap_prod, prod_prod, mul_commₓ]

theorem prod_apply_symm {s : Set (α × β)} (hs : MeasurableSet s) : μ.prod ν s = ∫⁻y, μ ((fun x => (x, y)) ⁻¹' s) ∂ν :=
  by 
    rw [←prod_swap, map_apply measurable_swap hs]
    simp only [prod_apply (measurable_swap hs)]
    rfl

theorem prod_assoc_prod [sigma_finite τ] : map MeasurableEquiv.prodAssoc ((μ.prod ν).Prod τ) = μ.prod (ν.prod τ) :=
  by 
    refine'
      (prod_eq_generate_from generate_from_measurable_set generate_from_prod is_pi_system_measurable_set
          is_pi_system_prod μ.to_finite_spanning_sets_in
          (ν.to_finite_spanning_sets_in.prod τ.to_finite_spanning_sets_in) _).symm
        
    rintro s hs _ ⟨t, u, ht, hu, rfl⟩
    rw [mem_set_of_eq] at hs ht hu 
    simpRw [map_apply (MeasurableEquiv.measurable _) (hs.prod (ht.prod hu)), MeasurableEquiv.prodAssoc,
      MeasurableEquiv.coe_mk, Equiv.prod_assoc_preimage, prod_prod, mul_assocₓ]

/-! ### The product of specific measures -/


theorem prod_restrict (s : Set α) (t : Set β) : (μ.restrict s).Prod (ν.restrict t) = (μ.prod ν).restrict (s.prod t) :=
  by 
    refine' prod_eq fun s' t' hs' ht' => _ 
    rw [restrict_apply (hs'.prod ht'), prod_inter_prod, prod_prod, restrict_apply hs', restrict_apply ht']

-- error in MeasureTheory.Constructions.Prod: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem restrict_prod_eq_prod_univ (s : set α) : «expr = »((μ.restrict s).prod ν, (μ.prod ν).restrict (s.prod univ)) :=
begin
  have [] [":", expr «expr = »(ν, ν.restrict set.univ)] [":=", expr measure.restrict_univ.symm],
  rwa ["[", expr this, ",", expr measure.prod_restrict, ",", "<-", expr this, "]"] []
end

theorem prod_dirac (y : β) : μ.prod (dirac y) = map (fun x => (x, y)) μ :=
  by 
    refine' prod_eq fun s t hs ht => _ 
    simpRw [map_apply measurable_prod_mk_right (hs.prod ht), mk_preimage_prod_left_eq_if, measure_if, dirac_apply' _ ht,
      ←indicator_mul_right _ fun x => μ s, Pi.one_apply, mul_oneₓ]

theorem dirac_prod (x : α) : (dirac x).Prod ν = map (Prod.mk x) ν :=
  by 
    refine' prod_eq fun s t hs ht => _ 
    simpRw [map_apply measurable_prod_mk_left (hs.prod ht), mk_preimage_prod_right_eq_if, measure_if, dirac_apply' _ hs,
      ←indicator_mul_left _ _ fun x => ν t, Pi.one_apply, one_mulₓ]

theorem dirac_prod_dirac {x : α} {y : β} : (dirac x).Prod (dirac y) = dirac (x, y) :=
  by 
    rw [prod_dirac, map_dirac measurable_prod_mk_right]

theorem prod_sum {ι : Type _} [Fintype ι] (ν : ι → Measureₓ β) [∀ i, sigma_finite (ν i)] :
  μ.prod (Sum ν) = Sum fun i => μ.prod (ν i) :=
  by 
    refine' prod_eq fun s t hs ht => _ 
    simpRw [sum_apply _ (hs.prod ht), sum_apply _ ht, prod_prod, Ennreal.tsum_mul_left]

theorem sum_prod {ι : Type _} [Fintype ι] (μ : ι → Measureₓ α) [∀ i, sigma_finite (μ i)] :
  (Sum μ).Prod ν = Sum fun i => (μ i).Prod ν :=
  by 
    refine' prod_eq fun s t hs ht => _ 
    simpRw [sum_apply _ (hs.prod ht), sum_apply _ hs, prod_prod, Ennreal.tsum_mul_right]

theorem prod_add (ν' : Measureₓ β) [sigma_finite ν'] : μ.prod (ν+ν') = μ.prod ν+μ.prod ν' :=
  by 
    refine' prod_eq fun s t hs ht => _ 
    simpRw [add_apply, prod_prod, left_distrib]

theorem add_prod (μ' : Measureₓ α) [sigma_finite μ'] : (μ+μ').Prod ν = μ.prod ν+μ'.prod ν :=
  by 
    refine' prod_eq fun s t hs ht => _ 
    simpRw [add_apply, prod_prod, right_distrib]

@[simp]
theorem zero_prod (ν : Measureₓ β) : (0 : Measureₓ α).Prod ν = 0 :=
  by 
    rw [measure.prod]
    exact bind_zero_left _

@[simp]
theorem prod_zero (μ : Measureₓ α) : μ.prod (0 : Measureₓ β) = 0 :=
  by 
    simp [measure.prod]

-- error in MeasureTheory.Constructions.Prod: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem map_prod_map
{δ}
[measurable_space δ]
{f : α → β}
{g : γ → δ}
{μa : measure α}
{μc : measure γ}
(hfa : sigma_finite (map f μa))
(hgc : sigma_finite (map g μc))
(hf : measurable f)
(hg : measurable g) : «expr = »((map f μa).prod (map g μc), map (prod.map f g) (μa.prod μc)) :=
begin
  haveI [] [] [":=", expr hgc.of_map μc hg],
  refine [expr prod_eq (λ s t hs ht, _)],
  rw ["[", expr map_apply (hf.prod_map hg) (hs.prod ht), ",", expr map_apply hf hs, ",", expr map_apply hg ht, "]"] [],
  exact [expr prod_prod «expr ⁻¹' »(f, s) «expr ⁻¹' »(g, t)]
end

end Measureₓ

namespace MeasurePreserving

open Measureₓ

variable {δ : Type _} [MeasurableSpace δ] {μa : Measureₓ α} {μb : Measureₓ β} {μc : Measureₓ γ} {μd : Measureₓ δ}

-- error in MeasureTheory.Constructions.Prod: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem skew_product
[sigma_finite μb]
[sigma_finite μd]
{f : α → β}
(hf : measure_preserving f μa μb)
{g : α → γ → δ}
(hgm : measurable (uncurry g))
(hg : «expr∀ᵐ ∂ , »((x), μa, «expr = »(map (g x) μc, μd))) : measure_preserving (λ
 p : «expr × »(α, γ), (f p.1, g p.1 p.2)) (μa.prod μc) (μb.prod μd) :=
begin
  classical,
  have [] [":", expr measurable (λ
    p : «expr × »(α, γ), (f p.1, g p.1 p.2))] [":=", expr (hf.1.comp measurable_fst).prod_mk hgm],
  rcases [expr eq_or_ne μa 0, "with", "(", ident rfl, "|", ident ha, ")"],
  { rw ["[", "<-", expr hf.map_eq, ",", expr zero_prod, ",", expr (map f).map_zero, ",", expr zero_prod, "]"] [],
    exact [expr ⟨this, (map _).map_zero⟩] },
  haveI [] [":", expr sigma_finite μc] [],
  { rcases [expr (ae_ne_bot.2 ha).nonempty_of_mem hg, "with", "⟨", ident x, ",", ident hx, ":", expr «expr = »(map (g x) μc, μd), "⟩"],
    exact [expr sigma_finite.of_map _ hgm.of_uncurry_left (by rwa [expr hx] [])] },
  refine [expr ⟨this, «expr $ »(prod_eq, λ s t hs ht, _).symm⟩],
  rw ["[", expr map_apply this (hs.prod ht), "]"] [],
  refine [expr (prod_apply «expr $ »(this, hs.prod ht)).trans _],
  have [] [":", expr «expr∀ᵐ ∂ , »((x), μa, «expr = »(μc «expr ⁻¹' »(λ
      y, (f x, g x y), s.prod t), indicator «expr ⁻¹' »(f, s) (λ y, μd t) x))] [],
  { refine [expr hg.mono (λ x hx, _)],
    unfreezingI { subst [expr hx] },
    simp [] [] ["only"] ["[", expr mk_preimage_prod_right_fn_eq_if, ",", expr indicator_apply, ",", expr mem_preimage, "]"] [] [],
    split_ifs [] [],
    exacts ["[", expr (map_apply hgm.of_uncurry_left ht).symm, ",", expr measure_empty, "]"] },
  simp [] [] ["only"] ["[", expr preimage_preimage, "]"] [] [],
  rw ["[", expr lintegral_congr_ae this, ",", expr lintegral_indicator _ (hf.1 hs), ",", expr set_lintegral_const, ",", expr hf.measure_preimage hs, ",", expr mul_comm, "]"] []
end

/-- If `f : α → β` sends the measure `μa` to `μb` and `g : γ → δ` sends the measure `μc` to `μd`,
then `prod.map f g` sends `μa.prod μc` to `μb.prod μd`. -/
protected theorem Prod [sigma_finite μb] [sigma_finite μd] {f : α → β} {g : γ → δ} (hf : measure_preserving f μa μb)
  (hg : measure_preserving g μc μd) : measure_preserving (Prod.map f g) (μa.prod μc) (μb.prod μd) :=
  have  : Measurable (uncurry$ fun _ : α => g) := hg.1.comp measurable_snd 
  hf.skew_product this$ Filter.eventually_of_forall$ fun _ => hg.map_eq

end MeasurePreserving

end MeasureTheory

open MeasureTheory.Measure

section 

theorem AeMeasurable.prod_swap [sigma_finite μ] [sigma_finite ν] {f : β × α → γ} (hf : AeMeasurable f (ν.prod μ)) :
  AeMeasurable (fun z : α × β => f z.swap) (μ.prod ν) :=
  by 
    rw [←prod_swap] at hf 
    exact hf.comp_measurable measurable_swap

theorem AeMeasurable.fst [sigma_finite ν] {f : α → γ} (hf : AeMeasurable f μ) :
  AeMeasurable (fun z : α × β => f z.1) (μ.prod ν) :=
  hf.comp_measurable' measurable_fst prod_fst_absolutely_continuous

theorem AeMeasurable.snd [sigma_finite ν] {f : β → γ} (hf : AeMeasurable f ν) :
  AeMeasurable (fun z : α × β => f z.2) (μ.prod ν) :=
  hf.comp_measurable' measurable_snd prod_snd_absolutely_continuous

/-- The Bochner integral is a.e.-measurable.
  This shows that the integrand of (the right-hand-side of) Fubini's theorem is a.e.-measurable. -/
theorem AeMeasurable.integral_prod_right' [sigma_finite ν] [second_countable_topology E] [NormedSpace ℝ E]
  [BorelSpace E] [CompleteSpace E] ⦃f : α × β → E⦄ (hf : AeMeasurable f (μ.prod ν)) :
  AeMeasurable (fun x => ∫y, f (x, y) ∂ν) μ :=
  ⟨fun x => ∫y, hf.mk f (x, y) ∂ν, hf.measurable_mk.integral_prod_right',
    by 
      filterUpwards [ae_ae_of_ae_prod hf.ae_eq_mk]
      intro x hx 
      exact integral_congr_ae hx⟩

theorem AeMeasurable.prod_mk_left [sigma_finite ν] {f : α × β → γ} (hf : AeMeasurable f (μ.prod ν)) :
  ∀ᵐx ∂μ, AeMeasurable (fun y => f (x, y)) ν :=
  by 
    filterUpwards [ae_ae_of_ae_prod hf.ae_eq_mk]
    intro x hx 
    exact ⟨fun y => hf.mk f (x, y), hf.measurable_mk.comp measurable_prod_mk_left, hx⟩

end 

namespace MeasureTheory

/-! ### The Lebesgue integral on a product -/


variable [sigma_finite ν]

theorem lintegral_prod_swap [sigma_finite μ] (f : α × β → ℝ≥0∞) (hf : AeMeasurable f (μ.prod ν)) :
  (∫⁻z, f z.swap ∂ν.prod μ) = ∫⁻z, f z ∂μ.prod ν :=
  by 
    rw [←prod_swap] at hf 
    rw [←lintegral_map' hf measurable_swap, prod_swap]

-- error in MeasureTheory.Constructions.Prod: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- **Tonelli's Theorem**: For `ℝ≥0∞`-valued measurable functions on `α × β`,
  the integral of `f` is equal to the iterated integral. -/
theorem lintegral_prod_of_measurable : ∀
(f : «expr × »(α, β) → «exprℝ≥0∞»())
(hf : measurable f), «expr = »(«expr∫⁻ , ∂ »((z), f z, μ.prod ν), «expr∫⁻ , ∂ »((x), «expr∫⁻ , ∂ »((y), f (x, y), ν), μ)) :=
begin
  have [ident m] [] [":=", expr @measurable_prod_mk_left],
  refine [expr measurable.ennreal_induction _ _ _],
  { intros [ident c, ident s, ident hs],
    simp [] [] ["only"] ["[", "<-", expr indicator_comp_right, "]"] [] [],
    simp [] [] [] ["[", expr lintegral_indicator, ",", expr m hs, ",", expr hs, ",", expr lintegral_const_mul, ",", expr measurable_measure_prod_mk_left hs, ",", expr prod_apply, "]"] [] [] },
  { rintro [ident f, ident g, "-", ident hf, ident hg, ident h2f, ident h2g],
    simp [] [] [] ["[", expr lintegral_add, ",", expr measurable.lintegral_prod_right', ",", expr hf.comp m, ",", expr hg.comp m, ",", expr hf, ",", expr hg, ",", expr h2f, ",", expr h2g, "]"] [] [] },
  { intros [ident f, ident hf, ident h2f, ident h3f],
    have [ident kf] [":", expr ∀ x n, measurable (λ y, f n (x, y))] [":=", expr λ x n, (hf n).comp m],
    have [ident k2f] [":", expr ∀ x, monotone (λ n y, f n (x, y))] [":=", expr λ x i j hij y, h2f hij (x, y)],
    have [ident lf] [":", expr ∀
     n, measurable (λ x, «expr∫⁻ , ∂ »((y), f n (x, y), ν))] [":=", expr λ n, (hf n).lintegral_prod_right'],
    have [ident l2f] [":", expr monotone (λ
      n x, «expr∫⁻ , ∂ »((y), f n (x, y), ν))] [":=", expr λ i j hij x, lintegral_mono (k2f x hij)],
    simp [] [] ["only"] ["[", expr lintegral_supr hf h2f, ",", expr lintegral_supr (kf _), ",", expr k2f, ",", expr lintegral_supr lf l2f, ",", expr h3f, "]"] [] [] }
end

-- error in MeasureTheory.Constructions.Prod: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- **Tonelli's Theorem**: For `ℝ≥0∞`-valued almost everywhere measurable functions on `α × β`,
  the integral of `f` is equal to the iterated integral. -/
theorem lintegral_prod
(f : «expr × »(α, β) → «exprℝ≥0∞»())
(hf : ae_measurable f (μ.prod ν)) : «expr = »(«expr∫⁻ , ∂ »((z), f z, μ.prod ν), «expr∫⁻ , ∂ »((x), «expr∫⁻ , ∂ »((y), f (x, y), ν), μ)) :=
begin
  have [ident A] [":", expr «expr = »(«expr∫⁻ , ∂ »((z), f z, μ.prod ν), «expr∫⁻ , ∂ »((z), hf.mk f z, μ.prod ν))] [":=", expr lintegral_congr_ae hf.ae_eq_mk],
  have [ident B] [":", expr «expr = »(«expr∫⁻ , ∂ »((x), «expr∫⁻ , ∂ »((y), f (x, y), ν), μ), «expr∫⁻ , ∂ »((x), «expr∫⁻ , ∂ »((y), hf.mk f (x, y), ν), μ))] [],
  { apply [expr lintegral_congr_ae],
    filter_upwards ["[", expr ae_ae_of_ae_prod hf.ae_eq_mk, "]"] [],
    assume [binders (a ha)],
    exact [expr lintegral_congr_ae ha] },
  rw ["[", expr A, ",", expr B, ",", expr lintegral_prod_of_measurable _ hf.measurable_mk, "]"] [],
  apply_instance
end

/-- The symmetric verion of Tonelli's Theorem: For `ℝ≥0∞`-valued almost everywhere measurable
functions on `α × β`,  the integral of `f` is equal to the iterated integral, in reverse order. -/
theorem lintegral_prod_symm [sigma_finite μ] (f : α × β → ℝ≥0∞) (hf : AeMeasurable f (μ.prod ν)) :
  (∫⁻z, f z ∂μ.prod ν) = ∫⁻y, ∫⁻x, f (x, y) ∂μ ∂ν :=
  by 
    simpRw [←lintegral_prod_swap f hf]
    exact lintegral_prod _ hf.prod_swap

/-- The symmetric verion of Tonelli's Theorem: For `ℝ≥0∞`-valued measurable
functions on `α × β`,  the integral of `f` is equal to the iterated integral, in reverse order. -/
theorem lintegral_prod_symm' [sigma_finite μ] (f : α × β → ℝ≥0∞) (hf : Measurable f) :
  (∫⁻z, f z ∂μ.prod ν) = ∫⁻y, ∫⁻x, f (x, y) ∂μ ∂ν :=
  lintegral_prod_symm f hf.ae_measurable

/-- The reversed version of **Tonelli's Theorem**. In this version `f` is in curried form, which
makes it easier for the elaborator to figure out `f` automatically. -/
theorem lintegral_lintegral ⦃f : α → β → ℝ≥0∞⦄ (hf : AeMeasurable (uncurry f) (μ.prod ν)) :
  (∫⁻x, ∫⁻y, f x y ∂ν ∂μ) = ∫⁻z, f z.1 z.2 ∂μ.prod ν :=
  (lintegral_prod _ hf).symm

/-- The reversed version of **Tonelli's Theorem** (symmetric version). In this version `f` is in
curried form, which makes it easier for the elaborator to figure out `f` automatically. -/
theorem lintegral_lintegral_symm [sigma_finite μ] ⦃f : α → β → ℝ≥0∞⦄ (hf : AeMeasurable (uncurry f) (μ.prod ν)) :
  (∫⁻x, ∫⁻y, f x y ∂ν ∂μ) = ∫⁻z, f z.2 z.1 ∂ν.prod μ :=
  (lintegral_prod_symm _ hf.prod_swap).symm

/-- Change the order of Lebesgue integration. -/
theorem lintegral_lintegral_swap [sigma_finite μ] ⦃f : α → β → ℝ≥0∞⦄ (hf : AeMeasurable (uncurry f) (μ.prod ν)) :
  (∫⁻x, ∫⁻y, f x y ∂ν ∂μ) = ∫⁻y, ∫⁻x, f x y ∂μ ∂ν :=
  (lintegral_lintegral hf).trans (lintegral_prod_symm _ hf)

theorem lintegral_prod_mul {f : α → ℝ≥0∞} {g : β → ℝ≥0∞} (hf : AeMeasurable f μ) (hg : AeMeasurable g ν) :
  (∫⁻z, f z.1*g z.2 ∂μ.prod ν) = (∫⁻x, f x ∂μ)*∫⁻y, g y ∂ν :=
  by 
    simp [lintegral_prod _ (hf.fst.mul hg.snd), lintegral_lintegral_mul hf hg]

/-! ### Integrability on a product -/


section 

variable [OpensMeasurableSpace E]

theorem integrable.swap [sigma_finite μ] ⦃f : α × β → E⦄ (hf : integrable f (μ.prod ν)) :
  integrable (f ∘ Prod.swap) (ν.prod μ) :=
  ⟨hf.ae_measurable.prod_swap, (lintegral_prod_swap _ hf.ae_measurable.ennnorm : _).le.trans_lt hf.has_finite_integral⟩

theorem integrable_swap_iff [sigma_finite μ] ⦃f : α × β → E⦄ :
  integrable (f ∘ Prod.swap) (ν.prod μ) ↔ integrable f (μ.prod ν) :=
  ⟨fun hf =>
      by 
        convert hf.swap 
        ext ⟨x, y⟩
        rfl,
    fun hf => hf.swap⟩

-- error in MeasureTheory.Constructions.Prod: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem has_finite_integral_prod_iff
{{f : «expr × »(α, β) → E}}
(h1f : measurable f) : «expr ↔ »(has_finite_integral f (μ.prod ν), «expr ∧ »(«expr∀ᵐ ∂ , »((x), μ, has_finite_integral (λ
    y, f (x, y)) ν), has_finite_integral (λ x, «expr∫ , ∂ »((y), «expr∥ ∥»(f (x, y)), ν)) μ)) :=
begin
  simp [] [] ["only"] ["[", expr has_finite_integral, ",", expr lintegral_prod_of_measurable _ h1f.ennnorm, "]"] [] [],
  have [] [":", expr ∀
   x, «expr∀ᵐ ∂ , »((y), ν, «expr ≤ »(0, «expr∥ ∥»(f (x, y))))] [":=", expr λ
   x, eventually_of_forall (λ y, norm_nonneg _)],
  simp_rw ["[", expr integral_eq_lintegral_of_nonneg_ae (this _) (h1f.norm.comp measurable_prod_mk_left).ae_measurable, ",", expr ennnorm_eq_of_real to_real_nonneg, ",", expr of_real_norm_eq_coe_nnnorm, "]"] [],
  have [] [":", expr ∀
   {p q r : exprProp()}
   (h1 : r → p), «expr ↔ »(«expr ↔ »(r, «expr ∧ »(p, q)), p → «expr ↔ »(r, q))] [":=", expr λ
   p q r h1, by rw ["[", "<-", expr and.congr_right_iff, ",", expr and_iff_right_of_imp h1, "]"] []],
  rw ["[", expr this, "]"] [],
  { intro [ident h2f],
    rw [expr lintegral_congr_ae] [],
    refine [expr h2f.mp _],
    apply [expr eventually_of_forall],
    intros [ident x, ident hx],
    dsimp ["only"] [] [] [],
    rw ["[", expr of_real_to_real, "]"] [],
    rw ["[", "<-", expr lt_top_iff_ne_top, "]"] [],
    exact [expr hx] },
  { intro [ident h2f],
    refine [expr ae_lt_top _ h2f.ne],
    exact [expr h1f.ennnorm.lintegral_prod_right'] }
end

theorem has_finite_integral_prod_iff' ⦃f : α × β → E⦄ (h1f : AeMeasurable f (μ.prod ν)) :
  has_finite_integral f (μ.prod ν) ↔
    (∀ᵐx ∂μ, has_finite_integral (fun y => f (x, y)) ν) ∧ has_finite_integral (fun x => ∫y, ∥f (x, y)∥ ∂ν) μ :=
  by 
    rw [has_finite_integral_congr h1f.ae_eq_mk, has_finite_integral_prod_iff h1f.measurable_mk]
    apply and_congr
    ·
      apply eventually_congr 
      filterUpwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm]
      intro x hx 
      exact has_finite_integral_congr hx
    ·
      apply has_finite_integral_congr 
      filterUpwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm]
      intro x hx 
      exact integral_congr_ae (eventually_eq.fun_comp hx _)
    ·
      infer_instance

/-- A binary function is integrable if the function `y ↦ f (x, y)` is integrable for almost every
  `x` and the function `x ↦ ∫ ∥f (x, y)∥ dy` is integrable. -/
theorem integrable_prod_iff ⦃f : α × β → E⦄ (h1f : AeMeasurable f (μ.prod ν)) :
  integrable f (μ.prod ν) ↔ (∀ᵐx ∂μ, integrable (fun y => f (x, y)) ν) ∧ integrable (fun x => ∫y, ∥f (x, y)∥ ∂ν) μ :=
  by 
    simp [integrable, h1f, has_finite_integral_prod_iff', h1f.norm.integral_prod_right', h1f.prod_mk_left]

/-- A binary function is integrable if the function `x ↦ f (x, y)` is integrable for almost every
  `y` and the function `y ↦ ∫ ∥f (x, y)∥ dx` is integrable. -/
theorem integrable_prod_iff' [sigma_finite μ] ⦃f : α × β → E⦄ (h1f : AeMeasurable f (μ.prod ν)) :
  integrable f (μ.prod ν) ↔ (∀ᵐy ∂ν, integrable (fun x => f (x, y)) μ) ∧ integrable (fun y => ∫x, ∥f (x, y)∥ ∂μ) ν :=
  by 
    convert integrable_prod_iff h1f.prod_swap using 1
    rw [integrable_swap_iff]

theorem integrable.prod_left_ae [sigma_finite μ] ⦃f : α × β → E⦄ (hf : integrable f (μ.prod ν)) :
  ∀ᵐy ∂ν, integrable (fun x => f (x, y)) μ :=
  ((integrable_prod_iff' hf.ae_measurable).mp hf).1

theorem integrable.prod_right_ae [sigma_finite μ] ⦃f : α × β → E⦄ (hf : integrable f (μ.prod ν)) :
  ∀ᵐx ∂μ, integrable (fun y => f (x, y)) ν :=
  hf.swap.prod_left_ae

theorem integrable.integral_norm_prod_left ⦃f : α × β → E⦄ (hf : integrable f (μ.prod ν)) :
  integrable (fun x => ∫y, ∥f (x, y)∥ ∂ν) μ :=
  ((integrable_prod_iff hf.ae_measurable).mp hf).2

theorem integrable.integral_norm_prod_right [sigma_finite μ] ⦃f : α × β → E⦄ (hf : integrable f (μ.prod ν)) :
  integrable (fun y => ∫x, ∥f (x, y)∥ ∂μ) ν :=
  hf.swap.integral_norm_prod_left

end 

variable [second_countable_topology E] [NormedSpace ℝ E] [CompleteSpace E] [BorelSpace E]

theorem integrable.integral_prod_left ⦃f : α × β → E⦄ (hf : integrable f (μ.prod ν)) :
  integrable (fun x => ∫y, f (x, y) ∂ν) μ :=
  integrable.mono hf.integral_norm_prod_left hf.ae_measurable.integral_prod_right'$
    eventually_of_forall$
      fun x =>
        (norm_integral_le_integral_norm _).trans_eq$
          (norm_of_nonneg$ integral_nonneg_of_ae$ eventually_of_forall$ fun y => (norm_nonneg (f (x, y)) : _)).symm

theorem integrable.integral_prod_right [sigma_finite μ] ⦃f : α × β → E⦄ (hf : integrable f (μ.prod ν)) :
  integrable (fun y => ∫x, f (x, y) ∂μ) ν :=
  hf.swap.integral_prod_left

/-! ### The Bochner integral on a product -/


variable [sigma_finite μ]

theorem integral_prod_swap (f : α × β → E) (hf : AeMeasurable f (μ.prod ν)) :
  (∫z, f z.swap ∂ν.prod μ) = ∫z, f z ∂μ.prod ν :=
  by 
    rw [←prod_swap] at hf 
    rw [←integral_map measurable_swap hf, prod_swap]

variable {E' : Type _} [MeasurableSpace E'] [NormedGroup E'] [BorelSpace E'] [CompleteSpace E'] [NormedSpace ℝ E']
  [second_countable_topology E']

/-! Some rules about the sum/difference of double integrals. They follow from `integral_add`, but
  we separate them out as separate lemmas, because they involve quite some steps. -/


/-- Integrals commute with addition inside another integral. `F` can be any function. -/
theorem integral_fn_integral_add ⦃f g : α × β → E⦄ (F : E → E') (hf : integrable f (μ.prod ν))
  (hg : integrable g (μ.prod ν)) :
  (∫x, F (∫y, f (x, y)+g (x, y) ∂ν) ∂μ) = ∫x, F ((∫y, f (x, y) ∂ν)+∫y, g (x, y) ∂ν) ∂μ :=
  by 
    refine' integral_congr_ae _ 
    filterUpwards [hf.prod_right_ae, hg.prod_right_ae]
    intro x h2f h2g 
    simp [integral_add h2f h2g]

/-- Integrals commute with subtraction inside another integral.
  `F` can be any measurable function. -/
theorem integral_fn_integral_sub ⦃f g : α × β → E⦄ (F : E → E') (hf : integrable f (μ.prod ν))
  (hg : integrable g (μ.prod ν)) :
  (∫x, F (∫y, f (x, y) - g (x, y) ∂ν) ∂μ) = ∫x, F ((∫y, f (x, y) ∂ν) - ∫y, g (x, y) ∂ν) ∂μ :=
  by 
    refine' integral_congr_ae _ 
    filterUpwards [hf.prod_right_ae, hg.prod_right_ae]
    intro x h2f h2g 
    simp [integral_sub h2f h2g]

/-- Integrals commute with subtraction inside a lower Lebesgue integral.
  `F` can be any function. -/
theorem lintegral_fn_integral_sub ⦃f g : α × β → E⦄ (F : E → ℝ≥0∞) (hf : integrable f (μ.prod ν))
  (hg : integrable g (μ.prod ν)) :
  (∫⁻x, F (∫y, f (x, y) - g (x, y) ∂ν) ∂μ) = ∫⁻x, F ((∫y, f (x, y) ∂ν) - ∫y, g (x, y) ∂ν) ∂μ :=
  by 
    refine' lintegral_congr_ae _ 
    filterUpwards [hf.prod_right_ae, hg.prod_right_ae]
    intro x h2f h2g 
    simp [integral_sub h2f h2g]

/-- Double integrals commute with addition. -/
theorem integral_integral_add ⦃f g : α × β → E⦄ (hf : integrable f (μ.prod ν)) (hg : integrable g (μ.prod ν)) :
  (∫x, ∫y, f (x, y)+g (x, y) ∂ν ∂μ) = (∫x, ∫y, f (x, y) ∂ν ∂μ)+∫x, ∫y, g (x, y) ∂ν ∂μ :=
  (integral_fn_integral_add id hf hg).trans$ integral_add hf.integral_prod_left hg.integral_prod_left

/-- Double integrals commute with addition. This is the version with `(f + g) (x, y)`
  (instead of `f (x, y) + g (x, y)`) in the LHS. -/
theorem integral_integral_add' ⦃f g : α × β → E⦄ (hf : integrable f (μ.prod ν)) (hg : integrable g (μ.prod ν)) :
  (∫x, ∫y, (f+g) (x, y) ∂ν ∂μ) = (∫x, ∫y, f (x, y) ∂ν ∂μ)+∫x, ∫y, g (x, y) ∂ν ∂μ :=
  integral_integral_add hf hg

/-- Double integrals commute with subtraction. -/
theorem integral_integral_sub ⦃f g : α × β → E⦄ (hf : integrable f (μ.prod ν)) (hg : integrable g (μ.prod ν)) :
  (∫x, ∫y, f (x, y) - g (x, y) ∂ν ∂μ) = (∫x, ∫y, f (x, y) ∂ν ∂μ) - ∫x, ∫y, g (x, y) ∂ν ∂μ :=
  (integral_fn_integral_sub id hf hg).trans$ integral_sub hf.integral_prod_left hg.integral_prod_left

/-- Double integrals commute with subtraction. This is the version with `(f - g) (x, y)`
  (instead of `f (x, y) - g (x, y)`) in the LHS. -/
theorem integral_integral_sub' ⦃f g : α × β → E⦄ (hf : integrable f (μ.prod ν)) (hg : integrable g (μ.prod ν)) :
  (∫x, ∫y, (f - g) (x, y) ∂ν ∂μ) = (∫x, ∫y, f (x, y) ∂ν ∂μ) - ∫x, ∫y, g (x, y) ∂ν ∂μ :=
  integral_integral_sub hf hg

-- error in MeasureTheory.Constructions.Prod: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The map that sends an L¹-function `f : α × β → E` to `∫∫f` is continuous. -/
theorem continuous_integral_integral : continuous (λ
 f : «expr →₁[ ] »(«expr × »(α, β), μ.prod ν, E), «expr∫ , ∂ »((x), «expr∫ , ∂ »((y), f (x, y), ν), μ)) :=
begin
  rw ["[", expr continuous_iff_continuous_at, "]"] [],
  intro [ident g],
  refine [expr tendsto_integral_of_L1 _ (L1.integrable_coe_fn g).integral_prod_left «expr $ »(eventually_of_forall, λ
    h, (L1.integrable_coe_fn h).integral_prod_left) _],
  simp_rw ["[", "<-", expr lintegral_fn_integral_sub (λ
    x, (nnnorm x : «exprℝ≥0∞»())) (L1.integrable_coe_fn _) (L1.integrable_coe_fn g), "]"] [],
  refine [expr tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds _ (λ i, zero_le _) _],
  { exact [expr λ i, «expr∫⁻ , ∂ »((x), «expr∫⁻ , ∂ »((y), nnnorm «expr - »(i (x, y), g (x, y)), ν), μ)] },
  swap,
  { exact [expr λ i, lintegral_mono (λ x, ennnorm_integral_le_lintegral_ennnorm _)] },
  show [expr tendsto (λ
    i : «expr →₁[ ] »(«expr × »(α, β), μ.prod ν, E), «expr∫⁻ , ∂ »((x), «expr∫⁻ , ∂ »((y : β), nnnorm «expr - »(i (x, y), g (x, y)), ν), μ)) (expr𝓝() g) (expr𝓝() 0)],
  have [] [":", expr ∀
   i : «expr →₁[ ] »(«expr × »(α, β), μ.prod ν, E), measurable (λ
    z, (nnnorm «expr - »(i z, g z) : «exprℝ≥0∞»()))] [":=", expr λ
   i, ((Lp.measurable i).sub (Lp.measurable g)).ennnorm],
  simp_rw ["[", "<-", expr lintegral_prod_of_measurable _ (this _), ",", "<-", expr L1.of_real_norm_sub_eq_lintegral, ",", "<-", expr of_real_zero, "]"] [],
  refine [expr (continuous_of_real.tendsto 0).comp _],
  rw ["[", "<-", expr tendsto_iff_norm_tendsto_zero, "]"] [],
  exact [expr tendsto_id]
end

/-- **Fubini's Theorem**: For integrable functions on `α × β`,
  the Bochner integral of `f` is equal to the iterated Bochner integral.
  `integrable_prod_iff` can be useful to show that the function in question in integrable.
  `measure_theory.integrable.integral_prod_right` is useful to show that the inner integral
  of the right-hand side is integrable. -/
theorem integral_prod : ∀ f : α × β → E hf : integrable f (μ.prod ν), (∫z, f z ∂μ.prod ν) = ∫x, ∫y, f (x, y) ∂ν ∂μ :=
  by 
    apply integrable.induction
    ·
      intro c s hs h2s 
      simpRw [integral_indicator hs, ←indicator_comp_right, Function.comp,
        integral_indicator (measurable_prod_mk_left hs), set_integral_const, integral_smul_const,
        integral_to_real (measurable_measure_prod_mk_left hs).AeMeasurable (ae_measure_lt_top hs h2s.ne), prod_apply hs]
    ·
      intro f g hfg i_f i_g hf hg 
      simpRw [integral_add' i_f i_g, integral_integral_add' i_f i_g, hf, hg]
    ·
      exact is_closed_eq continuous_integral continuous_integral_integral
    ·
      intro f g hfg i_f hf 
      convert hf using 1
      ·
        exact integral_congr_ae hfg.symm
      ·
        refine' integral_congr_ae _ 
        refine' (ae_ae_of_ae_prod hfg).mp _ 
        apply eventually_of_forall 
        intro x hfgx 
        exact integral_congr_ae (ae_eq_symm hfgx)

/-- Symmetric version of **Fubini's Theorem**: For integrable functions on `α × β`,
  the Bochner integral of `f` is equal to the iterated Bochner integral.
  This version has the integrals on the right-hand side in the other order. -/
theorem integral_prod_symm (f : α × β → E) (hf : integrable f (μ.prod ν)) :
  (∫z, f z ∂μ.prod ν) = ∫y, ∫x, f (x, y) ∂μ ∂ν :=
  by 
    simpRw [←integral_prod_swap f hf.ae_measurable]
    exact integral_prod _ hf.swap

/-- Reversed version of **Fubini's Theorem**. -/
theorem integral_integral {f : α → β → E} (hf : integrable (uncurry f) (μ.prod ν)) :
  (∫x, ∫y, f x y ∂ν ∂μ) = ∫z, f z.1 z.2 ∂μ.prod ν :=
  (integral_prod _ hf).symm

/-- Reversed version of **Fubini's Theorem** (symmetric version). -/
theorem integral_integral_symm {f : α → β → E} (hf : integrable (uncurry f) (μ.prod ν)) :
  (∫x, ∫y, f x y ∂ν ∂μ) = ∫z, f z.2 z.1 ∂ν.prod μ :=
  (integral_prod_symm _ hf.swap).symm

/-- Change the order of Bochner integration. -/
theorem integral_integral_swap ⦃f : α → β → E⦄ (hf : integrable (uncurry f) (μ.prod ν)) :
  (∫x, ∫y, f x y ∂ν ∂μ) = ∫y, ∫x, f x y ∂μ ∂ν :=
  (integral_integral hf).trans (integral_prod_symm _ hf)

/-- **Fubini's Theorem** for set integrals. -/
theorem set_integral_prod (f : α × β → E) {s : Set α} {t : Set β} (hf : integrable_on f (s.prod t) (μ.prod ν)) :
  (∫z in s.prod t, f z ∂μ.prod ν) = ∫x in s, ∫y in t, f (x, y) ∂ν ∂μ :=
  by 
    simp only [←measure.prod_restrict s t, integrable_on] at hf⊢
    exact integral_prod f hf

end MeasureTheory

