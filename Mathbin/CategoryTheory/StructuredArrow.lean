/-
Copyright (c) 2021 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Adam Topaz, Scott Morrison

! This file was ported from Lean 3 source module category_theory.structured_arrow
! leanprover-community/mathlib commit 8a318021995877a44630c898d0b2bc376fceef3b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Punit
import Mathbin.CategoryTheory.Comma
import Mathbin.CategoryTheory.Limits.Shapes.Terminal
import Mathbin.CategoryTheory.EssentiallySmall

/-!
# The category of "structured arrows"

For `T : C ⥤ D`, a `T`-structured arrow with source `S : D`
is just a morphism `S ⟶ T.obj Y`, for some `Y : C`.

These form a category with morphisms `g : Y ⟶ Y'` making the obvious diagram commute.

We prove that `𝟙 (T.obj Y)` is the initial object in `T`-structured objects with source `T.obj Y`.
-/


namespace CategoryTheory

-- morphism levels before object levels. See note [category_theory universes].
universe v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄

variable {C : Type u₁} [Category.{v₁} C] {D : Type u₂} [Category.{v₂} D]

#print CategoryTheory.StructuredArrow /-
/-- The category of `T`-structured arrows with domain `S : D` (here `T : C ⥤ D`),
has as its objects `D`-morphisms of the form `S ⟶ T Y`, for some `Y : C`,
and morphisms `C`-morphisms `Y ⟶ Y'` making the obvious triangle commute.
-/
@[nolint has_nonempty_instance]
def StructuredArrow (S : D) (T : C ⥤ D) :=
  Comma (Functor.fromPUnit S) T deriving Category
#align category_theory.structured_arrow CategoryTheory.StructuredArrow
-/

namespace StructuredArrow

#print CategoryTheory.StructuredArrow.proj /-
/-- The obvious projection functor from structured arrows. -/
@[simps]
def proj (S : D) (T : C ⥤ D) : StructuredArrow S T ⥤ C :=
  Comma.snd _ _
#align category_theory.structured_arrow.proj CategoryTheory.StructuredArrow.proj
-/

variable {S S' S'' : D} {Y Y' : C} {T : C ⥤ D}

/- warning: category_theory.structured_arrow.mk -> CategoryTheory.StructuredArrow.mk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {Y : C} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2}, (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) S (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y)) -> (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {Y : C} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2}, (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) S (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) Y)) -> (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T)
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow.mk CategoryTheory.StructuredArrow.mkₓ'. -/
/-- Construct a structured arrow from a morphism. -/
def mk (f : S ⟶ T.obj Y) : StructuredArrow S T :=
  ⟨⟨⟨⟩⟩, Y, f⟩
#align category_theory.structured_arrow.mk CategoryTheory.StructuredArrow.mk

/- warning: category_theory.structured_arrow.mk_left -> CategoryTheory.StructuredArrow.mk_left is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {Y : C} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) S (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y)), Eq.{succ u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y T f)) (CategoryTheory.Discrete.mk.{u2} PUnit.{succ u2} PUnit.unit.{succ u2})
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {Y : C} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) S (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) Y)), Eq.{succ u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y T f)) (CategoryTheory.Discrete.mk.{u2} PUnit.{succ u2} PUnit.unit.{succ u2})
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow.mk_left CategoryTheory.StructuredArrow.mk_leftₓ'. -/
@[simp]
theorem mk_left (f : S ⟶ T.obj Y) : (mk f).left = ⟨⟨⟩⟩ :=
  rfl
#align category_theory.structured_arrow.mk_left CategoryTheory.StructuredArrow.mk_left

/- warning: category_theory.structured_arrow.mk_right -> CategoryTheory.StructuredArrow.mk_right is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {Y : C} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) S (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y)), Eq.{succ u3} C (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y T f)) Y
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {Y : C} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) S (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) Y)), Eq.{succ u3} C (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y T f)) Y
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow.mk_right CategoryTheory.StructuredArrow.mk_rightₓ'. -/
@[simp]
theorem mk_right (f : S ⟶ T.obj Y) : (mk f).right = Y :=
  rfl
#align category_theory.structured_arrow.mk_right CategoryTheory.StructuredArrow.mk_right

/- warning: category_theory.structured_arrow.mk_hom_eq_self -> CategoryTheory.StructuredArrow.mk_hom_eq_self is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {Y : C} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) S (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y)), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y T f))) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y T f)))) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y T f)) f
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {Y : C} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) S (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) Y)), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S)) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y T f))) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y T f)))) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y T f)) f
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow.mk_hom_eq_self CategoryTheory.StructuredArrow.mk_hom_eq_selfₓ'. -/
@[simp]
theorem mk_hom_eq_self (f : S ⟶ T.obj Y) : (mk f).Hom = f :=
  rfl
#align category_theory.structured_arrow.mk_hom_eq_self CategoryTheory.StructuredArrow.mk_hom_eq_self

/- warning: category_theory.structured_arrow.w -> CategoryTheory.StructuredArrow.w is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {A : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {B : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (f : Quiver.Hom.{succ (max u2 u1), max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T))) A B), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B)) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B) (CategoryTheory.CommaMorphism.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A B f))) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {A : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {B : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (f : Quiver.Hom.{max (succ u1) (succ u2), max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) A B), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S)) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S)) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B)) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B) (CategoryTheory.CommaMorphism.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A B f))) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B)
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow.w CategoryTheory.StructuredArrow.wₓ'. -/
@[simp, reassoc.1]
theorem w {A B : StructuredArrow S T} (f : A ⟶ B) : A.Hom ≫ T.map f.right = B.Hom := by
  have := f.w <;> tidy
#align category_theory.structured_arrow.w CategoryTheory.StructuredArrow.w

/- warning: category_theory.structured_arrow.hom_mk -> CategoryTheory.StructuredArrow.homMk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {f' : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (g : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f')), (Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f'))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f')) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f') g)) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f')) -> (Quiver.Hom.{succ (max u2 u1), max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T))) f f')
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {f' : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (g : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f')), (Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S)) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f'))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S)) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f')) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f') g)) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f')) -> (Quiver.Hom.{max (succ u1) (succ u2), max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) f f')
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow.hom_mk CategoryTheory.StructuredArrow.homMkₓ'. -/
/-- To construct a morphism of structured arrows,
we need a morphism of the objects underlying the target,
and to check that the triangle commutes.
-/
@[simps]
def homMk {f f' : StructuredArrow S T} (g : f.right ⟶ f'.right) (w : f.Hom ≫ T.map g = f'.Hom) :
    f ⟶ f' where
  left := eqToHom (by ext)
  right := g
  w' := by
    dsimp
    simpa using w.symm
#align category_theory.structured_arrow.hom_mk CategoryTheory.StructuredArrow.homMk

/- warning: category_theory.structured_arrow.hom_mk' -> CategoryTheory.StructuredArrow.homMk' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {X : D} {Y : C} (U : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 X F) (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 X) F U) Y), Quiver.Hom.{succ (max u2 u1), max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 X F) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 X F) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 X F) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 X F))) U (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 X Y F (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) X (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 X) F U)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 X) F U) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 X) F U) Y f)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {X : D} {Y : C} (U : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 X F) (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 X) F U) Y), Quiver.Hom.{max (succ u1) (succ u2), max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 X F) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 X F) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 X F) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 X F))) U (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 X Y F (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) X (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 X) F U)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 X) F U) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 X) F U) Y f)))
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow.hom_mk' CategoryTheory.StructuredArrow.homMk'ₓ'. -/
/-- Given a structured arrow `X ⟶ F(U)`, and an arrow `U ⟶ Y`, we can construct a morphism of
structured arrow given by `(X ⟶ F(U)) ⟶ (X ⟶ F(U) ⟶ F(Y))`.
-/
def homMk' {F : C ⥤ D} {X : D} {Y : C} (U : StructuredArrow X F) (f : U.right ⟶ Y) :
    U ⟶ mk (U.Hom ≫ F.map f) where
  left := eqToHom (by ext)
  right := f
#align category_theory.structured_arrow.hom_mk' CategoryTheory.StructuredArrow.homMk'

/- warning: category_theory.structured_arrow.iso_mk -> CategoryTheory.StructuredArrow.isoMk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {f' : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (g : CategoryTheory.Iso.{u1, u3} C _inst_1 (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f')), (Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f'))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f')) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f') (CategoryTheory.Iso.hom.{u1, u3} C _inst_1 (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f') g))) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f')) -> (CategoryTheory.Iso.{max u2 u1, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.commaCategory.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T) f f')
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {f' : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (g : CategoryTheory.Iso.{u1, u3} C _inst_1 (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f')), (Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S)) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f'))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S)) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f')) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f') (CategoryTheory.Iso.hom.{u1, u3} C _inst_1 (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f') g))) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T f')) -> (CategoryTheory.Iso.{max u1 u2, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) f f')
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow.iso_mk CategoryTheory.StructuredArrow.isoMkₓ'. -/
/-- To construct an isomorphism of structured arrows,
we need an isomorphism of the objects underlying the target,
and to check that the triangle commutes.
-/
@[simps]
def isoMk {f f' : StructuredArrow S T} (g : f.right ≅ f'.right) (w : f.Hom ≫ T.map g.Hom = f'.Hom) :
    f ≅ f' :=
  Comma.isoMk (eqToIso (by ext)) g (by simpa [eq_to_hom_map] using w.symm)
#align category_theory.structured_arrow.iso_mk CategoryTheory.StructuredArrow.isoMk

#print CategoryTheory.StructuredArrow.ext /-
theorem ext {A B : StructuredArrow S T} (f g : A ⟶ B) : f.right = g.right → f = g :=
  CommaMorphism.ext _ _ (Subsingleton.elim _ _)
#align category_theory.structured_arrow.ext CategoryTheory.StructuredArrow.ext
-/

#print CategoryTheory.StructuredArrow.ext_iff /-
theorem ext_iff {A B : StructuredArrow S T} (f g : A ⟶ B) : f = g ↔ f.right = g.right :=
  ⟨fun h => h ▸ rfl, ext f g⟩
#align category_theory.structured_arrow.ext_iff CategoryTheory.StructuredArrow.ext_iff
-/

#print CategoryTheory.StructuredArrow.proj_faithful /-
instance proj_faithful : Faithful (proj S T) where map_injective' X Y := ext
#align category_theory.structured_arrow.proj_faithful CategoryTheory.StructuredArrow.proj_faithful
-/

#print CategoryTheory.StructuredArrow.mono_of_mono_right /-
/-- The converse of this is true with additional assumptions, see `mono_iff_mono_right`. -/
theorem mono_of_mono_right {A B : StructuredArrow S T} (f : A ⟶ B) [h : Mono f.right] : Mono f :=
  (proj S T).mono_of_mono_map h
#align category_theory.structured_arrow.mono_of_mono_right CategoryTheory.StructuredArrow.mono_of_mono_right
-/

#print CategoryTheory.StructuredArrow.epi_of_epi_right /-
theorem epi_of_epi_right {A B : StructuredArrow S T} (f : A ⟶ B) [h : Epi f.right] : Epi f :=
  (proj S T).epi_of_epi_map h
#align category_theory.structured_arrow.epi_of_epi_right CategoryTheory.StructuredArrow.epi_of_epi_right
-/

/- warning: category_theory.structured_arrow.mono_hom_mk -> CategoryTheory.StructuredArrow.mono_homMk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {A : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {B : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B)) (w : Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B)) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B) f)) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B)) [h : CategoryTheory.Mono.{u1, u3} C _inst_1 (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B) f], CategoryTheory.Mono.{max u2 u1, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T) A B (CategoryTheory.StructuredArrow.homMk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T A B f w)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {A : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {B : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B)) (w : Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S)) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S)) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B)) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B) f)) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B)) [h : CategoryTheory.Mono.{u1, u3} C _inst_1 (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B) f], CategoryTheory.Mono.{max u2 u1, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) A B (CategoryTheory.StructuredArrow.homMk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T A B f w)
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow.mono_hom_mk CategoryTheory.StructuredArrow.mono_homMkₓ'. -/
instance mono_homMk {A B : StructuredArrow S T} (f : A.right ⟶ B.right) (w) [h : Mono f] :
    Mono (homMk f w) :=
  (proj S T).mono_of_mono_map h
#align category_theory.structured_arrow.mono_hom_mk CategoryTheory.StructuredArrow.mono_homMk

/- warning: category_theory.structured_arrow.epi_hom_mk -> CategoryTheory.StructuredArrow.epi_homMk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {A : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {B : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B)) (w : Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B)) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 T (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B) f)) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B)) [h : CategoryTheory.Epi.{u1, u3} C _inst_1 (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B) f], CategoryTheory.Epi.{max u2 u1, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T) A B (CategoryTheory.StructuredArrow.homMk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T A B f w)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {A : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {B : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B)) (w : Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S)) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S)) (CategoryTheory.Comma.left.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B)) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B) f)) (CategoryTheory.Comma.hom.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B)) [h : CategoryTheory.Epi.{u1, u3} C _inst_1 (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T A) (CategoryTheory.Comma.right.{u2, u1, u2, u2, u3, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) C _inst_1 D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 S) T B) f], CategoryTheory.Epi.{max u2 u1, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) A B (CategoryTheory.StructuredArrow.homMk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T A B f w)
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow.epi_hom_mk CategoryTheory.StructuredArrow.epi_homMkₓ'. -/
instance epi_homMk {A B : StructuredArrow S T} (f : A.right ⟶ B.right) (w) [h : Epi f] :
    Epi (homMk f w) :=
  (proj S T).epi_of_epi_map h
#align category_theory.structured_arrow.epi_hom_mk CategoryTheory.StructuredArrow.epi_homMk

#print CategoryTheory.StructuredArrow.eq_mk /-
/-- Eta rule for structured arrows. Prefer `structured_arrow.eta`, since equality of objects tends
    to cause problems. -/
theorem eq_mk (f : StructuredArrow S T) : f = mk f.Hom :=
  by
  cases f
  congr
  ext
#align category_theory.structured_arrow.eq_mk CategoryTheory.StructuredArrow.eq_mk
-/

#print CategoryTheory.StructuredArrow.eta /-
/-- Eta rule for structured arrows. -/
@[simps]
def eta (f : StructuredArrow S T) : f ≅ mk f.Hom :=
  isoMk (Iso.refl _) (by tidy)
#align category_theory.structured_arrow.eta CategoryTheory.StructuredArrow.eta
-/

#print CategoryTheory.StructuredArrow.map /-
/-- A morphism between source objects `S ⟶ S'`
contravariantly induces a functor between structured arrows,
`structured_arrow S' T ⥤ structured_arrow S T`.

Ideally this would be described as a 2-functor from `D`
(promoted to a 2-category with equations as 2-morphisms)
to `Cat`.
-/
@[simps]
def map (f : S ⟶ S') : StructuredArrow S' T ⥤ StructuredArrow S T :=
  Comma.mapLeft _ ((Functor.const _).map f)
#align category_theory.structured_arrow.map CategoryTheory.StructuredArrow.map
-/

/- warning: category_theory.structured_arrow.map_mk -> CategoryTheory.StructuredArrow.map_mk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {S' : D} {Y : C} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) S' (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y)} (g : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) S S'), Eq.{succ (max u3 u2)} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u3 u2, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S' T) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 S S' T g) (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' Y T f)) (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y T (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) S S' (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y) g f))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {S' : D} {Y : C} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) S' (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) Y)} (g : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) S S'), Eq.{max (succ u3) (succ u2)} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u3, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T))) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u3, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 S S' T g)) (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' Y T f)) (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y T (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) S S' (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) Y) g f))
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow.map_mk CategoryTheory.StructuredArrow.map_mkₓ'. -/
@[simp]
theorem map_mk {f : S' ⟶ T.obj Y} (g : S ⟶ S') : (map g).obj (mk f) = mk (g ≫ f) :=
  rfl
#align category_theory.structured_arrow.map_mk CategoryTheory.StructuredArrow.map_mk

/- warning: category_theory.structured_arrow.map_id -> CategoryTheory.StructuredArrow.map_id is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T}, Eq.{succ (max u3 u2)} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u3 u2, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 S S T (CategoryTheory.CategoryStruct.id.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) S)) f) f
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T}, Eq.{max (succ u3) (succ u2)} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u3, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u3, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 S S T (CategoryTheory.CategoryStruct.id.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) S))) f) f
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow.map_id CategoryTheory.StructuredArrow.map_idₓ'. -/
@[simp]
theorem map_id {f : StructuredArrow S T} : (map (𝟙 S)).obj f = f :=
  by
  rw [eq_mk f]
  simp
#align category_theory.structured_arrow.map_id CategoryTheory.StructuredArrow.map_id

/- warning: category_theory.structured_arrow.map_comp -> CategoryTheory.StructuredArrow.map_comp is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {S' : D} {S'' : D} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) S S'} {f' : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) S' S''} {h : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S'' T}, Eq.{succ (max u3 u2)} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u3 u2, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S'' T) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S'' T) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 S S'' T (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) S S' S'' f f')) h) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u3 u2, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S' T) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 S S' T f) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u3 u2, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S'' T) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S'' T) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S' T) (CategoryTheory.StructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' S'' T f') h))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {S' : D} {S'' : D} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) S S'} {f' : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) S' S''} {h : CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S'' T}, Eq.{max (succ u3) (succ u2)} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u3, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S'' T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S'' T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S'' T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S'' T))) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u3, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S'' T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S'' T) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 S S'' T (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) S S' S'' f f'))) h) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u3, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T))) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u3, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 S S' T f)) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u3, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S'' T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S'' T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S'' T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S'' T))) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u3, max u2 u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S'' T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S'' T) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' T) (CategoryTheory.StructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 S' S'' T f')) h))
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow.map_comp CategoryTheory.StructuredArrow.map_compₓ'. -/
@[simp]
theorem map_comp {f : S ⟶ S'} {f' : S' ⟶ S''} {h : StructuredArrow S'' T} :
    (map (f ≫ f')).obj h = (map f).obj ((map f').obj h) :=
  by
  rw [eq_mk h]
  simp
#align category_theory.structured_arrow.map_comp CategoryTheory.StructuredArrow.map_comp

#print CategoryTheory.StructuredArrow.proj_reflects_iso /-
instance proj_reflects_iso : ReflectsIsomorphisms (proj S T)
    where reflects Y Z f t :=
    ⟨⟨structured_arrow.hom_mk (inv ((proj S T).map f)) (by simp), by tidy⟩⟩
#align category_theory.structured_arrow.proj_reflects_iso CategoryTheory.StructuredArrow.proj_reflects_iso
-/

open CategoryTheory.Limits

attribute [local tidy] tactic.discrete_cases

/- warning: category_theory.structured_arrow.mk_id_initial -> CategoryTheory.StructuredArrow.mkIdInitial is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {Y : C} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} [_inst_3 : CategoryTheory.Full.{u1, u2, u3, u4} C _inst_1 D _inst_2 T] [_inst_4 : CategoryTheory.Faithful.{u1, u2, u3, u4} C _inst_1 D _inst_2 T], CategoryTheory.Limits.IsInitial.{max u2 u1, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y) T) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y) T) (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y) Y T (CategoryTheory.CategoryStruct.id.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {Y : C} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} [_inst_3 : CategoryTheory.Full.{u1, u2, u3, u4} C _inst_1 D _inst_2 T] [_inst_4 : CategoryTheory.Faithful.{u1, u2, u3, u4} C _inst_1 D _inst_2 T], CategoryTheory.Limits.IsInitial.{max u1 u2, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) Y) T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) Y) T) (CategoryTheory.StructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) Y) Y T (CategoryTheory.CategoryStruct.id.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 T) Y)))
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow.mk_id_initial CategoryTheory.StructuredArrow.mkIdInitialₓ'. -/
/-- The identity structured arrow is initial. -/
def mkIdInitial [Full T] [Faithful T] : IsInitial (mk (𝟙 (T.obj Y)))
    where
  desc c :=
    homMk (T.preimage c.pt.Hom)
      (by
        dsimp
        simp)
  uniq c m _ := by
    ext
    apply T.map_injective
    simpa only [hom_mk_right, T.image_preimage, ← w m] using (category.id_comp _).symm
#align category_theory.structured_arrow.mk_id_initial CategoryTheory.StructuredArrow.mkIdInitial

variable {A : Type u₃} [Category.{v₃} A] {B : Type u₄} [Category.{v₄} B]

#print CategoryTheory.StructuredArrow.pre /-
/-- The functor `(S, F ⋙ G) ⥤ (S, G)`. -/
@[simps]
def pre (S : D) (F : B ⥤ C) (G : C ⥤ D) : StructuredArrow S (F ⋙ G) ⥤ StructuredArrow S G :=
  Comma.preRight _ F G
#align category_theory.structured_arrow.pre CategoryTheory.StructuredArrow.pre
-/

/- warning: category_theory.structured_arrow.post -> CategoryTheory.StructuredArrow.post is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u1, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u2, u5} D] {B : Type.{u6}} [_inst_4 : CategoryTheory.Category.{u3, u6} B] (S : C) (F : CategoryTheory.Functor.{u3, u1, u6, u4} B _inst_4 C _inst_1) (G : CategoryTheory.Functor.{u1, u2, u4, u5} C _inst_1 D _inst_2), CategoryTheory.Functor.{max u1 u3, max u2 u3, max u6 u1, max u6 u2} (CategoryTheory.StructuredArrow.{u3, u1, u6, u4} B _inst_4 C _inst_1 S F) (CategoryTheory.StructuredArrow.category.{u1, u4, u6, u3} B _inst_4 C _inst_1 S F) (CategoryTheory.StructuredArrow.{u3, u2, u6, u5} B _inst_4 D _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u4, u5} C _inst_1 D _inst_2 G S) (CategoryTheory.Functor.comp.{u3, u1, u2, u6, u4, u5} B _inst_4 C _inst_1 D _inst_2 F G)) (CategoryTheory.StructuredArrow.category.{u2, u5, u6, u3} B _inst_4 D _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u4, u5} C _inst_1 D _inst_2 G S) (CategoryTheory.Functor.comp.{u3, u1, u2, u6, u4, u5} B _inst_4 C _inst_1 D _inst_2 F G))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u1, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u2, u5} D] {B : Type.{u6}} [_inst_4 : CategoryTheory.Category.{u3, u6} B] (S : C) (F : CategoryTheory.Functor.{u3, u1, u6, u4} B _inst_4 C _inst_1) (G : CategoryTheory.Functor.{u1, u2, u4, u5} C _inst_1 D _inst_2), CategoryTheory.Functor.{max u1 u3, max u2 u3, max u6 u1, max u6 u2} (CategoryTheory.StructuredArrow.{u3, u1, u6, u4} B _inst_4 C _inst_1 S F) (CategoryTheory.instCategoryStructuredArrow.{u3, u1, u6, u4} B _inst_4 C _inst_1 S F) (CategoryTheory.StructuredArrow.{u3, u2, u6, u5} B _inst_4 D _inst_2 (Prefunctor.obj.{succ u1, succ u2, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u4} C (CategoryTheory.Category.toCategoryStruct.{u1, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u5} D (CategoryTheory.Category.toCategoryStruct.{u2, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u4, u5} C _inst_1 D _inst_2 G) S) (CategoryTheory.Functor.comp.{u3, u1, u2, u6, u4, u5} B _inst_4 C _inst_1 D _inst_2 F G)) (CategoryTheory.instCategoryStructuredArrow.{u3, u2, u6, u5} B _inst_4 D _inst_2 (Prefunctor.obj.{succ u1, succ u2, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u4} C (CategoryTheory.Category.toCategoryStruct.{u1, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u5} D (CategoryTheory.Category.toCategoryStruct.{u2, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u4, u5} C _inst_1 D _inst_2 G) S) (CategoryTheory.Functor.comp.{u3, u1, u2, u6, u4, u5} B _inst_4 C _inst_1 D _inst_2 F G))
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow.post CategoryTheory.StructuredArrow.postₓ'. -/
/-- The functor `(S, F) ⥤ (G(S), F ⋙ G)`. -/
@[simps]
def post (S : C) (F : B ⥤ C) (G : C ⥤ D) : StructuredArrow S F ⥤ StructuredArrow (G.obj S) (F ⋙ G)
    where
  obj X := StructuredArrow.mk (G.map X.Hom)
  map X Y f := StructuredArrow.homMk f.right (by simp [functor.comp_map, ← G.map_comp, ← f.w])
#align category_theory.structured_arrow.post CategoryTheory.StructuredArrow.post

/- warning: category_theory.structured_arrow.small_proj_preimage_of_locally_small -> CategoryTheory.StructuredArrow.small_proj_preimage_of_locallySmall is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {𝒢 : Set.{u3} C} [_inst_5 : Small.{u1, u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} C) Type.{u3} (Set.hasCoeToSort.{u3} C) 𝒢)] [_inst_6 : CategoryTheory.LocallySmall.{u1, u2, u4} D _inst_2], Small.{u1, max u3 u2} (coeSort.{succ (max u3 u2), succ (succ (max u3 u2))} (Set.{max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T)) Type.{max u3 u2} (Set.hasCoeToSort.{max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T)) (Set.preimage.{max u3 u2, u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) C (CategoryTheory.Functor.obj.{max u2 u1, u1, max u3 u2, u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T) C _inst_1 (CategoryTheory.StructuredArrow.proj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T)) 𝒢))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {S : D} {T : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {𝒢 : Set.{u3} C} [_inst_5 : Small.{u1, u3} (Set.Elem.{u3} C 𝒢)] [_inst_6 : CategoryTheory.LocallySmall.{u1, u2, u4} D _inst_2], Small.{u1, max u3 u2} (Set.Elem.{max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (Set.preimage.{max u3 u2, u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) C (Prefunctor.obj.{max (succ u1) (succ u2), succ u1, max u3 u2, u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u1 u2, u1, max u3 u2, u3} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) C _inst_1 (CategoryTheory.StructuredArrow.proj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) 𝒢))
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow.small_proj_preimage_of_locally_small CategoryTheory.StructuredArrow.small_proj_preimage_of_locallySmallₓ'. -/
instance small_proj_preimage_of_locallySmall {𝒢 : Set C} [Small.{v₁} 𝒢] [LocallySmall.{v₁} D] :
    Small.{v₁} ((proj S T).obj ⁻¹' 𝒢) :=
  by
  suffices (proj S T).obj ⁻¹' 𝒢 = Set.range fun f : ΣG : 𝒢, S ⟶ T.obj G => mk f.2
    by
    rw [this]
    infer_instance
  exact Set.ext fun X => ⟨fun h => ⟨⟨⟨_, h⟩, X.Hom⟩, (eq_mk _).symm⟩, by tidy⟩
#align category_theory.structured_arrow.small_proj_preimage_of_locally_small CategoryTheory.StructuredArrow.small_proj_preimage_of_locallySmall

end StructuredArrow

#print CategoryTheory.CostructuredArrow /-
/-- The category of `S`-costructured arrows with target `T : D` (here `S : C ⥤ D`),
has as its objects `D`-morphisms of the form `S Y ⟶ T`, for some `Y : C`,
and morphisms `C`-morphisms `Y ⟶ Y'` making the obvious triangle commute.
-/
@[nolint has_nonempty_instance]
def CostructuredArrow (S : C ⥤ D) (T : D) :=
  Comma S (Functor.fromPUnit T)deriving Category
#align category_theory.costructured_arrow CategoryTheory.CostructuredArrow
-/

namespace CostructuredArrow

#print CategoryTheory.CostructuredArrow.proj /-
/-- The obvious projection functor from costructured arrows. -/
@[simps]
def proj (S : C ⥤ D) (T : D) : CostructuredArrow S T ⥤ C :=
  Comma.fst _ _
#align category_theory.costructured_arrow.proj CategoryTheory.CostructuredArrow.proj
-/

variable {T T' T'' : D} {Y Y' : C} {S : C ⥤ D}

/- warning: category_theory.costructured_arrow.mk -> CategoryTheory.CostructuredArrow.mk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {Y : C} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2}, (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y) T) -> (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {Y : C} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2}, (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) Y) T) -> (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T)
Case conversion may be inaccurate. Consider using '#align category_theory.costructured_arrow.mk CategoryTheory.CostructuredArrow.mkₓ'. -/
/-- Construct a costructured arrow from a morphism. -/
def mk (f : S.obj Y ⟶ T) : CostructuredArrow S T :=
  ⟨Y, ⟨⟨⟩⟩, f⟩
#align category_theory.costructured_arrow.mk CategoryTheory.CostructuredArrow.mk

/- warning: category_theory.costructured_arrow.mk_left -> CategoryTheory.CostructuredArrow.mk_left is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {Y : C} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y) T), Eq.{succ u3} C (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.CostructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y S f)) Y
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {Y : C} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) Y) T), Eq.{succ u3} C (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.CostructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y S f)) Y
Case conversion may be inaccurate. Consider using '#align category_theory.costructured_arrow.mk_left CategoryTheory.CostructuredArrow.mk_leftₓ'. -/
@[simp]
theorem mk_left (f : S.obj Y ⟶ T) : (mk f).left = Y :=
  rfl
#align category_theory.costructured_arrow.mk_left CategoryTheory.CostructuredArrow.mk_left

/- warning: category_theory.costructured_arrow.mk_right -> CategoryTheory.CostructuredArrow.mk_right is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {Y : C} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y) T), Eq.{succ u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.CostructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y S f)) (CategoryTheory.Discrete.mk.{u2} PUnit.{succ u2} PUnit.unit.{succ u2})
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {Y : C} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) Y) T), Eq.{succ u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.CostructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y S f)) (CategoryTheory.Discrete.mk.{u2} PUnit.{succ u2} PUnit.unit.{succ u2})
Case conversion may be inaccurate. Consider using '#align category_theory.costructured_arrow.mk_right CategoryTheory.CostructuredArrow.mk_rightₓ'. -/
@[simp]
theorem mk_right (f : S.obj Y ⟶ T) : (mk f).right = ⟨⟨⟩⟩ :=
  rfl
#align category_theory.costructured_arrow.mk_right CategoryTheory.CostructuredArrow.mk_right

/- warning: category_theory.costructured_arrow.mk_hom_eq_self -> CategoryTheory.CostructuredArrow.mk_hom_eq_self is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {Y : C} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y) T), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.CostructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y S f))) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.CostructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y S f)))) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.CostructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y S f)) f
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {Y : C} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) Y) T), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.CostructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y S f))) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T)) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.CostructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y S f)))) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.CostructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y S f)) f
Case conversion may be inaccurate. Consider using '#align category_theory.costructured_arrow.mk_hom_eq_self CategoryTheory.CostructuredArrow.mk_hom_eq_selfₓ'. -/
@[simp]
theorem mk_hom_eq_self (f : S.obj Y ⟶ T) : (mk f).Hom = f :=
  rfl
#align category_theory.costructured_arrow.mk_hom_eq_self CategoryTheory.CostructuredArrow.mk_hom_eq_self

/- warning: category_theory.costructured_arrow.w -> CategoryTheory.CostructuredArrow.w is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {A : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {B : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (f : Quiver.Hom.{succ (max u1 u2), max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T))) A B), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B) (CategoryTheory.CommaMorphism.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A B f)) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {A : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {B : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (f : Quiver.Hom.{max (succ u1) (succ u2), max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) A B), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T)) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T)) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B) (CategoryTheory.CommaMorphism.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A B f)) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)
Case conversion may be inaccurate. Consider using '#align category_theory.costructured_arrow.w CategoryTheory.CostructuredArrow.wₓ'. -/
@[simp, reassoc.1]
theorem w {A B : CostructuredArrow S T} (f : A ⟶ B) : S.map f.left ≫ B.Hom = A.Hom := by tidy
#align category_theory.costructured_arrow.w CategoryTheory.CostructuredArrow.w

/- warning: category_theory.costructured_arrow.hom_mk -> CategoryTheory.CostructuredArrow.homMk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {f' : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (g : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f')), (Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f)) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f'))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f')) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f')) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f') g) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f')) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f)) -> (Quiver.Hom.{succ (max u1 u2), max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T))) f f')
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {f' : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (g : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f')), (Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f)) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T)) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f'))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f')) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T)) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f')) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f') g) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f')) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f)) -> (Quiver.Hom.{max (succ u1) (succ u2), max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) f f')
Case conversion may be inaccurate. Consider using '#align category_theory.costructured_arrow.hom_mk CategoryTheory.CostructuredArrow.homMkₓ'. -/
/-- To construct a morphism of costructured arrows,
we need a morphism of the objects underlying the source,
and to check that the triangle commutes.
-/
@[simps]
def homMk {f f' : CostructuredArrow S T} (g : f.left ⟶ f'.left) (w : S.map g ≫ f'.Hom = f.Hom) :
    f ⟶ f' where
  left := g
  right := eqToHom (by ext)
  w' := by simpa [eq_to_hom_map] using w
#align category_theory.costructured_arrow.hom_mk CategoryTheory.CostructuredArrow.homMk

/- warning: category_theory.costructured_arrow.iso_mk -> CategoryTheory.CostructuredArrow.isoMk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {f' : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (g : CategoryTheory.Iso.{u1, u3} C _inst_1 (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f')), (Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f)) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f'))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f')) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f')) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f') (CategoryTheory.Iso.hom.{u1, u3} C _inst_1 (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f') g)) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f')) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f)) -> (CategoryTheory.Iso.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.commaCategory.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T)) f f')
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {f' : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (g : CategoryTheory.Iso.{u1, u3} C _inst_1 (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f')), (Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f)) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T)) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f'))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f')) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T)) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f')) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f') (CategoryTheory.Iso.hom.{u1, u3} C _inst_1 (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f') g)) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f')) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) f)) -> (CategoryTheory.Iso.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) f f')
Case conversion may be inaccurate. Consider using '#align category_theory.costructured_arrow.iso_mk CategoryTheory.CostructuredArrow.isoMkₓ'. -/
/-- To construct an isomorphism of costructured arrows,
we need an isomorphism of the objects underlying the source,
and to check that the triangle commutes.
-/
@[simps]
def isoMk {f f' : CostructuredArrow S T} (g : f.left ≅ f'.left) (w : S.map g.Hom ≫ f'.Hom = f.Hom) :
    f ≅ f' :=
  Comma.isoMk g (eqToIso (by ext)) (by simpa [eq_to_hom_map] using w)
#align category_theory.costructured_arrow.iso_mk CategoryTheory.CostructuredArrow.isoMk

#print CategoryTheory.CostructuredArrow.ext /-
theorem ext {A B : CostructuredArrow S T} (f g : A ⟶ B) (h : f.left = g.left) : f = g :=
  CommaMorphism.ext _ _ h (Subsingleton.elim _ _)
#align category_theory.costructured_arrow.ext CategoryTheory.CostructuredArrow.ext
-/

#print CategoryTheory.CostructuredArrow.ext_iff /-
theorem ext_iff {A B : CostructuredArrow S T} (f g : A ⟶ B) : f = g ↔ f.left = g.left :=
  ⟨fun h => h ▸ rfl, ext f g⟩
#align category_theory.costructured_arrow.ext_iff CategoryTheory.CostructuredArrow.ext_iff
-/

#print CategoryTheory.CostructuredArrow.proj_faithful /-
instance proj_faithful : Faithful (proj S T) where map_injective' X Y := ext
#align category_theory.costructured_arrow.proj_faithful CategoryTheory.CostructuredArrow.proj_faithful
-/

#print CategoryTheory.CostructuredArrow.mono_of_mono_left /-
theorem mono_of_mono_left {A B : CostructuredArrow S T} (f : A ⟶ B) [h : Mono f.left] : Mono f :=
  (proj S T).mono_of_mono_map h
#align category_theory.costructured_arrow.mono_of_mono_left CategoryTheory.CostructuredArrow.mono_of_mono_left
-/

#print CategoryTheory.CostructuredArrow.epi_of_epi_left /-
/-- The converse of this is true with additional assumptions, see `epi_iff_epi_left`. -/
theorem epi_of_epi_left {A B : CostructuredArrow S T} (f : A ⟶ B) [h : Epi f.left] : Epi f :=
  (proj S T).epi_of_epi_map h
#align category_theory.costructured_arrow.epi_of_epi_left CategoryTheory.CostructuredArrow.epi_of_epi_left
-/

/- warning: category_theory.costructured_arrow.mono_hom_mk -> CategoryTheory.CostructuredArrow.mono_homMk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {A : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {B : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (w : Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B) f) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)) [h : CategoryTheory.Mono.{u1, u3} C _inst_1 (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B) f], CategoryTheory.Mono.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T) A B (CategoryTheory.CostructuredArrow.homMk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T S A B f w)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {A : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {B : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (w : Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T)) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T)) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B) f) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)) [h : CategoryTheory.Mono.{u1, u3} C _inst_1 (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B) f], CategoryTheory.Mono.{max u2 u1, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) A B (CategoryTheory.CostructuredArrow.homMk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T S A B f w)
Case conversion may be inaccurate. Consider using '#align category_theory.costructured_arrow.mono_hom_mk CategoryTheory.CostructuredArrow.mono_homMkₓ'. -/
instance mono_homMk {A B : CostructuredArrow S T} (f : A.left ⟶ B.left) (w) [h : Mono f] :
    Mono (homMk f w) :=
  (proj S T).mono_of_mono_map h
#align category_theory.costructured_arrow.mono_hom_mk CategoryTheory.CostructuredArrow.mono_homMk

/- warning: category_theory.costructured_arrow.epi_hom_mk -> CategoryTheory.CostructuredArrow.epi_homMk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {A : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {B : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (w : Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (CategoryTheory.Functor.obj.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B) f) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)) [h : CategoryTheory.Epi.{u1, u3} C _inst_1 (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B) f], CategoryTheory.Epi.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T) A B (CategoryTheory.CostructuredArrow.homMk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T S A B f w)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {A : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} {B : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T} (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (w : Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T)) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (Prefunctor.obj.{succ u2, succ u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.CategoryStruct.toQuiver.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.Category.toCategoryStruct.{u2, u2} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}))) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u2, u4} (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T)) (CategoryTheory.Comma.right.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B) f) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B)) (CategoryTheory.Comma.hom.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A)) [h : CategoryTheory.Epi.{u1, u3} C _inst_1 (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) A) (CategoryTheory.Comma.left.{u1, u2, u2, u3, u2, u4} C _inst_1 (CategoryTheory.Discrete.{u2} PUnit.{succ u2}) (CategoryTheory.discreteCategory.{u2} PUnit.{succ u2}) D _inst_2 S (CategoryTheory.Functor.fromPUnit.{u2, u4} D _inst_2 T) B) f], CategoryTheory.Epi.{max u2 u1, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) A B (CategoryTheory.CostructuredArrow.homMk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T S A B f w)
Case conversion may be inaccurate. Consider using '#align category_theory.costructured_arrow.epi_hom_mk CategoryTheory.CostructuredArrow.epi_homMkₓ'. -/
instance epi_homMk {A B : CostructuredArrow S T} (f : A.left ⟶ B.left) (w) [h : Epi f] :
    Epi (homMk f w) :=
  (proj S T).epi_of_epi_map h
#align category_theory.costructured_arrow.epi_hom_mk CategoryTheory.CostructuredArrow.epi_homMk

#print CategoryTheory.CostructuredArrow.eq_mk /-
/-- Eta rule for costructured arrows. Prefer `costructured_arrow.eta`, as equality of objects tends
    to cause problems. -/
theorem eq_mk (f : CostructuredArrow S T) : f = mk f.Hom :=
  by
  cases f
  congr
  ext
#align category_theory.costructured_arrow.eq_mk CategoryTheory.CostructuredArrow.eq_mk
-/

#print CategoryTheory.CostructuredArrow.eta /-
/-- Eta rule for costructured arrows. -/
@[simps]
def eta (f : CostructuredArrow S T) : f ≅ mk f.Hom :=
  isoMk (Iso.refl _) (by tidy)
#align category_theory.costructured_arrow.eta CategoryTheory.CostructuredArrow.eta
-/

#print CategoryTheory.CostructuredArrow.map /-
/-- A morphism between target objects `T ⟶ T'`
covariantly induces a functor between costructured arrows,
`costructured_arrow S T ⥤ costructured_arrow S T'`.

Ideally this would be described as a 2-functor from `D`
(promoted to a 2-category with equations as 2-morphisms)
to `Cat`.
-/
@[simps]
def map (f : T ⟶ T') : CostructuredArrow S T ⥤ CostructuredArrow S T' :=
  Comma.mapRight _ ((Functor.const _).map f)
#align category_theory.costructured_arrow.map CategoryTheory.CostructuredArrow.map
-/

/- warning: category_theory.costructured_arrow.map_mk -> CategoryTheory.CostructuredArrow.map_mk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {T' : D} {Y : C} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y) T} (g : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) T T'), Eq.{succ (max u3 u2)} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, max u3 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T') (CategoryTheory.CostructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 T T' S g) (CategoryTheory.CostructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y S f)) (CategoryTheory.CostructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T' Y S (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y) T T' f g))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {T' : D} {Y : C} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) Y) T} (g : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) T T'), Eq.{max (succ u3) (succ u2)} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u3, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u3, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.CostructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 T T' S g)) (CategoryTheory.CostructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T Y S f)) (CategoryTheory.CostructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 T' Y S (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) Y) T T' f g))
Case conversion may be inaccurate. Consider using '#align category_theory.costructured_arrow.map_mk CategoryTheory.CostructuredArrow.map_mkₓ'. -/
@[simp]
theorem map_mk {f : S.obj Y ⟶ T} (g : T ⟶ T') : (map g).obj (mk f) = mk (f ≫ g) :=
  rfl
#align category_theory.costructured_arrow.map_mk CategoryTheory.CostructuredArrow.map_mk

/- warning: category_theory.costructured_arrow.map_id -> CategoryTheory.CostructuredArrow.map_id is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T}, Eq.{succ (max u3 u2)} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, max u3 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 T T S (CategoryTheory.CategoryStruct.id.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) T)) f) f
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T}, Eq.{max (succ u3) (succ u2)} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u3, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u3, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 T T S (CategoryTheory.CategoryStruct.id.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) T))) f) f
Case conversion may be inaccurate. Consider using '#align category_theory.costructured_arrow.map_id CategoryTheory.CostructuredArrow.map_idₓ'. -/
@[simp]
theorem map_id {f : CostructuredArrow S T} : (map (𝟙 T)).obj f = f :=
  by
  rw [eq_mk f]
  simp
#align category_theory.costructured_arrow.map_id CategoryTheory.CostructuredArrow.map_id

/- warning: category_theory.costructured_arrow.map_comp -> CategoryTheory.CostructuredArrow.map_comp is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {T' : D} {T'' : D} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) T T'} {f' : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) T' T''} {h : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T}, Eq.{succ (max u3 u2)} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'') (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, max u3 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'') (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T'') (CategoryTheory.CostructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 T T'' S (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) T T' T'' f f')) h) (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, max u3 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T') (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'') (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T'') (CategoryTheory.CostructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 T' T'' S f') (CategoryTheory.Functor.obj.{max u1 u2, max u1 u2, max u3 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T') (CategoryTheory.CostructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 T T' S f) h))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {T' : D} {T'' : D} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {f : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) T T'} {f' : Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) T' T''} {h : CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T}, Eq.{max (succ u3) (succ u2)} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'') (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u3, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'') (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'') (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'') (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T''))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u3, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'') (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'') (CategoryTheory.CostructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 T T'' S (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) T T' T'' f f'))) h) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u3, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'))) (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'') (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'') (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'') (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T''))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u3, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'') (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'') (CategoryTheory.CostructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 T' T'' S f')) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u3, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T'))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u3, max u2 u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T') (CategoryTheory.CostructuredArrow.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 T T' S f)) h))
Case conversion may be inaccurate. Consider using '#align category_theory.costructured_arrow.map_comp CategoryTheory.CostructuredArrow.map_compₓ'. -/
@[simp]
theorem map_comp {f : T ⟶ T'} {f' : T' ⟶ T''} {h : CostructuredArrow S T} :
    (map (f ≫ f')).obj h = (map f').obj ((map f).obj h) :=
  by
  rw [eq_mk h]
  simp
#align category_theory.costructured_arrow.map_comp CategoryTheory.CostructuredArrow.map_comp

#print CategoryTheory.CostructuredArrow.proj_reflects_iso /-
instance proj_reflects_iso : ReflectsIsomorphisms (proj S T)
    where reflects Y Z f t :=
    ⟨⟨costructured_arrow.hom_mk (inv ((proj S T).map f)) (by simp), by tidy⟩⟩
#align category_theory.costructured_arrow.proj_reflects_iso CategoryTheory.CostructuredArrow.proj_reflects_iso
-/

open CategoryTheory.Limits

attribute [local tidy] tactic.discrete_cases

/- warning: category_theory.costructured_arrow.mk_id_terminal -> CategoryTheory.CostructuredArrow.mkIdTerminal is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {Y : C} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} [_inst_3 : CategoryTheory.Full.{u1, u2, u3, u4} C _inst_1 D _inst_2 S] [_inst_4 : CategoryTheory.Faithful.{u1, u2, u3, u4} C _inst_1 D _inst_2 S], CategoryTheory.Limits.IsTerminal.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y)) (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y)) (CategoryTheory.CostructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y) Y S (CategoryTheory.CategoryStruct.id.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S Y)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {Y : C} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} [_inst_3 : CategoryTheory.Full.{u1, u2, u3, u4} C _inst_1 D _inst_2 S] [_inst_4 : CategoryTheory.Faithful.{u1, u2, u3, u4} C _inst_1 D _inst_2 S], CategoryTheory.Limits.IsTerminal.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) Y)) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) Y)) (CategoryTheory.CostructuredArrow.mk.{u1, u2, u3, u4} C _inst_1 D _inst_2 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) Y) Y S (CategoryTheory.CategoryStruct.id.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 S) Y)))
Case conversion may be inaccurate. Consider using '#align category_theory.costructured_arrow.mk_id_terminal CategoryTheory.CostructuredArrow.mkIdTerminalₓ'. -/
/-- The identity costructured arrow is terminal. -/
def mkIdTerminal [Full S] [Faithful S] : IsTerminal (mk (𝟙 (S.obj Y)))
    where
  lift c :=
    homMk (S.preimage c.pt.Hom)
      (by
        dsimp
        simp)
  uniq := by
    rintro c m -
    ext
    apply S.map_injective
    simpa only [hom_mk_left, S.image_preimage, ← w m] using (category.comp_id _).symm
#align category_theory.costructured_arrow.mk_id_terminal CategoryTheory.CostructuredArrow.mkIdTerminal

variable {A : Type u₃} [Category.{v₃} A] {B : Type u₄} [Category.{v₄} B]

#print CategoryTheory.CostructuredArrow.pre /-
/-- The functor `(F ⋙ G, S) ⥤ (G, S)`. -/
@[simps]
def pre (F : B ⥤ C) (G : C ⥤ D) (S : D) : CostructuredArrow (F ⋙ G) S ⥤ CostructuredArrow G S :=
  Comma.preLeft F G _
#align category_theory.costructured_arrow.pre CategoryTheory.CostructuredArrow.pre
-/

/- warning: category_theory.costructured_arrow.post -> CategoryTheory.CostructuredArrow.post is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u1, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u2, u5} D] {B : Type.{u6}} [_inst_4 : CategoryTheory.Category.{u3, u6} B] (F : CategoryTheory.Functor.{u3, u1, u6, u4} B _inst_4 C _inst_1) (G : CategoryTheory.Functor.{u1, u2, u4, u5} C _inst_1 D _inst_2) (S : C), CategoryTheory.Functor.{max u3 u1, max u3 u2, max u6 u1, max u6 u2} (CategoryTheory.CostructuredArrow.{u3, u1, u6, u4} B _inst_4 C _inst_1 F S) (CategoryTheory.CostructuredArrow.category.{u1, u4, u6, u3} B _inst_4 C _inst_1 F S) (CategoryTheory.CostructuredArrow.{u3, u2, u6, u5} B _inst_4 D _inst_2 (CategoryTheory.Functor.comp.{u3, u1, u2, u6, u4, u5} B _inst_4 C _inst_1 D _inst_2 F G) (CategoryTheory.Functor.obj.{u1, u2, u4, u5} C _inst_1 D _inst_2 G S)) (CategoryTheory.CostructuredArrow.category.{u2, u5, u6, u3} B _inst_4 D _inst_2 (CategoryTheory.Functor.comp.{u3, u1, u2, u6, u4, u5} B _inst_4 C _inst_1 D _inst_2 F G) (CategoryTheory.Functor.obj.{u1, u2, u4, u5} C _inst_1 D _inst_2 G S))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u1, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u2, u5} D] {B : Type.{u6}} [_inst_4 : CategoryTheory.Category.{u3, u6} B] (F : CategoryTheory.Functor.{u3, u1, u6, u4} B _inst_4 C _inst_1) (G : CategoryTheory.Functor.{u1, u2, u4, u5} C _inst_1 D _inst_2) (S : C), CategoryTheory.Functor.{max u1 u3, max u2 u3, max u6 u1, max u6 u2} (CategoryTheory.CostructuredArrow.{u3, u1, u6, u4} B _inst_4 C _inst_1 F S) (CategoryTheory.instCategoryCostructuredArrow.{u3, u1, u6, u4} B _inst_4 C _inst_1 F S) (CategoryTheory.CostructuredArrow.{u3, u2, u6, u5} B _inst_4 D _inst_2 (CategoryTheory.Functor.comp.{u3, u1, u2, u6, u4, u5} B _inst_4 C _inst_1 D _inst_2 F G) (Prefunctor.obj.{succ u1, succ u2, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u4} C (CategoryTheory.Category.toCategoryStruct.{u1, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u5} D (CategoryTheory.Category.toCategoryStruct.{u2, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u4, u5} C _inst_1 D _inst_2 G) S)) (CategoryTheory.instCategoryCostructuredArrow.{u3, u2, u6, u5} B _inst_4 D _inst_2 (CategoryTheory.Functor.comp.{u3, u1, u2, u6, u4, u5} B _inst_4 C _inst_1 D _inst_2 F G) (Prefunctor.obj.{succ u1, succ u2, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u4} C (CategoryTheory.Category.toCategoryStruct.{u1, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u5} D (CategoryTheory.Category.toCategoryStruct.{u2, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u4, u5} C _inst_1 D _inst_2 G) S))
Case conversion may be inaccurate. Consider using '#align category_theory.costructured_arrow.post CategoryTheory.CostructuredArrow.postₓ'. -/
/-- The functor `(F, S) ⥤ (F ⋙ G, G(S))`. -/
@[simps]
def post (F : B ⥤ C) (G : C ⥤ D) (S : C) :
    CostructuredArrow F S ⥤ CostructuredArrow (F ⋙ G) (G.obj S)
    where
  obj X := CostructuredArrow.mk (G.map X.Hom)
  map X Y f := CostructuredArrow.homMk f.left (by simp [functor.comp_map, ← G.map_comp, ← f.w])
#align category_theory.costructured_arrow.post CategoryTheory.CostructuredArrow.post

/- warning: category_theory.costructured_arrow.small_proj_preimage_of_locally_small -> CategoryTheory.CostructuredArrow.small_proj_preimage_of_locallySmall is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {𝒢 : Set.{u3} C} [_inst_5 : Small.{u1, u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} C) Type.{u3} (Set.hasCoeToSort.{u3} C) 𝒢)] [_inst_6 : CategoryTheory.LocallySmall.{u1, u2, u4} D _inst_2], Small.{u1, max u3 u2} (coeSort.{succ (max u3 u2), succ (succ (max u3 u2))} (Set.{max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T)) Type.{max u3 u2} (Set.hasCoeToSort.{max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T)) (Set.preimage.{max u3 u2, u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) C (CategoryTheory.Functor.obj.{max u1 u2, u1, max u3 u2, u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 S T) C _inst_1 (CategoryTheory.CostructuredArrow.proj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T)) 𝒢))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {T : D} {S : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {𝒢 : Set.{u3} C} [_inst_5 : Small.{u1, u3} (Set.Elem.{u3} C 𝒢)] [_inst_6 : CategoryTheory.LocallySmall.{u1, u2, u4} D _inst_2], Small.{u1, max u3 u2} (Set.Elem.{max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (Set.preimage.{max u3 u2, u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) C (Prefunctor.obj.{max (succ u1) (succ u2), succ u1, max u3 u2, u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u1 u2, u1, max u3 u2, u3} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T) C _inst_1 (CategoryTheory.CostructuredArrow.proj.{u1, u2, u3, u4} C _inst_1 D _inst_2 S T))) 𝒢))
Case conversion may be inaccurate. Consider using '#align category_theory.costructured_arrow.small_proj_preimage_of_locally_small CategoryTheory.CostructuredArrow.small_proj_preimage_of_locallySmallₓ'. -/
instance small_proj_preimage_of_locallySmall {𝒢 : Set C} [Small.{v₁} 𝒢] [LocallySmall.{v₁} D] :
    Small.{v₁} ((proj S T).obj ⁻¹' 𝒢) :=
  by
  suffices (proj S T).obj ⁻¹' 𝒢 = Set.range fun f : ΣG : 𝒢, S.obj G ⟶ T => mk f.2
    by
    rw [this]
    infer_instance
  exact Set.ext fun X => ⟨fun h => ⟨⟨⟨_, h⟩, X.Hom⟩, (eq_mk _).symm⟩, by tidy⟩
#align category_theory.costructured_arrow.small_proj_preimage_of_locally_small CategoryTheory.CostructuredArrow.small_proj_preimage_of_locallySmall

end CostructuredArrow

open Opposite

namespace StructuredArrow

#print CategoryTheory.StructuredArrow.toCostructuredArrow /-
/-- For a functor `F : C ⥤ D` and an object `d : D`, we obtain a contravariant functor from the
category of structured arrows `d ⟶ F.obj c` to the category of costructured arrows
`F.op.obj c ⟶ (op d)`.
-/
@[simps]
def toCostructuredArrow (F : C ⥤ D) (d : D) :
    (StructuredArrow d F)ᵒᵖ ⥤ CostructuredArrow F.op (op d)
    where
  obj X := @CostructuredArrow.mk _ _ _ _ _ (op X.unop.right) F.op X.unop.Hom.op
  map X Y f :=
    CostructuredArrow.homMk f.unop.right.op
      (by
        dsimp
        rw [← op_comp, ← f.unop.w, functor.const_obj_map]
        erw [category.id_comp])
#align category_theory.structured_arrow.to_costructured_arrow CategoryTheory.StructuredArrow.toCostructuredArrow
-/

#print CategoryTheory.StructuredArrow.toCostructuredArrow' /-
/-- For a functor `F : C ⥤ D` and an object `d : D`, we obtain a contravariant functor from the
category of structured arrows `op d ⟶ F.op.obj c` to the category of costructured arrows
`F.obj c ⟶ d`.
-/
@[simps]
def toCostructuredArrow' (F : C ⥤ D) (d : D) :
    (StructuredArrow (op d) F.op)ᵒᵖ ⥤ CostructuredArrow F d
    where
  obj X := @CostructuredArrow.mk _ _ _ _ _ (unop X.unop.right) F X.unop.Hom.unop
  map X Y f :=
    CostructuredArrow.homMk f.unop.right.unop
      (by
        dsimp
        rw [← Quiver.Hom.unop_op (F.map (Quiver.Hom.unop f.unop.right)), ← unop_comp, ← F.op_map, ←
          f.unop.w, functor.const_obj_map]
        erw [category.id_comp])
#align category_theory.structured_arrow.to_costructured_arrow' CategoryTheory.StructuredArrow.toCostructuredArrow'
-/

end StructuredArrow

namespace CostructuredArrow

#print CategoryTheory.CostructuredArrow.toStructuredArrow /-
/-- For a functor `F : C ⥤ D` and an object `d : D`, we obtain a contravariant functor from the
category of costructured arrows `F.obj c ⟶ d` to the category of structured arrows
`op d ⟶ F.op.obj c`.
-/
@[simps]
def toStructuredArrow (F : C ⥤ D) (d : D) : (CostructuredArrow F d)ᵒᵖ ⥤ StructuredArrow (op d) F.op
    where
  obj X := @StructuredArrow.mk _ _ _ _ _ (op X.unop.left) F.op X.unop.Hom.op
  map X Y f :=
    StructuredArrow.homMk f.unop.left.op
      (by
        dsimp
        rw [← op_comp, f.unop.w, functor.const_obj_map]
        erw [category.comp_id])
#align category_theory.costructured_arrow.to_structured_arrow CategoryTheory.CostructuredArrow.toStructuredArrow
-/

#print CategoryTheory.CostructuredArrow.toStructuredArrow' /-
/-- For a functor `F : C ⥤ D` and an object `d : D`, we obtain a contravariant functor from the
category of costructured arrows `F.op.obj c ⟶ op d` to the category of structured arrows
`d ⟶ F.obj c`.
-/
@[simps]
def toStructuredArrow' (F : C ⥤ D) (d : D) : (CostructuredArrow F.op (op d))ᵒᵖ ⥤ StructuredArrow d F
    where
  obj X := @StructuredArrow.mk _ _ _ _ _ (unop X.unop.left) F X.unop.Hom.unop
  map X Y f :=
    StructuredArrow.homMk f.unop.left.unop
      (by
        dsimp
        rw [← Quiver.Hom.unop_op (F.map f.unop.left.unop), ← unop_comp, ← F.op_map, f.unop.w,
          functor.const_obj_map]
        erw [category.comp_id])
#align category_theory.costructured_arrow.to_structured_arrow' CategoryTheory.CostructuredArrow.toStructuredArrow'
-/

end CostructuredArrow

/- warning: category_theory.structured_arrow_op_equivalence -> CategoryTheory.structuredArrowOpEquivalence is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (d : D), CategoryTheory.Equivalence.{max u2 u1, max u1 u2, max u3 u2, max u3 u2} (Opposite.{succ (max u3 u2)} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 d F)) (CategoryTheory.Category.opposite.{max u2 u1, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 d F) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 d F)) (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u1, u3} C _inst_1) (Opposite.{succ u4} D) (CategoryTheory.Category.opposite.{u2, u4} D _inst_2) (CategoryTheory.Functor.op.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (Opposite.op.{succ u4} D d)) (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u1, u3} C _inst_1) (Opposite.{succ u4} D) (CategoryTheory.Category.opposite.{u2, u4} D _inst_2) (CategoryTheory.Functor.op.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (Opposite.op.{succ u4} D d))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (d : D), CategoryTheory.Equivalence.{max u1 u2, max u1 u2, max u3 u2, max u3 u2} (Opposite.{succ (max u3 u2)} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 d F)) (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u1, u3} C _inst_1) (Opposite.{succ u4} D) (CategoryTheory.Category.opposite.{u2, u4} D _inst_2) (CategoryTheory.Functor.op.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (Opposite.op.{succ u4} D d)) (CategoryTheory.Category.opposite.{max u1 u2, max u3 u2} (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 d F) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 d F)) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u1, u3} C _inst_1) (Opposite.{succ u4} D) (CategoryTheory.Category.opposite.{u2, u4} D _inst_2) (CategoryTheory.Functor.op.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (Opposite.op.{succ u4} D d))
Case conversion may be inaccurate. Consider using '#align category_theory.structured_arrow_op_equivalence CategoryTheory.structuredArrowOpEquivalenceₓ'. -/
/-- For a functor `F : C ⥤ D` and an object `d : D`, the category of structured arrows `d ⟶ F.obj c`
is contravariantly equivalent to the category of costructured arrows `F.op.obj c ⟶ op d`.
-/
def structuredArrowOpEquivalence (F : C ⥤ D) (d : D) :
    (StructuredArrow d F)ᵒᵖ ≌ CostructuredArrow F.op (op d) :=
  Equivalence.mk (StructuredArrow.toCostructuredArrow F d)
    (CostructuredArrow.toStructuredArrow' F d).rightOp
    (NatIso.ofComponents
      (fun X =>
        (@StructuredArrow.isoMk _ _ _ _ _ _ (StructuredArrow.mk (unop X).Hom) (unop X) (Iso.refl _)
            (by tidy)).op)
      fun X Y f => Quiver.Hom.unop_inj <| by ext; dsimp; simp)
    (NatIso.ofComponents
      (fun X =>
        @CostructuredArrow.isoMk _ _ _ _ _ _ (CostructuredArrow.mk X.Hom) X (Iso.refl _) (by tidy))
      fun X Y f => by ext; dsimp; simp)
#align category_theory.structured_arrow_op_equivalence CategoryTheory.structuredArrowOpEquivalence

/- warning: category_theory.costructured_arrow_op_equivalence -> CategoryTheory.costructuredArrowOpEquivalence is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (d : D), CategoryTheory.Equivalence.{max u1 u2, max u2 u1, max u3 u2, max u3 u2} (Opposite.{succ (max u3 u2)} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 F d)) (CategoryTheory.Category.opposite.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 F d) (CategoryTheory.CostructuredArrow.category.{u2, u4, u3, u1} C _inst_1 D _inst_2 F d)) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u1, u3} C _inst_1) (Opposite.{succ u4} D) (CategoryTheory.Category.opposite.{u2, u4} D _inst_2) (Opposite.op.{succ u4} D d) (CategoryTheory.Functor.op.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (CategoryTheory.StructuredArrow.category.{u2, u4, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u1, u3} C _inst_1) (Opposite.{succ u4} D) (CategoryTheory.Category.opposite.{u2, u4} D _inst_2) (Opposite.op.{succ u4} D d) (CategoryTheory.Functor.op.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (d : D), CategoryTheory.Equivalence.{max u1 u2, max u1 u2, max u3 u2, max u3 u2} (Opposite.{succ (max u3 u2)} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 F d)) (CategoryTheory.StructuredArrow.{u1, u2, u3, u4} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u1, u3} C _inst_1) (Opposite.{succ u4} D) (CategoryTheory.Category.opposite.{u2, u4} D _inst_2) (Opposite.op.{succ u4} D d) (CategoryTheory.Functor.op.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (CategoryTheory.Category.opposite.{max u1 u2, max u3 u2} (CategoryTheory.CostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 F d) (CategoryTheory.instCategoryCostructuredArrow.{u1, u2, u3, u4} C _inst_1 D _inst_2 F d)) (CategoryTheory.instCategoryStructuredArrow.{u1, u2, u3, u4} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u1, u3} C _inst_1) (Opposite.{succ u4} D) (CategoryTheory.Category.opposite.{u2, u4} D _inst_2) (Opposite.op.{succ u4} D d) (CategoryTheory.Functor.op.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))
Case conversion may be inaccurate. Consider using '#align category_theory.costructured_arrow_op_equivalence CategoryTheory.costructuredArrowOpEquivalenceₓ'. -/
/-- For a functor `F : C ⥤ D` and an object `d : D`, the category of costructured arrows
`F.obj c ⟶ d` is contravariantly equivalent to the category of structured arrows
`op d ⟶ F.op.obj c`.
-/
def costructuredArrowOpEquivalence (F : C ⥤ D) (d : D) :
    (CostructuredArrow F d)ᵒᵖ ≌ StructuredArrow (op d) F.op :=
  Equivalence.mk (CostructuredArrow.toStructuredArrow F d)
    (StructuredArrow.toCostructuredArrow' F d).rightOp
    (NatIso.ofComponents
      (fun X =>
        (@CostructuredArrow.isoMk _ _ _ _ _ _ (CostructuredArrow.mk (unop X).Hom) (unop X)
            (Iso.refl _) (by tidy)).op)
      fun X Y f => Quiver.Hom.unop_inj <| by ext; dsimp; simp)
    (NatIso.ofComponents
      (fun X =>
        @StructuredArrow.isoMk _ _ _ _ _ _ (StructuredArrow.mk X.Hom) X (Iso.refl _) (by tidy))
      fun X Y f => by ext; dsimp; simp)
#align category_theory.costructured_arrow_op_equivalence CategoryTheory.costructuredArrowOpEquivalence

end CategoryTheory

