import Mathbin.CategoryTheory.Monoidal.Braided 
import Mathbin.CategoryTheory.Limits.Shapes.BinaryProducts 
import Mathbin.CategoryTheory.Limits.Shapes.Terminal 
import Mathbin.CategoryTheory.Pempty

/-!
# The monoidal structure on a category with chosen finite products.

This is a variant of the development in `category_theory.monoidal.of_has_finite_products`,
which uses specified choices of the terminal object and binary product,
enabling the construction of a cartesian category with specific definitions of the tensor unit
and tensor product.

(Because the construction in `category_theory.monoidal.of_has_finite_products` uses `has_limit`
classes, the actual definitions there are opaque behind `classical.choice`.)

We use this in `category_theory.monoidal.types` to construct the monoidal category of types
so that the tensor product is the usual cartesian product of types.

For now we only do the construction from products, and not from coproducts,
which seems less often useful.
-/


universe v u

noncomputable theory

namespace CategoryTheory

variable(C : Type u)[category.{v} C]{X Y : C}

namespace Limits

section 

variable{C}

/-- Swap the two sides of a `binary_fan`. -/
def binary_fan.swap {P Q : C} (t : binary_fan P Q) : binary_fan Q P :=
  binary_fan.mk t.snd t.fst

@[simp]
theorem binary_fan.swap_fst {P Q : C} (t : binary_fan P Q) : t.swap.fst = t.snd :=
  rfl

@[simp]
theorem binary_fan.swap_snd {P Q : C} (t : binary_fan P Q) : t.swap.snd = t.fst :=
  rfl

-- error in CategoryTheory.Monoidal.OfChosenFiniteProducts: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/--
If a cone `t` over `P Q` is a limit cone, then `t.swap` is a limit cone over `Q P`.
-/ @[simps #[]] def is_limit.swap_binary_fan {P Q : C} {t : binary_fan P Q} (I : is_limit t) : is_limit t.swap :=
{ lift := Œª s, I.lift (binary_fan.swap s),
  fac' := Œª s, by { rintro ["‚ü®", "‚ü©"]; simp [] [] [] [] [] [] },
  uniq' := Œª s m w, begin
    have [ident h] [] [":=", expr I.uniq (binary_fan.swap s) m],
    rw [expr h] [],
    intro [ident j],
    specialize [expr w j.swap],
    cases [expr j] []; exact [expr w]
  end }

/--
Construct `has_binary_product Q P` from `has_binary_product P Q`.
This can't be an instance, as it would cause a loop in typeclass search.
-/
theorem has_binary_product.swap (P Q : C) [has_binary_product P Q] : has_binary_product Q P :=
  has_limit.mk ‚ü®binary_fan.swap (limit.cone (pair P Q)), (limit.is_limit (pair P Q)).swapBinaryFan‚ü©

/--
Given a limit cone over `X` and `Y`, and another limit cone over `Y` and `X`, we can construct
an isomorphism between the cone points. Relative to some fixed choice of limits cones for every
pair, these isomorphisms constitute a braiding.
-/
def binary_fan.braiding {X Y : C} {s : binary_fan X Y} (P : is_limit s) {t : binary_fan Y X} (Q : is_limit t) :
  s.X ‚âÖ t.X :=
  is_limit.cone_point_unique_up_to_iso P Q.swap_binary_fan

/--
Given binary fans `sXY` over `X Y`, and `sYZ` over `Y Z`, and `s` over `sXY.X Z`,
if `sYZ` is a limit cone we can construct a binary fan over `X sYZ.X`.

This is an ingredient of building the associator for a cartesian category.
-/
def binary_fan.assoc {X Y Z : C} {sXY : binary_fan X Y} {sYZ : binary_fan Y Z} (Q : is_limit sYZ)
  (s : binary_fan sXY.X Z) : binary_fan X sYZ.X :=
  binary_fan.mk (s.fst ‚â´ sXY.fst) (Q.lift (binary_fan.mk (s.fst ‚â´ sXY.snd) s.snd))

@[simp]
theorem binary_fan.assoc_fst {X Y Z : C} {sXY : binary_fan X Y} {sYZ : binary_fan Y Z} (Q : is_limit sYZ)
  (s : binary_fan sXY.X Z) : (s.assoc Q).fst = s.fst ‚â´ sXY.fst :=
  rfl

@[simp]
theorem binary_fan.assoc_snd {X Y Z : C} {sXY : binary_fan X Y} {sYZ : binary_fan Y Z} (Q : is_limit sYZ)
  (s : binary_fan sXY.X Z) : (s.assoc Q).snd = Q.lift (binary_fan.mk (s.fst ‚â´ sXY.snd) s.snd) :=
  rfl

/--
Given binary fans `sXY` over `X Y`, and `sYZ` over `Y Z`, and `s` over `X sYZ.X`,
if `sYZ` is a limit cone we can construct a binary fan over `sXY.X Z`.

This is an ingredient of building the associator for a cartesian category.
-/
def binary_fan.assoc_inv {X Y Z : C} {sXY : binary_fan X Y} (P : is_limit sXY) {sYZ : binary_fan Y Z}
  (s : binary_fan X sYZ.X) : binary_fan sXY.X Z :=
  binary_fan.mk (P.lift (binary_fan.mk s.fst (s.snd ‚â´ sYZ.fst))) (s.snd ‚â´ sYZ.snd)

@[simp]
theorem binary_fan.assoc_inv_fst {X Y Z : C} {sXY : binary_fan X Y} (P : is_limit sXY) {sYZ : binary_fan Y Z}
  (s : binary_fan X sYZ.X) : (s.assoc_inv P).fst = P.lift (binary_fan.mk s.fst (s.snd ‚â´ sYZ.fst)) :=
  rfl

@[simp]
theorem binary_fan.assoc_inv_snd {X Y Z : C} {sXY : binary_fan X Y} (P : is_limit sXY) {sYZ : binary_fan Y Z}
  (s : binary_fan X sYZ.X) : (s.assoc_inv P).snd = s.snd ‚â´ sYZ.snd :=
  rfl

-- error in CategoryTheory.Monoidal.OfChosenFiniteProducts: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/--
If all the binary fans involved a limit cones, `binary_fan.assoc` produces another limit cone.
-/
@[simps #[]]
def is_limit.assoc
{X Y Z : C}
{sXY : binary_fan X Y}
(P : is_limit sXY)
{sYZ : binary_fan Y Z}
(Q : is_limit sYZ)
{s : binary_fan sXY.X Z}
(R : is_limit s) : is_limit (s.assoc Q) :=
{ lift := Œª t, R.lift (binary_fan.assoc_inv P t),
  fac' := Œª t, begin
    rintro ["‚ü®", "‚ü©"]; simp [] [] [] [] [] [],
    apply [expr Q.hom_ext],
    rintro ["‚ü®", "‚ü©"]; simp [] [] [] [] [] []
  end,
  uniq' := Œª t m w, begin
    have [ident h] [] [":=", expr R.uniq (binary_fan.assoc_inv P t) m],
    rw [expr h] [],
    rintro ["‚ü®", "‚ü©"]; simp [] [] [] [] [] [],
    apply [expr P.hom_ext],
    rintro ["‚ü®", "‚ü©"]; simp [] [] [] [] [] [],
    { exact [expr w walking_pair.left] },
    { specialize [expr w walking_pair.right],
      simp [] [] [] [] [] ["at", ident w],
      rw ["[", "<-", expr w, "]"] [],
      simp [] [] [] [] [] [] },
    { specialize [expr w walking_pair.right],
      simp [] [] [] [] [] ["at", ident w],
      rw ["[", "<-", expr w, "]"] [],
      simp [] [] [] [] [] [] }
  end }

/--
Given two pairs of limit cones corresponding to the parenthesisations of `X √ó Y √ó Z`,
we obtain an isomorphism between the cone points.
-/
@[reducible]
def binary_fan.associator {X Y Z : C} {sXY : binary_fan X Y} (P : is_limit sXY) {sYZ : binary_fan Y Z}
  (Q : is_limit sYZ) {s : binary_fan sXY.X Z} (R : is_limit s) {t : binary_fan X sYZ.X} (S : is_limit t) : s.X ‚âÖ t.X :=
  is_limit.cone_point_unique_up_to_iso (is_limit.assoc P Q R) S

/--
Given a fixed family of limit data for every pair `X Y`, we obtain an associator.
-/
@[reducible]
def binary_fan.associator_of_limit_cone (L : ‚àÄ (X Y : C), limit_cone (pair X Y)) (X Y Z : C) :
  (L (L X Y).Cone.x Z).Cone.x ‚âÖ (L X (L Y Z).Cone.x).Cone.x :=
  binary_fan.associator (L X Y).IsLimit (L Y Z).IsLimit (L (L X Y).Cone.x Z).IsLimit (L X (L Y Z).Cone.x).IsLimit

/--
Construct a left unitor from specified limit cones.
-/
@[simps]
def binary_fan.left_unitor {X : C} {s : cone (functor.empty C)} (P : is_limit s) {t : binary_fan s.X X}
  (Q : is_limit t) : t.X ‚âÖ X :=
  { Hom := t.snd, inv := Q.lift (binary_fan.mk (P.lift { x, œÄ := { app := Pempty.rec _ } }) (ùüô X)),
    hom_inv_id' :=
      by 
        apply Q.hom_ext 
        rintro ‚ü®‚ü©
        ¬∑
          apply P.hom_ext 
          rintro ‚ü®‚ü©
        ¬∑
          simp  }

/--
Construct a right unitor from specified limit cones.
-/
@[simps]
def binary_fan.right_unitor {X : C} {s : cone (functor.empty C)} (P : is_limit s) {t : binary_fan X s.X}
  (Q : is_limit t) : t.X ‚âÖ X :=
  { Hom := t.fst, inv := Q.lift (binary_fan.mk (ùüô X) (P.lift { x, œÄ := { app := Pempty.rec _ } })),
    hom_inv_id' :=
      by 
        apply Q.hom_ext 
        rintro ‚ü®‚ü©
        ¬∑
          simp 
        ¬∑
          apply P.hom_ext 
          rintro ‚ü®‚ü© }

end 

end Limits

open CategoryTheory.Limits

section 

attribute [local tidy] tactic.case_bash

variable{C}

variable(ùíØ : limit_cone (functor.empty C))

variable(‚Ñ¨ : ‚àÄ (X Y : C), limit_cone (pair X Y))

namespace MonoidalOfChosenFiniteProducts

/-- Implementation of the tensor product for `monoidal_of_chosen_finite_products`. -/
@[reducible]
def tensor_obj (X Y : C) : C :=
  (‚Ñ¨ X Y).Cone.x

/-- Implementation of the tensor product of morphisms for `monoidal_of_chosen_finite_products`. -/
@[reducible]
def tensor_hom {W X Y Z : C} (f : W ‚ü∂ X) (g : Y ‚ü∂ Z) : tensor_obj ‚Ñ¨ W Y ‚ü∂ tensor_obj ‚Ñ¨ X Z :=
  (binary_fan.is_limit.lift' (‚Ñ¨ X Z).IsLimit ((‚Ñ¨ W Y).Cone.œÄ.app walking_pair.left ‚â´ f)
      (((‚Ñ¨ W Y).Cone.œÄ.app walking_pair.right : (‚Ñ¨ W Y).Cone.x ‚ü∂ Y) ‚â´ g)).val

theorem tensor_id (X‚ÇÅ X‚ÇÇ : C) : tensor_hom ‚Ñ¨ (ùüô X‚ÇÅ) (ùüô X‚ÇÇ) = ùüô (tensor_obj ‚Ñ¨ X‚ÇÅ X‚ÇÇ) :=
  by 
    apply is_limit.hom_ext (‚Ñ¨ _ _).IsLimit 
    rintro ‚ü®‚ü© <;>
      ¬∑
        dsimp [tensor_hom]
        simp 

theorem tensor_comp {X‚ÇÅ Y‚ÇÅ Z‚ÇÅ X‚ÇÇ Y‚ÇÇ Z‚ÇÇ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (g‚ÇÅ : Y‚ÇÅ ‚ü∂ Z‚ÇÅ) (g‚ÇÇ : Y‚ÇÇ ‚ü∂ Z‚ÇÇ) :
  tensor_hom ‚Ñ¨ (f‚ÇÅ ‚â´ g‚ÇÅ) (f‚ÇÇ ‚â´ g‚ÇÇ) = tensor_hom ‚Ñ¨ f‚ÇÅ f‚ÇÇ ‚â´ tensor_hom ‚Ñ¨ g‚ÇÅ g‚ÇÇ :=
  by 
    apply is_limit.hom_ext (‚Ñ¨ _ _).IsLimit 
    rintro ‚ü®‚ü© <;>
      ¬∑
        dsimp [tensor_hom]
        simp 

theorem pentagon (W X Y Z : C) :
  tensor_hom ‚Ñ¨ (binary_fan.associator_of_limit_cone ‚Ñ¨ W X Y).Hom (ùüô Z) ‚â´
      (binary_fan.associator_of_limit_cone ‚Ñ¨ W (tensor_obj ‚Ñ¨ X Y) Z).Hom ‚â´
        tensor_hom ‚Ñ¨ (ùüô W) (binary_fan.associator_of_limit_cone ‚Ñ¨ X Y Z).Hom =
    (binary_fan.associator_of_limit_cone ‚Ñ¨ (tensor_obj ‚Ñ¨ W X) Y Z).Hom ‚â´
      (binary_fan.associator_of_limit_cone ‚Ñ¨ W X (tensor_obj ‚Ñ¨ Y Z)).Hom :=
  by 
    dsimp [tensor_hom]
    apply is_limit.hom_ext (‚Ñ¨ _ _).IsLimit 
    rintro ‚ü®‚ü©
    ¬∑
      simp 
    ¬∑
      apply is_limit.hom_ext (‚Ñ¨ _ _).IsLimit 
      rintro ‚ü®‚ü©
      ¬∑
        simp 
      apply is_limit.hom_ext (‚Ñ¨ _ _).IsLimit 
      rintro ‚ü®‚ü©
      ¬∑
        simp 
      ¬∑
        simp 

theorem triangle (X Y : C) :
  (binary_fan.associator_of_limit_cone ‚Ñ¨ X ùíØ.cone.X Y).Hom ‚â´
      tensor_hom ‚Ñ¨ (ùüô X) (binary_fan.left_unitor ùíØ.is_limit (‚Ñ¨ ùíØ.cone.X Y).IsLimit).Hom =
    tensor_hom ‚Ñ¨ (binary_fan.right_unitor ùíØ.is_limit (‚Ñ¨ X ùíØ.cone.X).IsLimit).Hom (ùüô Y) :=
  by 
    dsimp [tensor_hom]
    apply is_limit.hom_ext (‚Ñ¨ _ _).IsLimit 
    rintro ‚ü®‚ü© <;> simp 

theorem left_unitor_naturality {X‚ÇÅ X‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) :
  tensor_hom ‚Ñ¨ (ùüô ùíØ.cone.X) f ‚â´ (binary_fan.left_unitor ùíØ.is_limit (‚Ñ¨ ùíØ.cone.X X‚ÇÇ).IsLimit).Hom =
    (binary_fan.left_unitor ùíØ.is_limit (‚Ñ¨ ùíØ.cone.X X‚ÇÅ).IsLimit).Hom ‚â´ f :=
  by 
    dsimp [tensor_hom]
    simp 

theorem right_unitor_naturality {X‚ÇÅ X‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) :
  tensor_hom ‚Ñ¨ f (ùüô ùíØ.cone.X) ‚â´ (binary_fan.right_unitor ùíØ.is_limit (‚Ñ¨ X‚ÇÇ ùíØ.cone.X).IsLimit).Hom =
    (binary_fan.right_unitor ùíØ.is_limit (‚Ñ¨ X‚ÇÅ ùíØ.cone.X).IsLimit).Hom ‚â´ f :=
  by 
    dsimp [tensor_hom]
    simp 

theorem associator_naturality {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) :
  tensor_hom ‚Ñ¨ (tensor_hom ‚Ñ¨ f‚ÇÅ f‚ÇÇ) f‚ÇÉ ‚â´ (binary_fan.associator_of_limit_cone ‚Ñ¨ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ).Hom =
    (binary_fan.associator_of_limit_cone ‚Ñ¨ X‚ÇÅ X‚ÇÇ X‚ÇÉ).Hom ‚â´ tensor_hom ‚Ñ¨ f‚ÇÅ (tensor_hom ‚Ñ¨ f‚ÇÇ f‚ÇÉ) :=
  by 
    dsimp [tensor_hom]
    apply is_limit.hom_ext (‚Ñ¨ _ _).IsLimit 
    rintro ‚ü®‚ü©
    ¬∑
      simp 
    ¬∑
      apply is_limit.hom_ext (‚Ñ¨ _ _).IsLimit 
      rintro ‚ü®‚ü©
      ¬∑
        simp 
      ¬∑
        simp 

end MonoidalOfChosenFiniteProducts

open MonoidalOfChosenFiniteProducts

/-- A category with a terminal object and binary products has a natural monoidal structure. -/
def monoidal_of_chosen_finite_products : monoidal_category C :=
  { tensorUnit := ùíØ.cone.X, tensorObj := fun X Y => tensor_obj ‚Ñ¨ X Y, tensorHom := fun _ _ _ _ f g => tensor_hom ‚Ñ¨ f g,
    tensor_id' := tensor_id ‚Ñ¨, tensor_comp' := fun _ _ _ _ _ _ f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ => tensor_comp ‚Ñ¨ f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ,
    associator := fun X Y Z => binary_fan.associator_of_limit_cone ‚Ñ¨ X Y Z,
    leftUnitor := fun X => binary_fan.left_unitor ùíØ.is_limit (‚Ñ¨ ùíØ.cone.X X).IsLimit,
    rightUnitor := fun X => binary_fan.right_unitor ùíØ.is_limit (‚Ñ¨ X ùíØ.cone.X).IsLimit, pentagon' := pentagon ‚Ñ¨,
    triangle' := triangle ùíØ ‚Ñ¨, left_unitor_naturality' := fun _ _ f => left_unitor_naturality ùíØ ‚Ñ¨ f,
    right_unitor_naturality' := fun _ _ f => right_unitor_naturality ùíØ ‚Ñ¨ f,
    associator_naturality' := fun _ _ _ _ _ _ f‚ÇÅ f‚ÇÇ f‚ÇÉ => associator_naturality ‚Ñ¨ f‚ÇÅ f‚ÇÇ f‚ÇÉ }

namespace MonoidalOfChosenFiniteProducts

open MonoidalCategory

-- error in CategoryTheory.Monoidal.OfChosenFiniteProducts: ././Mathport/Syntax/Translate/Basic.lean:704:9: unsupported derive handler category
/--
A type synonym for `C` carrying a monoidal category structure corresponding to
a fixed choice of limit data for the empty functor, and for `pair X Y` for every `X Y : C`.

This is an implementation detail for `symmetric_of_chosen_finite_products`.
-/
@[derive #[expr category], nolint #[ident unused_arguments, ident has_inhabited_instance]]
def monoidal_of_chosen_finite_products_synonym
(ùíØ : limit_cone (functor.empty C))
(‚Ñ¨ : ‚àÄ X Y : C, limit_cone (pair X Y)) :=
C

instance  : monoidal_category (monoidal_of_chosen_finite_products_synonym ùíØ ‚Ñ¨) :=
  monoidal_of_chosen_finite_products ùíØ ‚Ñ¨

theorem braiding_naturality {X X' Y Y' : C} (f : X ‚ü∂ Y) (g : X' ‚ü∂ Y') :
  tensor_hom ‚Ñ¨ f g ‚â´ (limits.binary_fan.braiding (‚Ñ¨ Y Y').IsLimit (‚Ñ¨ Y' Y).IsLimit).Hom =
    (limits.binary_fan.braiding (‚Ñ¨ X X').IsLimit (‚Ñ¨ X' X).IsLimit).Hom ‚â´ tensor_hom ‚Ñ¨ g f :=
  by 
    dsimp [tensor_hom, limits.binary_fan.braiding]
    apply (‚Ñ¨ _ _).IsLimit.hom_ext 
    rintro ‚ü®‚ü© <;>
      ¬∑
        dsimp [limits.is_limit.cone_point_unique_up_to_iso]
        simp 

theorem hexagon_forward (X Y Z : C) :
  (binary_fan.associator_of_limit_cone ‚Ñ¨ X Y Z).Hom ‚â´
      (limits.binary_fan.braiding (‚Ñ¨ X (tensor_obj ‚Ñ¨ Y Z)).IsLimit (‚Ñ¨ (tensor_obj ‚Ñ¨ Y Z) X).IsLimit).Hom ‚â´
        (binary_fan.associator_of_limit_cone ‚Ñ¨ Y Z X).Hom =
    tensor_hom ‚Ñ¨ (limits.binary_fan.braiding (‚Ñ¨ X Y).IsLimit (‚Ñ¨ Y X).IsLimit).Hom (ùüô Z) ‚â´
      (binary_fan.associator_of_limit_cone ‚Ñ¨ Y X Z).Hom ‚â´
        tensor_hom ‚Ñ¨ (ùüô Y) (limits.binary_fan.braiding (‚Ñ¨ X Z).IsLimit (‚Ñ¨ Z X).IsLimit).Hom :=
  by 
    dsimp [tensor_hom, limits.binary_fan.braiding]
    apply (‚Ñ¨ _ _).IsLimit.hom_ext 
    rintro ‚ü®‚ü©
    ¬∑
      dsimp [limits.is_limit.cone_point_unique_up_to_iso]
      simp 
    ¬∑
      apply (‚Ñ¨ _ _).IsLimit.hom_ext 
      rintro ‚ü®‚ü© <;>
        ¬∑
          dsimp [limits.is_limit.cone_point_unique_up_to_iso]
          simp 

theorem hexagon_reverse (X Y Z : C) :
  (binary_fan.associator_of_limit_cone ‚Ñ¨ X Y Z).inv ‚â´
      (limits.binary_fan.braiding (‚Ñ¨ (tensor_obj ‚Ñ¨ X Y) Z).IsLimit (‚Ñ¨ Z (tensor_obj ‚Ñ¨ X Y)).IsLimit).Hom ‚â´
        (binary_fan.associator_of_limit_cone ‚Ñ¨ Z X Y).inv =
    tensor_hom ‚Ñ¨ (ùüô X) (limits.binary_fan.braiding (‚Ñ¨ Y Z).IsLimit (‚Ñ¨ Z Y).IsLimit).Hom ‚â´
      (binary_fan.associator_of_limit_cone ‚Ñ¨ X Z Y).inv ‚â´
        tensor_hom ‚Ñ¨ (limits.binary_fan.braiding (‚Ñ¨ X Z).IsLimit (‚Ñ¨ Z X).IsLimit).Hom (ùüô Y) :=
  by 
    dsimp [tensor_hom, limits.binary_fan.braiding]
    apply (‚Ñ¨ _ _).IsLimit.hom_ext 
    rintro ‚ü®‚ü©
    ¬∑
      apply (‚Ñ¨ _ _).IsLimit.hom_ext 
      rintro ‚ü®‚ü© <;>
        ¬∑
          dsimp [binary_fan.associator_of_limit_cone, binary_fan.associator,
            limits.is_limit.cone_point_unique_up_to_iso]
          simp 
    ¬∑
      dsimp [binary_fan.associator_of_limit_cone, binary_fan.associator, limits.is_limit.cone_point_unique_up_to_iso]
      simp 

theorem symmetry (X Y : C) :
  (limits.binary_fan.braiding (‚Ñ¨ X Y).IsLimit (‚Ñ¨ Y X).IsLimit).Hom ‚â´
      (limits.binary_fan.braiding (‚Ñ¨ Y X).IsLimit (‚Ñ¨ X Y).IsLimit).Hom =
    ùüô (tensor_obj ‚Ñ¨ X Y) :=
  by 
    dsimp [tensor_hom, limits.binary_fan.braiding]
    apply (‚Ñ¨ _ _).IsLimit.hom_ext 
    rintro ‚ü®‚ü© <;>
      ¬∑
        dsimp [limits.is_limit.cone_point_unique_up_to_iso]
        simp 

end MonoidalOfChosenFiniteProducts

open MonoidalOfChosenFiniteProducts

/--
The monoidal structure coming from finite products is symmetric.
-/
def symmetric_of_chosen_finite_products : symmetric_category (monoidal_of_chosen_finite_products_synonym ùíØ ‚Ñ¨) :=
  { braiding := fun X Y => limits.binary_fan.braiding (‚Ñ¨ _ _).IsLimit (‚Ñ¨ _ _).IsLimit,
    braiding_naturality' := fun X X' Y Y' f g => braiding_naturality ‚Ñ¨ f g,
    hexagon_forward' := fun X Y Z => hexagon_forward ‚Ñ¨ X Y Z, hexagon_reverse' := fun X Y Z => hexagon_reverse ‚Ñ¨ X Y Z,
    symmetry' := fun X Y => symmetry ‚Ñ¨ X Y }

end 

end CategoryTheory

