/-
Copyright (c) 2020 David W√§rn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David W√§rn

! This file was ported from Lean 3 source module category_theory.quotient
! leanprover-community/mathlib commit f47581155c818e6361af4e4fda60d27d020c226b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.NaturalIsomorphism
import Mathbin.CategoryTheory.EqToHom

/-!
# Quotient category

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Constructs the quotient of a category by an arbitrary family of relations on its hom-sets,
by introducing a type synonym for the objects, and identifying homs as necessary.

This is analogous to 'the quotient of a group by the normal closure of a subset', rather
than 'the quotient of a group by a normal subgroup'. When taking the quotient by a congruence
relation, `functor_map_eq_iff` says that no unnecessary identifications have been made.
-/


#print HomRel /-
/-- A `hom_rel` on `C` consists of a relation on every hom-set. -/
def HomRel (C) [Quiver C] :=
  ‚àÄ ‚¶ÉX Y : C‚¶Ñ, (X ‚ü∂ Y) ‚Üí (X ‚ü∂ Y) ‚Üí Prop deriving Inhabited
#align hom_rel HomRel
-/

namespace CategoryTheory

variable {C : Type _} [Category C] (r : HomRel C)

include r

#print CategoryTheory.Congruence /-
/-- A `hom_rel` is a congruence when it's an equivalence on every hom-set, and it can be composed
from left and right. -/
class Congruence : Prop where
  IsEquiv : ‚àÄ {X Y}, IsEquiv _ (@r X Y)
  compLeft : ‚àÄ {X Y Z} (f : X ‚ü∂ Y) {g g' : Y ‚ü∂ Z}, r g g' ‚Üí r (f ‚â´ g) (f ‚â´ g')
  compRight : ‚àÄ {X Y Z} {f f' : X ‚ü∂ Y} (g : Y ‚ü∂ Z), r f f' ‚Üí r (f ‚â´ g) (f' ‚â´ g)
#align category_theory.congruence CategoryTheory.Congruence
-/

attribute [instance] congruence.is_equiv

#print CategoryTheory.Quotient /-
/-- A type synonym for `C`, thought of as the objects of the quotient category. -/
@[ext]
structure Quotient where
  as : C
#align category_theory.quotient CategoryTheory.Quotient
-/

instance [Inhabited C] : Inhabited (Quotient r) :=
  ‚ü®{ as := default }‚ü©

namespace Quotient

#print CategoryTheory.Quotient.CompClosure /-
/-- Generates the closure of a family of relations w.r.t. composition from left and right. -/
inductive CompClosure ‚¶És t : C‚¶Ñ : (s ‚ü∂ t) ‚Üí (s ‚ü∂ t) ‚Üí Prop
  |
  intro {a b} (f : s ‚ü∂ a) (m‚ÇÅ m‚ÇÇ : a ‚ü∂ b) (g : b ‚ü∂ t) (h : r m‚ÇÅ m‚ÇÇ) :
    comp_closure (f ‚â´ m‚ÇÅ ‚â´ g) (f ‚â´ m‚ÇÇ ‚â´ g)
#align category_theory.quotient.comp_closure CategoryTheory.Quotient.CompClosure
-/

#print CategoryTheory.Quotient.CompClosure.of /-
theorem CompClosure.of {a b} (m‚ÇÅ m‚ÇÇ : a ‚ü∂ b) (h : r m‚ÇÅ m‚ÇÇ) : CompClosure r m‚ÇÅ m‚ÇÇ := by
  simpa using comp_closure.intro (ùüô _) m‚ÇÅ m‚ÇÇ (ùüô _) h
#align category_theory.quotient.comp_closure.of CategoryTheory.Quotient.CompClosure.of
-/

#print CategoryTheory.Quotient.comp_left /-
theorem comp_left {a b c : C} (f : a ‚ü∂ b) :
    ‚àÄ (g‚ÇÅ g‚ÇÇ : b ‚ü∂ c) (h : CompClosure r g‚ÇÅ g‚ÇÇ), CompClosure r (f ‚â´ g‚ÇÅ) (f ‚â´ g‚ÇÇ)
  | _, _, ‚ü®x, m‚ÇÅ, m‚ÇÇ, y, h‚ü© => by simpa using comp_closure.intro (f ‚â´ x) m‚ÇÅ m‚ÇÇ y h
#align category_theory.quotient.comp_left CategoryTheory.Quotient.comp_left
-/

#print CategoryTheory.Quotient.comp_right /-
theorem comp_right {a b c : C} (g : b ‚ü∂ c) :
    ‚àÄ (f‚ÇÅ f‚ÇÇ : a ‚ü∂ b) (h : CompClosure r f‚ÇÅ f‚ÇÇ), CompClosure r (f‚ÇÅ ‚â´ g) (f‚ÇÇ ‚â´ g)
  | _, _, ‚ü®x, m‚ÇÅ, m‚ÇÇ, y, h‚ü© => by simpa using comp_closure.intro x m‚ÇÅ m‚ÇÇ (y ‚â´ g) h
#align category_theory.quotient.comp_right CategoryTheory.Quotient.comp_right
-/

#print CategoryTheory.Quotient.Hom /-
/-- Hom-sets of the quotient category. -/
def Hom (s t : Quotient r) :=
  Quot <| @CompClosure C _ r s.as t.as
#align category_theory.quotient.hom CategoryTheory.Quotient.Hom
-/

instance (a : Quotient r) : Inhabited (Hom r a a) :=
  ‚ü®Quot.mk _ (ùüô a.as)‚ü©

#print CategoryTheory.Quotient.comp /-
/-- Composition in the quotient category. -/
def comp ‚¶Éa b c : Quotient r‚¶Ñ : Hom r a b ‚Üí Hom r b c ‚Üí Hom r a c := fun hf hg =>
  Quot.liftOn hf
    (fun f =>
      Quot.liftOn hg (fun g => Quot.mk _ (f ‚â´ g)) fun g‚ÇÅ g‚ÇÇ h =>
        Quot.sound <| comp_left r f g‚ÇÅ g‚ÇÇ h)
    fun f‚ÇÅ f‚ÇÇ h => Quot.inductionOn hg fun g => Quot.sound <| comp_right r g f‚ÇÅ f‚ÇÇ h
#align category_theory.quotient.comp CategoryTheory.Quotient.comp
-/

/- warning: category_theory.quotient.comp_mk -> CategoryTheory.Quotient.comp_mk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (r : HomRel.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) {a : CategoryTheory.Quotient.{u1, u2} C _inst_1 r} {b : CategoryTheory.Quotient.{u1, u2} C _inst_1 r} {c : CategoryTheory.Quotient.{u1, u2} C _inst_1 r} (f : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r a) (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r b)) (g : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r b) (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r c)), Eq.{succ u2} (CategoryTheory.Quotient.Hom.{u1, u2} C _inst_1 r a c) (CategoryTheory.Quotient.comp.{u1, u2} C _inst_1 r a b c (Quot.mk.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r a) (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r b)) (CategoryTheory.Quotient.CompClosure.{u1, u2} C _inst_1 r (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r a) (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r b)) f) (Quot.mk.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r b) (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r c)) (CategoryTheory.Quotient.CompClosure.{u1, u2} C _inst_1 r (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r b) (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r c)) g)) (Quot.mk.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r a) (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r c)) (CategoryTheory.Quotient.CompClosure.{u1, u2} C _inst_1 r (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r a) (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r c)) (CategoryTheory.CategoryStruct.comp.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1) (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r a) (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r b) (CategoryTheory.Quotient.as.{u1, u2} C _inst_1 r c) f g))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (r : HomRel.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) {a : CategoryTheory.Quotient.{u2, u1} C _inst_1 r} {b : CategoryTheory.Quotient.{u2, u1} C _inst_1 r} {c : CategoryTheory.Quotient.{u2, u1} C _inst_1 r} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r a) (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r b)) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r b) (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r c)), Eq.{succ u1} (CategoryTheory.Quotient.Hom.{u2, u1} C _inst_1 r a c) (CategoryTheory.Quotient.comp.{u2, u1} C _inst_1 r a b c (Quot.mk.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r a) (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r b)) (CategoryTheory.Quotient.CompClosure.{u2, u1} C _inst_1 r (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r a) (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r b)) f) (Quot.mk.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r b) (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r c)) (CategoryTheory.Quotient.CompClosure.{u2, u1} C _inst_1 r (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r b) (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r c)) g)) (Quot.mk.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r a) (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r c)) (CategoryTheory.Quotient.CompClosure.{u2, u1} C _inst_1 r (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r a) (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r c)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r a) (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r b) (CategoryTheory.Quotient.as.{u2, u1} C _inst_1 r c) f g))
Case conversion may be inaccurate. Consider using '#align category_theory.quotient.comp_mk CategoryTheory.Quotient.comp_mk‚Çì'. -/
@[simp]
theorem comp_mk {a b c : Quotient r} (f : a.as ‚ü∂ b.as) (g : b.as ‚ü∂ c.as) :
    comp r (Quot.mk _ f) (Quot.mk _ g) = Quot.mk _ (f ‚â´ g) :=
  rfl
#align category_theory.quotient.comp_mk CategoryTheory.Quotient.comp_mk

#print CategoryTheory.Quotient.category /-
instance category : Category (Quotient r)
    where
  Hom := Hom r
  id a := Quot.mk _ (ùüô a.as)
  comp := comp r
#align category_theory.quotient.category CategoryTheory.Quotient.category
-/

#print CategoryTheory.Quotient.functor /-
/-- The functor from a category to its quotient. -/
@[simps]
def functor : C ‚•§ Quotient r where
  obj a := { as := a }
  map _ _ f := Quot.mk _ f
#align category_theory.quotient.functor CategoryTheory.Quotient.functor
-/

noncomputable instance : Full (functor r) where preimage X Y f := Quot.out f

instance : EssSurj (functor r)
    where mem_essImage Y :=
    ‚ü®Y.as,
      ‚ü®eqToIso
          (by
            ext
            rfl)‚ü©‚ü©

/- warning: category_theory.quotient.induction -> CategoryTheory.Quotient.induction is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (r : HomRel.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) {P : forall {a : CategoryTheory.Quotient.{u1, u2} C _inst_1 r} {b : CategoryTheory.Quotient.{u1, u2} C _inst_1 r}, (Quiver.Hom.{succ u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r))) a b) -> Prop}, (forall {x : C} {y : C} (f : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y), P (CategoryTheory.Functor.obj.{u2, u2, u1, u1} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) x) (CategoryTheory.Functor.obj.{u2, u2, u1, u1} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) y) (CategoryTheory.Functor.map.{u2, u2, u1, u1} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) x y f)) -> (forall {a : CategoryTheory.Quotient.{u1, u2} C _inst_1 r} {b : CategoryTheory.Quotient.{u1, u2} C _inst_1 r} (f : Quiver.Hom.{succ u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r))) a b), P a b f)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (r : HomRel.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) {P : forall {a : CategoryTheory.Quotient.{u2, u1} C _inst_1 r} {b : CategoryTheory.Quotient.{u2, u1} C _inst_1 r}, (Quiver.Hom.{succ u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r))) a b) -> Prop}, (forall {x : C} {y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) x y), P (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.functor.{u2, u1} C _inst_1 r)) x) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.functor.{u2, u1} C _inst_1 r)) y) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.functor.{u2, u1} C _inst_1 r)) x y f)) -> (forall {a : CategoryTheory.Quotient.{u2, u1} C _inst_1 r} {b : CategoryTheory.Quotient.{u2, u1} C _inst_1 r} (f : Quiver.Hom.{succ u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r))) a b), P a b f)
Case conversion may be inaccurate. Consider using '#align category_theory.quotient.induction CategoryTheory.Quotient.induction‚Çì'. -/
protected theorem induction {P : ‚àÄ {a b : Quotient r}, (a ‚ü∂ b) ‚Üí Prop}
    (h : ‚àÄ {x y : C} (f : x ‚ü∂ y), P ((functor r).map f)) : ‚àÄ {a b : Quotient r} (f : a ‚ü∂ b), P f :=
  by
  rintro ‚ü®x‚ü© ‚ü®y‚ü© ‚ü®f‚ü©
  exact h f
#align category_theory.quotient.induction CategoryTheory.Quotient.induction

/- warning: category_theory.quotient.sound -> CategoryTheory.Quotient.sound is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (r : HomRel.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) {a : C} {b : C} {f‚ÇÅ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) a b} {f‚ÇÇ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) a b}, (r a b f‚ÇÅ f‚ÇÇ) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r))) (CategoryTheory.Functor.obj.{u2, u2, u1, u1} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) a) (CategoryTheory.Functor.obj.{u2, u2, u1, u1} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) b)) (CategoryTheory.Functor.map.{u2, u2, u1, u1} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) a b f‚ÇÅ) (CategoryTheory.Functor.map.{u2, u2, u1, u1} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) a b f‚ÇÇ))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (r : HomRel.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) {a : C} {b : C} {f‚ÇÅ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) a b} {f‚ÇÇ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) a b}, (r a b f‚ÇÅ f‚ÇÇ) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r))) (Prefunctor.obj.{succ u2, succ u2, u1, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r)) a) (Prefunctor.obj.{succ u2, succ u2, u1, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r)) b)) (Prefunctor.map.{succ u2, succ u2, u1, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r)) a b f‚ÇÅ) (Prefunctor.map.{succ u2, succ u2, u1, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r)) a b f‚ÇÇ))
Case conversion may be inaccurate. Consider using '#align category_theory.quotient.sound CategoryTheory.Quotient.sound‚Çì'. -/
protected theorem sound {a b : C} {f‚ÇÅ f‚ÇÇ : a ‚ü∂ b} (h : r f‚ÇÅ f‚ÇÇ) :
    (functor r).map f‚ÇÅ = (functor r).map f‚ÇÇ := by
  simpa using Quot.sound (comp_closure.intro (ùüô a) f‚ÇÅ f‚ÇÇ (ùüô b) h)
#align category_theory.quotient.sound CategoryTheory.Quotient.sound

/- warning: category_theory.quotient.functor_map_eq_iff -> CategoryTheory.Quotient.functor_map_eq_iff is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (r : HomRel.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) [_inst_2 : CategoryTheory.Congruence.{u1, u2} C _inst_1 r] {X : C} {Y : C} (f : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (f' : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y), Iff (Eq.{succ u2} (Quiver.Hom.{succ u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r))) (CategoryTheory.Functor.obj.{u2, u2, u1, u1} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) X) (CategoryTheory.Functor.obj.{u2, u2, u1, u1} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) Y)) (CategoryTheory.Functor.map.{u2, u2, u1, u1} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) X Y f) (CategoryTheory.Functor.map.{u2, u2, u1, u1} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) X Y f')) (r X Y f f')
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (r : HomRel.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) [_inst_2 : CategoryTheory.Congruence.{u2, u1} C _inst_1 r] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (f' : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), Iff (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.functor.{u2, u1} C _inst_1 r)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.functor.{u2, u1} C _inst_1 r)) Y)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.functor.{u2, u1} C _inst_1 r)) X Y f) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 (CategoryTheory.Quotient.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u1} C _inst_1 r) (CategoryTheory.Quotient.functor.{u2, u1} C _inst_1 r)) X Y f')) (r X Y f f')
Case conversion may be inaccurate. Consider using '#align category_theory.quotient.functor_map_eq_iff CategoryTheory.Quotient.functor_map_eq_iff‚Çì'. -/
theorem functor_map_eq_iff [Congruence r] {X Y : C} (f f' : X ‚ü∂ Y) :
    (functor r).map f = (functor r).map f' ‚Üî r f f' :=
  by
  constructor
  ¬∑ erw [Quot.eq]
    intro h
    induction' h with m m' hm
    ¬∑ cases hm
      apply congruence.comp_left
      apply congruence.comp_right
      assumption
    ¬∑ apply refl
    ¬∑ apply symm
      assumption
    ¬∑ apply trans <;> assumption
  ¬∑ apply Quotient.sound
#align category_theory.quotient.functor_map_eq_iff CategoryTheory.Quotient.functor_map_eq_iff

variable {D : Type _} [Category D] (F : C ‚•§ D)
  (H : ‚àÄ (x y : C) (f‚ÇÅ f‚ÇÇ : x ‚ü∂ y), r f‚ÇÅ f‚ÇÇ ‚Üí F.map f‚ÇÅ = F.map f‚ÇÇ)

include H

/- warning: category_theory.quotient.lift -> CategoryTheory.Quotient.lift is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (r : HomRel.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] (F : CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2), (forall (x : C) (y : C) (f‚ÇÅ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y) (f‚ÇÇ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y), (r x y f‚ÇÅ f‚ÇÇ) -> (Eq.{succ u4} (Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 F y)) (CategoryTheory.Functor.map.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x y f‚ÇÅ) (CategoryTheory.Functor.map.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x y f‚ÇÇ))) -> (CategoryTheory.Functor.{u2, u4, u1, u3} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (r : HomRel.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] (F : CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2), (forall (x : C) (y : C) (f‚ÇÅ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y) (f‚ÇÇ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y), (r x y f‚ÇÅ f‚ÇÇ) -> (Eq.{succ u4} (Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (Prefunctor.obj.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) x) (Prefunctor.obj.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) y)) (Prefunctor.map.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) x y f‚ÇÅ) (Prefunctor.map.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) x y f‚ÇÇ))) -> (CategoryTheory.Functor.{u2, u4, u1, u3} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2)
Case conversion may be inaccurate. Consider using '#align category_theory.quotient.lift CategoryTheory.Quotient.lift‚Çì'. -/
/-- The induced functor on the quotient category. -/
@[simps]
def lift : Quotient r ‚•§ D where
  obj a := F.obj a.as
  map a b hf :=
    Quot.liftOn hf (fun f => F.map f)
      (by
        rintro _ _ ‚ü®_, _, _, _, h‚ü©
        simp [H _ _ _ _ h])
  map_id' a := F.map_id a.as
  map_comp' := by
    rintro a b c ‚ü®f‚ü© ‚ü®g‚ü©
    exact F.map_comp f g
#align category_theory.quotient.lift CategoryTheory.Quotient.lift

/- warning: category_theory.quotient.lift_spec -> CategoryTheory.Quotient.lift_spec is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (r : HomRel.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] (F : CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (H : forall (x : C) (y : C) (f‚ÇÅ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y) (f‚ÇÇ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y), (r x y f‚ÇÅ f‚ÇÇ) -> (Eq.{succ u4} (Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 F y)) (CategoryTheory.Functor.map.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x y f‚ÇÅ) (CategoryTheory.Functor.map.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x y f‚ÇÇ))), Eq.{succ (max u2 u4 u1 u3)} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.comp.{u2, u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.lift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) F
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u3, u4} C] (r : HomRel.{u4, succ u3} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1))) {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{u1, u2} D] (F : CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (H : forall (x : C) (y : C) (f‚ÇÅ : Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) x y) (f‚ÇÇ : Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) x y), (r x y f‚ÇÅ f‚ÇÇ) -> (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) x) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) y)) (Prefunctor.map.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) x y f‚ÇÅ) (Prefunctor.map.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) x y f‚ÇÇ))), Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.comp.{u3, u3, u1, u4, u4, u2} C _inst_1 (CategoryTheory.Quotient.{u4, u3} C _inst_1 r) (CategoryTheory.Quotient.category.{u4, u3} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u4, u3} C _inst_1 r) (CategoryTheory.Quotient.lift.{u4, u3, u2, u1} C _inst_1 r D _inst_2 F H)) F
Case conversion may be inaccurate. Consider using '#align category_theory.quotient.lift_spec CategoryTheory.Quotient.lift_spec‚Çì'. -/
theorem lift_spec : functor r ‚ãô lift r F H = F :=
  by
  apply Functor.ext; rotate_left
  ¬∑ rintro X
    rfl
  ¬∑ rintro X Y f
    simp
#align category_theory.quotient.lift_spec CategoryTheory.Quotient.lift_spec

/- warning: category_theory.quotient.lift_unique -> CategoryTheory.Quotient.lift_unique is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (r : HomRel.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] (F : CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (H : forall (x : C) (y : C) (f‚ÇÅ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y) (f‚ÇÇ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y), (r x y f‚ÇÅ f‚ÇÇ) -> (Eq.{succ u4} (Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 F y)) (CategoryTheory.Functor.map.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x y f‚ÇÅ) (CategoryTheory.Functor.map.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x y f‚ÇÇ))) (Œ¶ : CategoryTheory.Functor.{u2, u4, u1, u3} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2), (Eq.{succ (max u2 u4 u1 u3)} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.comp.{u2, u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) Œ¶) F) -> (Eq.{succ (max u2 u4 u1 u3)} (CategoryTheory.Functor.{u2, u4, u1, u3} (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2) Œ¶ (CategoryTheory.Quotient.lift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u4, u2} C] (r : HomRel.{u2, succ u4} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_1))) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{u3, u1} D] (F : CategoryTheory.Functor.{u4, u3, u2, u1} C _inst_1 D _inst_2) (H : forall (x : C) (y : C) (f‚ÇÅ : Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_1)) x y) (f‚ÇÇ : Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_1)) x y), (r x y f‚ÇÅ f‚ÇÇ) -> (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} D (CategoryTheory.Category.toCategoryStruct.{u3, u1} D _inst_2)) (Prefunctor.obj.{succ u4, succ u3, u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} D (CategoryTheory.Category.toCategoryStruct.{u3, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} C _inst_1 D _inst_2 F) x) (Prefunctor.obj.{succ u4, succ u3, u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} D (CategoryTheory.Category.toCategoryStruct.{u3, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} C _inst_1 D _inst_2 F) y)) (Prefunctor.map.{succ u4, succ u3, u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} D (CategoryTheory.Category.toCategoryStruct.{u3, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} C _inst_1 D _inst_2 F) x y f‚ÇÅ) (Prefunctor.map.{succ u4, succ u3, u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} D (CategoryTheory.Category.toCategoryStruct.{u3, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} C _inst_1 D _inst_2 F) x y f‚ÇÇ))) (Œ¶ : CategoryTheory.Functor.{u4, u3, u2, u1} (CategoryTheory.Quotient.{u2, u4} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u4} C _inst_1 r) D _inst_2), (Eq.{max (max (max (succ u2) (succ u4)) (succ u1)) (succ u3)} (CategoryTheory.Functor.{u4, u3, u2, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.comp.{u4, u4, u3, u2, u2, u1} C _inst_1 (CategoryTheory.Quotient.{u2, u4} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u4} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u2, u4} C _inst_1 r) Œ¶) F) -> (Eq.{max (max (max (succ u2) (succ u4)) (succ u1)) (succ u3)} (CategoryTheory.Functor.{u4, u3, u2, u1} (CategoryTheory.Quotient.{u2, u4} C _inst_1 r) (CategoryTheory.Quotient.category.{u2, u4} C _inst_1 r) D _inst_2) Œ¶ (CategoryTheory.Quotient.lift.{u2, u4, u1, u3} C _inst_1 r D _inst_2 F H))
Case conversion may be inaccurate. Consider using '#align category_theory.quotient.lift_unique CategoryTheory.Quotient.lift_unique‚Çì'. -/
theorem lift_unique (Œ¶ : Quotient r ‚•§ D) (hŒ¶ : functor r ‚ãô Œ¶ = F) : Œ¶ = lift r F H :=
  by
  subst_vars
  apply functor.hext
  ¬∑ rintro X
    dsimp [lift, Functor]
    congr
    ext
    rfl
  ¬∑ rintro X Y f
    dsimp [lift, Functor]
    apply Quot.inductionOn f
    rintro ff
    simp only [Quot.liftOn_mk, functor.comp_map]
    congr <;> ext <;> rfl
#align category_theory.quotient.lift_unique CategoryTheory.Quotient.lift_unique

/- warning: category_theory.quotient.lift.is_lift -> CategoryTheory.Quotient.lift.isLift is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (r : HomRel.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] (F : CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (H : forall (x : C) (y : C) (f‚ÇÅ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y) (f‚ÇÇ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y), (r x y f‚ÇÅ f‚ÇÇ) -> (Eq.{succ u4} (Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 F y)) (CategoryTheory.Functor.map.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x y f‚ÇÅ) (CategoryTheory.Functor.map.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x y f‚ÇÇ))), CategoryTheory.Iso.{max u1 u4, max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.comp.{u2, u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.lift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) F
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (r : HomRel.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] (F : CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (H : forall (x : C) (y : C) (f‚ÇÅ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y) (f‚ÇÇ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y), (r x y f‚ÇÅ f‚ÇÇ) -> (Eq.{succ u4} (Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (Prefunctor.obj.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) x) (Prefunctor.obj.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) y)) (Prefunctor.map.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) x y f‚ÇÅ) (Prefunctor.map.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) x y f‚ÇÇ))), CategoryTheory.Iso.{max u1 u4, max (max (max u3 u1) u4) u2} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.comp.{u2, u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.lift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) F
Case conversion may be inaccurate. Consider using '#align category_theory.quotient.lift.is_lift CategoryTheory.Quotient.lift.isLift‚Çì'. -/
/-- The original functor factors through the induced functor. -/
def lift.isLift : functor r ‚ãô lift r F H ‚âÖ F :=
  NatIso.ofComponents (fun X => Iso.refl _) (by tidy)
#align category_theory.quotient.lift.is_lift CategoryTheory.Quotient.lift.isLift

/- warning: category_theory.quotient.lift.is_lift_hom -> CategoryTheory.Quotient.lift.isLift_hom is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (r : HomRel.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] (F : CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (H : forall (x : C) (y : C) (f‚ÇÅ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y) (f‚ÇÇ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y), (r x y f‚ÇÅ f‚ÇÇ) -> (Eq.{succ u4} (Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 F y)) (CategoryTheory.Functor.map.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x y f‚ÇÅ) (CategoryTheory.Functor.map.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x y f‚ÇÇ))) (X : C), Eq.{succ u4} (Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 (CategoryTheory.Functor.comp.{u2, u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.lift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) X) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 F X)) (CategoryTheory.NatTrans.app.{u2, u4, u1, u3} C _inst_1 D _inst_2 (CategoryTheory.Functor.comp.{u2, u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.lift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) F (CategoryTheory.Iso.hom.{max u1 u4, max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.comp.{u2, u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.lift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) F (CategoryTheory.Quotient.lift.isLift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) X) (CategoryTheory.CategoryStruct.id.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 F X))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (r : HomRel.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] (F : CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (H : forall (x : C) (y : C) (f‚ÇÅ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y) (f‚ÇÇ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y), (r x y f‚ÇÅ f‚ÇÇ) -> (Eq.{succ u4} (Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (Prefunctor.obj.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) x) (Prefunctor.obj.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) y)) (Prefunctor.map.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) x y f‚ÇÅ) (Prefunctor.map.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) x y f‚ÇÇ))) (X : C), Eq.{succ u4} (Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (Prefunctor.obj.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 (CategoryTheory.Functor.comp.{u2, u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.lift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H))) X) (Prefunctor.obj.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) X)) (CategoryTheory.NatTrans.app.{u2, u4, u1, u3} C _inst_1 D _inst_2 (CategoryTheory.Functor.comp.{u2, u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.lift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) F (CategoryTheory.Iso.hom.{max u1 u4, max (max (max u1 u2) u3) u4} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.comp.{u2, u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.lift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) F (CategoryTheory.Quotient.lift.isLift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) X) (CategoryTheory.CategoryStruct.id.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2) (Prefunctor.obj.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) X))
Case conversion may be inaccurate. Consider using '#align category_theory.quotient.lift.is_lift_hom CategoryTheory.Quotient.lift.isLift_hom‚Çì'. -/
@[simp]
theorem lift.isLift_hom (X : C) : (lift.isLift r F H).Hom.app X = ùüô (F.obj X) :=
  rfl
#align category_theory.quotient.lift.is_lift_hom CategoryTheory.Quotient.lift.isLift_hom

/- warning: category_theory.quotient.lift.is_lift_inv -> CategoryTheory.Quotient.lift.isLift_inv is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (r : HomRel.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] (F : CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (H : forall (x : C) (y : C) (f‚ÇÅ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y) (f‚ÇÇ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y), (r x y f‚ÇÅ f‚ÇÇ) -> (Eq.{succ u4} (Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 F y)) (CategoryTheory.Functor.map.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x y f‚ÇÅ) (CategoryTheory.Functor.map.{u2, u4, u1, u3} C _inst_1 D _inst_2 F x y f‚ÇÇ))) (X : C), Eq.{succ u4} (Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 (CategoryTheory.Functor.comp.{u2, u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.lift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) X)) (CategoryTheory.NatTrans.app.{u2, u4, u1, u3} C _inst_1 D _inst_2 F (CategoryTheory.Functor.comp.{u2, u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.lift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) (CategoryTheory.Iso.inv.{max u1 u4, max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.comp.{u2, u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.lift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) F (CategoryTheory.Quotient.lift.isLift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) X) (CategoryTheory.CategoryStruct.id.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2) (CategoryTheory.Functor.obj.{u2, u4, u1, u3} C _inst_1 D _inst_2 F X))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (r : HomRel.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] (F : CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (H : forall (x : C) (y : C) (f‚ÇÅ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y) (f‚ÇÇ : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) x y), (r x y f‚ÇÅ f‚ÇÇ) -> (Eq.{succ u4} (Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (Prefunctor.obj.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) x) (Prefunctor.obj.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) y)) (Prefunctor.map.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) x y f‚ÇÅ) (Prefunctor.map.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) x y f‚ÇÇ))) (X : C), Eq.{succ u4} (Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (Prefunctor.obj.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 (CategoryTheory.Functor.comp.{u2, u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.lift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H))) X)) (CategoryTheory.NatTrans.app.{u2, u4, u1, u3} C _inst_1 D _inst_2 F (CategoryTheory.Functor.comp.{u2, u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.lift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) (CategoryTheory.Iso.inv.{max u1 u4, max (max (max u1 u2) u3) u4} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.comp.{u2, u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.Quotient.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.category.{u1, u2} C _inst_1 r) D _inst_2 (CategoryTheory.Quotient.functor.{u1, u2} C _inst_1 r) (CategoryTheory.Quotient.lift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) F (CategoryTheory.Quotient.lift.isLift.{u1, u2, u3, u4} C _inst_1 r D _inst_2 F H)) X) (CategoryTheory.CategoryStruct.id.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2) (Prefunctor.obj.{succ u2, succ u4, u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u4, u1, u3} C _inst_1 D _inst_2 F) X))
Case conversion may be inaccurate. Consider using '#align category_theory.quotient.lift.is_lift_inv CategoryTheory.Quotient.lift.isLift_inv‚Çì'. -/
@[simp]
theorem lift.isLift_inv (X : C) : (lift.isLift r F H).inv.app X = ùüô (F.obj X) :=
  rfl
#align category_theory.quotient.lift.is_lift_inv CategoryTheory.Quotient.lift.isLift_inv

/- warning: category_theory.quotient.lift_map_functor_map -> CategoryTheory.Quotient.lift_map_functor_map is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.quotient.lift_map_functor_map CategoryTheory.Quotient.lift_map_functor_map‚Çì'. -/
theorem lift_map_functor_map {X Y : C} (f : X ‚ü∂ Y) :
    (lift r F H).map ((functor r).map f) = F.map f :=
  by
  rw [‚Üê nat_iso.naturality_1 (lift.is_lift r F H)]
  dsimp
  simp
#align category_theory.quotient.lift_map_functor_map CategoryTheory.Quotient.lift_map_functor_map

end Quotient

end CategoryTheory

