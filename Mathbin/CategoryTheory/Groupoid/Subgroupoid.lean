/-
Copyright (c) 2022 R√©mi Bottinelli. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: R√©mi Bottinelli, Junyan Xu
-/
import Mathbin.CategoryTheory.Groupoid.VertexGroup
import Mathbin.CategoryTheory.Groupoid
import Mathbin.Algebra.Group.Defs
import Mathbin.Algebra.Hom.Group
import Mathbin.Algebra.Hom.Equiv
import Mathbin.Data.Set.Lattice
import Mathbin.Combinatorics.Quiver.ConnectedComponent
import Mathbin.GroupTheory.Subgroup.Basic

/-!
# Subgroupoid

This file defines subgroupoids as `structure`s containing the subsets of arrows and their
stability under composition and inversion.
Also defined are

* containment of subgroupoids is a complete lattice;
* images and preimages of subgroupoids under a functor;
* the notion of normality of subgroupoids and its stability under intersection and preimage;
* compatibility of the above with `groupoid.vertex_group`.


## Main definitions

Given a type `C` with associated `groupoid C` instance.

* `subgroupoid C` is the type of subgroupoids of `C`
* `subgroupoid.is_normal` is the property that the subgroupoid is stable under conjugation
  by arbitrary arrows, _and_ that all identity arrows are contained in the subgroupoid.
* `subgroupoid.comap` is the "preimage" map of subgroupoids along a functor.
* `subgroupoid.map` is the "image" map of subgroupoids along a functor _injective on objects_.
* `subgroupoid.vertex_subgroup` is the subgroup of the `vertex group` at a given vertex `v`,
  assuming `v` is contained in the `subgroupoid` (meaning, by definition, that the arrow `ùüô v`
  is contained in the subgroupoid).

## Implementation details

The structure of this file is copied from/inspired by `group_theory.subgroup.basic`
and `combinatorics.simple_graph.subgraph`.

## TODO

* Equivalent inductive characterization of generated (normal) subgroupoids.
* Characterization of normal subgroupoids as kernels.

## Tags

subgroupoid

-/


namespace CategoryTheory

open Set Groupoid

attribute [local protected] CategoryTheory.inv

universe u v

variable {C : Type u} [Groupoid C]

/-- A sugroupoid of `C` consists of a choice of arrows for each pair of vertices, closed
under composition and inverses.
-/
@[ext]
structure Subgroupoid (C : Type u) [Groupoid C] where
  Arrows : ‚àÄ c d : C, Set (c ‚ü∂ d)
  inv : ‚àÄ {c d} {p : c ‚ü∂ d} (hp : p ‚àà arrows c d), inv p ‚àà arrows d c
  mul : ‚àÄ {c d e} {p} (hp : p ‚àà arrows c d) {q} (hq : q ‚àà arrows d e), p ‚â´ q ‚àà arrows c e

attribute [protected] subgroupoid.inv subgroupoid.mul

namespace Subgroupoid

variable (S : Subgroupoid C)

/-- The vertices of `C` on which `S` has non-trivial isotropy -/
def Objs : Set C :=
  { c : C | (S.Arrows c c).Nonempty }

theorem id_mem_of_nonempty_isotropy (c : C) : c ‚àà Objs S ‚Üí ùüô c ‚àà S.Arrows c c := by
  rintro ‚ü®Œ≥, hŒ≥‚ü©
  convert S.mul hŒ≥ (S.inv hŒ≥)
  simp only [inv_eq_inv, is_iso.hom_inv_id]

/-- A subgroupoid seen as a quiver on vertex set `C` -/
def asWideQuiver : Quiver C :=
  ‚ü®fun c d => Subtype <| S.Arrows c d‚ü©

/-- The coercion of a subgroupoid as a groupoid -/
instance coe : Groupoid S.Objs where
  Hom a b := S.Arrows a.val b.val
  id a := ‚ü®ùüô a.val, id_mem_of_nonempty_isotropy S a.val a.Prop‚ü©
  comp a b c p q := ‚ü®p.val ‚â´ q.val, S.mul p.Prop q.Prop‚ü©
  id_comp' := fun a b ‚ü®p, hp‚ü© => by simp only [category.id_comp]
  comp_id' := fun a b ‚ü®p, hp‚ü© => by simp only [category.comp_id]
  assoc' := fun a b c d ‚ü®p, hp‚ü© ‚ü®q, hq‚ü© ‚ü®r, hr‚ü© => by simp only [category.assoc]
  inv a b p := ‚ü®inv p.val, S.inv p.Prop‚ü©
  inv_comp' := fun a b ‚ü®p, hp‚ü© => by simp only [inv_comp]
  comp_inv' := fun a b ‚ü®p, hp‚ü© => by simp only [comp_inv]

/-- The embedding of the coerced subgroupoid to its parent-/
def hom : S.Objs ‚•§ C where
  obj c := c.val
  map c d f := f.val
  map_id' c := rfl
  map_comp' c d e f g := rfl

theorem hom.inj_on_objects : Function.Injective (hom S).obj := by
  rintro ‚ü®c, hc‚ü© ‚ü®d, hd‚ü© hcd
  simp only [Subtype.mk_eq_mk]
  exact hcd

theorem hom.faithful : ‚àÄ c d, Function.Injective fun f : c ‚ü∂ d => (hom S).map f := by
  rintro ‚ü®c, hc‚ü© ‚ü®d, hd‚ü© ‚ü®f, hf‚ü© ‚ü®g, hg‚ü© hfg
  simp only [Subtype.mk_eq_mk]
  exact hfg

/-- The subgroup of the vertex group at `c` given by the subgroupoid -/
def vertexSubgroup {c : C} (hc : c ‚àà S.Objs) : Subgroup (c ‚ü∂ c) where
  Carrier := S.Arrows c c
  mul_mem' f g hf hg := S.mul hf hg
  one_mem' := id_mem_of_nonempty_isotropy _ _ hc
  inv_mem' f hf := S.inv hf

instance : SetLike (Subgroupoid C) (Œ£c d : C, c ‚ü∂ d) where
  coe S := { F | F.2.2 ‚àà S.Arrows F.1 F.2.1 }
  coe_injective' := fun ‚ü®S, _, _‚ü© ‚ü®T, _, _‚ü© h => by
    ext c d f
    apply Set.ext_iff.1 h ‚ü®c, d, f‚ü©

theorem mem_iff (S : Subgroupoid C) (F : Œ£c d, c ‚ü∂ d) : F ‚àà S ‚Üî F.2.2 ‚àà S.Arrows F.1 F.2.1 :=
  Iff.rfl

theorem le_iff (S T : Subgroupoid C) : S ‚â§ T ‚Üî ‚àÄ {c d}, S.Arrows c d ‚äÜ T.Arrows c d := by
  rw [SetLike.le_def, Sigma.forall]
  exact forall_congr fun c => Sigma.forall

instance : HasTop (Subgroupoid C) :=
  ‚ü®{ Arrows := fun _ _ => Set.Univ,
      mul := by
        rintro
        trivial,
      inv := by
        rintro
        trivial }‚ü©

instance : HasBot (Subgroupoid C) :=
  ‚ü®{ Arrows := fun _ _ => ‚àÖ, mul := fun _ _ _ _ => False.elim, inv := fun _ _ _ => False.elim }‚ü©

instance : Inhabited (Subgroupoid C) :=
  ‚ü®‚ä§‚ü©

instance : HasInf (Subgroupoid C) :=
  ‚ü®fun S T =>
    { Arrows := fun c d => S.Arrows c d ‚à© T.Arrows c d,
      inv := by
        rintro
        exact ‚ü®S.inv hp.1, T.inv hp.2‚ü©,
      mul := by
        rintro
        exact ‚ü®S.mul hp.1 hq.1, T.mul hp.2 hq.2‚ü© }‚ü©

instance : HasInf (Subgroupoid C) :=
  ‚ü®fun s =>
    { Arrows := fun c d => ‚ãÇ S ‚àà s, Subgroupoid.Arrows S c d,
      inv := by
        intros
        rw [mem_Inter‚ÇÇ] at hp‚ä¢
        exact fun S hS => S.inv (hp S hS),
      mul := by
        intros
        rw [mem_Inter‚ÇÇ] at hp hq‚ä¢
        exact fun S hS => S.mul (hp S hS) (hq S hS) }‚ü©

instance : CompleteLattice (Subgroupoid C) :=
  { completeLatticeOfInf (Subgroupoid C)
      (by
        refine' fun s => ‚ü®fun S Ss F => _, fun T Tl F fT => _‚ü© <;> simp only [Inf, mem_iff, mem_Inter]
        exacts[fun hp => hp S Ss, fun S Ss => Tl Ss fT]) with
    bot := ‚ä•, bot_le := fun S => empty_subset _, top := ‚ä§, le_top := fun S => subset_univ _, inf := (¬∑ ‚äì ¬∑),
    le_inf := fun R S T RS RT _ pR => ‚ü®RS pR, RT pR‚ü©, inf_le_left := fun R S _ => And.left,
    inf_le_right := fun R S _ => And.right }

theorem le_objs {S T : Subgroupoid C} (h : S ‚â§ T) : S.Objs ‚äÜ T.Objs := fun s ‚ü®Œ≥, hŒ≥‚ü© => ‚ü®Œ≥, @h ‚ü®s, s, Œ≥‚ü© hŒ≥‚ü©

/-- The functor associated to the embedding of subgroupoids -/
def inclusion {S T : Subgroupoid C} (h : S ‚â§ T) : S.Objs ‚•§ T.Objs where
  obj s := ‚ü®s.val, le_objs h s.Prop‚ü©
  map s t f := ‚ü®f.val, @h ‚ü®s, t, f.val‚ü© f.Prop‚ü©
  map_id' _ := rfl
  map_comp' _ _ _ _ _ := rfl

theorem inclusion_inj_on_objects {S T : Subgroupoid C} (h : S ‚â§ T) : Function.Injective (inclusion h).obj :=
  fun ‚ü®s, hs‚ü© ‚ü®t, ht‚ü© => by simpa only [inclusion, Subtype.mk_eq_mk] using id

theorem inclusion_faithful {S T : Subgroupoid C} (h : S ‚â§ T) (s t : S.Objs) :
    Function.Injective fun f : s ‚ü∂ t => (inclusion h).map f := fun ‚ü®f, hf‚ü© ‚ü®g, hg‚ü© => by
  dsimp only [inclusion]
  simpa only [Subtype.mk_eq_mk] using id

theorem inclusion_refl {S : Subgroupoid C} : inclusion (le_refl S) = ùü≠ S.Objs :=
  Functor.hext (fun ‚ü®s, hs‚ü© => rfl) fun ‚ü®s, hs‚ü© ‚ü®t, ht‚ü© ‚ü®f, hf‚ü© => heq_of_eq rfl

theorem inclusion_trans {R S T : Subgroupoid C} (k : R ‚â§ S) (h : S ‚â§ T) :
    inclusion (k.trans h) = inclusion k ‚ãô inclusion h :=
  rfl

theorem inclusion_comp_embedding {S T : Subgroupoid C} (h : S ‚â§ T) : inclusion h ‚ãô T.Hom = S.Hom :=
  rfl

/-- The family of arrows of the discrete groupoid -/
inductive Discrete.Arrows : ‚àÄ c d : C, (c ‚ü∂ d) ‚Üí Prop
  | id (c : C) : discrete.arrows c c (ùüô c)

/-- The only arrows of the discrete groupoid are the identity arrows. -/
def discrete : Subgroupoid C where
  Arrows := Discrete.Arrows
  inv := by
    rintro _ _ _ ‚ü®‚ü©
    simp only [inv_eq_inv, is_iso.inv_id]
    constructor
  mul := by
    rintro _ _ _ _ ‚ü®‚ü© _ ‚ü®‚ü©
    rw [category.comp_id]
    constructor

theorem mem_discrete_iff {c d : C} (f : c ‚ü∂ d) : f ‚àà discrete.Arrows c d ‚Üî ‚àÉ h : c = d, f = eqToHom h :=
  ‚ü®by
    rintro ‚ü®‚ü©
    exact ‚ü®rfl, rfl‚ü©, by
    rintro ‚ü®rfl, rfl‚ü©
    constructor‚ü©

/-- A¬†subgroupoid is normal if it is ‚Äúwide‚Äù (meaning that its carrier set is all of `C`)
    and satisfies the expected stability under conjugacy. -/
structure IsNormal : Prop where
  wide : ‚àÄ c, ùüô c ‚àà S.Arrows c c
  conj : ‚àÄ {c d} (p : c ‚ü∂ d) {Œ≥ : c ‚ü∂ c} (hs : Œ≥ ‚àà S.Arrows c c), inv p ‚â´ Œ≥ ‚â´ p ‚àà S.Arrows d d

theorem IsNormal.conj' {S : Subgroupoid C} (Sn : IsNormal S) :
    ‚àÄ {c d} (p : d ‚ü∂ c) {Œ≥ : c ‚ü∂ c} (hs : Œ≥ ‚àà S.Arrows c c), p ‚â´ Œ≥ ‚â´ inv p ‚àà S.Arrows d d := fun c d p Œ≥ hs => by
  convert Sn.conj (inv p) hs
  simp

theorem IsNormal.conjugation_bij (Sn : IsNormal S) {c d} (p : c ‚ü∂ d) :
    Set.BijOn (fun Œ≥ : c ‚ü∂ c => inv p ‚â´ Œ≥ ‚â´ p) (S.Arrows c c) (S.Arrows d d) := by
  refine' ‚ü®fun Œ≥ Œ≥S => Sn.conj p Œ≥S, fun Œ≥‚ÇÅ Œ≥‚ÇÅS Œ≥‚ÇÇ Œ≥‚ÇÇS h => _, fun Œ¥ Œ¥S => ‚ü®p ‚â´ Œ¥ ‚â´ inv p, Sn.conj' p Œ¥S, _‚ü©‚ü©
  ¬∑ simpa only [inv_eq_inv, category.assoc, is_iso.hom_inv_id, category.comp_id, is_iso.hom_inv_id_assoc] using
      p ‚â´= h =‚â´ inv p
    
  ¬∑ simp only [inv_eq_inv, category.assoc, is_iso.inv_hom_id, category.comp_id, is_iso.inv_hom_id_assoc]
    

theorem top_is_normal : IsNormal (‚ä§ : Subgroupoid C) :=
  { wide := fun c => trivial, conj := fun a b c d e => trivial }

theorem Inf_is_normal (s : Set <| Subgroupoid C) (sn : ‚àÄ S ‚àà s, IsNormal S) : IsNormal (inf s) :=
  { wide := by
      simp_rw [Inf, mem_Inter‚ÇÇ]
      exact fun c S Ss => (sn S Ss).wide c,
    conj := by
      simp_rw [Inf, mem_Inter‚ÇÇ]
      exact fun c d p Œ≥ hŒ≥ S Ss => (sn S Ss).conj p (hŒ≥ S Ss) }

theorem IsNormal.vertex_subgroup (Sn : IsNormal S) (c : C) (cS : c ‚àà S.Objs) : (S.vertexSubgroup cS).Normal :=
  { conj_mem := fun x hx y => by
      rw [mul_assoc]
      exact Sn.conj' y hx }

section GeneratedSubgroupoid

-- TODO:¬†proof that generated is just "words in X" and generated_normal is similarly
variable (X : ‚àÄ c d : C, Set (c ‚ü∂ d))

/-- The subgropoid generated by the set of arrows `X` -/
def generated : Subgroupoid C :=
  inf { S : Subgroupoid C | ‚àÄ c d, X c d ‚äÜ S.Arrows c d }

/-- The normal sugroupoid generated by the set of arrows `X` -/
def generatedNormal : Subgroupoid C :=
  inf { S : Subgroupoid C | (‚àÄ c d, X c d ‚äÜ S.Arrows c d) ‚àß S.IsNormal }

theorem generated_normal_is_normal : (generatedNormal X).IsNormal :=
  Inf_is_normal _ fun S h => h.right

end GeneratedSubgroupoid

section Hom

variable {D : Type _} [Groupoid D] (œÜ : C ‚•§ D)

/-- A functor between groupoid defines a map of subgroupoids in the reverse direction
by taking preimages.
 -/
def comap (S : Subgroupoid D) : Subgroupoid C where
  Arrows c d := { f : c ‚ü∂ d | œÜ.map f ‚àà S.Arrows (œÜ.obj c) (œÜ.obj d) }
  inv c d p hp := by
    rw [mem_set_of, inv_eq_inv, œÜ.map_inv p, ‚Üê inv_eq_inv]
    exact S.inv hp
  mul := by
    rintro
    simp only [mem_set_of, functor.map_comp]
    apply S.mul <;> assumption

theorem comap_mono (S T : Subgroupoid D) : S ‚â§ T ‚Üí comap œÜ S ‚â§ comap œÜ T := fun ST ‚ü®c, d, p‚ü© => @ST ‚ü®_, _, _‚ü©

theorem is_normal_comap {S : Subgroupoid D} (Sn : IsNormal S) : IsNormal (comap œÜ S) :=
  { wide := fun c => by
      rw [comap, mem_set_of, Functor.map_id]
      apply Sn.wide,
    conj := fun c d f Œ≥ hŒ≥ => by
      simp only [comap, mem_set_of, functor.map_comp, functor.map_inv, inv_eq_inv]
      rw [‚Üê inv_eq_inv]
      exact Sn.conj _ hŒ≥ }

/-- The kernel of a functor between subgroupoid is the preimage. -/
def ker : Subgroupoid C :=
  comap œÜ discrete

theorem mem_ker_iff {c d : C} (f : c ‚ü∂ d) : f ‚àà (ker œÜ).Arrows c d ‚Üî ‚àÉ h : œÜ.obj c = œÜ.obj d, œÜ.map f = eqToHom h :=
  mem_discrete_iff (œÜ.map f)

/-- The family of arrows of the image of a subgroupoid under a functor injective on objects -/
inductive Map.Arrows (hœÜ : Function.Injective œÜ.obj) (S : Subgroupoid C) : ‚àÄ c d : D, (c ‚ü∂ d) ‚Üí Prop
  | im {c d : C} (f : c ‚ü∂ d) (hf : f ‚àà S.Arrows c d) : map.arrows (œÜ.obj c) (œÜ.obj d) (œÜ.map f)

theorem Map.mem_arrows_iff (hœÜ : Function.Injective œÜ.obj) (S : Subgroupoid C) {c d : D} (f : c ‚ü∂ d) :
    Map.Arrows œÜ hœÜ S c d f ‚Üî
      ‚àÉ (a b : C)(g : a ‚ü∂ b)(ha : œÜ.obj a = c)(hb : œÜ.obj b = d)(hg : g ‚àà S.Arrows a b),
        f = eqToHom ha.symm ‚â´ œÜ.map g ‚â´ eqToHom hb :=
  by
  constructor
  ¬∑ rintro ‚ü®g, hg‚ü©
    exact ‚ü®_, _, g, rfl, rfl, hg, eq_conj_eq_to_hom _‚ü©
    
  ¬∑ rintro ‚ü®a, b, g, rfl, rfl, hg, rfl‚ü©
    rw [‚Üê eq_conj_eq_to_hom]
    constructor
    exact hg
    

/-- The "forward" image of a subgroupoid under a functor injective on objects -/
def map (hœÜ : Function.Injective œÜ.obj) (S : Subgroupoid C) : Subgroupoid D where
  Arrows := Map.Arrows œÜ hœÜ S
  inv := by
    rintro _ _ _ ‚ü®‚ü©
    rw [inv_eq_inv, ‚Üê functor.map_inv, ‚Üê inv_eq_inv]
    constructor
    apply S.inv
    assumption
  mul := by
    rintro _ _ _ _ ‚ü®f, hf‚ü© q hq
    obtain ‚ü®c‚ÇÉ, c‚ÇÑ, g, he, rfl, hg, gq‚ü© := (map.mem_arrows_iff œÜ hœÜ S q).mp hq
    cases hœÜ he
    rw [gq, ‚Üê eq_conj_eq_to_hom, ‚Üê œÜ.map_comp]
    constructor
    exact S.mul hf hg

theorem map_mono (hœÜ : Function.Injective œÜ.obj) (S T : Subgroupoid C) : S ‚â§ T ‚Üí map œÜ hœÜ S ‚â§ map œÜ hœÜ T := by
  rintro ST ‚ü®c, d, f‚ü© ‚ü®_, h‚ü©
  constructor
  exact @ST ‚ü®_, _, _‚ü© h

/-- The image of a functor injective on objects -/
def im (hœÜ : Function.Injective œÜ.obj) :=
  map œÜ hœÜ ‚ä§

theorem mem_im_iff (hœÜ : Function.Injective œÜ.obj) {c d : D} (f : c ‚ü∂ d) :
    f ‚àà (im œÜ hœÜ).Arrows c d ‚Üî
      ‚àÉ (a b : C)(g : a ‚ü∂ b)(ha : œÜ.obj a = c)(hb : œÜ.obj b = d), f = eqToHom ha.symm ‚â´ œÜ.map g ‚â´ eqToHom hb :=
  by
  convert map.mem_arrows_iff œÜ hœÜ ‚ä§ f
  simp only [HasTop.top, mem_univ, exists_true_left]

end Hom

end Subgroupoid

end CategoryTheory

