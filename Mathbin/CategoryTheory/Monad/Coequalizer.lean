/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta

! This file was ported from Lean 3 source module category_theory.monad.coequalizer
! leanprover-community/mathlib commit 3a061790136d13594ec10c7c90d202335ac5d854
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Limits.Shapes.Reflexive
import Mathbin.CategoryTheory.Limits.Shapes.SplitCoequalizer
import Mathbin.CategoryTheory.Monad.Algebra

/-!
# Special coequalizers associated to a monad

Associated to a monad `T : C ⥤ C` we have important coequalizer constructions:
Any algebra is a coequalizer (in the category of algebras) of free algebras. Furthermore, this
coequalizer is reflexive.
In `C`, this cofork diagram is a split coequalizer (in particular, it is still a coequalizer).
This split coequalizer is known as the Beck coequalizer (as it features heavily in Beck's
monadicity theorem).
-/


universe v₁ u₁

namespace CategoryTheory

namespace Monad

open Limits

variable {C : Type u₁}

variable [Category.{v₁} C]

variable {T : Monad C} (X : Algebra T)

/-!
Show that any algebra is a coequalizer of free algebras.
-/


/- warning: category_theory.monad.free_coequalizer.top_map -> CategoryTheory.Monad.FreeCoequalizer.topMap is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T))) (CategoryTheory.Functor.obj.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.instCategoryStructAlgebra.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, max u2 u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, max u2 u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))
Case conversion may be inaccurate. Consider using '#align category_theory.monad.free_coequalizer.top_map CategoryTheory.Monad.FreeCoequalizer.topMapₓ'. -/
/-- The top map in the coequalizer diagram we will construct. -/
@[simps]
def FreeCoequalizer.topMap : (Monad.free T).obj (T.obj X.A) ⟶ (Monad.free T).obj X.A :=
  (Monad.free T).map X.a
#align category_theory.monad.free_coequalizer.top_map CategoryTheory.Monad.FreeCoequalizer.topMap

/- warning: category_theory.monad.free_coequalizer.bottom_map -> CategoryTheory.Monad.FreeCoequalizer.bottomMap is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.CategoryTheory.categoryStruct.{u1, u2} C _inst_1 T)) (CategoryTheory.Functor.obj.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.instCategoryStructAlgebra.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, max u2 u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, max u2 u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))
Case conversion may be inaccurate. Consider using '#align category_theory.monad.free_coequalizer.bottom_map CategoryTheory.Monad.FreeCoequalizer.bottomMapₓ'. -/
/-- The bottom map in the coequalizer diagram we will construct. -/
@[simps]
def FreeCoequalizer.bottomMap : (Monad.free T).obj (T.obj X.A) ⟶ (Monad.free T).obj X.A
    where
  f := T.μ.app X.A
  h' := T.and_assoc X.A
#align category_theory.monad.free_coequalizer.bottom_map CategoryTheory.Monad.FreeCoequalizer.bottomMap

/- warning: category_theory.monad.free_coequalizer.π -> CategoryTheory.Monad.FreeCoequalizer.π is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.CategoryTheory.categoryStruct.{u1, u2} C _inst_1 T)) (CategoryTheory.Functor.obj.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) X
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.instCategoryStructAlgebra.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, max u2 u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) X
Case conversion may be inaccurate. Consider using '#align category_theory.monad.free_coequalizer.π CategoryTheory.Monad.FreeCoequalizer.πₓ'. -/
/-- The cofork map in the coequalizer diagram we will construct. -/
@[simps]
def FreeCoequalizer.π : (Monad.free T).obj X.A ⟶ X
    where
  f := X.a
  h' := X.and_assoc.symm
#align category_theory.monad.free_coequalizer.π CategoryTheory.Monad.FreeCoequalizer.π

/- warning: category_theory.monad.free_coequalizer.condition -> CategoryTheory.Monad.FreeCoequalizer.condition is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), Eq.{succ u1} (Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T))) (CategoryTheory.Functor.obj.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) X) (CategoryTheory.CategoryStruct.comp.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T)) (CategoryTheory.Functor.obj.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) X (CategoryTheory.Monad.FreeCoequalizer.topMap.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.FreeCoequalizer.π.{u1, u2} C _inst_1 T X)) (CategoryTheory.CategoryStruct.comp.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.CategoryTheory.categoryStruct.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) X (CategoryTheory.Monad.FreeCoequalizer.bottomMap.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.FreeCoequalizer.π.{u1, u2} C _inst_1 T X))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), Eq.{succ u1} (Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.instCategoryStructAlgebra.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, max u2 u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) X) (CategoryTheory.CategoryStruct.comp.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.instCategoryStructAlgebra.{u1, u2} C _inst_1 T) (Prefunctor.obj.{succ u1, succ u1, u2, max u2 u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, max u2 u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) X (CategoryTheory.Monad.FreeCoequalizer.topMap.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.FreeCoequalizer.π.{u1, u2} C _inst_1 T X)) (CategoryTheory.CategoryStruct.comp.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.instCategoryStructAlgebra.{u1, u2} C _inst_1 T) (Prefunctor.obj.{succ u1, succ u1, u2, max u2 u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, max u2 u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) X (CategoryTheory.Monad.FreeCoequalizer.bottomMap.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.FreeCoequalizer.π.{u1, u2} C _inst_1 T X))
Case conversion may be inaccurate. Consider using '#align category_theory.monad.free_coequalizer.condition CategoryTheory.Monad.FreeCoequalizer.conditionₓ'. -/
theorem FreeCoequalizer.condition :
    FreeCoequalizer.topMap X ≫ FreeCoequalizer.π X =
      FreeCoequalizer.bottomMap X ≫ FreeCoequalizer.π X :=
  Algebra.Hom.ext _ _ X.and_assoc.symm
#align category_theory.monad.free_coequalizer.condition CategoryTheory.Monad.FreeCoequalizer.condition

instance : IsReflexivePair (FreeCoequalizer.topMap X) (FreeCoequalizer.bottomMap X) :=
  by
  apply is_reflexive_pair.mk' _ _ _
  apply (free T).map (T.η.app X.A)
  · ext
    dsimp
    rw [← functor.map_comp, X.unit, Functor.map_id]
  · ext
    apply monad.right_unit

/- warning: category_theory.monad.beck_algebra_cofork -> CategoryTheory.Monad.beckAlgebraCofork is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), CategoryTheory.Limits.Cofork.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.FreeCoequalizer.topMap.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.FreeCoequalizer.bottomMap.{u1, u2} C _inst_1 T X)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), CategoryTheory.Limits.Cofork.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (Prefunctor.obj.{succ u1, succ u1, u2, max u2 u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, max u2 u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.FreeCoequalizer.topMap.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.FreeCoequalizer.bottomMap.{u1, u2} C _inst_1 T X)
Case conversion may be inaccurate. Consider using '#align category_theory.monad.beck_algebra_cofork CategoryTheory.Monad.beckAlgebraCoforkₓ'. -/
/-- Construct the Beck cofork in the category of algebras. This cofork is reflexive as well as a
coequalizer.
-/
@[simps]
def beckAlgebraCofork : Cofork (FreeCoequalizer.topMap X) (FreeCoequalizer.bottomMap X) :=
  Cofork.ofπ _ (FreeCoequalizer.condition X)
#align category_theory.monad.beck_algebra_cofork CategoryTheory.Monad.beckAlgebraCofork

/- warning: category_theory.monad.beck_algebra_coequalizer -> CategoryTheory.Monad.beckAlgebraCoequalizer is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), CategoryTheory.Limits.IsColimit.{0, u1, 0, max u2 u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Limits.parallelPair.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.FreeCoequalizer.topMap.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.FreeCoequalizer.bottomMap.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.beckAlgebraCofork.{u1, u2} C _inst_1 T X)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), CategoryTheory.Limits.IsColimit.{0, u1, 0, max u2 u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Limits.parallelPair.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (Prefunctor.obj.{succ u1, succ u1, u2, max u2 u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, max u2 u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.eilenbergMoore.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.free.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.FreeCoequalizer.topMap.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.FreeCoequalizer.bottomMap.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.beckAlgebraCofork.{u1, u2} C _inst_1 T X)
Case conversion may be inaccurate. Consider using '#align category_theory.monad.beck_algebra_coequalizer CategoryTheory.Monad.beckAlgebraCoequalizerₓ'. -/
/-- The cofork constructed is a colimit. This shows that any algebra is a (reflexive) coequalizer of
free algebras.
-/
def beckAlgebraCoequalizer : IsColimit (beckAlgebraCofork X) :=
  Cofork.IsColimit.mk' _ fun s =>
    by
    have h₁ : (T : C ⥤ C).map X.a ≫ s.π.f = T.μ.app X.A ≫ s.π.f :=
      congr_arg monad.algebra.hom.f s.condition
    have h₂ : (T : C ⥤ C).map s.π.f ≫ s.X.a = T.μ.app X.A ≫ s.π.f := s.π.h
    refine' ⟨⟨T.η.app _ ≫ s.π.f, _⟩, _, _⟩
    · dsimp
      rw [functor.map_comp, category.assoc, h₂, monad.right_unit_assoc,
        show X.a ≫ _ ≫ _ = _ from T.η.naturality_assoc _ _, h₁, monad.left_unit_assoc]
    · ext
      simpa [← T.η.naturality_assoc, T.left_unit_assoc] using T.η.app ((T : C ⥤ C).obj X.A) ≫= h₁
    · intro m hm
      ext
      dsimp only
      rw [← hm]
      apply (X.unit_assoc _).symm
#align category_theory.monad.beck_algebra_coequalizer CategoryTheory.Monad.beckAlgebraCoequalizer

/- warning: category_theory.monad.beck_split_coequalizer -> CategoryTheory.Monad.beckSplitCoequalizer is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), CategoryTheory.IsSplitCoequalizer.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), CategoryTheory.IsSplitCoequalizer.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)
Case conversion may be inaccurate. Consider using '#align category_theory.monad.beck_split_coequalizer CategoryTheory.Monad.beckSplitCoequalizerₓ'. -/
/-- The Beck cofork is a split coequalizer. -/
def beckSplitCoequalizer : IsSplitCoequalizer (T.map X.a) (T.μ.app _) X.a :=
  ⟨T.η.app _, T.η.app _, X.and_assoc.symm, X.Unit, T.left_unit _, (T.η.naturality _).symm⟩
#align category_theory.monad.beck_split_coequalizer CategoryTheory.Monad.beckSplitCoequalizer

/- warning: category_theory.monad.beck_cofork -> CategoryTheory.Monad.beckCofork is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), CategoryTheory.Limits.Cofork.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), CategoryTheory.Limits.Cofork.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))
Case conversion may be inaccurate. Consider using '#align category_theory.monad.beck_cofork CategoryTheory.Monad.beckCoforkₓ'. -/
/-- This is the Beck cofork. It is a split coequalizer, in particular a coequalizer. -/
@[simps pt]
def beckCofork : Cofork (T.map X.a) (T.μ.app _) :=
  (beckSplitCoequalizer X).asCofork
#align category_theory.monad.beck_cofork CategoryTheory.Monad.beckCofork

/- warning: category_theory.monad.beck_cofork_π -> CategoryTheory.Monad.beckCofork_π is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) CategoryTheory.Limits.WalkingParallelPair.one) (CategoryTheory.Functor.obj.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Monad.beckCofork.{u1, u2} C _inst_1 T X))) CategoryTheory.Limits.WalkingParallelPair.one)) (CategoryTheory.Limits.Cofork.π.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.beckCofork.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{1, succ u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)))) CategoryTheory.Limits.WalkingParallelPair.one) (Prefunctor.obj.{1, succ u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Monad.beckCofork.{u1, u2} C _inst_1 T X)))) CategoryTheory.Limits.WalkingParallelPair.one)) (CategoryTheory.Limits.Cofork.π.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.beckCofork.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)
Case conversion may be inaccurate. Consider using '#align category_theory.monad.beck_cofork_π CategoryTheory.Monad.beckCofork_πₓ'. -/
@[simp]
theorem beckCofork_π : (beckCofork X).π = X.a :=
  rfl
#align category_theory.monad.beck_cofork_π CategoryTheory.Monad.beckCofork_π

/- warning: category_theory.monad.beck_coequalizer -> CategoryTheory.Monad.beckCoequalizer is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), CategoryTheory.Limits.IsColimit.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Monad.beckCofork.{u1, u2} C _inst_1 T X)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T), CategoryTheory.Limits.IsColimit.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Monad.beckCofork.{u1, u2} C _inst_1 T X)
Case conversion may be inaccurate. Consider using '#align category_theory.monad.beck_coequalizer CategoryTheory.Monad.beckCoequalizerₓ'. -/
/-- The Beck cofork is a coequalizer. -/
def beckCoequalizer : IsColimit (beckCofork X) :=
  (beckSplitCoequalizer X).isCoequalizer
#align category_theory.monad.beck_coequalizer CategoryTheory.Monad.beckCoequalizer

/- warning: category_theory.monad.beck_coequalizer_desc -> CategoryTheory.Monad.beckCoequalizer_desc is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (s : CategoryTheory.Limits.Cofork.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Monad.beckCofork.{u1, u2} C _inst_1 T X)) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) s)) (CategoryTheory.Limits.IsColimit.desc.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Monad.beckCofork.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.beckCoequalizer.{u1, u2} C _inst_1 T X) s) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Monad.beckCofork.{u1, u2} C _inst_1 T X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) s) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.η.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Limits.Cofork.π.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCₓ.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) s))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {T : CategoryTheory.Monad.{u1, u2} C _inst_1} (X : CategoryTheory.Monad.Algebra.{u1, u2} C _inst_1 T) (s : CategoryTheory.Limits.Cofork.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Monad.beckCofork.{u1, u2} C _inst_1 T X)) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) s)) (CategoryTheory.Limits.IsColimit.desc.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (CategoryTheory.Monad.beckCofork.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.beckCoequalizer.{u1, u2} C _inst_1 T X) s) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (Prefunctor.obj.{1, succ u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} C _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1)) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) s))) CategoryTheory.Limits.WalkingParallelPair.one) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.η.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Limits.Cofork.π.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X) (CategoryTheory.Monad.Algebra.a.{u1, u2} C _inst_1 T X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.μ.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Algebra.A.{u1, u2} C _inst_1 T X)) s))
Case conversion may be inaccurate. Consider using '#align category_theory.monad.beck_coequalizer_desc CategoryTheory.Monad.beckCoequalizer_descₓ'. -/
@[simp]
theorem beckCoequalizer_desc (s : Cofork (T.toFunctor.map X.a) (T.μ.app X.A)) :
    (beckCoequalizer X).desc s = T.η.app _ ≫ s.π :=
  rfl
#align category_theory.monad.beck_coequalizer_desc CategoryTheory.Monad.beckCoequalizer_desc

end Monad

end CategoryTheory

