/-
Copyright (c) 2019 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module category_theory.sums.associator
! leanprover-community/mathlib commit ee05e9ce1322178f0c12004eb93c00d2c8c00ed2
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Sums.Basic

/-!
# Associator for binary disjoint union of categories.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

The associator functor `((C ⊕ D) ⊕ E) ⥤ (C ⊕ (D ⊕ E))` and its inverse form an equivalence.
-/


universe v u

open CategoryTheory

open Sum

namespace CategoryTheory.sum

variable (C : Type u) [Category.{v} C] (D : Type u) [Category.{v} D] (E : Type u) [Category.{v} E]

#print CategoryTheory.sum.associator /-
/-- The associator functor `(C ⊕ D) ⊕ E ⥤ C ⊕ (D ⊕ E)` for sums of categories.
-/
def associator : Sum (Sum C D) E ⥤ Sum C (Sum D E)
    where
  obj X :=
    match X with
    | inl (inl X) => inl X
    | inl (inr X) => inr (inl X)
    | inr X => inr (inr X)
  map X Y f :=
    match X, Y, f with
    | inl (inl X), inl (inl Y), f => f
    | inl (inr X), inl (inr Y), f => f
    | inr X, inr Y, f => f
#align category_theory.sum.associator CategoryTheory.sum.associator
-/

/- warning: category_theory.sum.associator_obj_inl_inl -> CategoryTheory.sum.associator_obj_inl_inl is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] (X : C), Eq.{succ u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inl.{u2, u2} C D X))) (Sum.inl.{u2, u2} C (Sum.{u2, u2} D E) X)
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] (X : C), Eq.{succ u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inl.{u2, u2} C D X))) (Sum.inl.{u2, u2} C (Sum.{u2, u2} D E) X)
Case conversion may be inaccurate. Consider using '#align category_theory.sum.associator_obj_inl_inl CategoryTheory.sum.associator_obj_inl_inlₓ'. -/
@[simp]
theorem associator_obj_inl_inl (X) : (associator C D E).obj (inl (inl X)) = inl X :=
  rfl
#align category_theory.sum.associator_obj_inl_inl CategoryTheory.sum.associator_obj_inl_inl

/- warning: category_theory.sum.associator_obj_inl_inr -> CategoryTheory.sum.associator_obj_inl_inr is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] (X : D), Eq.{succ u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inr.{u2, u2} C D X))) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inl.{u2, u2} D E X))
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] (X : D), Eq.{succ u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inr.{u2, u2} C D X))) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inl.{u2, u2} D E X))
Case conversion may be inaccurate. Consider using '#align category_theory.sum.associator_obj_inl_inr CategoryTheory.sum.associator_obj_inl_inrₓ'. -/
@[simp]
theorem associator_obj_inl_inr (X) : (associator C D E).obj (inl (inr X)) = inr (inl X) :=
  rfl
#align category_theory.sum.associator_obj_inl_inr CategoryTheory.sum.associator_obj_inl_inr

/- warning: category_theory.sum.associator_obj_inr -> CategoryTheory.sum.associator_obj_inr is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] (X : E), Eq.{succ u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inr.{u2, u2} (Sum.{u2, u2} C D) E X)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inr.{u2, u2} D E X))
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] (X : E), Eq.{succ u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inr.{u2, u2} (Sum.{u2, u2} C D) E X)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inr.{u2, u2} D E X))
Case conversion may be inaccurate. Consider using '#align category_theory.sum.associator_obj_inr CategoryTheory.sum.associator_obj_inrₓ'. -/
@[simp]
theorem associator_obj_inr (X) : (associator C D E).obj (inr X) = inr (inr X) :=
  rfl
#align category_theory.sum.associator_obj_inr CategoryTheory.sum.associator_obj_inr

/- warning: category_theory.sum.associator_map_inl_inl -> CategoryTheory.sum.associator_map_inl_inl is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inl.{u2, u2} C D X)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inl.{u2, u2} C D Y))), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inl.{u2, u2} C D X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inl.{u2, u2} C D Y)))) (CategoryTheory.Functor.map.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inl.{u2, u2} C D X)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inl.{u2, u2} C D Y)) f) f
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inl.{u2, u2} C D X)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inl.{u2, u2} C D Y))), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inl.{u2, u2} C D X))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inl.{u2, u2} C D Y)))) (Prefunctor.map.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inl.{u2, u2} C D X)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inl.{u2, u2} C D Y)) f) f
Case conversion may be inaccurate. Consider using '#align category_theory.sum.associator_map_inl_inl CategoryTheory.sum.associator_map_inl_inlₓ'. -/
@[simp]
theorem associator_map_inl_inl {X Y : C} (f : inl (inl X) ⟶ inl (inl Y)) :
    (associator C D E).map f = f :=
  rfl
#align category_theory.sum.associator_map_inl_inl CategoryTheory.sum.associator_map_inl_inl

/- warning: category_theory.sum.associator_map_inl_inr -> CategoryTheory.sum.associator_map_inl_inr is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] {X : D} {Y : D} (f : Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inr.{u2, u2} C D X)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inr.{u2, u2} C D Y))), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inr.{u2, u2} C D X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inr.{u2, u2} C D Y)))) (CategoryTheory.Functor.map.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inr.{u2, u2} C D X)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inr.{u2, u2} C D Y)) f) f
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] {X : D} {Y : D} (f : Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inr.{u2, u2} C D X)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inr.{u2, u2} C D Y))), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inr.{u2, u2} C D X))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inr.{u2, u2} C D Y)))) (Prefunctor.map.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inr.{u2, u2} C D X)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inr.{u2, u2} C D Y)) f) f
Case conversion may be inaccurate. Consider using '#align category_theory.sum.associator_map_inl_inr CategoryTheory.sum.associator_map_inl_inrₓ'. -/
@[simp]
theorem associator_map_inl_inr {X Y : D} (f : inl (inr X) ⟶ inl (inr Y)) :
    (associator C D E).map f = f :=
  rfl
#align category_theory.sum.associator_map_inl_inr CategoryTheory.sum.associator_map_inl_inr

/- warning: category_theory.sum.associator_map_inr -> CategoryTheory.sum.associator_map_inr is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] {X : E} {Y : E} (f : Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.inr.{u2, u2} (Sum.{u2, u2} C D) E X) (Sum.inr.{u2, u2} (Sum.{u2, u2} C D) E Y)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inr.{u2, u2} (Sum.{u2, u2} C D) E X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inr.{u2, u2} (Sum.{u2, u2} C D) E Y))) (CategoryTheory.Functor.map.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inr.{u2, u2} (Sum.{u2, u2} C D) E X) (Sum.inr.{u2, u2} (Sum.{u2, u2} C D) E Y) f) f
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] {X : E} {Y : E} (f : Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.inr.{u2, u2} (Sum.{u2, u2} C D) E X) (Sum.inr.{u2, u2} (Sum.{u2, u2} C D) E Y)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inr.{u2, u2} (Sum.{u2, u2} C D) E X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inr.{u2, u2} (Sum.{u2, u2} C D) E Y))) (Prefunctor.map.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (CategoryTheory.sum.associator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inr.{u2, u2} (Sum.{u2, u2} C D) E X) (Sum.inr.{u2, u2} (Sum.{u2, u2} C D) E Y) f) f
Case conversion may be inaccurate. Consider using '#align category_theory.sum.associator_map_inr CategoryTheory.sum.associator_map_inrₓ'. -/
@[simp]
theorem associator_map_inr {X Y : E} (f : inr X ⟶ inr Y) : (associator C D E).map f = f :=
  rfl
#align category_theory.sum.associator_map_inr CategoryTheory.sum.associator_map_inr

#print CategoryTheory.sum.inverseAssociator /-
/-- The inverse associator functor `C ⊕ (D ⊕ E) ⥤ (C ⊕ D) ⊕ E` for sums of categories.
-/
def inverseAssociator : Sum C (Sum D E) ⥤ Sum (Sum C D) E
    where
  obj X :=
    match X with
    | inl X => inl (inl X)
    | inr (inl X) => inl (inr X)
    | inr (inr X) => inr X
  map X Y f :=
    match X, Y, f with
    | inl X, inl Y, f => f
    | inr (inl X), inr (inl Y), f => f
    | inr (inr X), inr (inr Y), f => f
#align category_theory.sum.inverse_associator CategoryTheory.sum.inverseAssociator
-/

/- warning: category_theory.sum.inverse_associator_obj_inl -> CategoryTheory.sum.inverseAssociator_obj_inl is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] (X : C), Eq.{succ u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inl.{u2, u2} C (Sum.{u2, u2} D E) X)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inl.{u2, u2} C D X))
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] (X : C), Eq.{succ u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inl.{u2, u2} C (Sum.{u2, u2} D E) X)) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inl.{u2, u2} C D X))
Case conversion may be inaccurate. Consider using '#align category_theory.sum.inverse_associator_obj_inl CategoryTheory.sum.inverseAssociator_obj_inlₓ'. -/
@[simp]
theorem inverseAssociator_obj_inl (X) : (inverseAssociator C D E).obj (inl X) = inl (inl X) :=
  rfl
#align category_theory.sum.inverse_associator_obj_inl CategoryTheory.sum.inverseAssociator_obj_inl

/- warning: category_theory.sum.inverse_associator_obj_inr_inl -> CategoryTheory.sum.inverseAssociator_obj_inr_inl is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] (X : D), Eq.{succ u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inl.{u2, u2} D E X))) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inr.{u2, u2} C D X))
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] (X : D), Eq.{succ u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inl.{u2, u2} D E X))) (Sum.inl.{u2, u2} (Sum.{u2, u2} C D) E (Sum.inr.{u2, u2} C D X))
Case conversion may be inaccurate. Consider using '#align category_theory.sum.inverse_associator_obj_inr_inl CategoryTheory.sum.inverseAssociator_obj_inr_inlₓ'. -/
@[simp]
theorem inverseAssociator_obj_inr_inl (X) :
    (inverseAssociator C D E).obj (inr (inl X)) = inl (inr X) :=
  rfl
#align category_theory.sum.inverse_associator_obj_inr_inl CategoryTheory.sum.inverseAssociator_obj_inr_inl

/- warning: category_theory.sum.inverse_associator_obj_inr_inr -> CategoryTheory.sum.inverseAssociator_obj_inr_inr is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] (X : E), Eq.{succ u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inr.{u2, u2} D E X))) (Sum.inr.{u2, u2} (Sum.{u2, u2} C D) E X)
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] (X : E), Eq.{succ u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inr.{u2, u2} D E X))) (Sum.inr.{u2, u2} (Sum.{u2, u2} C D) E X)
Case conversion may be inaccurate. Consider using '#align category_theory.sum.inverse_associator_obj_inr_inr CategoryTheory.sum.inverseAssociator_obj_inr_inrₓ'. -/
@[simp]
theorem inverseAssociator_obj_inr_inr (X) : (inverseAssociator C D E).obj (inr (inr X)) = inr X :=
  rfl
#align category_theory.sum.inverse_associator_obj_inr_inr CategoryTheory.sum.inverseAssociator_obj_inr_inr

/- warning: category_theory.sum.inverse_associator_map_inl -> CategoryTheory.sum.inverseAssociator_map_inl is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.inl.{u2, u2} C (Sum.{u2, u2} D E) X) (Sum.inl.{u2, u2} C (Sum.{u2, u2} D E) Y)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inl.{u2, u2} C (Sum.{u2, u2} D E) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inl.{u2, u2} C (Sum.{u2, u2} D E) Y))) (CategoryTheory.Functor.map.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inl.{u2, u2} C (Sum.{u2, u2} D E) X) (Sum.inl.{u2, u2} C (Sum.{u2, u2} D E) Y) f) f
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.inl.{u2, u2} C (Sum.{u2, u2} D E) X) (Sum.inl.{u2, u2} C (Sum.{u2, u2} D E) Y)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inl.{u2, u2} C (Sum.{u2, u2} D E) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inl.{u2, u2} C (Sum.{u2, u2} D E) Y))) (Prefunctor.map.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inl.{u2, u2} C (Sum.{u2, u2} D E) X) (Sum.inl.{u2, u2} C (Sum.{u2, u2} D E) Y) f) f
Case conversion may be inaccurate. Consider using '#align category_theory.sum.inverse_associator_map_inl CategoryTheory.sum.inverseAssociator_map_inlₓ'. -/
@[simp]
theorem inverseAssociator_map_inl {X Y : C} (f : inl X ⟶ inl Y) :
    (inverseAssociator C D E).map f = f :=
  rfl
#align category_theory.sum.inverse_associator_map_inl CategoryTheory.sum.inverseAssociator_map_inl

/- warning: category_theory.sum.inverse_associator_map_inr_inl -> CategoryTheory.sum.inverseAssociator_map_inr_inl is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] {X : D} {Y : D} (f : Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inl.{u2, u2} D E X)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inl.{u2, u2} D E Y))), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inl.{u2, u2} D E X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inl.{u2, u2} D E Y)))) (CategoryTheory.Functor.map.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inl.{u2, u2} D E X)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inl.{u2, u2} D E Y)) f) f
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] {X : D} {Y : D} (f : Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inl.{u2, u2} D E X)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inl.{u2, u2} D E Y))), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inl.{u2, u2} D E X))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inl.{u2, u2} D E Y)))) (Prefunctor.map.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inl.{u2, u2} D E X)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inl.{u2, u2} D E Y)) f) f
Case conversion may be inaccurate. Consider using '#align category_theory.sum.inverse_associator_map_inr_inl CategoryTheory.sum.inverseAssociator_map_inr_inlₓ'. -/
@[simp]
theorem inverseAssociator_map_inr_inl {X Y : D} (f : inr (inl X) ⟶ inr (inl Y)) :
    (inverseAssociator C D E).map f = f :=
  rfl
#align category_theory.sum.inverse_associator_map_inr_inl CategoryTheory.sum.inverseAssociator_map_inr_inl

/- warning: category_theory.sum.inverse_associator_map_inr_inr -> CategoryTheory.sum.inverseAssociator_map_inr_inr is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] {X : E} {Y : E} (f : Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inr.{u2, u2} D E X)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inr.{u2, u2} D E Y))), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inr.{u2, u2} D E X))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inr.{u2, u2} D E Y)))) (CategoryTheory.Functor.map.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inr.{u2, u2} D E X)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inr.{u2, u2} D E Y)) f) f
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E] {X : E} {Y : E} (f : Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inr.{u2, u2} D E X)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inr.{u2, u2} D E Y))), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inr.{u2, u2} D E X))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inr.{u2, u2} D E Y)))) (Prefunctor.map.{succ u1, succ u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)))) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3)) (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.inverseAssociator.{u1, u2} C _inst_1 D _inst_2 E _inst_3)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inr.{u2, u2} D E X)) (Sum.inr.{u2, u2} C (Sum.{u2, u2} D E) (Sum.inr.{u2, u2} D E Y)) f) f
Case conversion may be inaccurate. Consider using '#align category_theory.sum.inverse_associator_map_inr_inr CategoryTheory.sum.inverseAssociator_map_inr_inrₓ'. -/
@[simp]
theorem inverseAssociator_map_inr_inr {X Y : E} (f : inr (inr X) ⟶ inr (inr Y)) :
    (inverseAssociator C D E).map f = f :=
  rfl
#align category_theory.sum.inverse_associator_map_inr_inr CategoryTheory.sum.inverseAssociator_map_inr_inr

/- warning: category_theory.sum.associativity -> CategoryTheory.sum.associativity is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E], CategoryTheory.Equivalence.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3))
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] (D : Type.{u2}) [_inst_2 : CategoryTheory.Category.{u1, u2} D] (E : Type.{u2}) [_inst_3 : CategoryTheory.Category.{u1, u2} E], CategoryTheory.Equivalence.{u1, u1, u2, u2} (Sum.{u2, u2} (Sum.{u2, u2} C D) E) (Sum.{u2, u2} C (Sum.{u2, u2} D E)) (CategoryTheory.sum.{u1, u2} (Sum.{u2, u2} C D) (CategoryTheory.sum.{u1, u2} C _inst_1 D _inst_2) E _inst_3) (CategoryTheory.sum.{u1, u2} C _inst_1 (Sum.{u2, u2} D E) (CategoryTheory.sum.{u1, u2} D _inst_2 E _inst_3))
Case conversion may be inaccurate. Consider using '#align category_theory.sum.associativity CategoryTheory.sum.associativityₓ'. -/
/-- The equivalence of categories expressing associativity of sums of categories.
-/
def associativity : Sum (Sum C D) E ≌ Sum C (Sum D E) :=
  Equivalence.mk (associator C D E) (inverseAssociator C D E)
    (NatIso.ofComponents (fun X => eqToIso (by tidy)) (by tidy))
    (NatIso.ofComponents (fun X => eqToIso (by tidy)) (by tidy))
#align category_theory.sum.associativity CategoryTheory.sum.associativity

#print CategoryTheory.sum.associatorIsEquivalence /-
instance associatorIsEquivalence : IsEquivalence (associator C D E) :=
  (by infer_instance : IsEquivalence (associativity C D E).Functor)
#align category_theory.sum.associator_is_equivalence CategoryTheory.sum.associatorIsEquivalence
-/

#print CategoryTheory.sum.inverseAssociatorIsEquivalence /-
instance inverseAssociatorIsEquivalence : IsEquivalence (inverseAssociator C D E) :=
  (by infer_instance : IsEquivalence (associativity C D E).inverse)
#align category_theory.sum.inverse_associator_is_equivalence CategoryTheory.sum.inverseAssociatorIsEquivalence
-/

-- TODO unitors?
-- TODO pentagon natural transformation? ...satisfying?
end CategoryTheory.sum

