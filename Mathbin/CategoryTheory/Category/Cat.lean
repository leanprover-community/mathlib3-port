/-
Copyright (c) 2019 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov

! This file was ported from Lean 3 source module category_theory.category.Cat
! leanprover-community/mathlib commit a836c6dba9bd1ee2a0cdc9af0006a596f243031c
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.ConcreteCategory.Bundled
import Mathbin.CategoryTheory.DiscreteCategory
import Mathbin.CategoryTheory.Types
import Mathbin.CategoryTheory.Bicategory.Strict

/-!
# Category of categories

This file contains the definition of the category `Cat` of all categories.
In this category objects are categories and
morphisms are functors between these categories.

## Implementation notes

Though `Cat` is not a concrete category, we use `bundled` to define
its carrier type.
-/


universe v u

namespace CategoryTheory

#print CategoryTheory.Cat /-
-- intended to be used with explicit universe parameters
/-- Category of categories. -/
@[nolint check_univs]
def Cat :=
  Bundled Category.{v, u}
#align category_theory.Cat CategoryTheory.Cat
-/

namespace Cat

instance : Inhabited Cat :=
  ‚ü®‚ü®Type u, CategoryTheory.types‚ü©‚ü©

instance : CoeSort Cat (Type u) :=
  ‚ü®Bundled.Œ±‚ü©

#print CategoryTheory.Cat.str /-
instance str (C : Cat.{v, u}) : Category.{v, u} C :=
  C.str
#align category_theory.Cat.str CategoryTheory.Cat.str
-/

#print CategoryTheory.Cat.of /-
/-- Construct a bundled `Cat` from the underlying type and the typeclass. -/
def of (C : Type u) [Category.{v} C] : Cat.{v, u} :=
  Bundled.of C
#align category_theory.Cat.of CategoryTheory.Cat.of
-/

#print CategoryTheory.Cat.bicategory /-
/-- Bicategory structure on `Cat` -/
instance bicategory : Bicategory.{max v u, max v u} Cat.{v, u}
    where
  Hom C D := C ‚•§ D
  id C := ùü≠ C
  comp C D E F G := F ‚ãô G
  homCategory C D := Functor.category C D
  whiskerLeft C D E F G H Œ∑ := whiskerLeft F Œ∑
  whiskerRight C D E F G Œ∑ H := whiskerRight Œ∑ H
  associator A B C D := Functor.associator
  leftUnitor A B := Functor.leftUnitor
  rightUnitor A B := Functor.rightUnitor
  pentagon' A B C D E := Functor.pentagon
  triangle' A B C := Functor.triangle
#align category_theory.Cat.bicategory CategoryTheory.Cat.bicategory
-/

#print CategoryTheory.Cat.bicategory.strict /-
/-- `Cat` is a strict bicategory. -/
instance bicategory.strict : Bicategory.Strict Cat.{v, u}
    where
  id_comp' C D F := by cases F <;> rfl
  comp_id' C D F := by cases F <;> rfl
  assoc' := by intros <;> rfl
#align category_theory.Cat.bicategory.strict CategoryTheory.Cat.bicategory.strict
-/

#print CategoryTheory.Cat.category /-
/-- Category structure on `Cat` -/
instance category : LargeCategory.{max v u} Cat.{v, u} :=
  StrictBicategory.category Cat.{v, u}
#align category_theory.Cat.category CategoryTheory.Cat.category
-/

/- warning: category_theory.Cat.id_map -> CategoryTheory.Cat.id_map is a dubious translation:
lean 3 declaration is
  forall {C : CategoryTheory.Cat.{u1, u2}} {X : coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C} {Y : coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C} (f : Quiver.Hom.{succ u1, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C))) X Y), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C) (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C) (CategoryTheory.CategoryStruct.id.{max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} CategoryTheory.Cat.bicategory.{u1, u2}) C) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C) (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C) (CategoryTheory.CategoryStruct.id.{max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} CategoryTheory.Cat.bicategory.{u1, u2}) C) Y)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C) (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C) (CategoryTheory.CategoryStruct.id.{max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} CategoryTheory.Cat.bicategory.{u1, u2}) C) X Y f) f
but is expected to have type
  forall {C : CategoryTheory.Cat.{u2, u1}} {X : CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C} {Y : CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C} (f : Quiver.Hom.{succ u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) X Y), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) (Prefunctor.obj.{succ u2, succ u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C) (CategoryTheory.CategoryStruct.id.{max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} CategoryTheory.Cat.bicategory.{u2, u1}) C)) X) (Prefunctor.obj.{succ u2, succ u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C) (CategoryTheory.CategoryStruct.id.{max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} CategoryTheory.Cat.bicategory.{u2, u1}) C)) Y)) (Prefunctor.map.{succ u2, succ u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C) (CategoryTheory.CategoryStruct.id.{max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} CategoryTheory.Cat.bicategory.{u2, u1}) C)) X Y f) f
Case conversion may be inaccurate. Consider using '#align category_theory.Cat.id_map CategoryTheory.Cat.id_map‚Çì'. -/
@[simp]
theorem id_map {C : Cat} {X Y : C} (f : X ‚ü∂ Y) : (ùüô C : C ‚•§ C).map f = f :=
  Functor.id_map f
#align category_theory.Cat.id_map CategoryTheory.Cat.id_map

/- warning: category_theory.Cat.comp_obj -> CategoryTheory.Cat.comp_obj is a dubious translation:
lean 3 declaration is
  forall {C : CategoryTheory.Cat.{u1, u2}} {D : CategoryTheory.Cat.{u1, u2}} {E : CategoryTheory.Cat.{u1, u2}} (F : Quiver.Hom.{succ (max u1 u2), max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} CategoryTheory.Cat.bicategory.{u1, u2})) C D) (G : Quiver.Hom.{succ (max u1 u2), max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} CategoryTheory.Cat.bicategory.{u1, u2})) D E) (X : coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C), Eq.{succ u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} E) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C) (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} E) (CategoryTheory.Cat.str.{u1, u2} E) (CategoryTheory.CategoryStruct.comp.{max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} CategoryTheory.Cat.bicategory.{u1, u2}) C D E F G) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} D) (CategoryTheory.Cat.str.{u1, u2} D) (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} E) (CategoryTheory.Cat.str.{u1, u2} E) G (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C) (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} D) (CategoryTheory.Cat.str.{u1, u2} D) F X))
but is expected to have type
  forall {C : CategoryTheory.Cat.{u2, u1}} {D : CategoryTheory.Cat.{u2, u1}} {E : CategoryTheory.Cat.{u2, u1}} (F : Quiver.Hom.{max (succ u1) (succ u2), max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} CategoryTheory.Cat.bicategory.{u2, u1})) C D) (G : Quiver.Hom.{max (succ u1) (succ u2), max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} CategoryTheory.Cat.bicategory.{u2, u1})) D E) (X : CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C), Eq.{succ u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (Prefunctor.obj.{succ u2, succ u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Cat.str.{u2, u1} E))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Cat.str.{u2, u1} E) (CategoryTheory.CategoryStruct.comp.{max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} CategoryTheory.Cat.bicategory.{u2, u1}) C D E F G)) X) (Prefunctor.obj.{succ u2, succ u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Cat.str.{u2, u1} D))) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Cat.str.{u2, u1} E))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Cat.str.{u2, u1} D) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Cat.str.{u2, u1} E) G) (Prefunctor.obj.{succ u2, succ u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Cat.str.{u2, u1} D))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Cat.str.{u2, u1} D) F) X))
Case conversion may be inaccurate. Consider using '#align category_theory.Cat.comp_obj CategoryTheory.Cat.comp_obj‚Çì'. -/
@[simp]
theorem comp_obj {C D E : Cat} (F : C ‚ü∂ D) (G : D ‚ü∂ E) (X : C) : (F ‚â´ G).obj X = G.obj (F.obj X) :=
  Functor.comp_obj F G X
#align category_theory.Cat.comp_obj CategoryTheory.Cat.comp_obj

/- warning: category_theory.Cat.comp_map -> CategoryTheory.Cat.comp_map is a dubious translation:
lean 3 declaration is
  forall {C : CategoryTheory.Cat.{u1, u2}} {D : CategoryTheory.Cat.{u1, u2}} {E : CategoryTheory.Cat.{u1, u2}} (F : Quiver.Hom.{succ (max u1 u2), max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} CategoryTheory.Cat.bicategory.{u1, u2})) C D) (G : Quiver.Hom.{succ (max u1 u2), max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} CategoryTheory.Cat.bicategory.{u1, u2})) D E) {X : coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C} {Y : coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C} (f : Quiver.Hom.{succ u1, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C))) X Y), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} E) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} E) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} E) (CategoryTheory.Cat.str.{u1, u2} E))) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C) (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} E) (CategoryTheory.Cat.str.{u1, u2} E) (CategoryTheory.CategoryStruct.comp.{max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} CategoryTheory.Cat.bicategory.{u1, u2}) C D E F G) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C) (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} E) (CategoryTheory.Cat.str.{u1, u2} E) (CategoryTheory.CategoryStruct.comp.{max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} CategoryTheory.Cat.bicategory.{u1, u2}) C D E F G) Y)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C) (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} E) (CategoryTheory.Cat.str.{u1, u2} E) (CategoryTheory.CategoryStruct.comp.{max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} CategoryTheory.Cat.bicategory.{u1, u2}) C D E F G) X Y f) (CategoryTheory.Functor.map.{u1, u1, u2, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} D) (CategoryTheory.Cat.str.{u1, u2} D) (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} E) (CategoryTheory.Cat.str.{u1, u2} E) G (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C) (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} D) (CategoryTheory.Cat.str.{u1, u2} D) F X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C) (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} D) (CategoryTheory.Cat.str.{u1, u2} D) F Y) (CategoryTheory.Functor.map.{u1, u1, u2, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C) (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} D) (CategoryTheory.Cat.str.{u1, u2} D) F X Y f))
but is expected to have type
  forall {C : CategoryTheory.Cat.{u2, u1}} {D : CategoryTheory.Cat.{u2, u1}} {E : CategoryTheory.Cat.{u2, u1}} (F : Quiver.Hom.{max (succ u1) (succ u2), max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} CategoryTheory.Cat.bicategory.{u2, u1})) C D) (G : Quiver.Hom.{max (succ u1) (succ u2), max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} CategoryTheory.Cat.bicategory.{u2, u1})) D E) {X : CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C} {Y : CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C} (f : Quiver.Hom.{succ u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) X Y), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Cat.str.{u2, u1} E))) (Prefunctor.obj.{succ u2, succ u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Cat.str.{u2, u1} E))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Cat.str.{u2, u1} E) (CategoryTheory.CategoryStruct.comp.{max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} CategoryTheory.Cat.bicategory.{u2, u1}) C D E F G)) X) (Prefunctor.obj.{succ u2, succ u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Cat.str.{u2, u1} E))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Cat.str.{u2, u1} E) (CategoryTheory.CategoryStruct.comp.{max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} CategoryTheory.Cat.bicategory.{u2, u1}) C D E F G)) Y)) (Prefunctor.map.{succ u2, succ u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Cat.str.{u2, u1} E))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Cat.str.{u2, u1} E) (CategoryTheory.CategoryStruct.comp.{max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} (CategoryTheory.Bicategory.toCategoryStruct.{max u1 u2, max u1 u2, max (succ u1) (succ u2)} CategoryTheory.Cat.{u2, u1} CategoryTheory.Cat.bicategory.{u2, u1}) C D E F G)) X Y f) (Prefunctor.map.{succ u2, succ u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Cat.str.{u2, u1} D))) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Cat.str.{u2, u1} E))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Cat.str.{u2, u1} D) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} E) (CategoryTheory.Cat.str.{u2, u1} E) G) (Prefunctor.obj.{succ u2, succ u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Cat.str.{u2, u1} D))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Cat.str.{u2, u1} D) F) X) (Prefunctor.obj.{succ u2, succ u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Cat.str.{u2, u1} D))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Cat.str.{u2, u1} D) F) Y) (Prefunctor.map.{succ u2, succ u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C))) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Cat.str.{u2, u1} D))) (CategoryTheory.Functor.toPrefunctor.{u2, u2, u1, u1} (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} C) (CategoryTheory.Cat.str.{u2, u1} C) (CategoryTheory.Bundled.Œ±.{u1, max u1 (succ u2)} CategoryTheory.Category.{u2, u1} D) (CategoryTheory.Cat.str.{u2, u1} D) F) X Y f))
Case conversion may be inaccurate. Consider using '#align category_theory.Cat.comp_map CategoryTheory.Cat.comp_map‚Çì'. -/
@[simp]
theorem comp_map {C D E : Cat} (F : C ‚ü∂ D) (G : D ‚ü∂ E) {X Y : C} (f : X ‚ü∂ Y) :
    (F ‚â´ G).map f = G.map (F.map f) :=
  Functor.comp_map F G f
#align category_theory.Cat.comp_map CategoryTheory.Cat.comp_map

#print CategoryTheory.Cat.objects /-
/-- Functor that gets the set of objects of a category. It is not
called `forget`, because it is not a faithful functor. -/
def objects : Cat.{v, u} ‚•§ Type u where
  obj C := C
  map C D F := F.obj
#align category_theory.Cat.objects CategoryTheory.Cat.objects
-/

section

attribute [local simp] eq_to_hom_map

/- warning: category_theory.Cat.equiv_of_iso -> CategoryTheory.Cat.equivOfIso is a dubious translation:
lean 3 declaration is
  forall {C : CategoryTheory.Cat.{u1, u2}} {D : CategoryTheory.Cat.{u1, u2}}, (CategoryTheory.Iso.{max u1 u2, max (succ u2) u2 (succ u1)} CategoryTheory.Cat.{u1, u2} CategoryTheory.Cat.category.{u1, u2} C D) -> (CategoryTheory.Equivalence.{u1, u1, u2, u2} (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} C) (CategoryTheory.Cat.str.{u1, u2} C) (coeSort.{succ (max (succ u2) u2 (succ u1)), succ (succ u2)} CategoryTheory.Cat.{u1, u2} Type.{u2} CategoryTheory.Cat.hasCoeToSort.{u2, u1} D) (CategoryTheory.Cat.str.{u1, u2} D))
but is expected to have type
  forall {C : CategoryTheory.Cat.{u1, u2}} {D : CategoryTheory.Cat.{u1, u2}}, (CategoryTheory.Iso.{max u2 u1, max (succ u2) (succ u1)} CategoryTheory.Cat.{u1, u2} CategoryTheory.Cat.category.{u1, u2} C D) -> (CategoryTheory.Equivalence.{u1, u1, u2, u2} (CategoryTheory.Bundled.Œ±.{u2, max u2 (succ u1)} CategoryTheory.Category.{u1, u2} C) (CategoryTheory.Bundled.Œ±.{u2, max u2 (succ u1)} CategoryTheory.Category.{u1, u2} D) (CategoryTheory.Cat.str.{u1, u2} C) (CategoryTheory.Cat.str.{u1, u2} D))
Case conversion may be inaccurate. Consider using '#align category_theory.Cat.equiv_of_iso CategoryTheory.Cat.equivOfIso‚Çì'. -/
/-- Any isomorphism in `Cat` induces an equivalence of the underlying categories. -/
def equivOfIso {C D : Cat} (Œ≥ : C ‚âÖ D) : C ‚âå D
    where
  Functor := Œ≥.Hom
  inverse := Œ≥.inv
  unitIso := eqToIso <| Eq.symm Œ≥.hom_inv_id
  counitIso := eqToIso Œ≥.inv_hom_id
#align category_theory.Cat.equiv_of_iso CategoryTheory.Cat.equivOfIso

end

end Cat

#print CategoryTheory.typeToCat /-
/-- Embedding `Type` into `Cat` as discrete categories.

This ought to be modelled as a 2-functor!
-/
@[simps]
def typeToCat : Type u ‚•§ Cat where
  obj X := Cat.of (Discrete X)
  map X Y f := Discrete.functor (Discrete.mk ‚àò f)
  map_id' X := by apply Functor.ext; tidy
  map_comp' X Y Z f g := by apply Functor.ext; tidy
#align category_theory.Type_to_Cat CategoryTheory.typeToCat
-/

instance : Faithful typeToCat.{u}
    where map_injective' X Y f g h :=
    funext fun x => congr_arg Discrete.as (Functor.congr_obj h ‚ü®x‚ü©)

instance : Full typeToCat.{u}
    where
  preimage X Y F := Discrete.as ‚àò F.obj ‚àò Discrete.mk
  witness' := by
    intro X Y F
    apply Functor.ext
    ¬∑ intro x y f
      dsimp
      ext
    ¬∑ rintro ‚ü®x‚ü©
      ext
      rfl

end CategoryTheory

