/-
Copyright (c) 2022 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module category_theory.abelian.transfer
! leanprover-community/mathlib commit ef55335933293309ff8c0b1d20ffffeecbe5c39f
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Abelian.Basic
import Mathbin.CategoryTheory.Limits.Preserves.Shapes.Kernels
import Mathbin.CategoryTheory.Adjunction.Limits

/-!
# Transferring "abelian-ness" across a functor

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

If `C` is an additive category, `D` is an abelian category,
we have `F : C ‚•§ D` `G : D ‚•§ C` (both preserving zero morphisms),
`G` is left exact (that is, preserves finite limits),
and further we have `adj : G ‚ä£ F` and `i : F ‚ãô G ‚âÖ ùü≠ C`,
then `C` is also abelian.

See <https://stacks.math.columbia.edu/tag/03A3>

## Notes
The hypotheses, following the statement from the Stacks project,
may appear suprising: we don't ask that the counit of the adjunction is an isomorphism,
but just that we have some potentially unrelated isomorphism `i : F ‚ãô G ‚âÖ ùü≠ C`.

However Lemma A1.1.1 from [Elephant] shows that in this situation the counit itself
must be an isomorphism, and thus that `C` is a reflective subcategory of `D`.

Someone may like to formalize that lemma, and restate this theorem in terms of `reflective`.
(That lemma has a nice string diagrammatic proof that holds in any bicategory.)
-/


noncomputable section

namespace CategoryTheory

open CategoryTheory.Limits

universe v u‚ÇÅ u‚ÇÇ

namespace AbelianOfAdjunction

variable {C : Type u‚ÇÅ} [Category.{v} C] [Preadditive C]

variable {D : Type u‚ÇÇ} [Category.{v} D] [Abelian D]

variable (F : C ‚•§ D)

variable (G : D ‚•§ C) [Functor.PreservesZeroMorphisms G]

variable (i : F ‚ãô G ‚âÖ ùü≠ C) (adj : G ‚ä£ F)

include i

#print CategoryTheory.AbelianOfAdjunction.hasKernels /-
/-- No point making this an instance, as it requires `i`. -/
theorem hasKernels [PreservesFiniteLimits G] : HasKernels C :=
  {
    HasLimit := fun X Y f => by
      have := nat_iso.naturality_1 i f
      simp at this
      rw [‚Üê this]
      haveI : has_kernel (G.map (F.map f) ‚â´ i.hom.app _) := limits.has_kernel_comp_mono _ _
      apply limits.has_kernel_iso_comp }
#align category_theory.abelian_of_adjunction.has_kernels CategoryTheory.AbelianOfAdjunction.hasKernels
-/

include adj

#print CategoryTheory.AbelianOfAdjunction.hasCokernels /-
/-- No point making this an instance, as it requires `i` and `adj`. -/
theorem hasCokernels : HasCokernels C :=
  {
    HasColimit := fun X Y f =>
      by
      haveI : preserves_colimits G := adj.left_adjoint_preserves_colimits
      have := nat_iso.naturality_1 i f
      simp at this
      rw [‚Üê this]
      haveI : has_cokernel (G.map (F.map f) ‚â´ i.hom.app _) := limits.has_cokernel_comp_iso _ _
      apply limits.has_cokernel_epi_comp }
#align category_theory.abelian_of_adjunction.has_cokernels CategoryTheory.AbelianOfAdjunction.hasCokernels
-/

variable [Limits.HasCokernels C]

/- warning: category_theory.abelian_of_adjunction.cokernel_iso -> CategoryTheory.AbelianOfAdjunction.cokernelIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {D : Type.{u3}} [_inst_3 : CategoryTheory.Category.{u1, u3} D] [_inst_4 : CategoryTheory.Abelian.{u1, u3} D _inst_3] (F : CategoryTheory.Functor.{u1, u1, u2, u3} C _inst_1 D _inst_3) (G : CategoryTheory.Functor.{u1, u1, u3, u2} D _inst_3 C _inst_1) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u1, u3, u2} D _inst_3 C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) G], (CategoryTheory.Iso.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u3, u2} C _inst_1 D _inst_3 C _inst_1 F G) (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) -> (CategoryTheory.Adjunction.{u1, u1, u3, u2} D _inst_3 C _inst_1 G F) -> (forall [_inst_6 : CategoryTheory.Limits.HasCokernels.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), CategoryTheory.Iso.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u3, u2} D _inst_3 C _inst_1 G (CategoryTheory.Limits.cokernel.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Functor.obj.{u1, u1, u2, u3} C _inst_1 D _inst_3 F X) (CategoryTheory.Functor.obj.{u1, u1, u2, u3} C _inst_1 D _inst_3 F Y) (CategoryTheory.Functor.map.{u1, u1, u2, u3} C _inst_1 D _inst_3 F X Y f) (CategoryTheory.AbelianOfAdjunction.cokernelIso._proof_1.{u2, u3, u1} C _inst_1 D _inst_3 _inst_4 F X Y f))) (CategoryTheory.Limits.cokernel.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y f (CategoryTheory.AbelianOfAdjunction.cokernelIso._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_6 X Y f)))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {D : Type.{u3}} [_inst_3 : CategoryTheory.Category.{u1, u3} D] [_inst_4 : CategoryTheory.Abelian.{u1, u3} D _inst_3] (F : CategoryTheory.Functor.{u1, u1, u2, u3} C _inst_1 D _inst_3) (G : CategoryTheory.Functor.{u1, u1, u3, u2} D _inst_3 C _inst_1) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u1, u3, u2} D _inst_3 C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) G], (CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u3, u2} C _inst_1 D _inst_3 C _inst_1 F G) (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) -> (CategoryTheory.Adjunction.{u1, u1, u3, u2} D _inst_3 C _inst_1 G F) -> (forall [_inst_6 : CategoryTheory.Limits.HasCokernels.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), CategoryTheory.Iso.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u3, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u3, u2} D _inst_3 C _inst_1 G) (CategoryTheory.Limits.cokernel.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f) (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Abelian.hasCoequalizers.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f)))) (CategoryTheory.Limits.cokernel.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y f (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_6 X Y f)))
Case conversion may be inaccurate. Consider using '#align category_theory.abelian_of_adjunction.cokernel_iso CategoryTheory.AbelianOfAdjunction.cokernelIso‚Çì'. -/
/-- Auxiliary construction for `coimage_iso_image` -/
def cokernelIso {X Y : C} (f : X ‚ü∂ Y) : G.obj (cokernel (F.map f)) ‚âÖ cokernel f :=
  by
  -- We have to write an explicit `preserves_colimits` type here,
  -- as `left_adjoint_preserves_colimits` has universe variables.
  haveI : preserves_colimits G := adj.left_adjoint_preserves_colimits
  calc
    G.obj (cokernel (F.map f)) ‚âÖ cokernel (G.map (F.map f)) :=
      (as_iso (cokernel_comparison _ G)).symm
    _ ‚âÖ cokernel (_ ‚â´ f ‚â´ _) := (cokernel_iso_of_eq (nat_iso.naturality_2 i f).symm)
    _ ‚âÖ cokernel (f ‚â´ _) := (cokernel_epi_comp _ _)
    _ ‚âÖ cokernel f := cokernel_comp_is_iso _ _
    
#align category_theory.abelian_of_adjunction.cokernel_iso CategoryTheory.AbelianOfAdjunction.cokernelIso

variable [Limits.HasKernels C] [PreservesFiniteLimits G]

/- warning: category_theory.abelian_of_adjunction.coimage_iso_image_aux -> CategoryTheory.AbelianOfAdjunction.coimageIsoImageAux is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {D : Type.{u3}} [_inst_3 : CategoryTheory.Category.{u1, u3} D] [_inst_4 : CategoryTheory.Abelian.{u1, u3} D _inst_3] (F : CategoryTheory.Functor.{u1, u1, u2, u3} C _inst_1 D _inst_3) (G : CategoryTheory.Functor.{u1, u1, u3, u2} D _inst_3 C _inst_1) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u1, u3, u2} D _inst_3 C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) G], (CategoryTheory.Iso.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u3, u2} C _inst_1 D _inst_3 C _inst_1 F G) (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) -> (CategoryTheory.Adjunction.{u1, u1, u3, u2} D _inst_3 C _inst_1 G F) -> (forall [_inst_6 : CategoryTheory.Limits.HasCokernels.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] [_inst_7 : CategoryTheory.Limits.HasKernels.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] [_inst_8 : CategoryTheory.Limits.PreservesFiniteLimits.{u1, u1, u3, u2} D _inst_3 C _inst_1 G] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), CategoryTheory.Iso.{u1, u2} C _inst_1 (CategoryTheory.Limits.kernel.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Functor.obj.{u1, u1, u3, u2} D _inst_3 C _inst_1 G (CategoryTheory.Functor.obj.{u1, u1, u2, u3} C _inst_1 D _inst_3 F Y)) (CategoryTheory.Functor.obj.{u1, u1, u3, u2} D _inst_3 C _inst_1 G (CategoryTheory.Limits.cokernel.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Functor.obj.{u1, u1, u2, u3} C _inst_1 D _inst_3 F X) (CategoryTheory.Functor.obj.{u1, u1, u2, u3} C _inst_1 D _inst_3 F Y) (CategoryTheory.Functor.map.{u1, u1, u2, u3} C _inst_1 D _inst_3 F X Y f) (CategoryTheory.AbelianOfAdjunction.coimageIsoImageAux._proof_1.{u2, u3, u1} C _inst_1 D _inst_3 _inst_4 F X Y f))) (CategoryTheory.Functor.map.{u1, u1, u3, u2} D _inst_3 C _inst_1 G (CategoryTheory.Functor.obj.{u1, u1, u2, u3} C _inst_1 D _inst_3 F Y) (CategoryTheory.Limits.cokernel.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Functor.obj.{u1, u1, u2, u3} C _inst_1 D _inst_3 F X) (CategoryTheory.Functor.obj.{u1, u1, u2, u3} C _inst_1 D _inst_3 F Y) (CategoryTheory.Functor.map.{u1, u1, u2, u3} C _inst_1 D _inst_3 F X Y f) (CategoryTheory.AbelianOfAdjunction.coimageIsoImageAux._proof_1.{u2, u3, u1} C _inst_1 D _inst_3 _inst_4 F X Y f)) (CategoryTheory.Limits.cokernel.œÄ.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Functor.obj.{u1, u1, u2, u3} C _inst_1 D _inst_3 F X) (CategoryTheory.Functor.obj.{u1, u1, u2, u3} C _inst_1 D _inst_3 F Y) (CategoryTheory.Functor.map.{u1, u1, u2, u3} C _inst_1 D _inst_3 F X Y f) (CategoryTheory.AbelianOfAdjunction.coimageIsoImageAux._proof_2.{u2, u3, u1} C _inst_1 D _inst_3 _inst_4 F X Y f))) (CategoryTheory.AbelianOfAdjunction.coimageIsoImageAux._proof_3.{u2, u3, u1} C _inst_1 _inst_2 D _inst_3 _inst_4 F G _inst_5 _inst_8 X Y f)) (CategoryTheory.Limits.kernel.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y (CategoryTheory.Limits.cokernel.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y f (CategoryTheory.AbelianOfAdjunction.coimageIsoImageAux._proof_4.{u2, u1} C _inst_1 _inst_2 _inst_6 X Y f)) (CategoryTheory.Limits.cokernel.œÄ.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y f (CategoryTheory.AbelianOfAdjunction.coimageIsoImageAux._proof_5.{u2, u1} C _inst_1 _inst_2 _inst_6 X Y f)) (CategoryTheory.AbelianOfAdjunction.coimageIsoImageAux._proof_6.{u2, u1} C _inst_1 _inst_2 _inst_6 _inst_7 X Y f)))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {D : Type.{u3}} [_inst_3 : CategoryTheory.Category.{u1, u3} D] [_inst_4 : CategoryTheory.Abelian.{u1, u3} D _inst_3] (F : CategoryTheory.Functor.{u1, u1, u2, u3} C _inst_1 D _inst_3) (G : CategoryTheory.Functor.{u1, u1, u3, u2} D _inst_3 C _inst_1) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u1, u3, u2} D _inst_3 C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) G], (CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u3, u2} C _inst_1 D _inst_3 C _inst_1 F G) (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) -> (CategoryTheory.Adjunction.{u1, u1, u3, u2} D _inst_3 C _inst_1 G F) -> (forall [_inst_6 : CategoryTheory.Limits.HasCokernels.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] [_inst_7 : CategoryTheory.Limits.HasKernels.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] [_inst_8 : CategoryTheory.Limits.PreservesFiniteLimits.{u1, u1, u3, u2} D _inst_3 C _inst_1 G] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), CategoryTheory.Iso.{u1, u2} C _inst_1 (CategoryTheory.Limits.kernel.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) (Prefunctor.obj.{succ u1, succ u1, u3, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u3, u2} D _inst_3 C _inst_1 G) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y)) (Prefunctor.obj.{succ u1, succ u1, u3, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u3, u2} D _inst_3 C _inst_1 G) (CategoryTheory.Limits.cokernel.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f) (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Abelian.hasCoequalizers.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f)))) (Prefunctor.map.{succ u1, succ u1, u3, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u3, u2} D _inst_3 C _inst_1 G) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (CategoryTheory.Limits.cokernel.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f) (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Abelian.hasCoequalizers.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f))) (CategoryTheory.Limits.cokernel.œÄ.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f) (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Abelian.hasCoequalizers.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f)))) (CategoryTheory.Limits.instHasKernelObjToQuiverToCategoryStructToQuiverToCategoryStructToPrefunctorMap.{u1, u1, u3, u2} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) G _inst_5 (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (CategoryTheory.Limits.cokernel.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f) (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Abelian.hasCoequalizers.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f))) (CategoryTheory.Limits.cokernel.œÄ.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f) (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Abelian.hasCoequalizers.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f))) (CategoryTheory.Limits.HasKernels.has_limit.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Abelian.hasEqualizers.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (CategoryTheory.Limits.cokernel.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f) (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Abelian.hasCoequalizers.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f))) (CategoryTheory.Limits.cokernel.œÄ.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f) (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Abelian.hasCoequalizers.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f)))) (CategoryTheory.Limits.PreservesLimitsOfShape.preservesLimit.{0, 0, u1, u1, u3, u2} D _inst_3 C _inst_1 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory G (CategoryTheory.Limits.PreservesFiniteLimits.preservesFiniteLimits.{u1, u1, u3, u2} D _inst_3 C _inst_1 G _inst_8 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory CategoryTheory.Limits.instFinCategoryWalkingParallelPairWalkingParallelPairHomCategory) (CategoryTheory.Limits.parallelPair.{u1, u3} D _inst_3 (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (CategoryTheory.Limits.cokernel.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f) (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Abelian.hasCoequalizers.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f))) (CategoryTheory.Limits.cokernel.œÄ.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f) (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Abelian.hasCoequalizers.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f))) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (CategoryTheory.Limits.cokernel.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f) (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Abelian.hasCoequalizers.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f)))) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (CategoryTheory.Limits.cokernel.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f) (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Abelian.hasCoequalizers.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f)))) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (CategoryTheory.Limits.cokernel.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f) (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{u1, u3} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} D _inst_3 (CategoryTheory.Abelian.toPreadditive.{u1, u3} D _inst_3 _inst_4)) (CategoryTheory.Abelian.hasCoequalizers.{u1, u3} D _inst_3 _inst_4)) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) Y) (Prefunctor.map.{succ u1, succ u1, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} D (CategoryTheory.Category.toCategoryStruct.{u1, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u3} C _inst_1 D _inst_3 F) X Y f)))))))))) (CategoryTheory.Limits.kernel.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y (CategoryTheory.Limits.cokernel.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y f (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_6 X Y f)) (CategoryTheory.Limits.cokernel.œÄ.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y f (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_6 X Y f)) (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_7 Y (CategoryTheory.Limits.cokernel.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y f (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_6 X Y f)) (CategoryTheory.Limits.cokernel.œÄ.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y f (CategoryTheory.Limits.HasCokernels.has_colimit.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_6 X Y f)))))
Case conversion may be inaccurate. Consider using '#align category_theory.abelian_of_adjunction.coimage_iso_image_aux CategoryTheory.AbelianOfAdjunction.coimageIsoImageAux‚Çì'. -/
/-- Auxiliary construction for `coimage_iso_image` -/
def coimageIsoImageAux {X Y : C} (f : X ‚ü∂ Y) :
    kernel (G.map (cokernel.œÄ (F.map f))) ‚âÖ kernel (cokernel.œÄ f) :=
  by
  haveI : preserves_colimits G := adj.left_adjoint_preserves_colimits
  calc
    kernel (G.map (cokernel.œÄ (F.map f))) ‚âÖ
        kernel (cokernel.œÄ (G.map (F.map f)) ‚â´ cokernel_comparison (F.map f) G) :=
      kernel_iso_of_eq (œÄ_comp_cokernel_comparison _ _).symm
    _ ‚âÖ kernel (cokernel.œÄ (G.map (F.map f))) := (kernel_comp_mono _ _)
    _ ‚âÖ kernel (cokernel.œÄ (_ ‚â´ f ‚â´ _) ‚â´ (cokernel_iso_of_eq _).Hom) :=
      (kernel_iso_of_eq (œÄ_comp_cokernel_iso_of_eq_hom (nat_iso.naturality_2 i f)).symm)
    _ ‚âÖ kernel (cokernel.œÄ (_ ‚â´ f ‚â´ _)) := (kernel_comp_mono _ _)
    _ ‚âÖ kernel (cokernel.œÄ (f ‚â´ i.inv.app Y) ‚â´ (cokernel_epi_comp (i.hom.app X) _).inv) :=
      (kernel_iso_of_eq (by simp only [cokernel.œÄ_desc, cokernel_epi_comp_inv]))
    _ ‚âÖ kernel (cokernel.œÄ (f ‚â´ _)) := (kernel_comp_mono _ _)
    _ ‚âÖ kernel (inv (i.inv.app Y) ‚â´ cokernel.œÄ f ‚â´ (cokernel_comp_is_iso f (i.inv.app Y)).inv) :=
      (kernel_iso_of_eq
        (by
          simp only [cokernel.œÄ_desc, cokernel_comp_is_iso_inv, iso.hom_inv_id_app_assoc,
            nat_iso.inv_inv_app]))
    _ ‚âÖ kernel (cokernel.œÄ f ‚â´ _) := (kernel_is_iso_comp _ _)
    _ ‚âÖ kernel (cokernel.œÄ f) := kernel_comp_mono _ _
    
#align category_theory.abelian_of_adjunction.coimage_iso_image_aux CategoryTheory.AbelianOfAdjunction.coimageIsoImageAux

variable [Functor.PreservesZeroMorphisms F]

#print CategoryTheory.AbelianOfAdjunction.coimageIsoImage /-
/-- Auxiliary definition: the abelian coimage and abelian image agree.
We still need to check that this agrees with the canonical morphism.
-/
def coimageIsoImage {X Y : C} (f : X ‚ü∂ Y) : Abelian.coimage f ‚âÖ Abelian.image f :=
  by
  haveI : preserves_limits F := adj.right_adjoint_preserves_limits
  haveI : preserves_colimits G := adj.left_adjoint_preserves_colimits
  calc
    abelian.coimage f ‚âÖ cokernel (kernel.Œπ f) := iso.refl _
    _ ‚âÖ G.obj (cokernel (F.map (kernel.Œπ f))) := (cokernel_iso _ _ i adj _).symm
    _ ‚âÖ G.obj (cokernel (kernel_comparison f F ‚â´ kernel.Œπ (F.map f))) :=
      (G.map_iso (cokernel_iso_of_eq (by simp)))
    _ ‚âÖ G.obj (cokernel (kernel.Œπ (F.map f))) := (G.map_iso (cokernel_epi_comp _ _))
    _ ‚âÖ G.obj (abelian.coimage (F.map f)) := (iso.refl _)
    _ ‚âÖ G.obj (abelian.image (F.map f)) := (G.map_iso (abelian.coimage_iso_image _))
    _ ‚âÖ G.obj (kernel (cokernel.œÄ (F.map f))) := (iso.refl _)
    _ ‚âÖ kernel (G.map (cokernel.œÄ (F.map f))) := (preserves_kernel.iso _ _)
    _ ‚âÖ kernel (cokernel.œÄ f) := (coimage_iso_image_aux F G i adj f)
    _ ‚âÖ abelian.image f := iso.refl _
    
#align category_theory.abelian_of_adjunction.coimage_iso_image CategoryTheory.AbelianOfAdjunction.coimageIsoImage
-/

attribute [local simp] cokernel_iso coimage_iso_image coimage_iso_image_aux

#print CategoryTheory.AbelianOfAdjunction.coimageIsoImage_hom /-
-- The account of this proof in the Stacks project omits this calculation.
theorem coimageIsoImage_hom {X Y : C} (f : X ‚ü∂ Y) :
    (coimageIsoImage F G i adj f).Hom = Abelian.coimageImageComparison f :=
  by
  ext
  simpa only [‚Üê G.map_comp_assoc, coimage_iso_image, nat_iso.inv_inv_app, cokernel_iso,
    coimage_iso_image_aux, iso.trans_symm, iso.symm_symm_eq, iso.refl_trans, iso.trans_refl,
    iso.trans_hom, iso.symm_hom, cokernel_comp_is_iso_inv, cokernel_epi_comp_inv, as_iso_hom,
    functor.map_iso_hom, cokernel_epi_comp_hom, preserves_kernel.iso_hom, kernel_comp_mono_hom,
    kernel_is_iso_comp_hom, cokernel_iso_of_eq_hom_comp_desc_assoc, cokernel.œÄ_desc_assoc,
    category.assoc, œÄ_comp_cokernel_iso_of_eq_inv_assoc, œÄ_comp_cokernel_comparison_assoc,
    kernel.lift_Œπ, kernel.lift_Œπ_assoc, kernel_iso_of_eq_hom_comp_Œπ_assoc,
    kernel_comparison_comp_Œπ_assoc, abelian.coimage_image_factorisation] using
    nat_iso.naturality_1 i f
#align category_theory.abelian_of_adjunction.coimage_iso_image_hom CategoryTheory.AbelianOfAdjunction.coimageIsoImage_hom
-/

end AbelianOfAdjunction

open AbelianOfAdjunction

#print CategoryTheory.abelianOfAdjunction /-
/-- If `C` is an additive category, `D` is an abelian category,
we have `F : C ‚•§ D` `G : D ‚•§ C` (both preserving zero morphisms),
`G` is left exact (that is, preserves finite limits),
and further we have `adj : G ‚ä£ F` and `i : F ‚ãô G ‚âÖ ùü≠ C`,
then `C` is also abelian.

See <https://stacks.math.columbia.edu/tag/03A3>
-/
def abelianOfAdjunction {C : Type u‚ÇÅ} [Category.{v} C] [Preadditive C] [HasFiniteProducts C]
    {D : Type u‚ÇÇ} [Category.{v} D] [Abelian D] (F : C ‚•§ D) [Functor.PreservesZeroMorphisms F]
    (G : D ‚•§ C) [Functor.PreservesZeroMorphisms G] [PreservesFiniteLimits G] (i : F ‚ãô G ‚âÖ ùü≠ C)
    (adj : G ‚ä£ F) : Abelian C := by
  haveI := has_kernels F G i
  haveI := has_cokernels F G i adj
  have : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), is_iso (abelian.coimage_image_comparison f) :=
    by
    intro X Y f
    rw [‚Üê coimage_iso_image_hom F G i adj f]
    infer_instance
  apply abelian.of_coimage_image_comparison_is_iso
#align category_theory.abelian_of_adjunction CategoryTheory.abelianOfAdjunction
-/

#print CategoryTheory.abelianOfEquivalence /-
/-- If `C` is an additive category equivalent to an abelian category `D`
via a functor that preserves zero morphisms,
then `C` is also abelian.
-/
def abelianOfEquivalence {C : Type u‚ÇÅ} [Category.{v} C] [Preadditive C] [HasFiniteProducts C]
    {D : Type u‚ÇÇ} [Category.{v} D] [Abelian D] (F : C ‚•§ D) [Functor.PreservesZeroMorphisms F]
    [IsEquivalence F] : Abelian C :=
  abelianOfAdjunction F F.inv F.asEquivalence.unitIso.symm F.asEquivalence.symm.toAdjunction
#align category_theory.abelian_of_equivalence CategoryTheory.abelianOfEquivalence
-/

end CategoryTheory

