/-
Copyright (c) 2022 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module category_theory.abelian.functor_category
! leanprover-community/mathlib commit 8abfb3ba5e211d8376b855dab5d67f9eba9e0774
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Abelian.Basic
import Mathbin.CategoryTheory.Preadditive.FunctorCategory
import Mathbin.CategoryTheory.Limits.Shapes.FunctorCategory
import Mathbin.CategoryTheory.Limits.Preserves.Shapes.Kernels

/-!
# If `D` is abelian, then the functor category `C ⥤ D` is also abelian.

-/


noncomputable section

namespace CategoryTheory

open CategoryTheory.Limits

namespace Abelian

section

universe z w v u

variable {C : Type max v u} [Category.{v} C]

variable {D : Type w} [Category.{max z v u} D] [Abelian D]

namespace FunctorCategory

variable {F G : C ⥤ D} (α : F ⟶ G) (X : C)

/- warning: category_theory.abelian.functor_category.coimage_obj_iso -> CategoryTheory.Abelian.FunctorCategory.coimageObjIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{max u3 u4}} [_inst_1 : CategoryTheory.Category.{u3, max u3 u4} C] {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{max u1 u3 u4, u2} D] [_inst_3 : CategoryTheory.Abelian.{max u1 u3 u4, u2} D _inst_2] {F : CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2} {G : CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2} (α : Quiver.Hom.{succ (max u1 u3 u4), max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2))) F G) (X : C), CategoryTheory.Iso.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) X) (CategoryTheory.Abelian.coimage.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.hasKernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.hasCokernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 G X) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F G α X))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u3, u4} C] {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{u1, u2} D] [_inst_3 : CategoryTheory.Abelian.{u1, u2} D _inst_2] {F : CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2} {G : CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2} (α : Quiver.Hom.{max (succ u4) (succ u1), max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2))) F G) (X : C), CategoryTheory.Iso.{u1, u2} D _inst_2 (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α)) X) (CategoryTheory.Abelian.coimage.{u1, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.has_kernels.{u1, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.has_cokernels.{u1, u2} D _inst_2 _inst_3) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 G) X) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 F G α X))
Case conversion may be inaccurate. Consider using '#align category_theory.abelian.functor_category.coimage_obj_iso CategoryTheory.Abelian.FunctorCategory.coimageObjIsoₓ'. -/
/-- The abelian coimage in a functor category can be calculated componentwise. -/
@[simps]
def coimageObjIso : (Abelian.coimage α).obj X ≅ Abelian.coimage (α.app X) :=
  PreservesCokernel.iso ((evaluation C D).obj X) _ ≪≫
    cokernel.mapIso _ _ (PreservesKernel.iso ((evaluation C D).obj X) _) (Iso.refl _)
      (by
        dsimp
        simp only [category.comp_id]
        exact (kernel_comparison_comp_ι _ ((evaluation C D).obj X)).symm)
#align category_theory.abelian.functor_category.coimage_obj_iso CategoryTheory.Abelian.FunctorCategory.coimageObjIso

/- warning: category_theory.abelian.functor_category.image_obj_iso -> CategoryTheory.Abelian.FunctorCategory.imageObjIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{max u3 u4}} [_inst_1 : CategoryTheory.Category.{u3, max u3 u4} C] {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{max u1 u3 u4, u2} D] [_inst_3 : CategoryTheory.Abelian.{max u1 u3 u4, u2} D _inst_2] {F : CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2} {G : CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2} (α : Quiver.Hom.{succ (max u1 u3 u4), max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2))) F G) (X : C), CategoryTheory.Iso.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.image.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.imageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.imageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) X) (CategoryTheory.Abelian.image.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.hasKernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.hasCokernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 G X) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F G α X))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u3, u4} C] {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{u1, u2} D] [_inst_3 : CategoryTheory.Abelian.{u1, u2} D _inst_2] {F : CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2} {G : CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2} (α : Quiver.Hom.{max (succ u4) (succ u1), max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2))) F G) (X : C), CategoryTheory.Iso.{u1, u2} D _inst_2 (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.image.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α)) X) (CategoryTheory.Abelian.image.{u1, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.has_kernels.{u1, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.has_cokernels.{u1, u2} D _inst_2 _inst_3) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 G) X) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 F G α X))
Case conversion may be inaccurate. Consider using '#align category_theory.abelian.functor_category.image_obj_iso CategoryTheory.Abelian.FunctorCategory.imageObjIsoₓ'. -/
/-- The abelian image in a functor category can be calculated componentwise. -/
@[simps]
def imageObjIso : (Abelian.image α).obj X ≅ Abelian.image (α.app X) :=
  PreservesKernel.iso ((evaluation C D).obj X) _ ≪≫
    kernel.mapIso _ _ (Iso.refl _) (PreservesCokernel.iso ((evaluation C D).obj X) _)
      (by
        apply (cancel_mono (preserves_cokernel.iso ((evaluation C D).obj X) α).inv).1
        simp only [category.assoc, iso.hom_inv_id]
        dsimp
        simp only [category.id_comp, category.comp_id]
        exact (π_comp_cokernel_comparison _ ((evaluation C D).obj X)).symm)
#align category_theory.abelian.functor_category.image_obj_iso CategoryTheory.Abelian.FunctorCategory.imageObjIso

/- warning: category_theory.abelian.functor_category.coimage_image_comparison_app -> CategoryTheory.Abelian.FunctorCategory.coimageImageComparison_app is a dubious translation:
lean 3 declaration is
  forall {C : Type.{max u3 u4}} [_inst_1 : CategoryTheory.Category.{u3, max u3 u4} C] {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{max u1 u3 u4, u2} D] [_inst_3 : CategoryTheory.Abelian.{max u1 u3 u4, u2} D _inst_2] {F : CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2} {G : CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2} (α : Quiver.Hom.{succ (max u1 u3 u4), max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2))) F G) (X : C), Eq.{succ (max u1 u3 u4)} (Quiver.Hom.{succ (max u1 u3 u4), u2} D (CategoryTheory.CategoryStruct.toQuiver.{max u1 u3 u4, u2} D (CategoryTheory.Category.toCategoryStruct.{max u1 u3 u4, u2} D _inst_2)) (CategoryTheory.Abelian.coimage.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.hasKernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.hasCokernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 G X) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Abelian.image.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.hasKernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.hasCokernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 G X) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F G α X))) (CategoryTheory.Abelian.coimageImageComparison.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.hasKernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.hasCokernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 G X) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.CategoryStruct.comp.{max u1 u3 u4, u2} D (CategoryTheory.Category.toCategoryStruct.{max u1 u3 u4, u2} D _inst_2) (CategoryTheory.Abelian.coimage.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.hasKernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.hasCokernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 G X) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) X) (CategoryTheory.Abelian.image.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.hasKernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.hasCokernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 G X) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Iso.inv.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) X) (CategoryTheory.Abelian.coimage.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.hasKernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.hasCokernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 G X) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 F G α X)) (CategoryTheory.CategoryStruct.comp.{max u1 u3 u4, u2} D (CategoryTheory.Category.toCategoryStruct.{max u1 u3 u4, u2} D _inst_2) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.image.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) X) (CategoryTheory.Abelian.image.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.hasKernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.hasCokernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 G X) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) (CategoryTheory.Abelian.image.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) (CategoryTheory.Abelian.coimageImageComparison.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) X) (CategoryTheory.Iso.hom.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.image.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.imageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.imageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) X) (CategoryTheory.Abelian.image.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.hasKernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.hasCokernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 G X) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Abelian.FunctorCategory.imageObjIso.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 F G α X))))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u3, u4} C] {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{u1, u2} D] [_inst_3 : CategoryTheory.Abelian.{u1, u2} D _inst_2] {F : CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2} {G : CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2} (α : Quiver.Hom.{max (succ u4) (succ u1), max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2))) F G) (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Abelian.coimage.{u1, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.has_kernels.{u1, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.has_cokernels.{u1, u2} D _inst_2 _inst_3) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 G) X) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Abelian.image.{u1, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.has_kernels.{u1, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.has_cokernels.{u1, u2} D _inst_2 _inst_3) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 G) X) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 F G α X))) (CategoryTheory.Abelian.coimageImageComparison.{u1, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.has_kernels.{u1, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.has_cokernels.{u1, u2} D _inst_2 _inst_3) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 G) X) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2) (CategoryTheory.Abelian.coimage.{u1, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.has_kernels.{u1, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.has_cokernels.{u1, u2} D _inst_2 _inst_3) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 G) X) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 F G α X)) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α)) X) (CategoryTheory.Abelian.image.{u1, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.has_kernels.{u1, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.has_cokernels.{u1, u2} D _inst_2 _inst_3) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 G) X) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Iso.inv.{u1, u2} D _inst_2 (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α)) X) (CategoryTheory.Abelian.coimage.{u1, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.has_kernels.{u1, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.has_cokernels.{u1, u2} D _inst_2 _inst_3) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 G) X) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 F G α X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α)) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.image.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α)) X) (CategoryTheory.Abelian.image.{u1, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.has_kernels.{u1, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.has_cokernels.{u1, u2} D _inst_2 _inst_3) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 G) X) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α) (CategoryTheory.Abelian.image.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α) (CategoryTheory.Abelian.coimageImageComparison.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α) X) (CategoryTheory.Iso.hom.{u1, u2} D _inst_2 (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.image.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α)) X) (CategoryTheory.Abelian.image.{u1, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.has_kernels.{u1, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.has_cokernels.{u1, u2} D _inst_2 _inst_3) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 G) X) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Abelian.FunctorCategory.imageObjIso.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 F G α X))))
Case conversion may be inaccurate. Consider using '#align category_theory.abelian.functor_category.coimage_image_comparison_app CategoryTheory.Abelian.FunctorCategory.coimageImageComparison_appₓ'. -/
theorem coimageImageComparison_app :
    coimageImageComparison (α.app X) =
      (coimage_obj_iso α X).inv ≫ (coimageImageComparison α).app X ≫ (image_obj_iso α X).Hom :=
  by
  ext
  dsimp
  simp only [category.comp_id, category.id_comp, category.assoc, coimage_image_factorisation,
    limits.cokernel.π_desc_assoc, limits.kernel.lift_ι]
  simp only [← evaluation_obj_map C D X]
  erw [kernel_comparison_comp_ι _ ((evaluation C D).obj X)]
  erw [π_comp_cokernel_comparison_assoc _ ((evaluation C D).obj X)]
  simp only [← functor.map_comp]
  simp only [coimage_image_factorisation, evaluation_obj_map]
#align category_theory.abelian.functor_category.coimage_image_comparison_app CategoryTheory.Abelian.FunctorCategory.coimageImageComparison_app

/- warning: category_theory.abelian.functor_category.coimage_image_comparison_app' -> CategoryTheory.Abelian.FunctorCategory.coimageImageComparison_app' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{max u3 u4}} [_inst_1 : CategoryTheory.Category.{u3, max u3 u4} C] {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{max u1 u3 u4, u2} D] [_inst_3 : CategoryTheory.Abelian.{max u1 u3 u4, u2} D _inst_2] {F : CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2} {G : CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2} (α : Quiver.Hom.{succ (max u1 u3 u4), max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2))) F G) (X : C), Eq.{succ (max u1 u3 u4)} (Quiver.Hom.{succ (max u1 u3 u4), u2} D (CategoryTheory.CategoryStruct.toQuiver.{max u1 u3 u4, u2} D (CategoryTheory.Category.toCategoryStruct.{max u1 u3 u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.image.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) X)) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) (CategoryTheory.Abelian.image.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) (CategoryTheory.Abelian.coimageImageComparison.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) X) (CategoryTheory.CategoryStruct.comp.{max u1 u3 u4, u2} D (CategoryTheory.Category.toCategoryStruct.{max u1 u3 u4, u2} D _inst_2) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) X) (CategoryTheory.Abelian.coimage.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.hasKernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.hasCokernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 G X) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.image.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) X) (CategoryTheory.Iso.hom.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) X) (CategoryTheory.Abelian.coimage.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.hasKernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.hasCokernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 G X) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 F G α X)) (CategoryTheory.CategoryStruct.comp.{max u1 u3 u4, u2} D (CategoryTheory.Category.toCategoryStruct.{max u1 u3 u4, u2} D _inst_2) (CategoryTheory.Abelian.coimage.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.hasKernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.hasCokernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 G X) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Abelian.image.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.hasKernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.hasCokernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 G X) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.image.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) X) (CategoryTheory.Abelian.coimageImageComparison.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.hasKernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.hasCokernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 G X) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Iso.inv.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.image.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Abelian.FunctorCategory.imageObjIso._proof_1.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) (CategoryTheory.Abelian.FunctorCategory.imageObjIso._proof_2.{u4, u3, u2, u1} C _inst_1 D _inst_2 _inst_3) F G α) X) (CategoryTheory.Abelian.image.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.hasKernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.hasCokernels.{max u1 u3 u4, u2} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 G X) (CategoryTheory.NatTrans.app.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Abelian.FunctorCategory.imageObjIso.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 F G α X))))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u3, u4} C] {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{u1, u2} D] [_inst_3 : CategoryTheory.Abelian.{u1, u2} D _inst_2] {F : CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2} {G : CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2} (α : Quiver.Hom.{max (succ u4) (succ u1), max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2))) F G) (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α)) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.image.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α)) X)) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α) (CategoryTheory.Abelian.image.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α) (CategoryTheory.Abelian.coimageImageComparison.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α) X) (CategoryTheory.CategoryStruct.comp.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α)) X) (CategoryTheory.Abelian.coimage.{u1, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.has_kernels.{u1, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.has_cokernels.{u1, u2} D _inst_2 _inst_3) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 G) X) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 F G α X)) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.image.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α)) X) (CategoryTheory.Iso.hom.{u1, u2} D _inst_2 (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.coimage.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α)) X) (CategoryTheory.Abelian.coimage.{u1, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.has_kernels.{u1, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.has_cokernels.{u1, u2} D _inst_2 _inst_3) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 G) X) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Abelian.FunctorCategory.coimageObjIso.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 F G α X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2) (CategoryTheory.Abelian.coimage.{u1, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.has_kernels.{u1, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.has_cokernels.{u1, u2} D _inst_2 _inst_3) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 G) X) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Abelian.image.{u1, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.has_kernels.{u1, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.has_cokernels.{u1, u2} D _inst_2 _inst_3) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 G) X) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 F G α X)) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.image.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α)) X) (CategoryTheory.Abelian.coimageImageComparison.{u1, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.has_kernels.{u1, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.has_cokernels.{u1, u2} D _inst_2 _inst_3) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 G) X) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Iso.inv.{u1, u2} D _inst_2 (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Abelian.image.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α)) X) (CategoryTheory.Abelian.image.{u1, u2} D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3)) (CategoryTheory.Abelian.has_kernels.{u1, u2} D _inst_2 _inst_3) (CategoryTheory.Abelian.has_cokernels.{u1, u2} D _inst_2 _inst_3) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u3, succ u1, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} D (CategoryTheory.Category.toCategoryStruct.{u1, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} C _inst_1 D _inst_2 G) X) (CategoryTheory.NatTrans.app.{u3, u1, u4, u2} C _inst_1 D _inst_2 F G α X)) (CategoryTheory.Abelian.FunctorCategory.imageObjIso.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 F G α X))))
Case conversion may be inaccurate. Consider using '#align category_theory.abelian.functor_category.coimage_image_comparison_app' CategoryTheory.Abelian.FunctorCategory.coimageImageComparison_app'ₓ'. -/
theorem coimageImageComparison_app' :
    (coimageImageComparison α).app X =
      (coimage_obj_iso α X).Hom ≫ coimageImageComparison (α.app X) ≫ (image_obj_iso α X).inv :=
  by
  simp only [coimage_image_comparison_app, iso.hom_inv_id_assoc, iso.hom_inv_id, category.assoc,
    category.comp_id]
#align category_theory.abelian.functor_category.coimage_image_comparison_app' CategoryTheory.Abelian.FunctorCategory.coimageImageComparison_app'

/- warning: category_theory.abelian.functor_category.functor_category_is_iso_coimage_image_comparison -> CategoryTheory.Abelian.FunctorCategory.functor_category_isIso_coimageImageComparison is a dubious translation:
lean 3 declaration is
  forall {C : Type.{max u3 u4}} [_inst_1 : CategoryTheory.Category.{u3, max u3 u4} C] {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{max u1 u3 u4, u2} D] [_inst_3 : CategoryTheory.Abelian.{max u1 u3 u4, u2} D _inst_2] {F : CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2} {G : CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2} (α : Quiver.Hom.{succ (max u1 u3 u4), max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2))) F G), CategoryTheory.IsIso.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Abelian.coimage.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, max u3 u4, max u1 u3 u4, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, max u3 u4, max u1 u3 u4, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{max u1 u3 u4, u2} D _inst_2 _inst_3))) F G α) (CategoryTheory.Abelian.image.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, max u3 u4, max u1 u3 u4, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, max u3 u4, max u1 u3 u4, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{max u1 u3 u4, u2} D _inst_2 _inst_3))) F G α) (CategoryTheory.Abelian.coimageImageComparison.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, max u3 u4, max u1 u3 u4, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u3, max u3 u4, max u1 u3 u4, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u1 u3 u4, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{max u1 u3 u4, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, max u3 u4, max u1 u3 u4, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{max u1 u3 u4, u2} D _inst_2 _inst_3))) F G α)
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u3, u4} C] {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{u1, u2} D] [_inst_3 : CategoryTheory.Abelian.{u1, u2} D _inst_2] {F : CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2} {G : CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2} (α : Quiver.Hom.{max (succ u4) (succ u1), max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2))) F G), CategoryTheory.IsIso.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Abelian.coimage.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α) (CategoryTheory.Abelian.image.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α) (CategoryTheory.Abelian.coimageImageComparison.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasEqualizers.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.hasCokernels_of_hasCoequalizers.{max u4 u1, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u3, u4, u1, u2} C _inst_1 D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} D _inst_2 (CategoryTheory.Abelian.toPreadditive.{u1, u2} D _inst_2 _inst_3))) (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{0, u3, 0, u4, u1, u2} D _inst_2 CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory C _inst_1 (CategoryTheory.Abelian.hasCoequalizers.{u1, u2} D _inst_2 _inst_3))) F G α)
Case conversion may be inaccurate. Consider using '#align category_theory.abelian.functor_category.functor_category_is_iso_coimage_image_comparison CategoryTheory.Abelian.FunctorCategory.functor_category_isIso_coimageImageComparisonₓ'. -/
instance functor_category_isIso_coimageImageComparison : IsIso (Abelian.coimageImageComparison α) :=
  by
  have : ∀ X : C, is_iso ((abelian.coimage_image_comparison α).app X) :=
    by
    intros
    rw [coimage_image_comparison_app']
    infer_instance
  apply nat_iso.is_iso_of_is_iso_app
#align category_theory.abelian.functor_category.functor_category_is_iso_coimage_image_comparison CategoryTheory.Abelian.FunctorCategory.functor_category_isIso_coimageImageComparison

end FunctorCategory

/- warning: category_theory.abelian.functor_category_abelian -> CategoryTheory.Abelian.functorCategoryAbelian is a dubious translation:
lean 3 declaration is
  forall {C : Type.{max u3 u4}} [_inst_1 : CategoryTheory.Category.{u3, max u3 u4} C] {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{max u1 u3 u4, u2} D] [_inst_3 : CategoryTheory.Abelian.{max u1 u3 u4, u2} D _inst_2], CategoryTheory.Abelian.{max u1 u3 u4, max u3 (max u1 u3 u4) (max u3 u4) u2} (CategoryTheory.Functor.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, max u1 u3 u4, max u3 u4, u2} C _inst_1 D _inst_2)
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u3, u4} C] {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{u1, u2} D] [_inst_3 : CategoryTheory.Abelian.{u1, u2} D _inst_2], CategoryTheory.Abelian.{max u4 u1, max (max (max u2 u4) u1) u3} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u1, u4, u2} C _inst_1 D _inst_2)
Case conversion may be inaccurate. Consider using '#align category_theory.abelian.functor_category_abelian CategoryTheory.Abelian.functorCategoryAbelianₓ'. -/
noncomputable instance functorCategoryAbelian : Abelian (C ⥤ D) :=
  Abelian.ofCoimageImageComparisonIsIso
#align category_theory.abelian.functor_category_abelian CategoryTheory.Abelian.functorCategoryAbelian

end

section

universe u

variable {C : Type u} [SmallCategory C]

variable {D : Type (u + 1)} [LargeCategory D] [Abelian D]

/-- A variant with specialized universes for a common case. -/
noncomputable instance functorCategoryAbelian' : Abelian (C ⥤ D) :=
  Abelian.functorCategoryAbelian.{u, u + 1, u, u}
#align category_theory.abelian.functor_category_abelian' CategoryTheory.Abelian.functorCategoryAbelian'

end

end Abelian

end CategoryTheory

