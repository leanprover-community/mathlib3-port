import Mathbin.CategoryTheory.Limits.Shapes.Images 
import Mathbin.CategoryTheory.Filtered 
import Mathbin.Tactic.EquivRw

universe u

open CategoryTheory

open CategoryTheory.Limits

namespace CategoryTheory.Limits.Types

variable{J : Type u}[small_category J]

/--
(internal implementation) the limit cone of a functor,
implemented as flat sections of a pi type
-/
def limit_cone (F : J ‚•§ Type u) : cone F :=
  { x := F.sections, œÄ := { app := fun j u => u.val j } }

attribute [local elabWithoutExpectedType] congr_fun‚Çì

/-- (internal implementation) the fact that the proposed limit cone is the limit -/
def limit_cone_is_limit (F : J ‚•§ Type u) : is_limit (limit_cone F) :=
  { lift := fun s v => ‚ü®fun j => s.œÄ.app j v, fun j j' f => congr_fun‚Çì (cone.w s f) _‚ü©,
    uniq' :=
      by 
        intros 
        ext x j 
        exact congr_fun‚Çì (w j) x }

/--
The category of types has all limits.

See https://stacks.math.columbia.edu/tag/002U.
-/
instance  : has_limits (Type u) :=
  { HasLimitsOfShape :=
      fun J ùí• =>
        by 
          exact { HasLimit := fun F => has_limit.mk { Cone := limit_cone F, IsLimit := limit_cone_is_limit F } } }

/--
The equivalence between a limiting cone of `F` in `Type u` and the "concrete" definition as the
sections of `F`.
-/
def is_limit_equiv_sections {F : J ‚•§ Type u} {c : cone F} (t : is_limit c) : c.X ‚âÉ F.sections :=
  (is_limit.cone_point_unique_up_to_iso t (limit_cone_is_limit F)).toEquiv

@[simp]
theorem is_limit_equiv_sections_apply {F : J ‚•§ Type u} {c : cone F} (t : is_limit c) (j : J) (x : c.X) :
  ((is_limit_equiv_sections t) x : ‚àÄ j, F.obj j) j = c.œÄ.app j x :=
  rfl

@[simp]
theorem is_limit_equiv_sections_symm_apply {F : J ‚•§ Type u} {c : cone F} (t : is_limit c) (x : F.sections) (j : J) :
  c.œÄ.app j ((is_limit_equiv_sections t).symm x) = (x : ‚àÄ j, F.obj j) j :=
  by 
    equivRw (is_limit_equiv_sections t).symm  at x 
    simp 

/--
The equivalence between the abstract limit of `F` in `Type u`
and the "concrete" definition as the sections of `F`.
-/
noncomputable def limit_equiv_sections (F : J ‚•§ Type u) : (limit F : Type u) ‚âÉ F.sections :=
  is_limit_equiv_sections (limit.is_limit _)

@[simp]
theorem limit_equiv_sections_apply (F : J ‚•§ Type u) (x : limit F) (j : J) :
  ((limit_equiv_sections F) x : ‚àÄ j, F.obj j) j = limit.œÄ F j x :=
  rfl

@[simp]
theorem limit_equiv_sections_symm_apply (F : J ‚•§ Type u) (x : F.sections) (j : J) :
  limit.œÄ F j ((limit_equiv_sections F).symm x) = (x : ‚àÄ j, F.obj j) j :=
  is_limit_equiv_sections_symm_apply _ _ _

/--
Construct a term of `limit F : Type u` from a family of terms `x : Œ† j, F.obj j`
which are "coherent": `‚àÄ (j j') (f : j ‚ü∂ j'), F.map f (x j) = x j'`.
-/
@[ext]
noncomputable def limit.mk (F : J ‚•§ Type u) (x : ‚àÄ j, F.obj j) (h : ‚àÄ j j' (f : j ‚ü∂ j'), F.map f (x j) = x j') :
  (limit F : Type u) :=
  (limit_equiv_sections F).symm ‚ü®x, h‚ü©

@[simp]
theorem limit.œÄ_mk (F : J ‚•§ Type u) (x : ‚àÄ j, F.obj j) (h : ‚àÄ j j' (f : j ‚ü∂ j'), F.map f (x j) = x j') j :
  limit.œÄ F j (limit.mk F x h) = x j :=
  by 
    dsimp [limit.mk]
    simp 

@[ext]
theorem limit_ext (F : J ‚•§ Type u) (x y : limit F) (w : ‚àÄ j, limit.œÄ F j x = limit.œÄ F j y) : x = y :=
  by 
    apply (limit_equiv_sections F).Injective 
    ext j 
    simp [w j]

theorem limit_ext_iff (F : J ‚•§ Type u) (x y : limit F) : x = y ‚Üî ‚àÄ j, limit.œÄ F j x = limit.œÄ F j y :=
  ‚ü®fun t _ => t ‚ñ∏ rfl, limit_ext _ _ _‚ü©

@[simp]
theorem limit.w_apply {F : J ‚•§ Type u} {j j' : J} {x : limit F} (f : j ‚ü∂ j') :
  F.map f (limit.œÄ F j x) = limit.œÄ F j' x :=
  congr_fun‚Çì (limit.w F f) x

@[simp]
theorem limit.lift_œÄ_apply (F : J ‚•§ Type u) (s : cone F) (j : J) (x : s.X) :
  limit.œÄ F j (limit.lift F s x) = s.œÄ.app j x :=
  congr_fun‚Çì (limit.lift_œÄ s j) x

@[simp]
theorem limit.map_œÄ_apply {F G : J ‚•§ Type u} (Œ± : F ‚ü∂ G) (j : J) x :
  limit.œÄ G j (lim_map Œ± x) = Œ±.app j (limit.œÄ F j x) :=
  congr_fun‚Çì (lim_map_œÄ Œ± j) x

/--
The relation defining the quotient type which implements the colimit of a functor `F : J ‚•§ Type u`.
See `category_theory.limits.types.quot`.
-/
def quot.rel (F : J ‚•§ Type u) : (Œ£j, F.obj j) ‚Üí (Œ£j, F.obj j) ‚Üí Prop :=
  fun p p' => ‚àÉ f : p.1 ‚ü∂ p'.1, p'.2 = F.map f p.2

/--
A quotient type implementing the colimit of a functor `F : J ‚•§ Type u`,
as pairs `‚ü®j, x‚ü©` where `x : F.obj j`, modulo the equivalence relation generated by
`‚ü®j, x‚ü© ~ ‚ü®j', x'‚ü©` whenever there is a morphism `f : j ‚ü∂ j'` so `F.map f x = x'`.
-/
@[nolint has_inhabited_instance]
def Quot (F : J ‚•§ Type u) : Type u :=
  @Quot (Œ£j, F.obj j) (quot.rel F)

/--
(internal implementation) the colimit cocone of a functor,
implemented as a quotient of a sigma type
-/
def colimit_cocone (F : J ‚•§ Type u) : cocone F :=
  { x := Quot F,
    Œπ :=
      { app := fun j x => Quot.mk _ ‚ü®j, x‚ü©,
        naturality' := fun j j' f => funext$ fun x => Eq.symm (Quot.sound ‚ü®f, rfl‚ü©) } }

attribute [local elab_with_expected_type] Quot.lift

-- error in CategoryTheory.Limits.Types: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- (internal implementation) the fact that the proposed colimit cocone is the colimit -/
def colimit_cocone_is_colimit (F : ¬´expr ‚•§ ¬ª(J, Type u)) : is_colimit (colimit_cocone F) :=
{ desc := Œª
  s, quot.lift (Œª
   p : ¬´exprŒ£ , ¬ª((j), F.obj j), s.Œπ.app p.1 p.2) (assume
   ‚ü®j, x‚ü©
   ‚ü®j', x'‚ü©
   ‚ü®f, hf‚ü©, by rw [expr hf] []; exact [expr (congr_fun (cocone.w s f) x).symm]) }

/--
The category of types has all colimits.

See https://stacks.math.columbia.edu/tag/002U.
-/
instance  : has_colimits (Type u) :=
  { HasColimitsOfShape :=
      fun J ùí• =>
        by 
          exact
            { HasColimit :=
                fun F => has_colimit.mk { Cocone := colimit_cocone F, IsColimit := colimit_cocone_is_colimit F } } }

/--
The equivalence between the abstract colimit of `F` in `Type u`
and the "concrete" definition as a quotient.
-/
noncomputable def colimit_equiv_quot (F : J ‚•§ Type u) : (colimit F : Type u) ‚âÉ Quot F :=
  (is_colimit.cocone_point_unique_up_to_iso (colimit.is_colimit F) (colimit_cocone_is_colimit F)).toEquiv

@[simp]
theorem colimit_equiv_quot_symm_apply (F : J ‚•§ Type u) (j : J) (x : F.obj j) :
  (colimit_equiv_quot F).symm (Quot.mk _ ‚ü®j, x‚ü©) = colimit.Œπ F j x :=
  rfl

@[simp]
theorem colimit_equiv_quot_apply (F : J ‚•§ Type u) (j : J) (x : F.obj j) :
  (colimit_equiv_quot F) (colimit.Œπ F j x) = Quot.mk _ ‚ü®j, x‚ü© :=
  by 
    apply (colimit_equiv_quot F).symm.Injective 
    simp 

@[simp]
theorem colimit.w_apply {F : J ‚•§ Type u} {j j' : J} {x : F.obj j} (f : j ‚ü∂ j') :
  colimit.Œπ F j' (F.map f x) = colimit.Œπ F j x :=
  congr_fun‚Çì (colimit.w F f) x

@[simp]
theorem colimit.Œπ_desc_apply (F : J ‚•§ Type u) (s : cocone F) (j : J) (x : F.obj j) :
  colimit.desc F s (colimit.Œπ F j x) = s.Œπ.app j x :=
  congr_fun‚Çì (colimit.Œπ_desc s j) x

@[simp]
theorem colimit.Œπ_map_apply {F G : J ‚•§ Type u} (Œ± : F ‚ü∂ G) (j : J) x :
  colim.map Œ± (colimit.Œπ F j x) = colimit.Œπ G j (Œ±.app j x) :=
  congr_fun‚Çì (colimit.Œπ_map Œ± j) x

theorem colimit_sound {F : J ‚•§ Type u} {j j' : J} {x : F.obj j} {x' : F.obj j'} (f : j ‚ü∂ j') (w : F.map f x = x') :
  colimit.Œπ F j x = colimit.Œπ F j' x' :=
  by 
    rw [‚Üêw]
    simp 

theorem colimit_sound' {F : J ‚•§ Type u} {j j' : J} {x : F.obj j} {x' : F.obj j'} {j'' : J} (f : j ‚ü∂ j'') (f' : j' ‚ü∂ j'')
  (w : F.map f x = F.map f' x') : colimit.Œπ F j x = colimit.Œπ F j' x' :=
  by 
    rw [‚Üêcolimit.w _ f, ‚Üêcolimit.w _ f']
    rw [types_comp_apply, types_comp_apply, w]

theorem colimit_eq {F : J ‚•§ Type u} {j j' : J} {x : F.obj j} {x' : F.obj j'} (w : colimit.Œπ F j x = colimit.Œπ F j' x') :
  EqvGen (quot.rel F) ‚ü®j, x‚ü© ‚ü®j', x'‚ü© :=
  by 
    apply Quot.eq.1
    simpa using congr_arg‚Çì (colimit_equiv_quot F) w

-- error in CategoryTheory.Limits.Types: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem jointly_surjective
(F : ¬´expr ‚•§ ¬ª(J, Type u))
{t : cocone F}
(h : is_colimit t)
(x : t.X) : ¬´expr‚àÉ , ¬ª((j y), ¬´expr = ¬ª(t.Œπ.app j y, x)) :=
begin
  suffices [] [":", expr ¬´expr = ¬ª(Œª
    x : t.X, ulift.up ¬´expr‚àÉ , ¬ª((j y), ¬´expr = ¬ª(t.Œπ.app j y, x)), Œª _, ulift.up true)],
  { have [] [] [":=", expr congr_fun this x],
    have [ident H] [] [":=", expr congr_arg ulift.down this],
    dsimp [] [] [] ["at", ident H],
    rwa [expr eq_true] ["at", ident H] },
  refine [expr h.hom_ext _],
  intro [ident j],
  ext [] [ident y] [],
  erw [expr iff_true] [],
  exact [expr ‚ü®j, y, rfl‚ü©]
end

/-- A variant of `jointly_surjective` for `x : colimit F`. -/
theorem jointly_surjective' {F : J ‚•§ Type u} (x : colimit F) : ‚àÉ j y, colimit.Œπ F j y = x :=
  jointly_surjective F (colimit.is_colimit _) x

namespace FilteredColimit

variable(F : J ‚•§ Type u)

/--
An alternative relation on `Œ£ j, F.obj j`,
which generates the same equivalence relation as we use to define the colimit in `Type` above,
but that is more convenient when working with filtered colimits.

Elements in `F.obj j` and `F.obj j'` are equivalent if there is some `k : J` to the right
where their images are equal.
-/
protected def rel (x y : Œ£j, F.obj j) : Prop :=
  ‚àÉ (k : _)(f : x.1 ‚ü∂ k)(g : y.1 ‚ü∂ k), F.map f x.2 = F.map g y.2

theorem rel_of_quot_rel (x y : Œ£j, F.obj j) : quot.rel F x y ‚Üí filtered_colimit.rel F x y :=
  fun ‚ü®f, h‚ü© =>
    ‚ü®y.1, f, ùüô y.1,
      by 
        rw [‚Üêh, functor_to_types.map_id_apply]‚ü©

theorem eqv_gen_quot_rel_of_rel (x y : Œ£j, F.obj j) : filtered_colimit.rel F x y ‚Üí EqvGen (quot.rel F) x y :=
  fun ‚ü®k, f, g, h‚ü© =>
    EqvGen.trans _ ‚ü®k, F.map f x.2‚ü© _ (EqvGen.rel _ _ ‚ü®f, rfl‚ü©) (EqvGen.symm _ _ (EqvGen.rel _ _ ‚ü®g, h‚ü©))

attribute [local elabWithoutExpectedType] nat_trans.app

/-- Recognizing filtered colimits of types. -/
noncomputable def is_colimit_of (t : cocone F) (hsurj : ‚àÄ (x : t.X), ‚àÉ i xi, x = t.Œπ.app i xi)
  (hinj : ‚àÄ i j xi xj, t.Œπ.app i xi = t.Œπ.app j xj ‚Üí ‚àÉ (k : _)(f : i ‚ü∂ k)(g : j ‚ü∂ k), F.map f xi = F.map g xj) :
  is_colimit t :=
  by 
    apply is_colimit.of_iso_colimit (colimit.is_colimit F)
    refine' cocones.ext (Equiv.toIso (Equiv.ofBijective _ _)) _
    ¬∑
      exact colimit.desc F t
    ¬∑
      split 
      ¬∑
        show Function.Injective _ 
        intro a b h 
        rcases jointly_surjective F (colimit.is_colimit F) a with ‚ü®i, xi, rfl‚ü©
        rcases jointly_surjective F (colimit.is_colimit F) b with ‚ü®j, xj, rfl‚ü©
        change (colimit.Œπ F i ‚â´ colimit.desc F t) xi = (colimit.Œπ F j ‚â´ colimit.desc F t) xj at h 
        rw [colimit.Œπ_desc, colimit.Œπ_desc] at h 
        rcases hinj i j xi xj h with ‚ü®k, f, g, h'‚ü©
        change colimit.Œπ F i xi = colimit.Œπ F j xj 
        rw [‚Üêcolimit.w F f, ‚Üêcolimit.w F g]
        change colimit.Œπ F k (F.map f xi) = colimit.Œπ F k (F.map g xj)
        rw [h']
      ¬∑
        show Function.Surjective _ 
        intro x 
        rcases hsurj x with ‚ü®i, xi, rfl‚ü©
        use colimit.Œπ F i xi 
        simp 
    ¬∑
      intro j 
      apply colimit.Œπ_desc

variable[is_filtered_or_empty J]

protected theorem rel_equiv : Equivalence‚Çì (filtered_colimit.rel F) :=
  ‚ü®fun x => ‚ü®x.1, ùüô x.1, ùüô x.1, rfl‚ü©, fun x y ‚ü®k, f, g, h‚ü© => ‚ü®k, g, f, h.symm‚ü©,
    fun x y z ‚ü®k, f, g, h‚ü© ‚ü®k', f', g', h'‚ü© =>
      let ‚ü®l, fl, gl, _‚ü© := is_filtered_or_empty.cocone_objs k k' 
      let ‚ü®m, n, hn‚ü© := is_filtered_or_empty.cocone_maps (g ‚â´ fl) (f' ‚â´ gl)
      ‚ü®m, f ‚â´ fl ‚â´ n, g' ‚â´ gl ‚â´ n,
        calc F.map (f ‚â´ fl ‚â´ n) x.2 = F.map (fl ‚â´ n) (F.map f x.2) :=
          by 
            simp 
          _ = F.map (fl ‚â´ n) (F.map g y.2) :=
          by 
            rw [h]
          _ = F.map ((g ‚â´ fl) ‚â´ n) y.2 :=
          by 
            simp 
          _ = F.map ((f' ‚â´ gl) ‚â´ n) y.2 :=
          by 
            rw [hn]
          _ = F.map (gl ‚â´ n) (F.map f' y.2) :=
          by 
            simp 
          _ = F.map (gl ‚â´ n) (F.map g' z.2) :=
          by 
            rw [h']
          _ = F.map (g' ‚â´ gl ‚â´ n) z.2 :=
          by 
            simp 
          ‚ü©‚ü©

protected theorem rel_eq_eqv_gen_quot_rel : filtered_colimit.rel F = EqvGen (quot.rel F) :=
  by 
    ext ‚ü®j, x‚ü© ‚ü®j', y‚ü©
    split 
    ¬∑
      apply eqv_gen_quot_rel_of_rel
    ¬∑
      rw [‚Üê(filtered_colimit.rel_equiv F).eqv_gen_iff]
      exact EqvGen.mono (rel_of_quot_rel F)

theorem colimit_eq_iff_aux {i j : J} {xi : F.obj i} {xj : F.obj j} :
  (colimit_cocone F).Œπ.app i xi = (colimit_cocone F).Œπ.app j xj ‚Üî filtered_colimit.rel F ‚ü®i, xi‚ü© ‚ü®j, xj‚ü© :=
  by 
    change Quot.mk _ _ = Quot.mk _ _ ‚Üî _ 
    rw [Quot.eq, filtered_colimit.rel_eq_eqv_gen_quot_rel]

theorem is_colimit_eq_iff {t : cocone F} (ht : is_colimit t) {i j : J} {xi : F.obj i} {xj : F.obj j} :
  t.Œπ.app i xi = t.Œπ.app j xj ‚Üî ‚àÉ (k : _)(f : i ‚ü∂ k)(g : j ‚ü∂ k), F.map f xi = F.map g xj :=
  let t' := colimit_cocone F 
  let e : t' ‚âÖ t := is_colimit.unique_up_to_iso (colimit_cocone_is_colimit F) ht 
  let e' : t'.X ‚âÖ t.X := (cocones.forget _).mapIso e 
  by 
    refine' Iff.trans _ (colimit_eq_iff_aux F)
    convert e'.to_equiv.apply_eq_iff_eq <;> rw [‚Üêe.hom.w] <;> rfl

theorem colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :
  colimit.Œπ F i xi = colimit.Œπ F j xj ‚Üî ‚àÉ (k : _)(f : i ‚ü∂ k)(g : j ‚ü∂ k), F.map f xi = F.map g xj :=
  is_colimit_eq_iff _ (colimit.is_colimit F)

end FilteredColimit

variable{Œ± Œ≤ : Type u}(f : Œ± ‚ü∂ Œ≤)

section 

/-- the image of a morphism in Type is just `set.range f` -/
def image : Type u :=
  Set.Range f

instance  [Inhabited Œ±] : Inhabited (image f) :=
  { default := ‚ü®f (default Œ±), ‚ü®_, rfl‚ü©‚ü© }

/-- the inclusion of `image f` into the target -/
def image.Œπ : image f ‚ü∂ Œ≤ :=
  Subtype.val

instance  : mono (image.Œπ f) :=
  (mono_iff_injective _).2 Subtype.val_injective

variable{f}

/-- the universal property for the image factorisation -/
noncomputable def image.lift (F' : mono_factorisation f) : image f ‚ü∂ F'.I :=
  (fun x => F'.e (Classical.indefiniteDescription _ x.2).1 : image f ‚Üí F'.I)

theorem image.lift_fac (F' : mono_factorisation f) : image.lift F' ‚â´ F'.m = image.Œπ f :=
  by 
    ext x 
    change (F'.e ‚â´ F'.m) _ = _ 
    rw [F'.fac, (Classical.indefiniteDescription _ x.2).2]
    rfl

end 

/-- the factorisation of any morphism in Type through a mono. -/
def mono_factorisation : mono_factorisation f :=
  { i := image f, m := image.Œπ f, e := Set.rangeFactorization f }

/-- the facorisation through a mono has the universal property of the image. -/
noncomputable def is_image : is_image (mono_factorisation f) :=
  { lift := image.lift, lift_fac' := image.lift_fac }

instance  : has_image f :=
  has_image.mk ‚ü®_, is_image f‚ü©

instance  : has_images (Type u) :=
  { HasImage :=
      by 
        infer_instance }

-- error in CategoryTheory.Limits.Types: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
instance : has_image_maps (Type u) :=
{ has_image_map := Œª
  f
  g
  st, has_image_map.transport st (mono_factorisation f.hom) (is_image g.hom) (Œª
   x, ‚ü®st.right x.1, ‚ü®st.left (classical.some x.2), begin
       have [ident p] [] [":=", expr st.w],
       replace [ident p] [] [":=", expr congr_fun p (classical.some x.2)],
       simp [] [] ["only"] ["[", expr functor.id_map, ",", expr types_comp_apply, ",", expr subtype.val_eq_coe, "]"] [] ["at", ident p],
       erw ["[", expr p, ",", expr classical.some_spec x.2, "]"] []
     end‚ü©‚ü©) rfl }

end CategoryTheory.Limits.Types

