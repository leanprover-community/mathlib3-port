/-
Copyright (c) 2022 Markus Himmel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Markus Himmel

! This file was ported from Lean 3 source module category_theory.limits.exact_functor
! leanprover-community/mathlib commit 9fc53308a90fac244ac715308e1f9c969e6843a4
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Limits.Preserves.Finite

/-!
# Bundled exact functors

We say that a functor `F` is left exact if it preserves finite limits, it is right exact if it
preserves finite colimits, and it is exact if it is both left exact and right exact.

In this file, we define the categories of bundled left exact, right exact and exact functors.

-/


universe v₁ v₂ u₁ u₂

open CategoryTheory.Limits

namespace CategoryTheory

variable {C : Type u₁} [Category.{v₁} C] {D : Type u₂} [Category.{v₂} D]

section

variable (C) (D)

#print CategoryTheory.LeftExactFunctor /-
/-- Bundled left-exact functors. -/
@[nolint has_nonempty_instance]
def LeftExactFunctor :=
  FullSubcategory fun F : C ⥤ D => Nonempty (PreservesFiniteLimits F)deriving Category
#align category_theory.LeftExactFunctor CategoryTheory.LeftExactFunctor
-/

-- mathport name: «expr ⥤ₗ »
infixr:26 " ⥤ₗ " => LeftExactFunctor

#print CategoryTheory.LeftExactFunctor.forget /-
/-- A left exact functor is in particular a functor. -/
def LeftExactFunctor.forget : (C ⥤ₗ D) ⥤ C ⥤ D :=
  fullSubcategoryInclusion _ deriving Full, Faithful
#align category_theory.LeftExactFunctor.forget CategoryTheory.LeftExactFunctor.forget
-/

#print CategoryTheory.RightExactFunctor /-
/-- Bundled right-exact functors. -/
@[nolint has_nonempty_instance]
def RightExactFunctor :=
  FullSubcategory fun F : C ⥤ D => Nonempty (PreservesFiniteColimits F)deriving Category
#align category_theory.RightExactFunctor CategoryTheory.RightExactFunctor
-/

-- mathport name: «expr ⥤ᵣ »
infixr:26 " ⥤ᵣ " => RightExactFunctor

#print CategoryTheory.RightExactFunctor.forget /-
/-- A right exact functor is in particular a functor. -/
def RightExactFunctor.forget : (C ⥤ᵣ D) ⥤ C ⥤ D :=
  fullSubcategoryInclusion _ deriving Full, Faithful
#align category_theory.RightExactFunctor.forget CategoryTheory.RightExactFunctor.forget
-/

#print CategoryTheory.ExactFunctor /-
/-- Bundled exact functors. -/
@[nolint has_nonempty_instance]
def ExactFunctor :=
  FullSubcategory fun F : C ⥤ D =>
    Nonempty (PreservesFiniteLimits F) ∧ Nonempty (PreservesFiniteColimits F)deriving
  Category
#align category_theory.ExactFunctor CategoryTheory.ExactFunctor
-/

-- mathport name: «expr ⥤ₑ »
infixr:26 " ⥤ₑ " => ExactFunctor

#print CategoryTheory.ExactFunctor.forget /-
/-- An exact functor is in particular a functor. -/
def ExactFunctor.forget : (C ⥤ₑ D) ⥤ C ⥤ D :=
  fullSubcategoryInclusion _ deriving Full, Faithful
#align category_theory.ExactFunctor.forget CategoryTheory.ExactFunctor.forget
-/

#print CategoryTheory.LeftExactFunctor.ofExact /-
/-- Turn an exact functor into a left exact functor. -/
def LeftExactFunctor.ofExact : (C ⥤ₑ D) ⥤ C ⥤ₗ D :=
  FullSubcategory.map fun X => And.left deriving Full, Faithful
#align category_theory.LeftExactFunctor.of_exact CategoryTheory.LeftExactFunctor.ofExact
-/

#print CategoryTheory.RightExactFunctor.ofExact /-
/-- Turn an exact functor into a left exact functor. -/
def RightExactFunctor.ofExact : (C ⥤ₑ D) ⥤ C ⥤ᵣ D :=
  FullSubcategory.map fun X => And.right deriving Full, Faithful
#align category_theory.RightExactFunctor.of_exact CategoryTheory.RightExactFunctor.ofExact
-/

variable {C D}

/- warning: category_theory.LeftExactFunctor.of_exact_obj -> CategoryTheory.LeftExactFunctor.ofExact_obj is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2), Eq.{succ (max u1 u2 u3 u4)} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.ofExact.{u1, u2, u3, u4} C _inst_1 D _inst_2) F) (CategoryTheory.FullSubcategoryₓ.mk.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (CategoryTheory.FullSubcategoryₓ.obj.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F) (And.left (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 (CategoryTheory.FullSubcategoryₓ.obj.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F))) (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 (CategoryTheory.FullSubcategoryₓ.obj.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F))) (CategoryTheory.FullSubcategoryₓ.property.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2), Eq.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2)} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.ofExact.{u1, u2, u3, u4} C _inst_1 D _inst_2)) F) (CategoryTheory.FullSubcategory.mk.{max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (CategoryTheory.FullSubcategory.obj.{max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F) (And.left (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 (CategoryTheory.FullSubcategory.obj.{max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F))) (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 (CategoryTheory.FullSubcategory.obj.{max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F))) (CategoryTheory.FullSubcategory.property.{max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F)))
Case conversion may be inaccurate. Consider using '#align category_theory.LeftExactFunctor.of_exact_obj CategoryTheory.LeftExactFunctor.ofExact_objₓ'. -/
@[simp]
theorem LeftExactFunctor.ofExact_obj (F : C ⥤ₑ D) :
    (LeftExactFunctor.ofExact C D).obj F = ⟨F.1, F.2.1⟩ :=
  rfl
#align category_theory.LeftExactFunctor.of_exact_obj CategoryTheory.LeftExactFunctor.ofExact_obj

/- warning: category_theory.RightExactFunctor.of_exact_obj -> CategoryTheory.RightExactFunctor.ofExact_obj is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2), Eq.{succ (max u1 u2 u3 u4)} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.ofExact.{u1, u2, u3, u4} C _inst_1 D _inst_2) F) (CategoryTheory.FullSubcategoryₓ.mk.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (CategoryTheory.FullSubcategoryₓ.obj.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F) (And.right (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 (CategoryTheory.FullSubcategoryₓ.obj.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F))) (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 (CategoryTheory.FullSubcategoryₓ.obj.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F))) (CategoryTheory.FullSubcategoryₓ.property.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2), Eq.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2)} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.ofExact.{u1, u2, u3, u4} C _inst_1 D _inst_2)) F) (CategoryTheory.FullSubcategory.mk.{max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (CategoryTheory.FullSubcategory.obj.{max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F) (And.right (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 (CategoryTheory.FullSubcategory.obj.{max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F))) (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 (CategoryTheory.FullSubcategory.obj.{max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F))) (CategoryTheory.FullSubcategory.property.{max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F)))
Case conversion may be inaccurate. Consider using '#align category_theory.RightExactFunctor.of_exact_obj CategoryTheory.RightExactFunctor.ofExact_objₓ'. -/
@[simp]
theorem RightExactFunctor.ofExact_obj (F : C ⥤ₑ D) :
    (RightExactFunctor.ofExact C D).obj F = ⟨F.1, F.2.2⟩ :=
  rfl
#align category_theory.RightExactFunctor.of_exact_obj CategoryTheory.RightExactFunctor.ofExact_obj

/- warning: category_theory.LeftExactFunctor.of_exact_map -> CategoryTheory.LeftExactFunctor.ofExact_map is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {F : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {G : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (α : Quiver.Hom.{succ (max u3 u2), max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2))) F G), Eq.{succ (max u3 u2)} (Quiver.Hom.{succ (max u3 u2), max u1 u2 u3 u4} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2))) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.ofExact.{u1, u2, u3, u4} C _inst_1 D _inst_2) F) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.ofExact.{u1, u2, u3, u4} C _inst_1 D _inst_2) G)) (CategoryTheory.Functor.map.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.ofExact.{u1, u2, u3, u4} C _inst_1 D _inst_2) F G α) α
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {F : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {G : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (α : Quiver.Hom.{max (succ u3) (succ u2), max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) F G), Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{max (succ u3) (succ u2), max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.ofExact.{u1, u2, u3, u4} C _inst_1 D _inst_2)) F) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.ofExact.{u1, u2, u3, u4} C _inst_1 D _inst_2)) G)) (Prefunctor.map.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.ofExact.{u1, u2, u3, u4} C _inst_1 D _inst_2)) F G α) α
Case conversion may be inaccurate. Consider using '#align category_theory.LeftExactFunctor.of_exact_map CategoryTheory.LeftExactFunctor.ofExact_mapₓ'. -/
@[simp]
theorem LeftExactFunctor.ofExact_map {F G : C ⥤ₑ D} (α : F ⟶ G) :
    (LeftExactFunctor.ofExact C D).map α = α :=
  rfl
#align category_theory.LeftExactFunctor.of_exact_map CategoryTheory.LeftExactFunctor.ofExact_map

/- warning: category_theory.RightExactFunctor.of_exact_map -> CategoryTheory.RightExactFunctor.ofExact_map is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {F : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {G : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (α : Quiver.Hom.{succ (max u3 u2), max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2))) F G), Eq.{succ (max u3 u2)} (Quiver.Hom.{succ (max u3 u2), max u1 u2 u3 u4} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2))) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.ofExact.{u1, u2, u3, u4} C _inst_1 D _inst_2) F) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.ofExact.{u1, u2, u3, u4} C _inst_1 D _inst_2) G)) (CategoryTheory.Functor.map.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.ofExact.{u1, u2, u3, u4} C _inst_1 D _inst_2) F G α) α
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {F : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {G : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (α : Quiver.Hom.{max (succ u3) (succ u2), max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) F G), Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{max (succ u3) (succ u2), max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.ofExact.{u1, u2, u3, u4} C _inst_1 D _inst_2)) F) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.ofExact.{u1, u2, u3, u4} C _inst_1 D _inst_2)) G)) (Prefunctor.map.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.ofExact.{u1, u2, u3, u4} C _inst_1 D _inst_2)) F G α) α
Case conversion may be inaccurate. Consider using '#align category_theory.RightExactFunctor.of_exact_map CategoryTheory.RightExactFunctor.ofExact_mapₓ'. -/
@[simp]
theorem RightExactFunctor.ofExact_map {F G : C ⥤ₑ D} (α : F ⟶ G) :
    (RightExactFunctor.ofExact C D).map α = α :=
  rfl
#align category_theory.RightExactFunctor.of_exact_map CategoryTheory.RightExactFunctor.ofExact_map

/- warning: category_theory.LeftExactFunctor.forget_obj -> CategoryTheory.LeftExactFunctor.forget_obj is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2), Eq.{succ (max u1 u2 u3 u4)} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2) F) (CategoryTheory.FullSubcategoryₓ.obj.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) F)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2), Eq.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2)} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2)) F) (CategoryTheory.FullSubcategory.obj.{max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) F)
Case conversion may be inaccurate. Consider using '#align category_theory.LeftExactFunctor.forget_obj CategoryTheory.LeftExactFunctor.forget_objₓ'. -/
@[simp]
theorem LeftExactFunctor.forget_obj (F : C ⥤ₗ D) : (LeftExactFunctor.forget C D).obj F = F.1 :=
  rfl
#align category_theory.LeftExactFunctor.forget_obj CategoryTheory.LeftExactFunctor.forget_obj

/- warning: category_theory.RightExactFunctor.forget_obj -> CategoryTheory.RightExactFunctor.forget_obj is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2), Eq.{succ (max u1 u2 u3 u4)} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2) F) (CategoryTheory.FullSubcategoryₓ.obj.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) F)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2), Eq.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2)} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2)) F) (CategoryTheory.FullSubcategory.obj.{max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) F)
Case conversion may be inaccurate. Consider using '#align category_theory.RightExactFunctor.forget_obj CategoryTheory.RightExactFunctor.forget_objₓ'. -/
@[simp]
theorem RightExactFunctor.forget_obj (F : C ⥤ᵣ D) : (RightExactFunctor.forget C D).obj F = F.1 :=
  rfl
#align category_theory.RightExactFunctor.forget_obj CategoryTheory.RightExactFunctor.forget_obj

/- warning: category_theory.ExactFunctor.forget_obj -> CategoryTheory.ExactFunctor.forget_obj is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2), Eq.{succ (max u1 u2 u3 u4)} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2) F) (CategoryTheory.FullSubcategoryₓ.obj.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max 2 (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2), Eq.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2)} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2)) F) (CategoryTheory.FullSubcategory.obj.{max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (fun (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) => And (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F)) (Nonempty.{max (max (max (max 2 (succ u4)) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F))) F)
Case conversion may be inaccurate. Consider using '#align category_theory.ExactFunctor.forget_obj CategoryTheory.ExactFunctor.forget_objₓ'. -/
@[simp]
theorem ExactFunctor.forget_obj (F : C ⥤ₑ D) : (ExactFunctor.forget C D).obj F = F.1 :=
  rfl
#align category_theory.ExactFunctor.forget_obj CategoryTheory.ExactFunctor.forget_obj

/- warning: category_theory.LeftExactFunctor.forget_map -> CategoryTheory.LeftExactFunctor.forget_map is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {F : CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {G : CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (α : Quiver.Hom.{succ (max u3 u2), max u1 u2 u3 u4} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2))) F G), Eq.{succ (max u3 u2)} (Quiver.Hom.{succ (max u3 u2), max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2) F) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2) G)) (CategoryTheory.Functor.map.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2) F G α) α
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {F : CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {G : CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (α : Quiver.Hom.{max (succ u3) (succ u2), max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) F G), Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{max (succ u3) (succ u2), max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2)) F) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2)) G)) (Prefunctor.map.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2)) F G α) α
Case conversion may be inaccurate. Consider using '#align category_theory.LeftExactFunctor.forget_map CategoryTheory.LeftExactFunctor.forget_mapₓ'. -/
@[simp]
theorem LeftExactFunctor.forget_map {F G : C ⥤ₗ D} (α : F ⟶ G) :
    (LeftExactFunctor.forget C D).map α = α :=
  rfl
#align category_theory.LeftExactFunctor.forget_map CategoryTheory.LeftExactFunctor.forget_map

/- warning: category_theory.RightExactFunctor.forget_map -> CategoryTheory.RightExactFunctor.forget_map is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {F : CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {G : CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (α : Quiver.Hom.{succ (max u3 u2), max u1 u2 u3 u4} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2))) F G), Eq.{succ (max u3 u2)} (Quiver.Hom.{succ (max u3 u2), max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2) F) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2) G)) (CategoryTheory.Functor.map.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2) F G α) α
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {F : CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {G : CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (α : Quiver.Hom.{max (succ u3) (succ u2), max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) F G), Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{max (succ u3) (succ u2), max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2)) F) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2)) G)) (Prefunctor.map.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2)) F G α) α
Case conversion may be inaccurate. Consider using '#align category_theory.RightExactFunctor.forget_map CategoryTheory.RightExactFunctor.forget_mapₓ'. -/
@[simp]
theorem RightExactFunctor.forget_map {F G : C ⥤ᵣ D} (α : F ⟶ G) :
    (RightExactFunctor.forget C D).map α = α :=
  rfl
#align category_theory.RightExactFunctor.forget_map CategoryTheory.RightExactFunctor.forget_map

/- warning: category_theory.ExactFunctor.forget_map -> CategoryTheory.ExactFunctor.forget_map is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {F : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {G : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (α : Quiver.Hom.{succ (max u3 u2), max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2))) F G), Eq.{succ (max u3 u2)} (Quiver.Hom.{succ (max u3 u2), max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u1 u2 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2) F) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2) G)) (CategoryTheory.Functor.map.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2) F G α) α
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {F : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} {G : CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2} (α : Quiver.Hom.{max (succ u3) (succ u2), max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) F G), Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{max (succ u3) (succ u2), max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2)) F) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2)) G)) (Prefunctor.map.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2)) F G α) α
Case conversion may be inaccurate. Consider using '#align category_theory.ExactFunctor.forget_map CategoryTheory.ExactFunctor.forget_mapₓ'. -/
@[simp]
theorem ExactFunctor.forget_map {F G : C ⥤ₑ D} (α : F ⟶ G) : (ExactFunctor.forget C D).map α = α :=
  rfl
#align category_theory.ExactFunctor.forget_map CategoryTheory.ExactFunctor.forget_map

#print CategoryTheory.LeftExactFunctor.of /-
/-- Turn a left exact functor into an object of the category `LeftExactFunctor C D`. -/
def LeftExactFunctor.of (F : C ⥤ D) [PreservesFiniteLimits F] : C ⥤ₗ D :=
  ⟨F, ⟨inferInstance⟩⟩
#align category_theory.LeftExactFunctor.of CategoryTheory.LeftExactFunctor.of
-/

#print CategoryTheory.RightExactFunctor.of /-
/-- Turn a right exact functor into an object of the category `RightExactFunctor C D`. -/
def RightExactFunctor.of (F : C ⥤ D) [PreservesFiniteColimits F] : C ⥤ᵣ D :=
  ⟨F, ⟨inferInstance⟩⟩
#align category_theory.RightExactFunctor.of CategoryTheory.RightExactFunctor.of
-/

#print CategoryTheory.ExactFunctor.of /-
/-- Turn an exact functor into an object of the category `ExactFunctor C D`. -/
def ExactFunctor.of (F : C ⥤ D) [PreservesFiniteLimits F] [PreservesFiniteColimits F] : C ⥤ₑ D :=
  ⟨F, ⟨⟨inferInstance⟩, ⟨inferInstance⟩⟩⟩
#align category_theory.ExactFunctor.of CategoryTheory.ExactFunctor.of
-/

#print CategoryTheory.LeftExactFunctor.of_fst /-
@[simp]
theorem LeftExactFunctor.of_fst (F : C ⥤ D) [PreservesFiniteLimits F] :
    (LeftExactFunctor.of F).obj = F :=
  rfl
#align category_theory.LeftExactFunctor.of_fst CategoryTheory.LeftExactFunctor.of_fst
-/

#print CategoryTheory.RightExactFunctor.of_fst /-
@[simp]
theorem RightExactFunctor.of_fst (F : C ⥤ D) [PreservesFiniteColimits F] :
    (RightExactFunctor.of F).obj = F :=
  rfl
#align category_theory.RightExactFunctor.of_fst CategoryTheory.RightExactFunctor.of_fst
-/

#print CategoryTheory.ExactFunctor.of_fst /-
@[simp]
theorem ExactFunctor.of_fst (F : C ⥤ D) [PreservesFiniteLimits F] [PreservesFiniteColimits F] :
    (ExactFunctor.of F).obj = F :=
  rfl
#align category_theory.ExactFunctor.of_fst CategoryTheory.ExactFunctor.of_fst
-/

/- warning: category_theory.LeftExactFunctor.forget_obj_of -> CategoryTheory.LeftExactFunctor.forget_obj_of is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_3 : CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F], Eq.{succ (max u1 u2 u3 u4)} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.of.{u1, u2, u3, u4} C _inst_1 D _inst_2 F _inst_3)) F
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_3 : CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F], Eq.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2)} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.LeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryLeftExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.LeftExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2)) (CategoryTheory.LeftExactFunctor.of.{u1, u2, u3, u4} C _inst_1 D _inst_2 F _inst_3)) F
Case conversion may be inaccurate. Consider using '#align category_theory.LeftExactFunctor.forget_obj_of CategoryTheory.LeftExactFunctor.forget_obj_ofₓ'. -/
theorem LeftExactFunctor.forget_obj_of (F : C ⥤ D) [PreservesFiniteLimits F] :
    (LeftExactFunctor.forget C D).obj (LeftExactFunctor.of F) = F :=
  rfl
#align category_theory.LeftExactFunctor.forget_obj_of CategoryTheory.LeftExactFunctor.forget_obj_of

/- warning: category_theory.RightExactFunctor.forget_obj_of -> CategoryTheory.RightExactFunctor.forget_obj_of is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_3 : CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F], Eq.{succ (max u1 u2 u3 u4)} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.of.{u1, u2, u3, u4} C _inst_1 D _inst_2 F _inst_3)) F
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_3 : CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F], Eq.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2)} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.RightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryRightExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.RightExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2)) (CategoryTheory.RightExactFunctor.of.{u1, u2, u3, u4} C _inst_1 D _inst_2 F _inst_3)) F
Case conversion may be inaccurate. Consider using '#align category_theory.RightExactFunctor.forget_obj_of CategoryTheory.RightExactFunctor.forget_obj_ofₓ'. -/
theorem RightExactFunctor.forget_obj_of (F : C ⥤ D) [PreservesFiniteColimits F] :
    (RightExactFunctor.forget C D).obj (RightExactFunctor.of F) = F :=
  rfl
#align category_theory.RightExactFunctor.forget_obj_of CategoryTheory.RightExactFunctor.forget_obj_of

/- warning: category_theory.ExactFunctor.forget_obj_of -> CategoryTheory.ExactFunctor.forget_obj_of is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_3 : CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F] [_inst_4 : CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F], Eq.{succ (max u1 u2 u3 u4)} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u1 u2 u3 u4, max u1 u2 u3 u4} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.category.{u2, u4, u3, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.of.{u1, u2, u3, u4} C _inst_1 D _inst_2 F _inst_3 _inst_4)) F
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_3 : CategoryTheory.Limits.PreservesFiniteLimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F] [_inst_4 : CategoryTheory.Limits.PreservesFiniteColimits.{u1, u2, u3, u4} C _inst_1 D _inst_2 F], Eq.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2)} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max (max u3 u4) u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.ExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.instCategoryExactFunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.ExactFunctor.forget.{u1, u2, u3, u4} C _inst_1 D _inst_2)) (CategoryTheory.ExactFunctor.of.{u1, u2, u3, u4} C _inst_1 D _inst_2 F _inst_3 _inst_4)) F
Case conversion may be inaccurate. Consider using '#align category_theory.ExactFunctor.forget_obj_of CategoryTheory.ExactFunctor.forget_obj_ofₓ'. -/
theorem ExactFunctor.forget_obj_of (F : C ⥤ D) [PreservesFiniteLimits F]
    [PreservesFiniteColimits F] : (ExactFunctor.forget C D).obj (ExactFunctor.of F) = F :=
  rfl
#align category_theory.ExactFunctor.forget_obj_of CategoryTheory.ExactFunctor.forget_obj_of

noncomputable instance (F : C ⥤ₗ D) : PreservesFiniteLimits F.obj :=
  F.property.some

noncomputable instance (F : C ⥤ᵣ D) : PreservesFiniteColimits F.obj :=
  F.property.some

noncomputable instance (F : C ⥤ₑ D) : PreservesFiniteLimits F.obj :=
  F.property.1.some

noncomputable instance (F : C ⥤ₑ D) : PreservesFiniteColimits F.obj :=
  F.property.2.some

end

end CategoryTheory

