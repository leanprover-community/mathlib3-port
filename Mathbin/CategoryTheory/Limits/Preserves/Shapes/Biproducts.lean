/-
Copyright (c) 2022 Markus Himmel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Markus Himmel

! This file was ported from Lean 3 source module category_theory.limits.preserves.shapes.biproducts
! leanprover-community/mathlib commit 69c6a5a12d8a2b159f20933e60115a4f2de62b58
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Limits.Shapes.Biproducts
import Mathbin.CategoryTheory.Limits.Preserves.Shapes.Zero

/-!
# Preservation of biproducts

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We define the image of a (binary) bicone under a functor that preserves zero morphisms and define
classes `preserves_biproduct` and `preserves_binary_biproduct`. We then

* show that a functor that preserves biproducts of a two-element type preserves binary biproducts,
* construct the comparison morphisms between the image of a biproduct and the biproduct of the
  images and show that the biproduct is preserved if one of them is an isomorphism,
* give the canonical isomorphism between the image of a biproduct and the biproduct of the images
  in case that the biproduct is preserved.

-/


universe w₁ w₂ v₁ v₂ u₁ u₂

noncomputable section

open CategoryTheory

open CategoryTheory.Limits

namespace CategoryTheory

variable {C : Type u₁} [Category.{v₁} C] {D : Type u₂} [Category.{v₂} D]

section HasZeroMorphisms

variable [HasZeroMorphisms C] [HasZeroMorphisms D]

namespace Functor

section Map

variable (F : C ⥤ D) [PreservesZeroMorphisms F]

section Bicone

variable {J : Type w₁}

/- warning: category_theory.functor.map_bicone -> CategoryTheory.Functor.mapBicone is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] {J : Type.{u1}} {f : J -> C}, (CategoryTheory.Limits.Bicone.{u1, u2, u4} J C _inst_1 _inst_3 f) -> (CategoryTheory.Limits.Bicone.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] {J : Type.{u1}} {f : J -> C}, (CategoryTheory.Limits.Bicone.{u1, u2, u4} J C _inst_1 _inst_3 f) -> (CategoryTheory.Limits.Bicone.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.map_bicone CategoryTheory.Functor.mapBiconeₓ'. -/
/-- The image of a bicone under a functor. -/
@[simps]
def mapBicone {f : J → C} (b : Bicone f) : Bicone (F.obj ∘ f)
    where
  pt := F.obj b.pt
  π j := F.map (b.π j)
  ι j := F.map (b.ι j)
  ι_π j j' := by
    rw [← F.map_comp]
    split_ifs
    · subst h
      simp only [bicone_ι_π_self, CategoryTheory.Functor.map_id, eq_to_hom_refl]
    · rw [bicone_ι_π_ne _ h, F.map_zero]
#align category_theory.functor.map_bicone CategoryTheory.Functor.mapBicone

#print CategoryTheory.Functor.mapBicone_whisker /-
theorem mapBicone_whisker {K : Type w₂} {g : K ≃ J} {f : J → C} (c : Bicone f) :
    F.mapBicone (c.whisker g) = (F.mapBicone c).whisker g :=
  rfl
#align category_theory.functor.map_bicone_whisker CategoryTheory.Functor.mapBicone_whisker
-/

end Bicone

/- warning: category_theory.functor.map_binary_bicone -> CategoryTheory.Functor.mapBinaryBicone is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] {X : C} {Y : C}, (CategoryTheory.Limits.BinaryBicone.{u1, u3} C _inst_1 _inst_3 X Y) -> (CategoryTheory.Limits.BinaryBicone.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] {X : C} {Y : C}, (CategoryTheory.Limits.BinaryBicone.{u1, u3} C _inst_1 _inst_3 X Y) -> (CategoryTheory.Limits.BinaryBicone.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.map_binary_bicone CategoryTheory.Functor.mapBinaryBiconeₓ'. -/
/-- The image of a binary bicone under a functor. -/
@[simps]
def mapBinaryBicone {X Y : C} (b : BinaryBicone X Y) : BinaryBicone (F.obj X) (F.obj Y)
    where
  pt := F.obj b.pt
  fst := F.map b.fst
  snd := F.map b.snd
  inl := F.map b.inl
  inr := F.map b.inr
  inl_fst := by rw [← F.map_comp, b.inl_fst, F.map_id]
  inl_snd := by rw [← F.map_comp, b.inl_snd, F.map_zero]
  inr_fst := by rw [← F.map_comp, b.inr_fst, F.map_zero]
  inr_snd := by rw [← F.map_comp, b.inr_snd, F.map_id]
#align category_theory.functor.map_binary_bicone CategoryTheory.Functor.mapBinaryBicone

end Map

end Functor

open CategoryTheory.Functor

namespace Limits

section Bicone

variable {J : Type w₁} {K : Type w₂}

#print CategoryTheory.Limits.PreservesBiproduct /-
/-- A functor `F` preserves biproducts of `f` if `F` maps every bilimit bicone over `f` to a
    bilimit bicone over `F.obj ∘ f`. -/
class PreservesBiproduct (f : J → C) (F : C ⥤ D) [PreservesZeroMorphisms F] where
  preserves : ∀ {b : Bicone f}, b.IsBilimit → (F.mapBicone b).IsBilimit
#align category_theory.limits.preserves_biproduct CategoryTheory.Limits.PreservesBiproduct
-/

/- warning: category_theory.limits.is_bilimit_of_preserves -> CategoryTheory.Limits.isBilimitOfPreserves is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} {f : J -> C} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_6 : CategoryTheory.Limits.PreservesBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J f F _inst_5] {b : CategoryTheory.Limits.Bicone.{u1, u2, u4} J C _inst_1 _inst_3 f}, (CategoryTheory.Limits.Bicone.IsBilimit.{u1, u2, u4} J C _inst_1 _inst_3 f b) -> (CategoryTheory.Limits.Bicone.IsBilimit.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.mapBicone.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F _inst_5 J f b))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} {f : J -> C} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_6 : CategoryTheory.Limits.PreservesBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J f F _inst_5] {b : CategoryTheory.Limits.Bicone.{u1, u2, u4} J C _inst_1 _inst_3 f}, (CategoryTheory.Limits.Bicone.IsBilimit.{u1, u2, u4} J C _inst_1 _inst_3 f b) -> (CategoryTheory.Limits.Bicone.IsBilimit.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) (CategoryTheory.Functor.mapBicone.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F _inst_5 J f b))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.is_bilimit_of_preserves CategoryTheory.Limits.isBilimitOfPreservesₓ'. -/
/-- A functor `F` preserves biproducts of `f` if `F` maps every bilimit bicone over `f` to a
    bilimit bicone over `F.obj ∘ f`. -/
def isBilimitOfPreserves {f : J → C} (F : C ⥤ D) [PreservesZeroMorphisms F] [PreservesBiproduct f F]
    {b : Bicone f} (hb : b.IsBilimit) : (F.mapBicone b).IsBilimit :=
  PreservesBiproduct.preserves hb
#align category_theory.limits.is_bilimit_of_preserves CategoryTheory.Limits.isBilimitOfPreserves

variable (J)

#print CategoryTheory.Limits.PreservesBiproductsOfShape /-
/-- A functor `F` preserves biproducts of shape `J` if it preserves biproducts of `f` for every
    `f : J → C`. -/
class PreservesBiproductsOfShape (F : C ⥤ D) [PreservesZeroMorphisms F] where
  preserves : ∀ {f : J → C}, PreservesBiproduct f F
#align category_theory.limits.preserves_biproducts_of_shape CategoryTheory.Limits.PreservesBiproductsOfShape
-/

attribute [instance 100] preserves_biproducts_of_shape.preserves

end Bicone

#print CategoryTheory.Limits.PreservesFiniteBiproducts /-
/-- A functor `F` preserves finite biproducts if it preserves biproducts of shape `J` whenever
    `J` is a fintype. -/
class PreservesFiniteBiproducts (F : C ⥤ D) [PreservesZeroMorphisms F] where
  preserves : ∀ {J : Type} [Fintype J], PreservesBiproductsOfShape J F
#align category_theory.limits.preserves_finite_biproducts CategoryTheory.Limits.PreservesFiniteBiproducts
-/

attribute [instance 100] preserves_finite_biproducts.preserves

#print CategoryTheory.Limits.PreservesBiproducts /-
/-- A functor `F` preserves biproducts if it preserves biproducts of any shape `J` of size `w`.
    The usual notion of preservation of biproducts is recovered by choosing `w` to be the universe
    of the morphisms of `C`. -/
class PreservesBiproducts (F : C ⥤ D) [PreservesZeroMorphisms F] where
  preserves : ∀ {J : Type w₁}, PreservesBiproductsOfShape J F
#align category_theory.limits.preserves_biproducts CategoryTheory.Limits.PreservesBiproducts
-/

attribute [instance 100] preserves_biproducts.preserves

#print CategoryTheory.Limits.preservesBiproductsShrink /-
/-- Preserving biproducts at a bigger universe level implies preserving biproducts at a
smaller universe level. -/
def preservesBiproductsShrink (F : C ⥤ D) [PreservesZeroMorphisms F]
    [hp : PreservesBiproducts.{max w₁ w₂} F] : PreservesBiproducts.{w₁} F :=
  ⟨fun J =>
    ⟨fun f =>
      ⟨fun b ib =>
        ((F.mapBicone b).whiskerIsBilimitIff _).toFun
          (isBilimitOfPreserves F ((b.whiskerIsBilimitIff Equiv.ulift.{w₂}).invFun ib))⟩⟩⟩
#align category_theory.limits.preserves_biproducts_shrink CategoryTheory.Limits.preservesBiproductsShrink
-/

#print CategoryTheory.Limits.preservesFiniteBiproductsOfPreservesBiproducts /-
instance (priority := 100) preservesFiniteBiproductsOfPreservesBiproducts (F : C ⥤ D)
    [PreservesZeroMorphisms F] [PreservesBiproducts.{w₁} F] : PreservesFiniteBiproducts F
    where preserves J _ := by letI := preservesBiproductsShrink.{0} F <;> infer_instance
#align category_theory.limits.preserves_finite_biproducts_of_preserves_biproducts CategoryTheory.Limits.preservesFiniteBiproductsOfPreservesBiproducts
-/

#print CategoryTheory.Limits.PreservesBinaryBiproduct /-
/-- A functor `F` preserves binary biproducts of `X` and `Y` if `F` maps every bilimit bicone over
    `X` and `Y` to a bilimit bicone over `F.obj X` and `F.obj Y`. -/
class PreservesBinaryBiproduct (X Y : C) (F : C ⥤ D) [PreservesZeroMorphisms F] where
  preserves : ∀ {b : BinaryBicone X Y}, b.IsBilimit → (F.mapBinaryBicone b).IsBilimit
#align category_theory.limits.preserves_binary_biproduct CategoryTheory.Limits.PreservesBinaryBiproduct
-/

/- warning: category_theory.limits.is_binary_bilimit_of_preserves -> CategoryTheory.Limits.isBinaryBilimitOfPreserves is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] {X : C} {Y : C} (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_6 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_5] {b : CategoryTheory.Limits.BinaryBicone.{u1, u3} C _inst_1 _inst_3 X Y}, (CategoryTheory.Limits.BinaryBicone.IsBilimit.{u1, u3} C _inst_1 _inst_3 X Y b) -> (CategoryTheory.Limits.BinaryBicone.IsBilimit.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.mapBinaryBicone.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F _inst_5 X Y b))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] {X : C} {Y : C} (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_6 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_5] {b : CategoryTheory.Limits.BinaryBicone.{u1, u3} C _inst_1 _inst_3 X Y}, (CategoryTheory.Limits.BinaryBicone.IsBilimit.{u1, u3} C _inst_1 _inst_3 X Y b) -> (CategoryTheory.Limits.BinaryBicone.IsBilimit.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.mapBinaryBicone.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F _inst_5 X Y b))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.is_binary_bilimit_of_preserves CategoryTheory.Limits.isBinaryBilimitOfPreservesₓ'. -/
/-- A functor `F` preserves binary biproducts of `X` and `Y` if `F` maps every bilimit bicone over
    `X` and `Y` to a bilimit bicone over `F.obj X` and `F.obj Y`. -/
def isBinaryBilimitOfPreserves {X Y : C} (F : C ⥤ D) [PreservesZeroMorphisms F]
    [PreservesBinaryBiproduct X Y F] {b : BinaryBicone X Y} (hb : b.IsBilimit) :
    (F.mapBinaryBicone b).IsBilimit :=
  PreservesBinaryBiproduct.preserves hb
#align category_theory.limits.is_binary_bilimit_of_preserves CategoryTheory.Limits.isBinaryBilimitOfPreserves

#print CategoryTheory.Limits.PreservesBinaryBiproducts /-
/-- A functor `F` preserves binary biproducts if it preserves the binary biproduct of `X` and `Y`
    for all `X` and `Y`. -/
class PreservesBinaryBiproducts (F : C ⥤ D) [PreservesZeroMorphisms F] where
  preserves : ∀ {X Y : C}, PreservesBinaryBiproduct X Y F := by infer_instance
#align category_theory.limits.preserves_binary_biproducts CategoryTheory.Limits.PreservesBinaryBiproducts
-/

#print CategoryTheory.Limits.preservesBinaryBiproductOfPreservesBiproduct /-
/-- A functor that preserves biproducts of a pair preserves binary biproducts. -/
def preservesBinaryBiproductOfPreservesBiproduct (F : C ⥤ D) [PreservesZeroMorphisms F] (X Y : C)
    [PreservesBiproduct (pairFunction X Y) F] : PreservesBinaryBiproduct X Y F
    where preserves b hb :=
    { IsLimit :=
        IsLimit.ofIsoLimit
            ((IsLimit.postcomposeHomEquiv (diagram_iso_pair _) _).symm
              (isBilimitOfPreserves F (b.toBiconeIsBilimit.symm hb)).IsLimit) <|
          Cones.ext (Iso.refl _) fun j => by
            rcases j with ⟨⟨⟩⟩
            tidy
      IsColimit :=
        IsColimit.ofIsoColimit
            ((IsColimit.precomposeInvEquiv (diagram_iso_pair _) _).symm
              (isBilimitOfPreserves F (b.toBiconeIsBilimit.symm hb)).IsColimit) <|
          Cocones.ext (Iso.refl _) fun j => by
            rcases j with ⟨⟨⟩⟩
            tidy }
#align category_theory.limits.preserves_binary_biproduct_of_preserves_biproduct CategoryTheory.Limits.preservesBinaryBiproductOfPreservesBiproduct
-/

#print CategoryTheory.Limits.preservesBinaryBiproductsOfPreservesBiproducts /-
/-- A functor that preserves biproducts of a pair preserves binary biproducts. -/
def preservesBinaryBiproductsOfPreservesBiproducts (F : C ⥤ D) [PreservesZeroMorphisms F]
    [PreservesBiproductsOfShape WalkingPair F] : PreservesBinaryBiproducts F
    where preserves X Y := preservesBinaryBiproductOfPreservesBiproduct F X Y
#align category_theory.limits.preserves_binary_biproducts_of_preserves_biproducts CategoryTheory.Limits.preservesBinaryBiproductsOfPreservesBiproducts
-/

attribute [instance 100] preserves_binary_biproducts.preserves

end Limits

open CategoryTheory.Limits

namespace Functor

section Bicone

variable {J : Type w₁} (F : C ⥤ D) (f : J → C) [HasBiproduct f]

section

variable [HasBiproduct (F.obj ∘ f)]

/- warning: category_theory.functor.biproduct_comparison -> CategoryTheory.Functor.biproductComparison is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f)], Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) _inst_6)
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f)], Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) _inst_6)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.biproduct_comparison CategoryTheory.Functor.biproductComparisonₓ'. -/
/-- As for products, any functor between categories with biproducts gives rise to a morphism
    `F.obj (⨁ f) ⟶ ⨁ (F.obj ∘ f)`. -/
def biproductComparison : F.obj (⨁ f) ⟶ ⨁ F.obj ∘ f :=
  biproduct.lift fun j => F.map (biproduct.π f j)
#align category_theory.functor.biproduct_comparison CategoryTheory.Functor.biproductComparison

/- warning: category_theory.functor.biproduct_comparison_π -> CategoryTheory.Functor.biproductComparison_π is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f)] (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f j)) (CategoryTheory.CategoryStruct.comp.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) _inst_6) (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f j) (CategoryTheory.Functor.biproductComparison.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6) (CategoryTheory.Limits.biproduct.π.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) _inst_6 j)) (CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5) (f j) (CategoryTheory.Limits.biproduct.π.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5 j))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f)] (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f j)) (CategoryTheory.CategoryStruct.comp.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) _inst_6) (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f j) (CategoryTheory.Functor.biproductComparison.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6) (CategoryTheory.Limits.biproduct.π.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) _inst_6 j)) (Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5) (f j) (CategoryTheory.Limits.biproduct.π.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5 j))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.biproduct_comparison_π CategoryTheory.Functor.biproductComparison_πₓ'. -/
@[simp, reassoc.1]
theorem biproductComparison_π (j : J) :
    biproductComparison F f ≫ biproduct.π _ j = F.map (biproduct.π f j) :=
  biproduct.lift_π _ _
#align category_theory.functor.biproduct_comparison_π CategoryTheory.Functor.biproductComparison_π

/- warning: category_theory.functor.biproduct_comparison' -> CategoryTheory.Functor.biproductComparison' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f)], Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) _inst_6) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f)], Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) _inst_6) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.biproduct_comparison' CategoryTheory.Functor.biproductComparison'ₓ'. -/
/-- As for coproducts, any functor between categories with biproducts gives rise to a morphism
    `⨁ (F.obj ∘ f) ⟶ F.obj (⨁ f)` -/
def biproductComparison' : ⨁ F.obj ∘ f ⟶ F.obj (⨁ f) :=
  biproduct.desc fun j => F.map (biproduct.ι f j)
#align category_theory.functor.biproduct_comparison' CategoryTheory.Functor.biproductComparison'

/- warning: category_theory.functor.ι_biproduct_comparison' -> CategoryTheory.Functor.ι_biproductComparison' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f)] (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f j) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5))) (CategoryTheory.CategoryStruct.comp.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2) (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f j) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) _inst_6) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.ι.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) _inst_6 j) (CategoryTheory.Functor.biproductComparison'.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6)) (CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (f j) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5) (CategoryTheory.Limits.biproduct.ι.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5 j))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f)] (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f j) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5))) (CategoryTheory.CategoryStruct.comp.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2) (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f j) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) _inst_6) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.ι.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) _inst_6 j) (CategoryTheory.Functor.biproductComparison'.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6)) (Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (f j) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5) (CategoryTheory.Limits.biproduct.ι.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5 j))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.ι_biproduct_comparison' CategoryTheory.Functor.ι_biproductComparison'ₓ'. -/
@[simp, reassoc.1]
theorem ι_biproductComparison' (j : J) :
    biproduct.ι _ j ≫ biproductComparison' F f = F.map (biproduct.ι f j) :=
  biproduct.ι_desc _ _
#align category_theory.functor.ι_biproduct_comparison' CategoryTheory.Functor.ι_biproductComparison'

variable [PreservesZeroMorphisms F]

/- warning: category_theory.functor.biproduct_comparison'_comp_biproduct_comparison -> CategoryTheory.Functor.biproductComparison'_comp_biproductComparison is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f)] [_inst_7 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F], Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) _inst_6) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) _inst_6)) (CategoryTheory.CategoryStruct.comp.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) _inst_6) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) _inst_6) (CategoryTheory.Functor.biproductComparison'.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6) (CategoryTheory.Functor.biproductComparison.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6)) (CategoryTheory.CategoryStruct.id.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) _inst_6))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f)] [_inst_7 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F], Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) _inst_6) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) _inst_6)) (CategoryTheory.CategoryStruct.comp.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) _inst_6) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) _inst_6) (CategoryTheory.Functor.biproductComparison'.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6) (CategoryTheory.Functor.biproductComparison.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6)) (CategoryTheory.CategoryStruct.id.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) _inst_6))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.biproduct_comparison'_comp_biproduct_comparison CategoryTheory.Functor.biproductComparison'_comp_biproductComparisonₓ'. -/
/-- The composition in the opposite direction is equal to the identity if and only if `F` preserves
    the biproduct, see `preserves_biproduct_of_mono_biproduct_comparison`.  -/
@[simp, reassoc.1]
theorem biproductComparison'_comp_biproductComparison :
    biproductComparison' F f ≫ biproductComparison F f = 𝟙 (⨁ F.obj ∘ f) := by
  classical
    ext
    simp [biproduct.ι_π, ← functor.map_comp, eq_to_hom_map]
#align category_theory.functor.biproduct_comparison'_comp_biproduct_comparison CategoryTheory.Functor.biproductComparison'_comp_biproductComparison

/- warning: category_theory.functor.split_epi_biproduct_comparison -> CategoryTheory.Functor.splitEpiBiproductComparison is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f)] [_inst_7 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F], CategoryTheory.SplitEpi.{u3, u5} D _inst_2 (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) _inst_6) (CategoryTheory.Functor.biproductComparison.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6)
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f)] [_inst_7 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F], CategoryTheory.SplitEpi.{u3, u5} D _inst_2 (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) _inst_6) (CategoryTheory.Functor.biproductComparison.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.split_epi_biproduct_comparison CategoryTheory.Functor.splitEpiBiproductComparisonₓ'. -/
/-- `biproduct_comparison F f` is a split epimorphism. -/
@[simps]
def splitEpiBiproductComparison : SplitEpi (biproductComparison F f) :=
  ⟨biproductComparison' F f⟩
#align category_theory.functor.split_epi_biproduct_comparison CategoryTheory.Functor.splitEpiBiproductComparison

instance : IsSplitEpi (biproductComparison F f) :=
  IsSplitEpi.mk' (splitEpiBiproductComparison F f)

/- warning: category_theory.functor.split_mono_biproduct_comparison' -> CategoryTheory.Functor.splitMonoBiproductComparison' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f)] [_inst_7 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F], CategoryTheory.SplitMono.{u3, u5} D _inst_2 (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) _inst_6) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Functor.biproductComparison'.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6)
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f)] [_inst_7 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F], CategoryTheory.SplitMono.{u3, u5} D _inst_2 (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) _inst_6) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Functor.biproductComparison'.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.split_mono_biproduct_comparison' CategoryTheory.Functor.splitMonoBiproductComparison'ₓ'. -/
/-- `biproduct_comparison' F f` is a split monomorphism. -/
@[simps]
def splitMonoBiproductComparison' : SplitMono (biproductComparison' F f) :=
  ⟨biproductComparison F f⟩
#align category_theory.functor.split_mono_biproduct_comparison' CategoryTheory.Functor.splitMonoBiproductComparison'

instance : IsSplitMono (biproductComparison' F f) :=
  IsSplitMono.mk' (splitMonoBiproductComparison' F f)

end

variable [PreservesZeroMorphisms F] [PreservesBiproduct f F]

/- warning: category_theory.functor.has_biproduct_of_preserves -> CategoryTheory.Functor.hasBiproduct_of_preserves is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_7 : CategoryTheory.Limits.PreservesBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J f F _inst_6], CategoryTheory.Limits.HasBiproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f)
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_7 : CategoryTheory.Limits.PreservesBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J f F _inst_6], CategoryTheory.Limits.HasBiproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.has_biproduct_of_preserves CategoryTheory.Functor.hasBiproduct_of_preservesₓ'. -/
instance hasBiproduct_of_preserves : HasBiproduct (F.obj ∘ f) :=
  HasBiproduct.mk
    { Bicone := F.mapBicone (biproduct.bicone f)
      IsBilimit := PreservesBiproduct.preserves (biproduct.isBilimit _) }
#align category_theory.functor.has_biproduct_of_preserves CategoryTheory.Functor.hasBiproduct_of_preserves

/- warning: category_theory.functor.map_biproduct -> CategoryTheory.Functor.mapBiproduct is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_7 : CategoryTheory.Limits.PreservesBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J f F _inst_6], CategoryTheory.Iso.{u3, u5} D _inst_2 (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_7 : CategoryTheory.Limits.PreservesBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J f F _inst_6], CategoryTheory.Iso.{u3, u5} D _inst_2 (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.map_biproduct CategoryTheory.Functor.mapBiproductₓ'. -/
/-- If `F` preserves a biproduct, we get a definitionally nice isomorphism
    `F.obj (⨁ f) ≅ ⨁ (F.obj ∘ f)`. -/
@[simp]
def mapBiproduct : F.obj (⨁ f) ≅ ⨁ F.obj ∘ f :=
  biproduct.uniqueUpToIso _ (PreservesBiproduct.preserves (biproduct.isBilimit _))
#align category_theory.functor.map_biproduct CategoryTheory.Functor.mapBiproduct

/- warning: category_theory.functor.map_biproduct_hom -> CategoryTheory.Functor.mapBiproduct_hom is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_7 : CategoryTheory.Limits.PreservesBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J f F _inst_6], Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7))) (CategoryTheory.Iso.hom.{u3, u5} D _inst_2 (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7)) (CategoryTheory.Functor.mapBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7)) (CategoryTheory.Limits.biproduct.lift.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (fun (j : J) => CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5) (f j) (CategoryTheory.Limits.biproduct.π.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5 j)))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_7 : CategoryTheory.Limits.PreservesBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J f F _inst_6], Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7))) (CategoryTheory.Iso.hom.{u3, u5} D _inst_2 (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7)) (CategoryTheory.Functor.mapBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7)) (CategoryTheory.Limits.biproduct.lift.{u1, u3, u5} J D _inst_2 _inst_4 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (f j)) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (fun (j : J) => Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5) (f j) (CategoryTheory.Limits.biproduct.π.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5 j)))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.map_biproduct_hom CategoryTheory.Functor.mapBiproduct_homₓ'. -/
theorem mapBiproduct_hom :
    (mapBiproduct F f).hom = biproduct.lift fun j => F.map (biproduct.π f j) :=
  rfl
#align category_theory.functor.map_biproduct_hom CategoryTheory.Functor.mapBiproduct_hom

/- warning: category_theory.functor.map_biproduct_inv -> CategoryTheory.Functor.mapBiproduct_inv is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_7 : CategoryTheory.Limits.PreservesBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J f F _inst_6], Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5))) (CategoryTheory.Iso.inv.{u3, u5} D _inst_2 (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7)) (CategoryTheory.Functor.mapBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7)) (CategoryTheory.Limits.biproduct.desc.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (fun (j : J) => CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (f j) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5) (CategoryTheory.Limits.biproduct.ι.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5 j)))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] {J : Type.{u1}} (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) (f : J -> C) [_inst_5 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_7 : CategoryTheory.Limits.PreservesBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J f F _inst_6], Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5))) (CategoryTheory.Iso.inv.{u3, u5} D _inst_2 (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7)) (CategoryTheory.Functor.mapBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7)) (CategoryTheory.Limits.biproduct.desc.{u1, u3, u5} J D _inst_2 _inst_4 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (f j)) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_5 _inst_6 _inst_7) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5)) (fun (j : J) => Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (f j) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5) (CategoryTheory.Limits.biproduct.ι.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_5 j)))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.map_biproduct_inv CategoryTheory.Functor.mapBiproduct_invₓ'. -/
theorem mapBiproduct_inv :
    (mapBiproduct F f).inv = biproduct.desc fun j => F.map (biproduct.ι f j) :=
  rfl
#align category_theory.functor.map_biproduct_inv CategoryTheory.Functor.mapBiproduct_inv

end Bicone

variable (F : C ⥤ D) (X Y : C) [HasBinaryBiproduct X Y]

section

variable [HasBinaryBiproduct (F.obj X) (F.obj Y)]

/- warning: category_theory.functor.biprod_comparison -> CategoryTheory.Functor.biprodComparison is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y)], Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y)], Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.biprod_comparison CategoryTheory.Functor.biprodComparisonₓ'. -/
/-- As for products, any functor between categories with binary biproducts gives rise to a
    morphism `F.obj (X ⊞ Y) ⟶ F.obj X ⊞ F.obj Y`. -/
def biprodComparison : F.obj (X ⊞ Y) ⟶ F.obj X ⊞ F.obj Y :=
  biprod.lift (F.map biprod.fst) (F.map biprod.snd)
#align category_theory.functor.biprod_comparison CategoryTheory.Functor.biprodComparison

/- warning: category_theory.functor.biprod_comparison_fst -> CategoryTheory.Functor.biprodComparison_fst is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y)], Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X)) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.biprodComparison.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6) (CategoryTheory.Limits.biprod.fst.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6)) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5) X (CategoryTheory.Limits.biprod.fst.{u1, u3} C _inst_1 _inst_3 X Y _inst_5))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y)], Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X)) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (CategoryTheory.Functor.biprodComparison.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6) (CategoryTheory.Limits.biprod.fst.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6)) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5) X (CategoryTheory.Limits.biprod.fst.{u1, u3} C _inst_1 _inst_3 X Y _inst_5))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.biprod_comparison_fst CategoryTheory.Functor.biprodComparison_fstₓ'. -/
@[simp, reassoc.1]
theorem biprodComparison_fst : biprodComparison F X Y ≫ biprod.fst = F.map biprod.fst :=
  biprod.lift_fst _ _
#align category_theory.functor.biprod_comparison_fst CategoryTheory.Functor.biprodComparison_fst

/- warning: category_theory.functor.biprod_comparison_snd -> CategoryTheory.Functor.biprodComparison_snd is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y)], Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y)) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.biprodComparison.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6) (CategoryTheory.Limits.biprod.snd.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6)) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5) Y (CategoryTheory.Limits.biprod.snd.{u1, u3} C _inst_1 _inst_3 X Y _inst_5))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y)], Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y)) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.biprodComparison.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6) (CategoryTheory.Limits.biprod.snd.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6)) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5) Y (CategoryTheory.Limits.biprod.snd.{u1, u3} C _inst_1 _inst_3 X Y _inst_5))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.biprod_comparison_snd CategoryTheory.Functor.biprodComparison_sndₓ'. -/
@[simp, reassoc.1]
theorem biprodComparison_snd : biprodComparison F X Y ≫ biprod.snd = F.map biprod.snd :=
  biprod.lift_snd _ _
#align category_theory.functor.biprod_comparison_snd CategoryTheory.Functor.biprodComparison_snd

/- warning: category_theory.functor.biprod_comparison' -> CategoryTheory.Functor.biprodComparison' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y)], Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y)], Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.biprod_comparison' CategoryTheory.Functor.biprodComparison'ₓ'. -/
/-- As for coproducts, any functor between categories with binary biproducts gives rise to a
    morphism `F.obj X ⊞ F.obj Y ⟶ F.obj (X ⊞ Y)`. -/
def biprodComparison' : F.obj X ⊞ F.obj Y ⟶ F.obj (X ⊞ Y) :=
  biprod.desc (F.map biprod.inl) (F.map biprod.inr)
#align category_theory.functor.biprod_comparison' CategoryTheory.Functor.biprodComparison'

/- warning: category_theory.functor.inl_biprod_comparison' -> CategoryTheory.Functor.inl_biprodComparison' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y)], Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.inl.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6) (CategoryTheory.Functor.biprodComparison'.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6)) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5) (CategoryTheory.Limits.biprod.inl.{u1, u3} C _inst_1 _inst_3 X Y _inst_5))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y)], Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.inl.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6) (CategoryTheory.Functor.biprodComparison'.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6)) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5) (CategoryTheory.Limits.biprod.inl.{u1, u3} C _inst_1 _inst_3 X Y _inst_5))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.inl_biprod_comparison' CategoryTheory.Functor.inl_biprodComparison'ₓ'. -/
@[simp, reassoc.1]
theorem inl_biprodComparison' : biprod.inl ≫ biprodComparison' F X Y = F.map biprod.inl :=
  biprod.inl_desc _ _
#align category_theory.functor.inl_biprod_comparison' CategoryTheory.Functor.inl_biprodComparison'

/- warning: category_theory.functor.inr_biprod_comparison' -> CategoryTheory.Functor.inr_biprodComparison' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y)], Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.inr.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6) (CategoryTheory.Functor.biprodComparison'.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6)) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5) (CategoryTheory.Limits.biprod.inr.{u1, u3} C _inst_1 _inst_3 X Y _inst_5))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y)], Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.inr.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6) (CategoryTheory.Functor.biprodComparison'.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6)) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5) (CategoryTheory.Limits.biprod.inr.{u1, u3} C _inst_1 _inst_3 X Y _inst_5))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.inr_biprod_comparison' CategoryTheory.Functor.inr_biprodComparison'ₓ'. -/
@[simp, reassoc.1]
theorem inr_biprodComparison' : biprod.inr ≫ biprodComparison' F X Y = F.map biprod.inr :=
  biprod.inr_desc _ _
#align category_theory.functor.inr_biprod_comparison' CategoryTheory.Functor.inr_biprodComparison'

variable [PreservesZeroMorphisms F]

/- warning: category_theory.functor.biprod_comparison'_comp_biprod_comparison -> CategoryTheory.Functor.biprodComparison'_comp_biprodComparison is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y)] [_inst_7 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F], Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6)) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6) (CategoryTheory.Functor.biprodComparison'.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6) (CategoryTheory.Functor.biprodComparison.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6)) (CategoryTheory.CategoryStruct.id.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y)] [_inst_7 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F], Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6)) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6) (CategoryTheory.Functor.biprodComparison'.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6) (CategoryTheory.Functor.biprodComparison.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6)) (CategoryTheory.CategoryStruct.id.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.biprod_comparison'_comp_biprod_comparison CategoryTheory.Functor.biprodComparison'_comp_biprodComparisonₓ'. -/
/-- The composition in the opposite direction is equal to the identity if and only if `F` preserves
    the biproduct, see `preserves_binary_biproduct_of_mono_biprod_comparison`. -/
@[simp, reassoc.1]
theorem biprodComparison'_comp_biprodComparison :
    biprodComparison' F X Y ≫ biprodComparison F X Y = 𝟙 (F.obj X ⊞ F.obj Y) := by
  ext <;> simp [← functor.map_comp]
#align category_theory.functor.biprod_comparison'_comp_biprod_comparison CategoryTheory.Functor.biprodComparison'_comp_biprodComparison

/- warning: category_theory.functor.split_epi_biprod_comparison -> CategoryTheory.Functor.splitEpiBiprodComparison is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y)] [_inst_7 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F], CategoryTheory.SplitEpi.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6) (CategoryTheory.Functor.biprodComparison.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y)] [_inst_7 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F], CategoryTheory.SplitEpi.{u2, u4} D _inst_2 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6) (CategoryTheory.Functor.biprodComparison.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.split_epi_biprod_comparison CategoryTheory.Functor.splitEpiBiprodComparisonₓ'. -/
/-- `biprod_comparison F X Y` is a split epi. -/
@[simps]
def splitEpiBiprodComparison : SplitEpi (biprodComparison F X Y) :=
  ⟨biprodComparison' F X Y⟩
#align category_theory.functor.split_epi_biprod_comparison CategoryTheory.Functor.splitEpiBiprodComparison

instance : IsSplitEpi (biprodComparison F X Y) :=
  IsSplitEpi.mk' (splitEpiBiprodComparison F X Y)

/- warning: category_theory.functor.split_mono_biprod_comparison' -> CategoryTheory.Functor.splitMonoBiprodComparison' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y)] [_inst_7 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F], CategoryTheory.SplitMono.{u2, u4} D _inst_2 (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) _inst_6) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Functor.biprodComparison'.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y)] [_inst_7 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F], CategoryTheory.SplitMono.{u2, u4} D _inst_2 (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) _inst_6) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Functor.biprodComparison'.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.split_mono_biprod_comparison' CategoryTheory.Functor.splitMonoBiprodComparison'ₓ'. -/
/-- `biprod_comparison' F X Y` is a split mono. -/
@[simps]
def splitMonoBiprodComparison' : SplitMono (biprodComparison' F X Y) :=
  ⟨biprodComparison F X Y⟩
#align category_theory.functor.split_mono_biprod_comparison' CategoryTheory.Functor.splitMonoBiprodComparison'

instance : IsSplitMono (biprodComparison' F X Y) :=
  IsSplitMono.mk' (splitMonoBiprodComparison' F X Y)

end

variable [PreservesZeroMorphisms F] [PreservesBinaryBiproduct X Y F]

/- warning: category_theory.functor.has_binary_biproduct_of_preserves -> CategoryTheory.Functor.hasBinaryBiproduct_of_preserves is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_7 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_6], CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_7 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_6], CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.has_binary_biproduct_of_preserves CategoryTheory.Functor.hasBinaryBiproduct_of_preservesₓ'. -/
instance hasBinaryBiproduct_of_preserves : HasBinaryBiproduct (F.obj X) (F.obj Y) :=
  HasBinaryBiproduct.mk
    { Bicone := F.mapBinaryBicone (BinaryBiproduct.bicone X Y)
      IsBilimit := PreservesBinaryBiproduct.preserves (BinaryBiproduct.isBilimit _ _) }
#align category_theory.functor.has_binary_biproduct_of_preserves CategoryTheory.Functor.hasBinaryBiproduct_of_preserves

/- warning: category_theory.functor.map_biprod -> CategoryTheory.Functor.mapBiprod is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_7 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_6], CategoryTheory.Iso.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_7 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_6], CategoryTheory.Iso.{u2, u4} D _inst_2 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.map_biprod CategoryTheory.Functor.mapBiprodₓ'. -/
/-- If `F` preserves a binary biproduct, we get a definitionally nice isomorphism
    `F.obj (X ⊞ Y) ≅ F.obj X ⊞ F.obj Y`. -/
@[simp]
def mapBiprod : F.obj (X ⊞ Y) ≅ F.obj X ⊞ F.obj Y :=
  biprod.uniqueUpToIso _ _ (PreservesBinaryBiproduct.preserves (BinaryBiproduct.isBilimit _ _))
#align category_theory.functor.map_biprod CategoryTheory.Functor.mapBiprod

/- warning: category_theory.functor.map_biprod_hom -> CategoryTheory.Functor.mapBiprod_hom is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_7 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_6], Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7))) (CategoryTheory.Iso.hom.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7)) (CategoryTheory.Functor.mapBiprod.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7)) (CategoryTheory.Limits.biprod.lift.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5) X (CategoryTheory.Limits.biprod.fst.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5) Y (CategoryTheory.Limits.biprod.snd.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_7 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_6], Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7))) (CategoryTheory.Iso.hom.{u2, u4} D _inst_2 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7)) (CategoryTheory.Functor.mapBiprod.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7)) (CategoryTheory.Limits.biprod.lift.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5) X (CategoryTheory.Limits.biprod.fst.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5) Y (CategoryTheory.Limits.biprod.snd.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.map_biprod_hom CategoryTheory.Functor.mapBiprod_homₓ'. -/
theorem mapBiprod_hom : (mapBiprod F X Y).hom = biprod.lift (F.map biprod.fst) (F.map biprod.snd) :=
  rfl
#align category_theory.functor.map_biprod_hom CategoryTheory.Functor.mapBiprod_hom

/- warning: category_theory.functor.map_biprod_inv -> CategoryTheory.Functor.mapBiprod_inv is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_7 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_6], Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5))) (CategoryTheory.Iso.inv.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7)) (CategoryTheory.Functor.mapBiprod.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7)) (CategoryTheory.Limits.biprod.desc.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5) (CategoryTheory.Limits.biprod.inl.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5) (CategoryTheory.Limits.biprod.inr.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) (X : C) (Y : C) [_inst_5 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] [_inst_7 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_6], Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5))) (CategoryTheory.Iso.inv.{u2, u4} D _inst_2 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7)) (CategoryTheory.Functor.mapBiprod.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7)) (CategoryTheory.Limits.biprod.desc.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_5 _inst_6 _inst_7) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5) (CategoryTheory.Limits.biprod.inl.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_5) (CategoryTheory.Limits.biprod.inr.{u1, u3} C _inst_1 _inst_3 X Y _inst_5)))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.map_biprod_inv CategoryTheory.Functor.mapBiprod_invₓ'. -/
theorem mapBiprod_inv : (mapBiprod F X Y).inv = biprod.desc (F.map biprod.inl) (F.map biprod.inr) :=
  rfl
#align category_theory.functor.map_biprod_inv CategoryTheory.Functor.mapBiprod_inv

end Functor

namespace Limits

variable (F : C ⥤ D) [PreservesZeroMorphisms F]

section Bicone

variable {J : Type w₁} (f : J → C) [HasBiproduct f] [PreservesBiproduct f F] {W : C}

/- warning: category_theory.limits.biproduct.map_lift_map_biprod -> CategoryTheory.Limits.biproduct.map_lift_mapBiprod is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] {J : Type.{u1}} (f : J -> C) [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_7 : CategoryTheory.Limits.PreservesBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J f F _inst_5] {W : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) W (f j)), Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F W) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7))) (CategoryTheory.CategoryStruct.comp.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F W) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 (fun (j : J) => f j) _inst_6)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 F W (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 (fun (j : J) => f j) _inst_6) (CategoryTheory.Limits.biproduct.lift.{u1, u2, u4} J C _inst_1 _inst_3 (fun (j : J) => f j) _inst_6 W g)) (CategoryTheory.Iso.hom.{u3, u5} D _inst_2 (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.mapBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7))) (CategoryTheory.Limits.biproduct.lift.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F W) (fun (j : J) => CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 F W (f j) (g j)))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] {J : Type.{u1}} (f : J -> C) [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_7 : CategoryTheory.Limits.PreservesBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J f F _inst_5] {W : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) W (f j)), Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) W) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7))) (CategoryTheory.CategoryStruct.comp.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) W) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 (fun (j : J) => f j) _inst_6)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) W (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 (fun (j : J) => f j) _inst_6) (CategoryTheory.Limits.biproduct.lift.{u1, u2, u4} J C _inst_1 _inst_3 (fun (j : J) => f j) _inst_6 W g)) (CategoryTheory.Iso.hom.{u3, u5} D _inst_2 (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.mapBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7))) (CategoryTheory.Limits.biproduct.lift.{u1, u3, u5} J D _inst_2 _inst_4 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (f j)) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) W) (fun (j : J) => Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) W (f j) (g j)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.biproduct.map_lift_map_biprod CategoryTheory.Limits.biproduct.map_lift_mapBiprodₓ'. -/
theorem biproduct.map_lift_mapBiprod (g : ∀ j, W ⟶ f j) :
    F.map (biproduct.lift g) ≫ (F.mapBiproduct f).hom = biproduct.lift fun j => F.map (g j) :=
  by
  ext
  simp [← F.map_comp]
#align category_theory.limits.biproduct.map_lift_map_biprod CategoryTheory.Limits.biproduct.map_lift_mapBiprod

/- warning: category_theory.limits.biproduct.map_biproduct_inv_map_desc -> CategoryTheory.Limits.biproduct.mapBiproduct_inv_map_desc is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] {J : Type.{u1}} (f : J -> C) [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_7 : CategoryTheory.Limits.PreservesBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J f F _inst_5] {W : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) (f j) W), Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F W)) (CategoryTheory.CategoryStruct.comp.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F W) (CategoryTheory.Iso.inv.{u3, u5} D _inst_2 (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.mapBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6) W (CategoryTheory.Limits.biproduct.desc.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6 W g))) (CategoryTheory.Limits.biproduct.desc.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F W) (fun (j : J) => CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (f j) W (g j)))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] {J : Type.{u1}} (f : J -> C) [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_7 : CategoryTheory.Limits.PreservesBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J f F _inst_5] {W : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) (f j) W), Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) W)) (CategoryTheory.CategoryStruct.comp.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) W) (CategoryTheory.Iso.inv.{u3, u5} D _inst_2 (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.mapBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6) W (CategoryTheory.Limits.biproduct.desc.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6 W g))) (CategoryTheory.Limits.biproduct.desc.{u1, u3, u5} J D _inst_2 _inst_4 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (f j)) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) W) (fun (j : J) => Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (f j) W (g j)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.biproduct.map_biproduct_inv_map_desc CategoryTheory.Limits.biproduct.mapBiproduct_inv_map_descₓ'. -/
theorem biproduct.mapBiproduct_inv_map_desc (g : ∀ j, f j ⟶ W) :
    (F.mapBiproduct f).inv ≫ F.map (biproduct.desc g) = biproduct.desc fun j => F.map (g j) :=
  by
  ext
  simp [← F.map_comp]
#align category_theory.limits.biproduct.map_biproduct_inv_map_desc CategoryTheory.Limits.biproduct.mapBiproduct_inv_map_desc

/- warning: category_theory.limits.biproduct.map_biproduct_hom_desc -> CategoryTheory.Limits.biproduct.mapBiproduct_hom_desc is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] {J : Type.{u1}} (f : J -> C) [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_7 : CategoryTheory.Limits.PreservesBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J f F _inst_5] {W : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) (f j) W), Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F W)) (CategoryTheory.CategoryStruct.comp.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F W) (CategoryTheory.Iso.hom.{u3, u5} D _inst_2 (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.mapBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (CategoryTheory.Limits.biproduct.desc.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 F W) (fun (j : J) => CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (f j) W (g j)))) (CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6) W (CategoryTheory.Limits.biproduct.desc.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6 W g))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u3, u5} D _inst_2] (F : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 F] {J : Type.{u1}} (f : J -> C) [_inst_6 : CategoryTheory.Limits.HasBiproduct.{u1, u2, u4} J C _inst_1 _inst_3 f] [_inst_7 : CategoryTheory.Limits.PreservesBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J f F _inst_5] {W : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) (f j) W), Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) W)) (CategoryTheory.CategoryStruct.comp.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) W) (CategoryTheory.Iso.hom.{u3, u5} D _inst_2 (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 f _inst_6)) (CategoryTheory.Limits.biproduct.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.mapBiproduct.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7)) (CategoryTheory.Limits.biproduct.desc.{u1, u3, u5} J D _inst_2 _inst_4 (Function.comp.{succ u1, succ u4, succ u5} J C D (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F)) f) (CategoryTheory.Functor.hasBiproduct_of_preserves.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 _inst_3 _inst_4 J F f _inst_6 _inst_5 _inst_7) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) W) (fun (j : J) => Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (f j) W (g j)))) (Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biproduct.{u1, u2, u4} J C _inst_1 _inst_3 (fun (b : J) => f b) _inst_6) W (CategoryTheory.Limits.biproduct.desc.{u1, u2, u4} J C _inst_1 _inst_3 (fun (b : J) => f b) _inst_6 W g))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.biproduct.map_biproduct_hom_desc CategoryTheory.Limits.biproduct.mapBiproduct_hom_descₓ'. -/
theorem biproduct.mapBiproduct_hom_desc (g : ∀ j, f j ⟶ W) :
    ((F.mapBiproduct f).hom ≫ biproduct.desc fun j => F.map (g j)) = F.map (biproduct.desc g) := by
  rw [← biproduct.map_biproduct_inv_map_desc, iso.hom_inv_id_assoc]
#align category_theory.limits.biproduct.map_biproduct_hom_desc CategoryTheory.Limits.biproduct.mapBiproduct_hom_desc

end Bicone

section BinaryBicone

variable (X Y : C) [HasBinaryBiproduct X Y] [PreservesBinaryBiproduct X Y F] {W : C}

/- warning: category_theory.limits.biprod.map_lift_map_biprod -> CategoryTheory.Limits.biprod.map_lift_mapBiprod is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] (X : C) (Y : C) [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_7 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_5] {W : C} (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) W X) (g : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) W Y), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6) (CategoryTheory.Limits.biprod.lift.{u1, u3} C _inst_1 _inst_3 W X Y _inst_6 f g)) (CategoryTheory.Iso.hom.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.mapBiprod.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7))) (CategoryTheory.Limits.biprod.lift.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W X f) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W Y g))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] (X : C) (Y : C) [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_7 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_5] {W : C} (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) W X) (g : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) W Y), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6) (CategoryTheory.Limits.biprod.lift.{u1, u3} C _inst_1 _inst_3 W X Y _inst_6 f g)) (CategoryTheory.Iso.hom.{u2, u4} D _inst_2 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.mapBiprod.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7))) (CategoryTheory.Limits.biprod.lift.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W X f) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W Y g))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.biprod.map_lift_map_biprod CategoryTheory.Limits.biprod.map_lift_mapBiprodₓ'. -/
theorem biprod.map_lift_mapBiprod (f : W ⟶ X) (g : W ⟶ Y) :
    F.map (biprod.lift f g) ≫ (F.mapBiprod X Y).hom = biprod.lift (F.map f) (F.map g) := by
  ext <;> simp [← F.map_comp]
#align category_theory.limits.biprod.map_lift_map_biprod CategoryTheory.Limits.biprod.map_lift_mapBiprod

/- warning: category_theory.limits.biprod.lift_map_biprod -> CategoryTheory.Limits.biprod.lift_mapBiprod is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] (X : C) (Y : C) [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_7 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_5] {W : C} (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) W X) (g : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) W Y), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (CategoryTheory.Limits.biprod.lift.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W X f) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W Y g)) (CategoryTheory.Iso.inv.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.mapBiprod.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7))) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6) (CategoryTheory.Limits.biprod.lift.{u1, u3} C _inst_1 _inst_3 W X Y _inst_6 f g))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] (X : C) (Y : C) [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_7 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_5] {W : C} (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) W X) (g : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) W Y), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6))) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (CategoryTheory.Limits.biprod.lift.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W X f) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W Y g)) (CategoryTheory.Iso.inv.{u2, u4} D _inst_2 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.mapBiprod.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7))) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6) (CategoryTheory.Limits.biprod.lift.{u1, u3} C _inst_1 _inst_3 W X Y _inst_6 f g))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.biprod.lift_map_biprod CategoryTheory.Limits.biprod.lift_mapBiprodₓ'. -/
theorem biprod.lift_mapBiprod (f : W ⟶ X) (g : W ⟶ Y) :
    biprod.lift (F.map f) (F.map g) ≫ (F.mapBiprod X Y).inv = F.map (biprod.lift f g) := by
  rw [← biprod.map_lift_map_biprod, category.assoc, iso.hom_inv_id, category.comp_id]
#align category_theory.limits.biprod.lift_map_biprod CategoryTheory.Limits.biprod.lift_mapBiprod

/- warning: category_theory.limits.biprod.map_biprod_inv_map_desc -> CategoryTheory.Limits.biprod.mapBiprod_inv_map_desc is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] (X : C) (Y : C) [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_7 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_5] {W : C} (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) X W) (g : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) Y W), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W)) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W) (CategoryTheory.Iso.inv.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.mapBiprod.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6) W (CategoryTheory.Limits.biprod.desc.{u1, u3} C _inst_1 _inst_3 W X Y _inst_6 f g))) (CategoryTheory.Limits.biprod.desc.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X W f) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y W g))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] (X : C) (Y : C) [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_7 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_5] {W : C} (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) X W) (g : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) Y W), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W)) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W) (CategoryTheory.Iso.inv.{u2, u4} D _inst_2 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.mapBiprod.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6) W (CategoryTheory.Limits.biprod.desc.{u1, u3} C _inst_1 _inst_3 W X Y _inst_6 f g))) (CategoryTheory.Limits.biprod.desc.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X W f) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y W g))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.biprod.map_biprod_inv_map_desc CategoryTheory.Limits.biprod.mapBiprod_inv_map_descₓ'. -/
theorem biprod.mapBiprod_inv_map_desc (f : X ⟶ W) (g : Y ⟶ W) :
    (F.mapBiprod X Y).inv ≫ F.map (biprod.desc f g) = biprod.desc (F.map f) (F.map g) := by
  ext <;> simp [← F.map_comp]
#align category_theory.limits.biprod.map_biprod_inv_map_desc CategoryTheory.Limits.biprod.mapBiprod_inv_map_desc

/- warning: category_theory.limits.biprod.map_biprod_hom_desc -> CategoryTheory.Limits.biprod.mapBiprod_hom_desc is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] (X : C) (Y : C) [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_7 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_5] {W : C} (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) X W) (g : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) Y W), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W)) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W) (CategoryTheory.Iso.hom.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.mapBiprod.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (CategoryTheory.Limits.biprod.desc.{u2, u4} D _inst_2 _inst_4 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F W) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F X W f) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F Y W g))) (CategoryTheory.Functor.map.{u1, u2, u3, u4} C _inst_1 D _inst_2 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6) W (CategoryTheory.Limits.biprod.desc.{u1, u3} C _inst_1 _inst_3 W X Y _inst_6 f g))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_2) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F] (X : C) (Y : C) [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 _inst_3 X Y] [_inst_7 : CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 X Y F _inst_5] {W : C} (f : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) X W) (g : Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) Y W), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W)) (CategoryTheory.CategoryStruct.comp.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W) (CategoryTheory.Iso.hom.{u2, u4} D _inst_2 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (CategoryTheory.Functor.mapBiprod.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7)) (CategoryTheory.Limits.biprod.desc.{u2, u4} D _inst_2 _inst_4 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) W) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y) (CategoryTheory.Functor.hasBinaryBiproduct_of_preserves.{u1, u2, u3, u4} C _inst_1 D _inst_2 _inst_3 _inst_4 F X Y _inst_6 _inst_5 _inst_7) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) X W f) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) Y W g))) (Prefunctor.map.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_2 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 _inst_3 X Y _inst_6) W (CategoryTheory.Limits.biprod.desc.{u1, u3} C _inst_1 _inst_3 W X Y _inst_6 f g))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.biprod.map_biprod_hom_desc CategoryTheory.Limits.biprod.mapBiprod_hom_descₓ'. -/
theorem biprod.mapBiprod_hom_desc (f : X ⟶ W) (g : Y ⟶ W) :
    (F.mapBiprod X Y).hom ≫ biprod.desc (F.map f) (F.map g) = F.map (biprod.desc f g) := by
  rw [← biprod.map_biprod_inv_map_desc, iso.hom_inv_id_assoc]
#align category_theory.limits.biprod.map_biprod_hom_desc CategoryTheory.Limits.biprod.mapBiprod_hom_desc

end BinaryBicone

end Limits

end HasZeroMorphisms

end CategoryTheory

