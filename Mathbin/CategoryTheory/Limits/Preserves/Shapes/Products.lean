/-
Copyright (c) 2020 Scott Morrison, Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison, Bhavik Mehta

! This file was ported from Lean 3 source module category_theory.limits.preserves.shapes.products
! leanprover-community/mathlib commit 024a4231815538ac739f52d08dd20a55da0d6b23
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Limits.Shapes.Products
import Mathbin.CategoryTheory.Limits.Preserves.Basic

/-!
# Preserving products

Constructions to relate the notions of preserving products and reflecting products
to concrete fans.

In particular, we show that `pi_comparison G f` is an isomorphism iff `G` preserves
the limit of `f`.
-/


noncomputable section

universe w v₁ v₂ u₁ u₂

open CategoryTheory CategoryTheory.Category CategoryTheory.Limits

variable {C : Type u₁} [Category.{v₁} C]

variable {D : Type u₂} [Category.{v₂} D]

variable (G : C ⥤ D)

namespace CategoryTheory.Limits

variable {J : Type w} (f : J → C)

/- warning: category_theory.limits.is_limit_map_cone_fan_mk_equiv -> CategoryTheory.Limits.isLimitMapConeFanMkEquiv is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) {P : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) P (f j)), Equiv.{max (succ u1) (succ u5) (succ u3), max (succ u1) (succ u5) (succ u3)} (CategoryTheory.Limits.IsLimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Functor.comp.{u1, u2, u3, u1, u4, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) C _inst_1 D _inst_2 (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J (fun (j : J) => f j)) G) (CategoryTheory.Functor.mapCone.{u1, u2, u3, u1, u4, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) C _inst_1 D _inst_2 (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J (fun (j : J) => f j)) G (CategoryTheory.Limits.Fan.mk.{u1, u2, u4} J C _inst_1 (fun (j : J) => f j) P g))) (CategoryTheory.Limits.IsLimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Discrete.functor.{u3, u1, u5} D _inst_2 J (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j))) (CategoryTheory.Limits.Fan.mk.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G P) (fun (j : J) => CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 G P (f j) (g j))))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) {P : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) P (f j)), Equiv.{max (max (succ u5) (succ u1)) (succ u3), max (max (succ u5) (succ u1)) (succ u3)} (CategoryTheory.Limits.IsLimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Functor.comp.{u1, u2, u3, u1, u4, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) C _inst_1 D _inst_2 (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J (fun (j : J) => f j)) G) (CategoryTheory.Functor.mapCone.{u1, u2, u3, u1, u4, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) C _inst_1 D _inst_2 G (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J (fun (b : J) => f b)) (CategoryTheory.Limits.Fan.mk.{u1, u2, u4} J C _inst_1 (fun (j : J) => f j) P g))) (CategoryTheory.Limits.IsLimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Discrete.functor.{u3, u1, u5} D _inst_2 J (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j))) (CategoryTheory.Limits.Fan.mk.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) P) (fun (j : J) => Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) P (f j) (g j))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.is_limit_map_cone_fan_mk_equiv CategoryTheory.Limits.isLimitMapConeFanMkEquivₓ'. -/
/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `discrete_cases #[] -/
/-- The map of a fan is a limit iff the fan consisting of the mapped morphisms is a limit. This
essentially lets us commute `fan.mk` with `functor.map_cone`.
-/
def isLimitMapConeFanMkEquiv {P : C} (g : ∀ j, P ⟶ f j) :
    IsLimit (G.mapCone (Fan.mk P g)) ≃
      IsLimit (Fan.mk _ fun j => G.map (g j) : Fan fun j => G.obj (f j)) :=
  by
  refine' (is_limit.postcompose_hom_equiv _ _).symm.trans (is_limit.equiv_iso_limit _)
  refine' discrete.nat_iso fun j => iso.refl (G.obj (f j.as))
  refine'
    cones.ext (iso.refl _) fun j =>
      by
      trace
        "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `discrete_cases #[]"
      dsimp
      simp
#align category_theory.limits.is_limit_map_cone_fan_mk_equiv CategoryTheory.Limits.isLimitMapConeFanMkEquiv

/- warning: category_theory.limits.is_limit_fan_mk_obj_of_is_limit -> CategoryTheory.Limits.isLimitFanMkObjOfIsLimit is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G] {P : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) P (f j)), (CategoryTheory.Limits.IsLimit.{u1, u2, u1, u4} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) C _inst_1 (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J (fun (j : J) => f j)) (CategoryTheory.Limits.Fan.mk.{u1, u2, u4} J C _inst_1 (fun (j : J) => f j) P g)) -> (CategoryTheory.Limits.IsLimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Discrete.functor.{u3, u1, u5} D _inst_2 J (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j))) (CategoryTheory.Limits.Fan.mk.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G P) (fun (j : J) => CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 G P (f j) (g j))))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G] {P : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) P (f j)), (CategoryTheory.Limits.IsLimit.{u1, u2, u1, u4} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) C _inst_1 (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J (fun (j : J) => f j)) (CategoryTheory.Limits.Fan.mk.{u1, u2, u4} J C _inst_1 (fun (j : J) => f j) P g)) -> (CategoryTheory.Limits.IsLimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Discrete.functor.{u3, u1, u5} D _inst_2 J (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j))) (CategoryTheory.Limits.Fan.mk.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) P) (fun (j : J) => Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) P (f j) (g j))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.is_limit_fan_mk_obj_of_is_limit CategoryTheory.Limits.isLimitFanMkObjOfIsLimitₓ'. -/
/-- The property of preserving products expressed in terms of fans. -/
def isLimitFanMkObjOfIsLimit [PreservesLimit (Discrete.functor f) G] {P : C} (g : ∀ j, P ⟶ f j)
    (t : IsLimit (Fan.mk _ g)) :
    IsLimit (Fan.mk (G.obj P) fun j => G.map (g j) : Fan fun j => G.obj (f j)) :=
  isLimitMapConeFanMkEquiv _ _ _ (PreservesLimit.preserves t)
#align category_theory.limits.is_limit_fan_mk_obj_of_is_limit CategoryTheory.Limits.isLimitFanMkObjOfIsLimit

/- warning: category_theory.limits.is_limit_of_is_limit_fan_mk_obj -> CategoryTheory.Limits.isLimitOfIsLimitFanMkObj is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.ReflectsLimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G] {P : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) P (f j)), (CategoryTheory.Limits.IsLimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Discrete.functor.{u3, u1, u5} D _inst_2 J (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j))) (CategoryTheory.Limits.Fan.mk.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G P) (fun (j : J) => CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 G P (f j) (g j)))) -> (CategoryTheory.Limits.IsLimit.{u1, u2, u1, u4} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) C _inst_1 (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J (fun (j : J) => f j)) (CategoryTheory.Limits.Fan.mk.{u1, u2, u4} J C _inst_1 (fun (j : J) => f j) P g))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.ReflectsLimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G] {P : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) P (f j)), (CategoryTheory.Limits.IsLimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Discrete.functor.{u3, u1, u5} D _inst_2 J (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j))) (CategoryTheory.Limits.Fan.mk.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) P) (fun (j : J) => Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) P (f j) (g j)))) -> (CategoryTheory.Limits.IsLimit.{u1, u2, u1, u4} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) C _inst_1 (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J (fun (j : J) => f j)) (CategoryTheory.Limits.Fan.mk.{u1, u2, u4} J C _inst_1 (fun (j : J) => f j) P g))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.is_limit_of_is_limit_fan_mk_obj CategoryTheory.Limits.isLimitOfIsLimitFanMkObjₓ'. -/
/-- The property of reflecting products expressed in terms of fans. -/
def isLimitOfIsLimitFanMkObj [ReflectsLimit (Discrete.functor f) G] {P : C} (g : ∀ j, P ⟶ f j)
    (t : IsLimit (Fan.mk _ fun j => G.map (g j) : Fan fun j => G.obj (f j))) :
    IsLimit (Fan.mk P g) :=
  ReflectsLimit.reflects ((isLimitMapConeFanMkEquiv _ _ _).symm t)
#align category_theory.limits.is_limit_of_is_limit_fan_mk_obj CategoryTheory.Limits.isLimitOfIsLimitFanMkObj

section

variable [HasProduct f]

/- warning: category_theory.limits.is_limit_of_has_product_of_preserves_limit -> CategoryTheory.Limits.isLimitOfHasProductOfPreservesLimit is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.HasProduct.{u1, u2, u4} J C _inst_1 f] [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G], CategoryTheory.Limits.IsLimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Discrete.functor.{u3, u1, u5} D _inst_2 J (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j))) (CategoryTheory.Limits.Fan.mk.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (CategoryTheory.Limits.piObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (fun (j : J) => CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (CategoryTheory.Limits.piObj.{u1, u2, u4} J C _inst_1 f _inst_3) (f j) (CategoryTheory.Limits.Pi.π.{u1, u2, u4} J C _inst_1 f _inst_3 j)))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.HasProduct.{u1, u2, u4} J C _inst_1 f] [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G], CategoryTheory.Limits.IsLimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Discrete.functor.{u3, u1, u5} D _inst_2 J (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j))) (CategoryTheory.Limits.Fan.mk.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.piObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (fun (j : J) => Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.piObj.{u1, u2, u4} J C _inst_1 f _inst_3) (f j) (CategoryTheory.Limits.Pi.π.{u1, u2, u4} J C _inst_1 f _inst_3 j)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.is_limit_of_has_product_of_preserves_limit CategoryTheory.Limits.isLimitOfHasProductOfPreservesLimitₓ'. -/
/--
If `G` preserves products and `C` has them, then the fan constructed of the mapped projection of a
product is a limit.
-/
def isLimitOfHasProductOfPreservesLimit [PreservesLimit (Discrete.functor f) G] :
    IsLimit (Fan.mk _ fun j : J => G.map (Pi.π f j) : Fan fun j => G.obj (f j)) :=
  isLimitFanMkObjOfIsLimit G f _ (productIsProduct _)
#align category_theory.limits.is_limit_of_has_product_of_preserves_limit CategoryTheory.Limits.isLimitOfHasProductOfPreservesLimit

variable [HasProduct fun j : J => G.obj (f j)]

/- warning: category_theory.limits.preserves_product.of_iso_comparison -> CategoryTheory.Limits.PreservesProduct.ofIsoComparison is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.HasProduct.{u1, u2, u4} J C _inst_1 f] [_inst_4 : CategoryTheory.Limits.HasProduct.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j))] [i : CategoryTheory.IsIso.{u3, u5} D _inst_2 (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (CategoryTheory.Limits.piObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (CategoryTheory.Limits.piObj.{u1, u3, u5} J D _inst_2 (fun (b : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f b)) _inst_4) (CategoryTheory.Limits.piComparison.{u1, u2, u3, u4, u5} J C _inst_1 D _inst_2 G f _inst_3 _inst_4)], CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.HasProduct.{u1, u2, u4} J C _inst_1 f] [_inst_4 : CategoryTheory.Limits.HasProduct.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j))] [i : CategoryTheory.IsIso.{u3, u5} D _inst_2 (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.piObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (CategoryTheory.Limits.piObj.{u1, u3, u5} J D _inst_2 (fun (b : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f b)) _inst_4) (CategoryTheory.Limits.piComparison.{u1, u2, u3, u4, u5} J C _inst_1 D _inst_2 G f _inst_3 _inst_4)], CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G
Case conversion may be inaccurate. Consider using '#align category_theory.limits.preserves_product.of_iso_comparison CategoryTheory.Limits.PreservesProduct.ofIsoComparisonₓ'. -/
/-- If `pi_comparison G f` is an isomorphism, then `G` preserves the limit of `f`. -/
def PreservesProduct.ofIsoComparison [i : IsIso (piComparison G f)] :
    PreservesLimit (Discrete.functor f) G :=
  by
  apply preserves_limit_of_preserves_limit_cone (product_is_product f)
  apply (is_limit_map_cone_fan_mk_equiv _ _ _).symm _
  apply is_limit.of_point_iso (limit.is_limit (discrete.functor fun j : J => G.obj (f j)))
  apply i
#align category_theory.limits.preserves_product.of_iso_comparison CategoryTheory.Limits.PreservesProduct.ofIsoComparison

variable [PreservesLimit (Discrete.functor f) G]

/- warning: category_theory.limits.preserves_product.iso -> CategoryTheory.Limits.PreservesProduct.iso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.HasProduct.{u1, u2, u4} J C _inst_1 f] [_inst_4 : CategoryTheory.Limits.HasProduct.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j))] [_inst_5 : CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G], CategoryTheory.Iso.{u3, u5} D _inst_2 (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (CategoryTheory.Limits.piObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (CategoryTheory.Limits.piObj.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j)) _inst_4)
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.HasProduct.{u1, u2, u4} J C _inst_1 f] [_inst_4 : CategoryTheory.Limits.HasProduct.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j))] [_inst_5 : CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G], CategoryTheory.Iso.{u3, u5} D _inst_2 (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.piObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (CategoryTheory.Limits.piObj.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j)) _inst_4)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.preserves_product.iso CategoryTheory.Limits.PreservesProduct.isoₓ'. -/
/--
If `G` preserves limits, we have an isomorphism from the image of a product to the product of the
images.
-/
def PreservesProduct.iso : G.obj (∏ f) ≅ ∏ fun j => G.obj (f j) :=
  IsLimit.conePointUniqueUpToIso (isLimitOfHasProductOfPreservesLimit G f) (limit.isLimit _)
#align category_theory.limits.preserves_product.iso CategoryTheory.Limits.PreservesProduct.iso

/- warning: category_theory.limits.preserves_product.iso_hom -> CategoryTheory.Limits.PreservesProduct.iso_hom is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.HasProduct.{u1, u2, u4} J C _inst_1 f] [_inst_4 : CategoryTheory.Limits.HasProduct.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j))] [_inst_5 : CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G], Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (CategoryTheory.Limits.piObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (CategoryTheory.Limits.piObj.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j)) _inst_4)) (CategoryTheory.Iso.hom.{u3, u5} D _inst_2 (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (CategoryTheory.Limits.piObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (CategoryTheory.Limits.piObj.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j)) _inst_4) (CategoryTheory.Limits.PreservesProduct.iso.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 G J f _inst_3 _inst_4 _inst_5)) (CategoryTheory.Limits.piComparison.{u1, u2, u3, u4, u5} J C _inst_1 D _inst_2 G f _inst_3 _inst_4)
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.HasProduct.{u1, u2, u4} J C _inst_1 f] [_inst_4 : CategoryTheory.Limits.HasProduct.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j))] [_inst_5 : CategoryTheory.Limits.PreservesLimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G], Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.piObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (CategoryTheory.Limits.piObj.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j)) _inst_4)) (CategoryTheory.Iso.hom.{u3, u5} D _inst_2 (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.piObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (CategoryTheory.Limits.piObj.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j)) _inst_4) (CategoryTheory.Limits.PreservesProduct.iso.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 G J f _inst_3 _inst_4 _inst_5)) (CategoryTheory.Limits.piComparison.{u1, u2, u3, u4, u5} J C _inst_1 D _inst_2 G f _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.preserves_product.iso_hom CategoryTheory.Limits.PreservesProduct.iso_homₓ'. -/
@[simp]
theorem PreservesProduct.iso_hom : (PreservesProduct.iso G f).Hom = piComparison G f :=
  rfl
#align category_theory.limits.preserves_product.iso_hom CategoryTheory.Limits.PreservesProduct.iso_hom

instance : IsIso (piComparison G f) :=
  by
  rw [← preserves_product.iso_hom]
  infer_instance

end

/- warning: category_theory.limits.is_colimit_map_cocone_cofan_mk_equiv -> CategoryTheory.Limits.isColimitMapCoconeCofanMkEquiv is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) {P : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) (f j) P), Equiv.{max (succ u1) (succ u5) (succ u3), max (succ u1) (succ u5) (succ u3)} (CategoryTheory.Limits.IsColimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Functor.comp.{u1, u2, u3, u1, u4, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) C _inst_1 D _inst_2 (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J (fun (j : J) => f j)) G) (CategoryTheory.Functor.mapCocone.{u1, u2, u3, u1, u4, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) C _inst_1 D _inst_2 (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J (fun (j : J) => f j)) G (CategoryTheory.Limits.Cofan.mk.{u1, u2, u4} J C _inst_1 (fun (j : J) => f j) P g))) (CategoryTheory.Limits.IsColimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Discrete.functor.{u3, u1, u5} D _inst_2 J (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j))) (CategoryTheory.Limits.Cofan.mk.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G P) (fun (j : J) => CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j) P (g j))))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) {P : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) (f j) P), Equiv.{max (max (succ u5) (succ u1)) (succ u3), max (max (succ u5) (succ u1)) (succ u3)} (CategoryTheory.Limits.IsColimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Functor.comp.{u1, u2, u3, u1, u4, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) C _inst_1 D _inst_2 (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J (fun (j : J) => f j)) G) (CategoryTheory.Functor.mapCocone.{u1, u2, u3, u1, u4, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) C _inst_1 D _inst_2 G (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J (fun (b : J) => f b)) (CategoryTheory.Limits.Cofan.mk.{u1, u2, u4} J C _inst_1 (fun (j : J) => f j) P g))) (CategoryTheory.Limits.IsColimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Discrete.functor.{u3, u1, u5} D _inst_2 J (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j))) (CategoryTheory.Limits.Cofan.mk.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) P) (fun (j : J) => Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j) P (g j))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.is_colimit_map_cocone_cofan_mk_equiv CategoryTheory.Limits.isColimitMapCoconeCofanMkEquivₓ'. -/
/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `discrete_cases #[] -/
/-- The map of a cofan is a colimit iff the cofan consisting of the mapped morphisms is a colimit.
This essentially lets us commute `cofan.mk` with `functor.map_cocone`.
-/
def isColimitMapCoconeCofanMkEquiv {P : C} (g : ∀ j, f j ⟶ P) :
    IsColimit (G.mapCocone (Cofan.mk P g)) ≃
      IsColimit (Cofan.mk _ fun j => G.map (g j) : Cofan fun j => G.obj (f j)) :=
  by
  refine' (is_colimit.precompose_hom_equiv _ _).symm.trans (is_colimit.equiv_iso_colimit _)
  refine' discrete.nat_iso fun j => iso.refl (G.obj (f j.as))
  refine'
    cocones.ext (iso.refl _) fun j =>
      by
      trace
        "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `discrete_cases #[]"
      dsimp
      simp
#align category_theory.limits.is_colimit_map_cocone_cofan_mk_equiv CategoryTheory.Limits.isColimitMapCoconeCofanMkEquiv

/- warning: category_theory.limits.is_colimit_cofan_mk_obj_of_is_colimit -> CategoryTheory.Limits.isColimitCofanMkObjOfIsColimit is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G] {P : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) (f j) P), (CategoryTheory.Limits.IsColimit.{u1, u2, u1, u4} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) C _inst_1 (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J (fun (j : J) => f j)) (CategoryTheory.Limits.Cofan.mk.{u1, u2, u4} J C _inst_1 (fun (j : J) => f j) P g)) -> (CategoryTheory.Limits.IsColimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Discrete.functor.{u3, u1, u5} D _inst_2 J (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j))) (CategoryTheory.Limits.Cofan.mk.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G P) (fun (j : J) => CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j) P (g j))))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G] {P : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) (f j) P), (CategoryTheory.Limits.IsColimit.{u1, u2, u1, u4} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) C _inst_1 (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J (fun (j : J) => f j)) (CategoryTheory.Limits.Cofan.mk.{u1, u2, u4} J C _inst_1 (fun (j : J) => f j) P g)) -> (CategoryTheory.Limits.IsColimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Discrete.functor.{u3, u1, u5} D _inst_2 J (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j))) (CategoryTheory.Limits.Cofan.mk.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) P) (fun (j : J) => Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j) P (g j))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.is_colimit_cofan_mk_obj_of_is_colimit CategoryTheory.Limits.isColimitCofanMkObjOfIsColimitₓ'. -/
/-- The property of preserving coproducts expressed in terms of cofans. -/
def isColimitCofanMkObjOfIsColimit [PreservesColimit (Discrete.functor f) G] {P : C}
    (g : ∀ j, f j ⟶ P) (t : IsColimit (Cofan.mk _ g)) :
    IsColimit (Cofan.mk (G.obj P) fun j => G.map (g j) : Cofan fun j => G.obj (f j)) :=
  isColimitMapCoconeCofanMkEquiv _ _ _ (PreservesColimit.preserves t)
#align category_theory.limits.is_colimit_cofan_mk_obj_of_is_colimit CategoryTheory.Limits.isColimitCofanMkObjOfIsColimit

/- warning: category_theory.limits.is_colimit_of_is_colimit_cofan_mk_obj -> CategoryTheory.Limits.isColimitOfIsColimitCofanMkObj is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.ReflectsColimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G] {P : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) (f j) P), (CategoryTheory.Limits.IsColimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Discrete.functor.{u3, u1, u5} D _inst_2 J (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j))) (CategoryTheory.Limits.Cofan.mk.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G P) (fun (j : J) => CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j) P (g j)))) -> (CategoryTheory.Limits.IsColimit.{u1, u2, u1, u4} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) C _inst_1 (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J (fun (j : J) => f j)) (CategoryTheory.Limits.Cofan.mk.{u1, u2, u4} J C _inst_1 (fun (j : J) => f j) P g))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.ReflectsColimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G] {P : C} (g : forall (j : J), Quiver.Hom.{succ u2, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) (f j) P), (CategoryTheory.Limits.IsColimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Discrete.functor.{u3, u1, u5} D _inst_2 J (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j))) (CategoryTheory.Limits.Cofan.mk.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) P) (fun (j : J) => Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j) P (g j)))) -> (CategoryTheory.Limits.IsColimit.{u1, u2, u1, u4} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) C _inst_1 (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J (fun (j : J) => f j)) (CategoryTheory.Limits.Cofan.mk.{u1, u2, u4} J C _inst_1 (fun (j : J) => f j) P g))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.is_colimit_of_is_colimit_cofan_mk_obj CategoryTheory.Limits.isColimitOfIsColimitCofanMkObjₓ'. -/
/-- The property of reflecting coproducts expressed in terms of cofans. -/
def isColimitOfIsColimitCofanMkObj [ReflectsColimit (Discrete.functor f) G] {P : C}
    (g : ∀ j, f j ⟶ P)
    (t : IsColimit (Cofan.mk _ fun j => G.map (g j) : Cofan fun j => G.obj (f j))) :
    IsColimit (Cofan.mk P g) :=
  ReflectsColimit.reflects ((isColimitMapCoconeCofanMkEquiv _ _ _).symm t)
#align category_theory.limits.is_colimit_of_is_colimit_cofan_mk_obj CategoryTheory.Limits.isColimitOfIsColimitCofanMkObj

section

variable [HasCoproduct f]

/- warning: category_theory.limits.is_colimit_of_has_coproduct_of_preserves_colimit -> CategoryTheory.Limits.isColimitOfHasCoproductOfPreservesColimit is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.HasCoproduct.{u1, u2, u4} J C _inst_1 f] [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G], CategoryTheory.Limits.IsColimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Discrete.functor.{u3, u1, u5} D _inst_2 J (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j))) (CategoryTheory.Limits.Cofan.mk.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j)) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (CategoryTheory.Limits.sigmaObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (fun (j : J) => CategoryTheory.Functor.map.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j) (CategoryTheory.Limits.sigmaObj.{u1, u2, u4} J C _inst_1 f _inst_3) (CategoryTheory.Limits.Sigma.ι.{u1, u2, u4} J C _inst_1 f _inst_3 j)))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.HasCoproduct.{u1, u2, u4} J C _inst_1 f] [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G], CategoryTheory.Limits.IsColimit.{u1, u3, u1, u5} (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) D _inst_2 (CategoryTheory.Discrete.functor.{u3, u1, u5} D _inst_2 J (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j))) (CategoryTheory.Limits.Cofan.mk.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j)) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.sigmaObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (fun (j : J) => Prefunctor.map.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j) (CategoryTheory.Limits.sigmaObj.{u1, u2, u4} J C _inst_1 f _inst_3) (CategoryTheory.Limits.Sigma.ι.{u1, u2, u4} J C _inst_1 f _inst_3 j)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.is_colimit_of_has_coproduct_of_preserves_colimit CategoryTheory.Limits.isColimitOfHasCoproductOfPreservesColimitₓ'. -/
/-- If `G` preserves coproducts and `C` has them,
then the cofan constructed of the mapped inclusion of a coproduct is a colimit.
-/
def isColimitOfHasCoproductOfPreservesColimit [PreservesColimit (Discrete.functor f) G] :
    IsColimit (Cofan.mk _ fun j : J => G.map (Sigma.ι f j) : Cofan fun j => G.obj (f j)) :=
  isColimitCofanMkObjOfIsColimit G f _ (coproductIsCoproduct _)
#align category_theory.limits.is_colimit_of_has_coproduct_of_preserves_colimit CategoryTheory.Limits.isColimitOfHasCoproductOfPreservesColimit

variable [HasCoproduct fun j : J => G.obj (f j)]

/- warning: category_theory.limits.preserves_coproduct.of_iso_comparison -> CategoryTheory.Limits.PreservesCoproduct.ofIsoComparison is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.HasCoproduct.{u1, u2, u4} J C _inst_1 f] [_inst_4 : CategoryTheory.Limits.HasCoproduct.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j))] [i : CategoryTheory.IsIso.{u3, u5} D _inst_2 (CategoryTheory.Limits.sigmaObj.{u1, u3, u5} J D _inst_2 (fun (b : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f b)) _inst_4) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (CategoryTheory.Limits.sigmaObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (CategoryTheory.Limits.sigmaComparison.{u1, u2, u3, u4, u5} J C _inst_1 D _inst_2 G f _inst_3 _inst_4)], CategoryTheory.Limits.PreservesColimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.HasCoproduct.{u1, u2, u4} J C _inst_1 f] [_inst_4 : CategoryTheory.Limits.HasCoproduct.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j))] [i : CategoryTheory.IsIso.{u3, u5} D _inst_2 (CategoryTheory.Limits.sigmaObj.{u1, u3, u5} J D _inst_2 (fun (b : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f b)) _inst_4) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.sigmaObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (CategoryTheory.Limits.sigmaComparison.{u1, u2, u3, u4, u5} J C _inst_1 D _inst_2 G f _inst_3 _inst_4)], CategoryTheory.Limits.PreservesColimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G
Case conversion may be inaccurate. Consider using '#align category_theory.limits.preserves_coproduct.of_iso_comparison CategoryTheory.Limits.PreservesCoproduct.ofIsoComparisonₓ'. -/
/-- If `sigma_comparison G f` is an isomorphism, then `G` preserves the colimit of `f`. -/
def PreservesCoproduct.ofIsoComparison [i : IsIso (sigmaComparison G f)] :
    PreservesColimit (Discrete.functor f) G :=
  by
  apply preserves_colimit_of_preserves_colimit_cocone (coproduct_is_coproduct f)
  apply (is_colimit_map_cocone_cofan_mk_equiv _ _ _).symm _
  apply is_colimit.of_point_iso (colimit.is_colimit (discrete.functor fun j : J => G.obj (f j)))
  apply i
#align category_theory.limits.preserves_coproduct.of_iso_comparison CategoryTheory.Limits.PreservesCoproduct.ofIsoComparison

variable [PreservesColimit (Discrete.functor f) G]

/- warning: category_theory.limits.preserves_coproduct.iso -> CategoryTheory.Limits.PreservesCoproduct.iso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.HasCoproduct.{u1, u2, u4} J C _inst_1 f] [_inst_4 : CategoryTheory.Limits.HasCoproduct.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j))] [_inst_5 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G], CategoryTheory.Iso.{u3, u5} D _inst_2 (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (CategoryTheory.Limits.sigmaObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (CategoryTheory.Limits.sigmaObj.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j)) _inst_4)
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.HasCoproduct.{u1, u2, u4} J C _inst_1 f] [_inst_4 : CategoryTheory.Limits.HasCoproduct.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j))] [_inst_5 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G], CategoryTheory.Iso.{u3, u5} D _inst_2 (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.sigmaObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (CategoryTheory.Limits.sigmaObj.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j)) _inst_4)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.preserves_coproduct.iso CategoryTheory.Limits.PreservesCoproduct.isoₓ'. -/
/-- If `G` preserves colimits,
we have an isomorphism from the image of a coproduct to the coproduct of the images.
-/
def PreservesCoproduct.iso : G.obj (∐ f) ≅ ∐ fun j => G.obj (f j) :=
  IsColimit.coconePointUniqueUpToIso (isColimitOfHasCoproductOfPreservesColimit G f)
    (colimit.isColimit _)
#align category_theory.limits.preserves_coproduct.iso CategoryTheory.Limits.PreservesCoproduct.iso

/- warning: category_theory.limits.preserves_coproduct.inv_hom -> CategoryTheory.Limits.PreservesCoproduct.inv_hom is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.HasCoproduct.{u1, u2, u4} J C _inst_1 f] [_inst_4 : CategoryTheory.Limits.HasCoproduct.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j))] [_inst_5 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G], Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Limits.sigmaObj.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j)) _inst_4) (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (CategoryTheory.Limits.sigmaObj.{u1, u2, u4} J C _inst_1 f _inst_3))) (CategoryTheory.Iso.inv.{u3, u5} D _inst_2 (CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (CategoryTheory.Limits.sigmaObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (CategoryTheory.Limits.sigmaObj.{u1, u3, u5} J D _inst_2 (fun (j : J) => CategoryTheory.Functor.obj.{u2, u3, u4, u5} C _inst_1 D _inst_2 G (f j)) _inst_4) (CategoryTheory.Limits.PreservesCoproduct.iso.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 G J f _inst_3 _inst_4 _inst_5)) (CategoryTheory.Limits.sigmaComparison.{u1, u2, u3, u4, u5} J C _inst_1 D _inst_2 G f _inst_3 _inst_4)
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (G : CategoryTheory.Functor.{u2, u3, u4, u5} C _inst_1 D _inst_2) {J : Type.{u1}} (f : J -> C) [_inst_3 : CategoryTheory.Limits.HasCoproduct.{u1, u2, u4} J C _inst_1 f] [_inst_4 : CategoryTheory.Limits.HasCoproduct.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j))] [_inst_5 : CategoryTheory.Limits.PreservesColimit.{u1, u1, u2, u3, u4, u5} C _inst_1 D _inst_2 (CategoryTheory.Discrete.{u1} J) (CategoryTheory.discreteCategory.{u1} J) (CategoryTheory.Discrete.functor.{u2, u1, u4} C _inst_1 J f) G], Eq.{succ u3} (Quiver.Hom.{succ u3, u5} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Limits.sigmaObj.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j)) _inst_4) (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.sigmaObj.{u1, u2, u4} J C _inst_1 f _inst_3))) (CategoryTheory.Iso.inv.{u3, u5} D _inst_2 (Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.sigmaObj.{u1, u2, u4} J C _inst_1 f _inst_3)) (CategoryTheory.Limits.sigmaObj.{u1, u3, u5} J D _inst_2 (fun (j : J) => Prefunctor.obj.{succ u2, succ u3, u4, u5} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u4, u5} C _inst_1 D _inst_2 G) (f j)) _inst_4) (CategoryTheory.Limits.PreservesCoproduct.iso.{u1, u2, u3, u4, u5} C _inst_1 D _inst_2 G J f _inst_3 _inst_4 _inst_5)) (CategoryTheory.Limits.sigmaComparison.{u1, u2, u3, u4, u5} J C _inst_1 D _inst_2 G f _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.preserves_coproduct.inv_hom CategoryTheory.Limits.PreservesCoproduct.inv_homₓ'. -/
@[simp]
theorem PreservesCoproduct.inv_hom : (PreservesCoproduct.iso G f).inv = sigmaComparison G f :=
  rfl
#align category_theory.limits.preserves_coproduct.inv_hom CategoryTheory.Limits.PreservesCoproduct.inv_hom

instance : IsIso (sigmaComparison G f) :=
  by
  rw [← preserves_coproduct.inv_hom]
  infer_instance

end

end CategoryTheory.Limits

