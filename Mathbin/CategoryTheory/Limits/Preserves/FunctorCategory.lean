/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta

! This file was ported from Lean 3 source module category_theory.limits.preserves.functor_category
! leanprover-community/mathlib commit 39478763114722f0ec7613cb2f3f7701f9b86c8d
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Limits.FunctorCategory
import Mathbin.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts
import Mathbin.CategoryTheory.Limits.Yoneda
import Mathbin.CategoryTheory.Limits.Presheaf

/-!
# Preservation of (co)limits in the functor category

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

* Show that if `X ⨯ -` preserves colimits in `D` for any `X : D`, then the product functor `F ⨯ -`
for `F : C ⥤ D` preserves colimits.

The idea of the proof is simply that products and colimits in the functor category are computed
pointwise, so pointwise preservation implies general preservation.

* Show that `F ⋙ -` preserves limits if the target category has limits.
* Show that `F : C ⥤ D` preserves limits of a certain shape
  if `Lan F.op : Cᵒᵖ ⥤ Type*` preserves such limits.

# References

https://ncatlab.org/nlab/show/commutativity+of+limits+and+colimits#preservation_by_functor_categories_and_localizations

-/


universe v₁ v₂ u u₂

noncomputable section

namespace CategoryTheory

open Category Limits

variable {C : Type u} [Category.{v₁} C]

variable {D : Type u₂} [Category.{u} D]

variable {E : Type u} [Category.{v₂} E]

/- warning: category_theory.functor_category.prod_preserves_colimits -> CategoryTheory.FunctorCategory.prodPreservesColimits is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u2, u3} D] [_inst_4 : CategoryTheory.Limits.HasBinaryProducts.{u2, u3} D _inst_2] [_inst_5 : CategoryTheory.Limits.HasColimits.{u2, u3} D _inst_2] [_inst_6 : forall (X : D), CategoryTheory.Limits.PreservesColimits.{u2, u2, u3, u3} D _inst_2 D _inst_2 (CategoryTheory.Functor.obj.{u2, max u3 u2, u3, max u2 u3} D _inst_2 (CategoryTheory.Functor.{u2, u2, u3, u3} D _inst_2 D _inst_2) (CategoryTheory.Functor.category.{u2, u2, u3, u3} D _inst_2 D _inst_2) (CategoryTheory.Limits.prod.functor.{u2, u3} D _inst_2 _inst_4) X)] (F : CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2), CategoryTheory.Limits.PreservesColimits.{u2, u2, max u1 u2 u3, max u1 u2 u3} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.obj.{u2, max (max u1 u2 u3) u2, max u1 u2 u3, max u2 u1 u2 u3} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u2, u2, max u1 u2 u3, max u1 u2 u3} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2)) (CategoryTheory.Functor.category.{u2, u2, max u1 u2 u3, max u1 u2 u3} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2)) (CategoryTheory.Limits.prod.functor.{u2, max u1 u2 u3} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.FunctorCategory.prodPreservesColimits._proof_1.{u2, u3, u1} C _inst_1 D _inst_2 _inst_4)) F)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u2, u3} D] [_inst_4 : CategoryTheory.Limits.HasBinaryProducts.{u2, u3} D _inst_2] [_inst_5 : CategoryTheory.Limits.HasColimits.{u2, u3} D _inst_2] [_inst_6 : forall (X : D), CategoryTheory.Limits.PreservesColimits.{u2, u2, u3, u3} D _inst_2 D _inst_2 (Prefunctor.obj.{succ u2, max (succ u2) (succ u3), u3, max u2 u3} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} D (CategoryTheory.Category.toCategoryStruct.{u2, u3} D _inst_2)) (CategoryTheory.Functor.{u2, u2, u3, u3} D _inst_2 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Functor.{u2, u2, u3, u3} D _inst_2 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Functor.{u2, u2, u3, u3} D _inst_2 D _inst_2) (CategoryTheory.Functor.category.{u2, u2, u3, u3} D _inst_2 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, max u3 u2} D _inst_2 (CategoryTheory.Functor.{u2, u2, u3, u3} D _inst_2 D _inst_2) (CategoryTheory.Functor.category.{u2, u2, u3, u3} D _inst_2 D _inst_2) (CategoryTheory.Limits.prod.functor.{u2, u3} D _inst_2 _inst_4)) X)] (F : CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2), CategoryTheory.Limits.PreservesColimits.{u2, u2, max (max u2 u3) u1, max (max u2 u3) u1} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2) (Prefunctor.obj.{succ u2, max (succ u2) (succ (max (max u2 u3) u1)), max (max u2 u3) u1, max u2 (max u2 u3) u1} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u2, max (max u2 u3) u1} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, max (max u2 u3) u1} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{u2, u2, max (max u2 u3) u1, max (max u2 u3) u1} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2)) (CategoryTheory.CategoryStruct.toQuiver.{max (max (max u2 u3) u1) u2, max (max (max u2 u3) u1) u2} (CategoryTheory.Functor.{u2, u2, max (max u2 u3) u1, max (max u2 u3) u1} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2)) (CategoryTheory.Category.toCategoryStruct.{max (max (max u2 u3) u1) u2, max (max (max u2 u3) u1) u2} (CategoryTheory.Functor.{u2, u2, max (max u2 u3) u1, max (max u2 u3) u1} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2)) (CategoryTheory.Functor.category.{u2, u2, max (max u2 u3) u1, max (max u2 u3) u1} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2)))) (CategoryTheory.Functor.toPrefunctor.{u2, max (max (max u2 u3) u1) u2, max (max u2 u3) u1, max (max (max u2 u3) u1) u2} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u2, u2, max (max u2 u3) u1, max (max u2 u3) u1} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2)) (CategoryTheory.Functor.category.{u2, u2, max (max u2 u3) u1, max (max u2 u3) u1} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2)) (CategoryTheory.Limits.prod.functor.{u2, max (max u2 u3) u1} (CategoryTheory.Functor.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u2, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{0, u1, 0, u2, u2, u3} D _inst_2 (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) C _inst_1 _inst_4))) F)
Case conversion may be inaccurate. Consider using '#align category_theory.functor_category.prod_preserves_colimits CategoryTheory.FunctorCategory.prodPreservesColimitsₓ'. -/
/-- If `X × -` preserves colimits in `D` for any `X : D`, then the product functor `F ⨯ -` for
`F : C ⥤ D` also preserves colimits.

Note this is (mathematically) a special case of the statement that
"if limits commute with colimits in `D`, then they do as well in `C ⥤ D`"
but the story in Lean is a bit more complex, and this statement isn't directly a special case.
That is, even with a formalised proof of the general statement, there would still need to be some
work to convert to this version: namely, the natural isomorphism
`(evaluation C D).obj k ⋙ prod.functor.obj (F.obj k) ≅ prod.functor.obj F ⋙ (evaluation C D).obj k`
-/
def FunctorCategory.prodPreservesColimits [HasBinaryProducts D] [HasColimits D]
    [∀ X : D, PreservesColimits (prod.functor.obj X)] (F : C ⥤ D) :
    PreservesColimits (prod.functor.obj F)
    where PreservesColimitsOfShape J 𝒥 :=
    {
      PreservesColimit := fun K =>
        {
          preserves := fun c t =>
            by
            apply evaluation_jointly_reflects_colimits _ fun k => _
            change is_colimit ((prod.functor.obj F ⋙ (evaluation _ _).obj k).mapCocone c)
            let this :=
              is_colimit_of_preserves ((evaluation C D).obj k ⋙ prod.functor.obj (F.obj k)) t
            apply is_colimit.map_cocone_equiv _ this
            apply (nat_iso.of_components _ _).symm
            · intro G
              apply as_iso (prod_comparison ((evaluation C D).obj k) F G)
            · intro G G'
              apply prod_comparison_natural ((evaluation C D).obj k) (𝟙 F) } }
#align category_theory.functor_category.prod_preserves_colimits CategoryTheory.FunctorCategory.prodPreservesColimits

/- warning: category_theory.whiskering_left_preserves_limits -> CategoryTheory.whiskeringLeftPreservesLimits is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} D] {E : Type.{u3}} [_inst_3 : CategoryTheory.Category.{u2, u3} E] [_inst_4 : CategoryTheory.Limits.HasLimits.{u3, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u3} C _inst_1 E _inst_3), CategoryTheory.Limits.PreservesLimits.{u3, u3, max u2 u3 u4, max u1 u3 u4} (CategoryTheory.Functor.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.{u1, u3, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u3, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.obj.{max u3 u2, max (max u2 u3 u4) u3, max u1 u2 u3, max u3 (max u2 u3 u4) u1 u3 u4} (CategoryTheory.Functor.{u1, u2, u3, u3} C _inst_1 E _inst_3) (CategoryTheory.Functor.category.{u1, u2, u3, u3} C _inst_1 E _inst_3) (CategoryTheory.Functor.{u3, u3, max u2 u3 u4, max u1 u3 u4} (CategoryTheory.Functor.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.{u1, u3, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u3, u3, u4} C _inst_1 D _inst_2)) (CategoryTheory.Functor.category.{u3, u3, max u2 u3 u4, max u1 u3 u4} (CategoryTheory.Functor.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.{u1, u3, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u3, u3, u4} C _inst_1 D _inst_2)) (CategoryTheory.whiskeringLeft.{u3, u1, u3, u2, u4, u3} C _inst_1 E _inst_3 D _inst_2) F)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} D] {E : Type.{u3}} [_inst_3 : CategoryTheory.Category.{u2, u3} E] [_inst_4 : CategoryTheory.Limits.HasLimits.{u3, u4} D _inst_2] (F : CategoryTheory.Functor.{u1, u2, u3, u3} C _inst_1 E _inst_3), CategoryTheory.Limits.PreservesLimits.{u3, u3, max (max u3 u4) u2, max (max u3 u4) u1} (CategoryTheory.Functor.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.{u1, u3, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u3, u3, u4} C _inst_1 D _inst_2) (Prefunctor.obj.{max (succ u3) (succ u2), max (max (succ u3) (succ u4)) (succ u2), max (max u3 u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u3} C _inst_1 E _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u3} C _inst_1 E _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u3} C _inst_1 E _inst_3) (CategoryTheory.Functor.category.{u1, u2, u3, u3} C _inst_1 E _inst_3))) (CategoryTheory.Functor.{u3, u3, max (max u4 u3) u2, max (max u4 u3) u1} (CategoryTheory.Functor.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.{u1, u3, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u3, u3, u4} C _inst_1 D _inst_2)) (CategoryTheory.CategoryStruct.toQuiver.{max (max u3 u4) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u3, u3, max (max u4 u3) u2, max (max u4 u3) u1} (CategoryTheory.Functor.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.{u1, u3, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u3, u3, u4} C _inst_1 D _inst_2)) (CategoryTheory.Category.toCategoryStruct.{max (max u3 u4) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u3, u3, max (max u4 u3) u2, max (max u4 u3) u1} (CategoryTheory.Functor.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.{u1, u3, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u3, u3, u4} C _inst_1 D _inst_2)) (CategoryTheory.Functor.category.{u3, u3, max (max (max u3 u4) u2) u3, max (max (max u3 u4) u1) u3} (CategoryTheory.Functor.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.{u1, u3, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u3, u3, u4} C _inst_1 D _inst_2)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max (max u3 u4) u2, max (max u3 u1) u2, max (max (max u3 u4) u1) u2} (CategoryTheory.Functor.{u1, u2, u3, u3} C _inst_1 E _inst_3) (CategoryTheory.Functor.category.{u1, u2, u3, u3} C _inst_1 E _inst_3) (CategoryTheory.Functor.{u3, u3, max (max u4 u3) u2, max (max u4 u3) u1} (CategoryTheory.Functor.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.{u1, u3, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u3, u3, u4} C _inst_1 D _inst_2)) (CategoryTheory.Functor.category.{u3, u3, max (max (max u3 u4) u2) u3, max (max (max u3 u4) u1) u3} (CategoryTheory.Functor.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u2, u3, u3, u4} E _inst_3 D _inst_2) (CategoryTheory.Functor.{u1, u3, u3, u4} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u3, u3, u4} C _inst_1 D _inst_2)) (CategoryTheory.whiskeringLeft.{u3, u1, u3, u2, u4, u3} C _inst_1 E _inst_3 D _inst_2)) F)
Case conversion may be inaccurate. Consider using '#align category_theory.whiskering_left_preserves_limits CategoryTheory.whiskeringLeftPreservesLimitsₓ'. -/
instance whiskeringLeftPreservesLimits [HasLimits D] (F : C ⥤ E) :
    PreservesLimits ((whiskeringLeft C E D).obj F) :=
  ⟨fun J hJ =>
    ⟨fun K =>
      ⟨fun c hc => by
        apply evaluation_jointly_reflects_limits
        intro Y
        change is_limit (((evaluation E D).obj (F.obj Y)).mapCone c)
        exact preserves_limit.preserves hc⟩⟩⟩
#align category_theory.whiskering_left_preserves_limits CategoryTheory.whiskeringLeftPreservesLimits

/- warning: category_theory.whiskering_right_preserves_limits_of_shape -> CategoryTheory.whiskeringRightPreservesLimitsOfShape is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_4 : CategoryTheory.Category.{u2, u1} C] {D : Type.{u3}} [_inst_5 : CategoryTheory.Category.{u1, u3} D] {E : Type.{u4}} [_inst_6 : CategoryTheory.Category.{u1, u4} E] {J : Type.{u1}} [_inst_7 : CategoryTheory.SmallCategory.{u1} J] [_inst_8 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u1, u1, u3} J _inst_7 D _inst_5] (F : CategoryTheory.Functor.{u1, u1, u3, u4} D _inst_5 E _inst_6) [_inst_9 : CategoryTheory.Limits.PreservesLimitsOfShape.{u1, u1, u1, u1, u3, u4} D _inst_5 E _inst_6 J _inst_7 F], CategoryTheory.Limits.PreservesLimitsOfShape.{u1, u1, u1, u1, max u2 u1 u3, max u2 u1 u4} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6) J _inst_7 (CategoryTheory.Functor.obj.{max u3 u1, max (max u2 u1 u3) u1, max u1 u3 u4, max u1 (max u2 u1 u3) u2 u1 u4} (CategoryTheory.Functor.{u1, u1, u3, u4} D _inst_5 E _inst_6) (CategoryTheory.Functor.category.{u1, u1, u3, u4} D _inst_5 E _inst_6) (CategoryTheory.Functor.{u1, u1, max u2 u1 u3, max u2 u1 u4} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1 u3, max u2 u1 u4} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6)) (CategoryTheory.whiskeringRight.{u1, u2, u3, u1, u4, u1} C _inst_4 D _inst_5 E _inst_6) F)
but is expected to have type
  forall {C : Type.{u1}} [_inst_4 : CategoryTheory.Category.{u2, u1} C] {D : Type.{u3}} [_inst_5 : CategoryTheory.Category.{u1, u3} D] {E : Type.{u4}} [_inst_6 : CategoryTheory.Category.{u1, u4} E] {J : Type.{u1}} [_inst_7 : CategoryTheory.SmallCategory.{u1} J] [_inst_8 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u1, u1, u3} J _inst_7 D _inst_5] (F : CategoryTheory.Functor.{u1, u1, u3, u4} D _inst_5 E _inst_6) [_inst_9 : CategoryTheory.Limits.PreservesLimitsOfShape.{u1, u1, u1, u1, u3, u4} D _inst_5 E _inst_6 J _inst_7 F], CategoryTheory.Limits.PreservesLimitsOfShape.{u1, u1, u1, u1, max (max u1 u2) u3, max (max u1 u2) u4} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6) J _inst_7 (Prefunctor.obj.{max (succ u1) (succ u3), max (max (succ u1) (succ u2)) (succ u3), max (max u1 u3) u4, max (max (max u1 u2) u3) u4} (CategoryTheory.Functor.{u1, u1, u3, u4} D _inst_5 E _inst_6) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u3, max (max u1 u3) u4} (CategoryTheory.Functor.{u1, u1, u3, u4} D _inst_5 E _inst_6) (CategoryTheory.Category.toCategoryStruct.{max u1 u3, max (max u1 u3) u4} (CategoryTheory.Functor.{u1, u1, u3, u4} D _inst_5 E _inst_6) (CategoryTheory.Functor.category.{u1, u1, u3, u4} D _inst_5 E _inst_6))) (CategoryTheory.Functor.{u1, u1, max (max u3 u1) u2, max (max u4 u1) u2} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6)) (CategoryTheory.CategoryStruct.toQuiver.{max (max u1 u2) u3, max (max (max u1 u2) u3) u4} (CategoryTheory.Functor.{u1, u1, max (max u3 u1) u2, max (max u4 u1) u2} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6)) (CategoryTheory.Category.toCategoryStruct.{max (max u1 u2) u3, max (max (max u1 u2) u3) u4} (CategoryTheory.Functor.{u1, u1, max (max u3 u1) u2, max (max u4 u1) u2} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6)) (CategoryTheory.Functor.category.{u1, u1, max (max (max u1 u3) u2) u1, max (max (max u1 u4) u2) u1} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6)))) (CategoryTheory.Functor.toPrefunctor.{max u1 u3, max (max u1 u2) u3, max (max u1 u3) u4, max (max (max u1 u2) u3) u4} (CategoryTheory.Functor.{u1, u1, u3, u4} D _inst_5 E _inst_6) (CategoryTheory.Functor.category.{u1, u1, u3, u4} D _inst_5 E _inst_6) (CategoryTheory.Functor.{u1, u1, max (max u3 u1) u2, max (max u4 u1) u2} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6)) (CategoryTheory.Functor.category.{u1, u1, max (max (max u1 u3) u2) u1, max (max (max u1 u4) u2) u1} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6)) (CategoryTheory.whiskeringRight.{u1, u2, u3, u1, u4, u1} C _inst_4 D _inst_5 E _inst_6)) F)
Case conversion may be inaccurate. Consider using '#align category_theory.whiskering_right_preserves_limits_of_shape CategoryTheory.whiskeringRightPreservesLimitsOfShapeₓ'. -/
instance whiskeringRightPreservesLimitsOfShape {C : Type u} [Category C] {D : Type _}
    [Category.{u} D] {E : Type _} [Category.{u} E] {J : Type u} [SmallCategory J]
    [HasLimitsOfShape J D] (F : D ⥤ E) [PreservesLimitsOfShape J F] :
    PreservesLimitsOfShape J ((whiskeringRight C D E).obj F) :=
  ⟨fun K =>
    ⟨fun c hc => by
      apply evaluation_jointly_reflects_limits
      intro k
      change is_limit (((evaluation _ _).obj k ⋙ F).mapCone c)
      exact preserves_limit.preserves hc⟩⟩
#align category_theory.whiskering_right_preserves_limits_of_shape CategoryTheory.whiskeringRightPreservesLimitsOfShape

/- warning: category_theory.whiskering_right_preserves_limits -> CategoryTheory.whiskeringRightPreservesLimits is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_4 : CategoryTheory.Category.{u2, u1} C] {D : Type.{u3}} [_inst_5 : CategoryTheory.Category.{u1, u3} D] {E : Type.{u4}} [_inst_6 : CategoryTheory.Category.{u1, u4} E] (F : CategoryTheory.Functor.{u1, u1, u3, u4} D _inst_5 E _inst_6) [_inst_7 : CategoryTheory.Limits.HasLimits.{u1, u3} D _inst_5] [_inst_8 : CategoryTheory.Limits.PreservesLimits.{u1, u1, u3, u4} D _inst_5 E _inst_6 F], CategoryTheory.Limits.PreservesLimits.{u1, u1, max u2 u1 u3, max u2 u1 u4} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.obj.{max u3 u1, max (max u2 u1 u3) u1, max u1 u3 u4, max u1 (max u2 u1 u3) u2 u1 u4} (CategoryTheory.Functor.{u1, u1, u3, u4} D _inst_5 E _inst_6) (CategoryTheory.Functor.category.{u1, u1, u3, u4} D _inst_5 E _inst_6) (CategoryTheory.Functor.{u1, u1, max u2 u1 u3, max u2 u1 u4} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1 u3, max u2 u1 u4} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6)) (CategoryTheory.whiskeringRight.{u1, u2, u3, u1, u4, u1} C _inst_4 D _inst_5 E _inst_6) F)
but is expected to have type
  forall {C : Type.{u1}} [_inst_4 : CategoryTheory.Category.{u2, u1} C] {D : Type.{u3}} [_inst_5 : CategoryTheory.Category.{u1, u3} D] {E : Type.{u4}} [_inst_6 : CategoryTheory.Category.{u1, u4} E] (F : CategoryTheory.Functor.{u1, u1, u3, u4} D _inst_5 E _inst_6) [_inst_7 : CategoryTheory.Limits.HasLimits.{u1, u3} D _inst_5] [_inst_8 : CategoryTheory.Limits.PreservesLimits.{u1, u1, u3, u4} D _inst_5 E _inst_6 F], CategoryTheory.Limits.PreservesLimits.{u1, u1, max (max u1 u2) u3, max (max u1 u2) u4} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6) (Prefunctor.obj.{max (succ u1) (succ u3), max (max (succ u1) (succ u2)) (succ u3), max (max u1 u3) u4, max (max (max u1 u2) u3) u4} (CategoryTheory.Functor.{u1, u1, u3, u4} D _inst_5 E _inst_6) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u3, max (max u1 u3) u4} (CategoryTheory.Functor.{u1, u1, u3, u4} D _inst_5 E _inst_6) (CategoryTheory.Category.toCategoryStruct.{max u1 u3, max (max u1 u3) u4} (CategoryTheory.Functor.{u1, u1, u3, u4} D _inst_5 E _inst_6) (CategoryTheory.Functor.category.{u1, u1, u3, u4} D _inst_5 E _inst_6))) (CategoryTheory.Functor.{u1, u1, max (max u3 u1) u2, max (max u4 u1) u2} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6)) (CategoryTheory.CategoryStruct.toQuiver.{max (max u1 u2) u3, max (max (max u1 u2) u3) u4} (CategoryTheory.Functor.{u1, u1, max (max u3 u1) u2, max (max u4 u1) u2} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6)) (CategoryTheory.Category.toCategoryStruct.{max (max u1 u2) u3, max (max (max u1 u2) u3) u4} (CategoryTheory.Functor.{u1, u1, max (max u3 u1) u2, max (max u4 u1) u2} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6)) (CategoryTheory.Functor.category.{u1, u1, max (max (max u1 u3) u2) u1, max (max (max u1 u4) u2) u1} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6)))) (CategoryTheory.Functor.toPrefunctor.{max u1 u3, max (max u1 u2) u3, max (max u1 u3) u4, max (max (max u1 u2) u3) u4} (CategoryTheory.Functor.{u1, u1, u3, u4} D _inst_5 E _inst_6) (CategoryTheory.Functor.category.{u1, u1, u3, u4} D _inst_5 E _inst_6) (CategoryTheory.Functor.{u1, u1, max (max u3 u1) u2, max (max u4 u1) u2} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6)) (CategoryTheory.Functor.category.{u1, u1, max (max (max u1 u3) u2) u1, max (max (max u1 u4) u2) u1} (CategoryTheory.Functor.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.category.{u2, u1, u1, u3} C _inst_4 D _inst_5) (CategoryTheory.Functor.{u2, u1, u1, u4} C _inst_4 E _inst_6) (CategoryTheory.Functor.category.{u2, u1, u1, u4} C _inst_4 E _inst_6)) (CategoryTheory.whiskeringRight.{u1, u2, u3, u1, u4, u1} C _inst_4 D _inst_5 E _inst_6)) F)
Case conversion may be inaccurate. Consider using '#align category_theory.whiskering_right_preserves_limits CategoryTheory.whiskeringRightPreservesLimitsₓ'. -/
instance whiskeringRightPreservesLimits {C : Type u} [Category C] {D : Type _} [Category.{u} D]
    {E : Type _} [Category.{u} E] (F : D ⥤ E) [HasLimits D] [PreservesLimits F] :
    PreservesLimits ((whiskeringRight C D E).obj F) :=
  ⟨⟩
#align category_theory.whiskering_right_preserves_limits CategoryTheory.whiskeringRightPreservesLimits

/- warning: category_theory.preserves_limit_of_Lan_preserves_limit clashes with category_theory.preserves_limit_of_Lan_presesrves_limit -> CategoryTheory.preservesLimitOfLanPreservesLimit
Case conversion may be inaccurate. Consider using '#align category_theory.preserves_limit_of_Lan_preserves_limit CategoryTheory.preservesLimitOfLanPreservesLimitₓ'. -/
#print CategoryTheory.preservesLimitOfLanPreservesLimit /-
/-- If `Lan F.op : (Cᵒᵖ ⥤ Type*) ⥤ (Dᵒᵖ ⥤ Type*)` preserves limits of shape `J`, so will `F`. -/
noncomputable def preservesLimitOfLanPreservesLimit {C D : Type u} [SmallCategory C]
    [SmallCategory D] (F : C ⥤ D) (J : Type u) [SmallCategory J]
    [PreservesLimitsOfShape J (lan F.op : _ ⥤ Dᵒᵖ ⥤ Type u)] : PreservesLimitsOfShape J F :=
  by
  apply preserves_limits_of_shape_of_reflects_of_preserves F yoneda
  exact preserves_limits_of_shape_of_nat_iso (comp_yoneda_iso_yoneda_comp_Lan F).symm
  infer_instance
#align category_theory.preserves_limit_of_Lan_preserves_limit CategoryTheory.preservesLimitOfLanPreservesLimit
-/

end CategoryTheory

