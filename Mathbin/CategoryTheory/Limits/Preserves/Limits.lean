/-
Copyright (c) 2020 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison, Bhavik Mehta

! This file was ported from Lean 3 source module category_theory.limits.preserves.limits
! leanprover-community/mathlib commit 9a8e9fa5b9303f03015eff7646b1a9f66f403033
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Limits.Preserves.Basic

/-!
# Isomorphisms about functors which preserve (co)limits

If `G` preserves limits, and `C` and `D` have limits, then for any diagram `F : J ⥤ C` we have a
canonical isomorphism `preserves_limit_iso : G.obj (limit F) ≅ limit (F ⋙ G)`.
We also show that we can commute `is_limit.lift` of a preserved limit with `functor.map_cone`:
`(preserves_limit.preserves t).lift (G.map_cone c₂) = G.map (t.lift c₂)`.

The duals of these are also given. For functors which preserve (co)limits of specific shapes, see
`preserves/shapes.lean`.
-/


universe w' w v₁ v₂ u₁ u₂

noncomputable section

namespace CategoryTheory

open Category Limits

variable {C : Type u₁} [Category.{v₁} C]

variable {D : Type u₂} [Category.{v₂} D]

variable (G : C ⥤ D)

variable {J : Type w} [Category.{w'} J]

variable (F : J ⥤ C)

section

variable [PreservesLimit F G]

/- warning: category_theory.preserves_lift_map_cone -> CategoryTheory.preserves_lift_mapCone is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] (c₁ : CategoryTheory.Limits.Cone.{u1, u3, u2, u5} J _inst_3 C _inst_1 F) (c₂ : CategoryTheory.Limits.Cone.{u1, u3, u2, u5} J _inst_3 C _inst_1 F) (t : CategoryTheory.Limits.IsLimit.{u1, u3, u2, u5} J _inst_3 C _inst_1 F c₁), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Limits.Cone.pt.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) (CategoryTheory.Functor.mapCone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G c₂)) (CategoryTheory.Limits.Cone.pt.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) (CategoryTheory.Functor.mapCone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G c₁))) (CategoryTheory.Limits.IsLimit.lift.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) (CategoryTheory.Functor.mapCone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G c₁) (CategoryTheory.Limits.PreservesLimit.preserves.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G _inst_4 c₁ t) (CategoryTheory.Functor.mapCone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G c₂)) (CategoryTheory.Functor.map.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F c₂) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F c₁) (CategoryTheory.Limits.IsLimit.lift.{u1, u3, u2, u5} J _inst_3 C _inst_1 F c₁ t c₂))
but is expected to have type
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] (c₁ : CategoryTheory.Limits.Cone.{u1, u3, u2, u5} J _inst_3 C _inst_1 F) (c₂ : CategoryTheory.Limits.Cone.{u1, u3, u2, u5} J _inst_3 C _inst_1 F) (t : CategoryTheory.Limits.IsLimit.{u1, u3, u2, u5} J _inst_3 C _inst_1 F c₁), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Limits.Cone.pt.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) (CategoryTheory.Functor.mapCone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G c₂)) (CategoryTheory.Limits.Cone.pt.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) (CategoryTheory.Functor.mapCone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G c₁))) (CategoryTheory.Limits.IsLimit.lift.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) (CategoryTheory.Functor.mapCone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G c₁) (CategoryTheory.Limits.PreservesLimit.preserves.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G _inst_4 c₁ t) (CategoryTheory.Functor.mapCone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G c₂)) (Prefunctor.map.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F c₂) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F c₁) (CategoryTheory.Limits.IsLimit.lift.{u1, u3, u2, u5} J _inst_3 C _inst_1 F c₁ t c₂))
Case conversion may be inaccurate. Consider using '#align category_theory.preserves_lift_map_cone CategoryTheory.preserves_lift_mapConeₓ'. -/
@[simp]
theorem preserves_lift_mapCone (c₁ c₂ : Cone F) (t : IsLimit c₁) :
    (PreservesLimit.preserves t).lift (G.mapCone c₂) = G.map (t.lift c₂) :=
  ((PreservesLimit.preserves t).uniq (G.mapCone c₂) _ (by simp [← G.map_comp])).symm
#align category_theory.preserves_lift_map_cone CategoryTheory.preserves_lift_mapCone

variable [HasLimit F] [HasLimit (F ⋙ G)]

/- warning: category_theory.preserves_limit_iso -> CategoryTheory.preservesLimitIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F] [_inst_6 : CategoryTheory.Limits.HasLimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)], CategoryTheory.Iso.{u4, u6} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6)
but is expected to have type
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F] [_inst_6 : CategoryTheory.Limits.HasLimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)], CategoryTheory.Iso.{u4, u6} D _inst_2 (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6)
Case conversion may be inaccurate. Consider using '#align category_theory.preserves_limit_iso CategoryTheory.preservesLimitIsoₓ'. -/
/-- If `G` preserves limits, we have an isomorphism from the image of the limit of a functor `F`
to the limit of the functor `F ⋙ G`.
-/
def preservesLimitIso : G.obj (limit F) ≅ limit (F ⋙ G) :=
  (PreservesLimit.preserves (limit.isLimit _)).conePointUniqueUpToIso (limit.isLimit _)
#align category_theory.preserves_limit_iso CategoryTheory.preservesLimitIso

/- warning: category_theory.preserves_limits_iso_hom_π -> CategoryTheory.preservesLimitsIso_hom_π is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F] [_inst_6 : CategoryTheory.Limits.HasLimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)] (j : J), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Functor.obj.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) j)) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.Functor.obj.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) j) (CategoryTheory.Iso.hom.{u4, u6} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.preservesLimitIso.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 G J _inst_3 F _inst_4 _inst_5 _inst_6)) (CategoryTheory.Limits.limit.π.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6 j)) (CategoryTheory.Functor.map.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Functor.obj.{u1, u3, u2, u5} J _inst_3 C _inst_1 F j) (CategoryTheory.Limits.limit.π.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5 j))
but is expected to have type
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F] [_inst_6 : CategoryTheory.Limits.HasLimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)] (j : J), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (Prefunctor.obj.{succ u1, succ u4, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)) j)) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (Prefunctor.obj.{succ u1, succ u4, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)) j) (CategoryTheory.Iso.hom.{u4, u6} D _inst_2 (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.preservesLimitIso.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 G J _inst_3 F _inst_4 _inst_5 _inst_6)) (CategoryTheory.Limits.limit.π.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6 j)) (Prefunctor.map.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5) (Prefunctor.obj.{succ u1, succ u3, u2, u5} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u5} J _inst_3 C _inst_1 F) j) (CategoryTheory.Limits.limit.π.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5 j))
Case conversion may be inaccurate. Consider using '#align category_theory.preserves_limits_iso_hom_π CategoryTheory.preservesLimitsIso_hom_πₓ'. -/
@[simp, reassoc.1]
theorem preservesLimitsIso_hom_π (j) :
    (preservesLimitIso G F).Hom ≫ limit.π _ j = G.map (limit.π F j) :=
  IsLimit.conePointUniqueUpToIso_hom_comp _ _ j
#align category_theory.preserves_limits_iso_hom_π CategoryTheory.preservesLimitsIso_hom_π

/- warning: category_theory.preserves_limits_iso_inv_π -> CategoryTheory.preservesLimitsIso_inv_π is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F] [_inst_6 : CategoryTheory.Limits.HasLimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)] (j : J), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Functor.obj.{u1, u3, u2, u5} J _inst_3 C _inst_1 F j))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Functor.obj.{u1, u3, u2, u5} J _inst_3 C _inst_1 F j)) (CategoryTheory.Iso.inv.{u4, u6} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.preservesLimitIso.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 G J _inst_3 F _inst_4 _inst_5 _inst_6)) (CategoryTheory.Functor.map.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Functor.obj.{u1, u3, u2, u5} J _inst_3 C _inst_1 F j) (CategoryTheory.Limits.limit.π.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5 j))) (CategoryTheory.Limits.limit.π.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6 j)
but is expected to have type
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F] [_inst_6 : CategoryTheory.Limits.HasLimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)] (j : J), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (Prefunctor.obj.{succ u1, succ u3, u2, u5} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u5} J _inst_3 C _inst_1 F) j))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (Prefunctor.obj.{succ u1, succ u3, u2, u5} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u5} J _inst_3 C _inst_1 F) j)) (CategoryTheory.Iso.inv.{u4, u6} D _inst_2 (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.preservesLimitIso.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 G J _inst_3 F _inst_4 _inst_5 _inst_6)) (Prefunctor.map.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5) (Prefunctor.obj.{succ u1, succ u3, u2, u5} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u5} J _inst_3 C _inst_1 F) j) (CategoryTheory.Limits.limit.π.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5 j))) (CategoryTheory.Limits.limit.π.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6 j)
Case conversion may be inaccurate. Consider using '#align category_theory.preserves_limits_iso_inv_π CategoryTheory.preservesLimitsIso_inv_πₓ'. -/
@[simp, reassoc.1]
theorem preservesLimitsIso_inv_π (j) :
    (preservesLimitIso G F).inv ≫ G.map (limit.π F j) = limit.π _ j :=
  IsLimit.conePointUniqueUpToIso_inv_comp _ _ j
#align category_theory.preserves_limits_iso_inv_π CategoryTheory.preservesLimitsIso_inv_π

/- warning: category_theory.lift_comp_preserves_limits_iso_hom -> CategoryTheory.lift_comp_preservesLimitsIso_hom is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F] [_inst_6 : CategoryTheory.Limits.HasLimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)] (t : CategoryTheory.Limits.Cone.{u1, u3, u2, u5} J _inst_3 C _inst_1 F), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F t)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6)) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F t)) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.Functor.map.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F t) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5 t)) (CategoryTheory.Iso.hom.{u4, u6} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.preservesLimitIso.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 G J _inst_3 F _inst_4 _inst_5 _inst_6))) (CategoryTheory.Limits.limit.lift.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6 (CategoryTheory.Functor.mapCone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G t))
but is expected to have type
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesLimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F] [_inst_6 : CategoryTheory.Limits.HasLimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)] (t : CategoryTheory.Limits.Cone.{u1, u3, u2, u5} J _inst_3 C _inst_1 F), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F t)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6)) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F t)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (Prefunctor.map.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F t) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5 t)) (CategoryTheory.Iso.hom.{u4, u6} D _inst_2 (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.preservesLimitIso.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 G J _inst_3 F _inst_4 _inst_5 _inst_6))) (CategoryTheory.Limits.limit.lift.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6 (CategoryTheory.Functor.mapCone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G t))
Case conversion may be inaccurate. Consider using '#align category_theory.lift_comp_preserves_limits_iso_hom CategoryTheory.lift_comp_preservesLimitsIso_homₓ'. -/
@[simp, reassoc.1]
theorem lift_comp_preservesLimitsIso_hom (t : Cone F) :
    G.map (limit.lift _ t) ≫ (preservesLimitIso G F).Hom = limit.lift (F ⋙ G) (G.mapCone _) :=
  by
  ext
  simp [← G.map_comp]
#align category_theory.lift_comp_preserves_limits_iso_hom CategoryTheory.lift_comp_preservesLimitsIso_hom

variable [PreservesLimitsOfShape J G] [HasLimitsOfShape J D] [HasLimitsOfShape J C]

/- warning: category_theory.preserves_limit_nat_iso -> CategoryTheory.preservesLimitNatIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] [_inst_7 : CategoryTheory.Limits.PreservesLimitsOfShape.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 G] [_inst_8 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u4, u6} J _inst_3 D _inst_2] [_inst_9 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u3, u5} J _inst_3 C _inst_1], CategoryTheory.Iso.{max (max u1 u3 u2 u5) u4, max (max u2 u3) u4 (max u1 u3 u2 u5) u6} (CategoryTheory.Functor.{max u2 u3, u4, max u1 u3 u2 u5, u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, u4, max u1 u3 u2 u5, u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) D _inst_2) (CategoryTheory.Functor.comp.{max u2 u3, u3, u4, max u1 u3 u2 u5, u5, u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) C _inst_1 D _inst_2 (CategoryTheory.Limits.lim.{u1, u2, u3, u5} J _inst_3 C _inst_1 _inst_9) G) (CategoryTheory.Functor.comp.{max u2 u3, max u2 u4, u4, max u1 u3 u2 u5, max u1 u4 u2 u6, u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2) D _inst_2 (CategoryTheory.Functor.obj.{max u5 u4, max (max u1 u3 u2 u5) u2 u4, max u3 u4 u5 u6, max (max u2 u3) (max u2 u4) (max u1 u3 u2 u5) u1 u4 u2 u6} (CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u4, u5, u6} C _inst_1 D _inst_2) (CategoryTheory.Functor.{max u2 u3, max u2 u4, max u1 u3 u2 u5, max u1 u4 u2 u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2)) (CategoryTheory.Functor.category.{max u2 u3, max u2 u4, max u1 u3 u2 u5, max u1 u4 u2 u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2)) (CategoryTheory.whiskeringRight.{u2, u1, u5, u3, u6, u4} J _inst_3 C _inst_1 D _inst_2) G) (CategoryTheory.Limits.lim.{u1, u2, u4, u6} J _inst_3 D _inst_2 _inst_8))
but is expected to have type
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] [_inst_7 : CategoryTheory.Limits.PreservesLimitsOfShape.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 G] [_inst_8 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u4, u6} J _inst_3 D _inst_2] [_inst_9 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u3, u5} J _inst_3 C _inst_1], CategoryTheory.Iso.{max (max (max (max u5 u3) u4) u2) u1, max (max (max u6 (max (max u5 u3) u2) u1) u4) u3 u2} (CategoryTheory.Functor.{max u3 u2, u4, max (max (max u5 u3) u2) u1, u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, u4, max (max (max u5 u3) u2) u1, u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) D _inst_2) (CategoryTheory.Functor.comp.{max u3 u2, u3, u4, max (max (max u5 u3) u2) u1, u5, u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) C _inst_1 D _inst_2 (CategoryTheory.Limits.lim.{u1, u2, u3, u5} J _inst_3 C _inst_1 _inst_9) G) (CategoryTheory.Functor.comp.{max u3 u2, max u4 u2, u4, max (max (max u5 u3) u2) u1, max (max (max u6 u4) u2) u1, u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2) D _inst_2 (Prefunctor.obj.{max (succ u5) (succ u4), max (max (max (max (succ u5) (succ u3)) (succ u4)) (succ u2)) (succ u1), max (max (max u5 u6) u3) u4, max (max (max (max (max u5 u6) u3) u4) u2) u1} (CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u4, max (max (max u5 u6) u3) u4} (CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u5 u4, max (max (max u5 u6) u3) u4} (CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u4, u5, u6} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{max u2 u3, max u2 u4, max (max (max u5 u2) u3) u1, max (max (max u6 u2) u4) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2)) (CategoryTheory.CategoryStruct.toQuiver.{max (max (max (max u5 u3) u4) u2) u1, max (max (max (max (max u5 u6) u3) u4) u2) u1} (CategoryTheory.Functor.{max u2 u3, max u2 u4, max (max (max u5 u2) u3) u1, max (max (max u6 u2) u4) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2)) (CategoryTheory.Category.toCategoryStruct.{max (max (max (max u5 u3) u4) u2) u1, max (max (max (max (max u5 u6) u3) u4) u2) u1} (CategoryTheory.Functor.{max u2 u3, max u2 u4, max (max (max u5 u2) u3) u1, max (max (max u6 u2) u4) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2)) (CategoryTheory.Functor.category.{max u2 u3, max u2 u4, max (max (max u2 u5) u1) u3, max (max (max u2 u6) u1) u4} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2)))) (CategoryTheory.Functor.toPrefunctor.{max u5 u4, max (max (max (max u5 u3) u4) u2) u1, max (max (max u5 u6) u3) u4, max (max (max (max (max u5 u6) u3) u4) u2) u1} (CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u4, u5, u6} C _inst_1 D _inst_2) (CategoryTheory.Functor.{max u2 u3, max u2 u4, max (max (max u5 u2) u3) u1, max (max (max u6 u2) u4) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2)) (CategoryTheory.Functor.category.{max u2 u3, max u2 u4, max (max (max u2 u5) u1) u3, max (max (max u2 u6) u1) u4} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2)) (CategoryTheory.whiskeringRight.{u2, u1, u5, u3, u6, u4} J _inst_3 C _inst_1 D _inst_2)) G) (CategoryTheory.Limits.lim.{u1, u2, u4, u6} J _inst_3 D _inst_2 _inst_8))
Case conversion may be inaccurate. Consider using '#align category_theory.preserves_limit_nat_iso CategoryTheory.preservesLimitNatIsoₓ'. -/
/-- If `C, D` has all limits of shape `J`, and `G` preserves them, then `preserves_limit_iso` is
functorial wrt `F`. -/
@[simps]
def preservesLimitNatIso : lim ⋙ G ≅ (whiskeringRight J C D).obj G ⋙ lim :=
  NatIso.ofComponents (fun F => preservesLimitIso G F)
    (by
      intro _ _ f
      ext
      dsimp
      simp only [preserves_limits_iso_hom_π, whisker_right_app, lim_map_π, category.assoc,
        preserves_limits_iso_hom_π_assoc, ← G.map_comp])
#align category_theory.preserves_limit_nat_iso CategoryTheory.preservesLimitNatIso

end

section

variable [PreservesColimit F G]

/- warning: category_theory.preserves_desc_map_cocone -> CategoryTheory.preserves_desc_mapCocone is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] (c₁ : CategoryTheory.Limits.Cocone.{u1, u3, u2, u5} J _inst_3 C _inst_1 F) (c₂ : CategoryTheory.Limits.Cocone.{u1, u3, u2, u5} J _inst_3 C _inst_1 F) (t : CategoryTheory.Limits.IsColimit.{u1, u3, u2, u5} J _inst_3 C _inst_1 F c₁), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Limits.Cocone.pt.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) (CategoryTheory.Functor.mapCocone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G c₁)) (CategoryTheory.Limits.Cocone.pt.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) (CategoryTheory.Functor.mapCocone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G c₂))) (CategoryTheory.Limits.IsColimit.desc.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) (CategoryTheory.Functor.mapCocone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G c₁) (CategoryTheory.Limits.PreservesColimit.preserves.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G _inst_4 c₁ t) (CategoryTheory.Functor.mapCocone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G c₂)) (CategoryTheory.Functor.map.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F c₁) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F c₂) (CategoryTheory.Limits.IsColimit.desc.{u1, u3, u2, u5} J _inst_3 C _inst_1 F c₁ t c₂))
but is expected to have type
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] (c₁ : CategoryTheory.Limits.Cocone.{u1, u3, u2, u5} J _inst_3 C _inst_1 F) (c₂ : CategoryTheory.Limits.Cocone.{u1, u3, u2, u5} J _inst_3 C _inst_1 F) (t : CategoryTheory.Limits.IsColimit.{u1, u3, u2, u5} J _inst_3 C _inst_1 F c₁), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Limits.Cocone.pt.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) (CategoryTheory.Functor.mapCocone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G c₁)) (CategoryTheory.Limits.Cocone.pt.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) (CategoryTheory.Functor.mapCocone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G c₂))) (CategoryTheory.Limits.IsColimit.desc.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) (CategoryTheory.Functor.mapCocone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G c₁) (CategoryTheory.Limits.PreservesColimit.preserves.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G _inst_4 c₁ t) (CategoryTheory.Functor.mapCocone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G c₂)) (Prefunctor.map.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F c₁) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F c₂) (CategoryTheory.Limits.IsColimit.desc.{u1, u3, u2, u5} J _inst_3 C _inst_1 F c₁ t c₂))
Case conversion may be inaccurate. Consider using '#align category_theory.preserves_desc_map_cocone CategoryTheory.preserves_desc_mapCoconeₓ'. -/
@[simp]
theorem preserves_desc_mapCocone (c₁ c₂ : Cocone F) (t : IsColimit c₁) :
    (PreservesColimit.preserves t).desc (G.mapCocone _) = G.map (t.desc c₂) :=
  ((PreservesColimit.preserves t).uniq (G.mapCocone _) _ (by simp [← G.map_comp])).symm
#align category_theory.preserves_desc_map_cocone CategoryTheory.preserves_desc_mapCocone

variable [HasColimit F] [HasColimit (F ⋙ G)]

/- warning: category_theory.preserves_colimit_iso -> CategoryTheory.preservesColimitIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F] [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)], CategoryTheory.Iso.{u4, u6} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6)
but is expected to have type
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F] [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)], CategoryTheory.Iso.{u4, u6} D _inst_2 (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6)
Case conversion may be inaccurate. Consider using '#align category_theory.preserves_colimit_iso CategoryTheory.preservesColimitIsoₓ'. -/
-- TODO: think about swapping the order here
/-- If `G` preserves colimits, we have an isomorphism from the image of the colimit of a functor `F`
to the colimit of the functor `F ⋙ G`.
-/
def preservesColimitIso : G.obj (colimit F) ≅ colimit (F ⋙ G) :=
  (PreservesColimit.preserves (colimit.isColimit _)).coconePointUniqueUpToIso (colimit.isColimit _)
#align category_theory.preserves_colimit_iso CategoryTheory.preservesColimitIso

/- warning: category_theory.ι_preserves_colimits_iso_inv -> CategoryTheory.ι_preservesColimitsIso_inv is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F] [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)] (j : J), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.obj.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) j) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2) (CategoryTheory.Functor.obj.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) j) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.colimit.ι.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6 j) (CategoryTheory.Iso.inv.{u4, u6} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.preservesColimitIso.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 G J _inst_3 F _inst_4 _inst_5 _inst_6))) (CategoryTheory.Functor.map.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Functor.obj.{u1, u3, u2, u5} J _inst_3 C _inst_1 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Limits.colimit.ι.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5 j))
but is expected to have type
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F] [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)] (j : J), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (Prefunctor.obj.{succ u1, succ u4, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)) j) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2) (Prefunctor.obj.{succ u1, succ u4, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u4, u2, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)) j) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.colimit.ι.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6 j) (CategoryTheory.Iso.inv.{u4, u6} D _inst_2 (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.preservesColimitIso.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 G J _inst_3 F _inst_4 _inst_5 _inst_6))) (Prefunctor.map.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (Prefunctor.obj.{succ u1, succ u3, u2, u5} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u5} J _inst_3 C _inst_1 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Limits.colimit.ι.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5 j))
Case conversion may be inaccurate. Consider using '#align category_theory.ι_preserves_colimits_iso_inv CategoryTheory.ι_preservesColimitsIso_invₓ'. -/
@[simp, reassoc.1]
theorem ι_preservesColimitsIso_inv (j : J) :
    colimit.ι _ j ≫ (preservesColimitIso G F).inv = G.map (colimit.ι F j) :=
  IsColimit.comp_coconePointUniqueUpToIso_inv _ (colimit.isColimit (F ⋙ G)) j
#align category_theory.ι_preserves_colimits_iso_inv CategoryTheory.ι_preservesColimitsIso_inv

/- warning: category_theory.ι_preserves_colimits_iso_hom -> CategoryTheory.ι_preservesColimitsIso_hom is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F] [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)] (j : J), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Functor.obj.{u1, u3, u2, u5} J _inst_3 C _inst_1 F j)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6)) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Functor.obj.{u1, u3, u2, u5} J _inst_3 C _inst_1 F j)) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.Functor.map.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Functor.obj.{u1, u3, u2, u5} J _inst_3 C _inst_1 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Limits.colimit.ι.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5 j)) (CategoryTheory.Iso.hom.{u4, u6} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.preservesColimitIso.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 G J _inst_3 F _inst_4 _inst_5 _inst_6))) (CategoryTheory.Limits.colimit.ι.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6 j)
but is expected to have type
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F] [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)] (j : J), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (Prefunctor.obj.{succ u1, succ u3, u2, u5} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u5} J _inst_3 C _inst_1 F) j)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6)) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (Prefunctor.obj.{succ u1, succ u3, u2, u5} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u5} J _inst_3 C _inst_1 F) j)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (Prefunctor.map.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (Prefunctor.obj.{succ u1, succ u3, u2, u5} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_3)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u5} J _inst_3 C _inst_1 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Limits.colimit.ι.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5 j)) (CategoryTheory.Iso.hom.{u4, u6} D _inst_2 (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.preservesColimitIso.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 G J _inst_3 F _inst_4 _inst_5 _inst_6))) (CategoryTheory.Limits.colimit.ι.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6 j)
Case conversion may be inaccurate. Consider using '#align category_theory.ι_preserves_colimits_iso_hom CategoryTheory.ι_preservesColimitsIso_homₓ'. -/
@[simp, reassoc.1]
theorem ι_preservesColimitsIso_hom (j : J) :
    G.map (colimit.ι F j) ≫ (preservesColimitIso G F).Hom = colimit.ι (F ⋙ G) j :=
  (PreservesColimit.preserves (colimit.isColimit _)).comp_coconePointUniqueUpToIso_hom _ j
#align category_theory.ι_preserves_colimits_iso_hom CategoryTheory.ι_preservesColimitsIso_hom

/- warning: category_theory.preserves_colimits_iso_inv_comp_desc -> CategoryTheory.preservesColimitsIso_inv_comp_desc is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F] [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)] (t : CategoryTheory.Limits.Cocone.{u1, u3, u2, u5} J _inst_3 C _inst_1 F), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F t))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F t)) (CategoryTheory.Iso.inv.{u4, u6} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.preservesColimitIso.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 G J _inst_3 F _inst_4 _inst_5 _inst_6)) (CategoryTheory.Functor.map.{u3, u4, u5, u6} C _inst_1 D _inst_2 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F t) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5 t))) (CategoryTheory.Limits.colimit.desc.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6 (CategoryTheory.Functor.mapCocone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G t))
but is expected to have type
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) [_inst_4 : CategoryTheory.Limits.PreservesColimit.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 F G] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F] [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G)] (t : CategoryTheory.Limits.Cocone.{u1, u3, u2, u5} J _inst_3 C _inst_1 F), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F t))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F t)) (CategoryTheory.Iso.inv.{u4, u6} D _inst_2 (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6) (CategoryTheory.preservesColimitIso.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 G J _inst_3 F _inst_4 _inst_5 _inst_6)) (Prefunctor.map.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_1 D _inst_2 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u5} J _inst_3 C _inst_1 F t) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u5} J _inst_3 C _inst_1 F _inst_5 t))) (CategoryTheory.Limits.colimit.desc.{u1, u2, u4, u6} J _inst_3 D _inst_2 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G) _inst_6 (CategoryTheory.Functor.mapCocone.{u1, u3, u4, u2, u5, u6} J _inst_3 C _inst_1 D _inst_2 F G t))
Case conversion may be inaccurate. Consider using '#align category_theory.preserves_colimits_iso_inv_comp_desc CategoryTheory.preservesColimitsIso_inv_comp_descₓ'. -/
@[simp, reassoc.1]
theorem preservesColimitsIso_inv_comp_desc (t : Cocone F) :
    (preservesColimitIso G F).inv ≫ G.map (colimit.desc _ t) = colimit.desc _ (G.mapCocone t) :=
  by
  ext
  simp [← G.map_comp]
#align category_theory.preserves_colimits_iso_inv_comp_desc CategoryTheory.preservesColimitsIso_inv_comp_desc

variable [PreservesColimitsOfShape J G] [HasColimitsOfShape J D] [HasColimitsOfShape J C]

/- warning: category_theory.preserves_colimit_nat_iso -> CategoryTheory.preservesColimitNatIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] [_inst_7 : CategoryTheory.Limits.PreservesColimitsOfShape.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 G] [_inst_8 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u4, u6} J _inst_3 D _inst_2] [_inst_9 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u3, u5} J _inst_3 C _inst_1], CategoryTheory.Iso.{max (max u1 u3 u2 u5) u4, max (max u2 u3) u4 (max u1 u3 u2 u5) u6} (CategoryTheory.Functor.{max u2 u3, u4, max u1 u3 u2 u5, u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, u4, max u1 u3 u2 u5, u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) D _inst_2) (CategoryTheory.Functor.comp.{max u2 u3, u3, u4, max u1 u3 u2 u5, u5, u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) C _inst_1 D _inst_2 (CategoryTheory.Limits.colim.{u1, u2, u3, u5} J _inst_3 C _inst_1 _inst_9) G) (CategoryTheory.Functor.comp.{max u2 u3, max u2 u4, u4, max u1 u3 u2 u5, max u1 u4 u2 u6, u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2) D _inst_2 (CategoryTheory.Functor.obj.{max u5 u4, max (max u1 u3 u2 u5) u2 u4, max u3 u4 u5 u6, max (max u2 u3) (max u2 u4) (max u1 u3 u2 u5) u1 u4 u2 u6} (CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u4, u5, u6} C _inst_1 D _inst_2) (CategoryTheory.Functor.{max u2 u3, max u2 u4, max u1 u3 u2 u5, max u1 u4 u2 u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2)) (CategoryTheory.Functor.category.{max u2 u3, max u2 u4, max u1 u3 u2 u5, max u1 u4 u2 u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2)) (CategoryTheory.whiskeringRight.{u2, u1, u5, u3, u6, u4} J _inst_3 C _inst_1 D _inst_2) G) (CategoryTheory.Limits.colim.{u1, u2, u4, u6} J _inst_3 D _inst_2 _inst_8))
but is expected to have type
  forall {C : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u3, u5} C] {D : Type.{u6}} [_inst_2 : CategoryTheory.Category.{u4, u6} D] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) {J : Type.{u2}} [_inst_3 : CategoryTheory.Category.{u1, u2} J] [_inst_7 : CategoryTheory.Limits.PreservesColimitsOfShape.{u1, u2, u3, u4, u5, u6} C _inst_1 D _inst_2 J _inst_3 G] [_inst_8 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u4, u6} J _inst_3 D _inst_2] [_inst_9 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u3, u5} J _inst_3 C _inst_1], CategoryTheory.Iso.{max (max (max (max u5 u3) u4) u2) u1, max (max (max u6 (max (max u5 u3) u2) u1) u4) u3 u2} (CategoryTheory.Functor.{max u3 u2, u4, max (max (max u5 u3) u2) u1, u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, u4, max (max (max u5 u3) u2) u1, u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) D _inst_2) (CategoryTheory.Functor.comp.{max u3 u2, u3, u4, max (max (max u5 u3) u2) u1, u5, u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) C _inst_1 D _inst_2 (CategoryTheory.Limits.colim.{u1, u2, u3, u5} J _inst_3 C _inst_1 _inst_9) G) (CategoryTheory.Functor.comp.{max u3 u2, max u4 u2, u4, max (max (max u5 u3) u2) u1, max (max (max u6 u4) u2) u1, u6} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2) D _inst_2 (Prefunctor.obj.{max (succ u5) (succ u4), max (max (max (max (succ u5) (succ u3)) (succ u4)) (succ u2)) (succ u1), max (max (max u5 u6) u3) u4, max (max (max (max (max u5 u6) u3) u4) u2) u1} (CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u4, max (max (max u5 u6) u3) u4} (CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u5 u4, max (max (max u5 u6) u3) u4} (CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u4, u5, u6} C _inst_1 D _inst_2))) (CategoryTheory.Functor.{max u2 u3, max u2 u4, max (max (max u5 u2) u3) u1, max (max (max u6 u2) u4) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2)) (CategoryTheory.CategoryStruct.toQuiver.{max (max (max (max u5 u3) u4) u2) u1, max (max (max (max (max u5 u6) u3) u4) u2) u1} (CategoryTheory.Functor.{max u2 u3, max u2 u4, max (max (max u5 u2) u3) u1, max (max (max u6 u2) u4) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2)) (CategoryTheory.Category.toCategoryStruct.{max (max (max (max u5 u3) u4) u2) u1, max (max (max (max (max u5 u6) u3) u4) u2) u1} (CategoryTheory.Functor.{max u2 u3, max u2 u4, max (max (max u5 u2) u3) u1, max (max (max u6 u2) u4) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2)) (CategoryTheory.Functor.category.{max u2 u3, max u2 u4, max (max (max u2 u5) u1) u3, max (max (max u2 u6) u1) u4} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2)))) (CategoryTheory.Functor.toPrefunctor.{max u5 u4, max (max (max (max u5 u3) u4) u2) u1, max (max (max u5 u6) u3) u4, max (max (max (max (max u5 u6) u3) u4) u2) u1} (CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u4, u5, u6} C _inst_1 D _inst_2) (CategoryTheory.Functor.{max u2 u3, max u2 u4, max (max (max u5 u2) u3) u1, max (max (max u6 u2) u4) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2)) (CategoryTheory.Functor.category.{max u2 u3, max u2 u4, max (max (max u2 u5) u1) u3, max (max (max u2 u6) u1) u4} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_3 C _inst_1) (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_3 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_3 D _inst_2)) (CategoryTheory.whiskeringRight.{u2, u1, u5, u3, u6, u4} J _inst_3 C _inst_1 D _inst_2)) G) (CategoryTheory.Limits.colim.{u1, u2, u4, u6} J _inst_3 D _inst_2 _inst_8))
Case conversion may be inaccurate. Consider using '#align category_theory.preserves_colimit_nat_iso CategoryTheory.preservesColimitNatIsoₓ'. -/
/-- If `C, D` has all colimits of shape `J`, and `G` preserves them, then `preserves_colimit_iso`
is functorial wrt `F`. -/
@[simps]
def preservesColimitNatIso : colim ⋙ G ≅ (whiskeringRight J C D).obj G ⋙ colim :=
  NatIso.ofComponents (fun F => preservesColimitIso G F)
    (by
      intro _ _ f
      rw [← iso.inv_comp_eq, ← category.assoc, ← iso.eq_comp_inv]
      ext
      dsimp
      erw [ι_colim_map_assoc]
      simp only [ι_preserves_colimits_iso_inv, whisker_right_app, category.assoc,
        ι_preserves_colimits_iso_inv_assoc, ← G.map_comp]
      erw [ι_colim_map])
#align category_theory.preserves_colimit_nat_iso CategoryTheory.preservesColimitNatIso

end

end CategoryTheory

