/-
Copyright (c) 2021 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison, Adam Topaz, Johan Commelin, Joël Riou

! This file was ported from Lean 3 source module category_theory.preadditive.opposite
! leanprover-community/mathlib commit f8d8465c3c392a93b9ed226956e26dee00975946
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Preadditive.AdditiveFunctor
import Mathbin.Logic.Equiv.TransferInstance

/-!
# If `C` is preadditive, `Cᵒᵖ` has a natural preadditive structure.

-/


open Opposite

namespace CategoryTheory

variable (C : Type _) [Category C] [Preadditive C]

instance : Preadditive Cᵒᵖ
    where
  homGroup X Y := Equiv.addCommGroup (opEquiv X Y)
  add_comp X Y Z f f' g :=
    congr_arg Quiver.Hom.op (Preadditive.comp_add _ _ _ g.unop f.unop f'.unop)
  comp_add X Y Z f g g' :=
    congr_arg Quiver.Hom.op (Preadditive.add_comp _ _ _ g.unop g'.unop f.unop)

/- warning: category_theory.module_End_left -> CategoryTheory.moduleEndLeft is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {X : Opposite.{succ u1} C} {Y : C}, Module.{u2, u2} (CategoryTheory.End.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1)) X) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C X) Y) (Ring.toSemiring.{u2} (CategoryTheory.End.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1)) X) (CategoryTheory.Preadditive.CategoryTheory.End.ring.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.Opposite.preadditive.{u1, u2} C _inst_1 _inst_2) X)) (AddCommGroup.toAddCommMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C X) Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 (Opposite.unop.{succ u1} C X) Y))
but is expected to have type
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {X : Opposite.{succ u1} C} {Y : C}, Module.{u2, u2} (CategoryTheory.End.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1)) X) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C X) Y) (CategoryTheory.Preadditive.instSemiringEndToCategoryStruct.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.instPreadditiveOppositeOpposite.{u1, u2} C _inst_1 _inst_2) X) (AddCommGroup.toAddCommMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C X) Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 (Opposite.unop.{succ u1} C X) Y))
Case conversion may be inaccurate. Consider using '#align category_theory.module_End_left CategoryTheory.moduleEndLeftₓ'. -/
instance moduleEndLeft {X : Cᵒᵖ} {Y : C} : Module (End X) (unop X ⟶ Y)
    where
  smul_add r f g := Preadditive.comp_add _ _ _ _ _ _
  smul_zero r := Limits.comp_zero
  add_smul r s f := Preadditive.add_comp _ _ _ _ _ _
  zero_smul f := Limits.zero_comp
#align category_theory.module_End_left CategoryTheory.moduleEndLeft

/- warning: category_theory.unop_zero -> CategoryTheory.unop_zero is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (X : Opposite.{succ u1} C) (Y : Opposite.{succ u1} C), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (Quiver.Hom.unop.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) 0 (OfNat.mk.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) 0 (Zero.zero.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.Limits.hasZeroMorphismsOpposite.{u2, u1} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2)) X Y))))) (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) 0 (OfNat.mk.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) 0 (Zero.zero.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u2, u1} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u1} C _inst_1 _inst_2) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)))))
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] (X : Opposite.{succ u2} C) (Y : Opposite.{succ u2} C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (Quiver.Hom.unop.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) (CategoryTheory.Limits.hasZeroMorphismsOpposite.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)) X Y)))) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X))))
Case conversion may be inaccurate. Consider using '#align category_theory.unop_zero CategoryTheory.unop_zeroₓ'. -/
@[simp]
theorem unop_zero (X Y : Cᵒᵖ) : (0 : X ⟶ Y).unop = 0 :=
  rfl
#align category_theory.unop_zero CategoryTheory.unop_zero

/- warning: category_theory.unop_add -> CategoryTheory.unop_add is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {X : Opposite.{succ u1} C} {Y : Opposite.{succ u1} C} (f : Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (g : Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (Quiver.Hom.unop.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y (HAdd.hAdd.{u2, u2, u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (instHAdd.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (AddZeroClass.toHasAdd.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (AddMonoid.toAddZeroClass.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (SubNegMonoid.toAddMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.Opposite.preadditive.{u1, u2} C _inst_1 _inst_2) X Y))))))) f g)) (HAdd.hAdd.{u2, u2, u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (instHAdd.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (AddZeroClass.toHasAdd.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (AddMonoid.toAddZeroClass.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (SubNegMonoid.toAddMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)))))))) (Quiver.Hom.unop.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y f) (Quiver.Hom.unop.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y g))
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : Opposite.{succ u2} C} {Y : Opposite.{succ u2} C} (f : Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (g : Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (Quiver.Hom.unop.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (CategoryTheory.Preadditive.homGroup.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) (CategoryTheory.instPreadditiveOppositeOpposite.{u2, u1} C _inst_1 _inst_2) X Y))))))) f g)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)))))))) (Quiver.Hom.unop.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y f) (Quiver.Hom.unop.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y g))
Case conversion may be inaccurate. Consider using '#align category_theory.unop_add CategoryTheory.unop_addₓ'. -/
@[simp]
theorem unop_add {X Y : Cᵒᵖ} (f g : X ⟶ Y) : (f + g).unop = f.unop + g.unop :=
  rfl
#align category_theory.unop_add CategoryTheory.unop_add

/- warning: category_theory.unop_zsmul -> CategoryTheory.unop_zsmul is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {X : Opposite.{succ u1} C} {Y : Opposite.{succ u1} C} (k : Int) (f : Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (Quiver.Hom.unop.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y (SMul.smul.{0, u2} Int (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (SubNegMonoid.SMulInt.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.Opposite.preadditive.{u1, u2} C _inst_1 _inst_2) X Y)))) k f)) (SMul.smul.{0, u2} Int (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (SubNegMonoid.SMulInt.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X))))) k (Quiver.Hom.unop.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y f))
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : Opposite.{succ u2} C} {Y : Opposite.{succ u2} C} (k : Int) (f : Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (Quiver.Hom.unop.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y (HSMul.hSMul.{0, u1, u1} Int (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (instHSMul.{0, u1} Int (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (SubNegMonoid.SMulInt.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (CategoryTheory.Preadditive.homGroup.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) (CategoryTheory.instPreadditiveOppositeOpposite.{u2, u1} C _inst_1 _inst_2) X Y))))) k f)) (HSMul.hSMul.{0, u1, u1} Int (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (instHSMul.{0, u1} Int (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (SubNegMonoid.SMulInt.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)))))) k (Quiver.Hom.unop.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y f))
Case conversion may be inaccurate. Consider using '#align category_theory.unop_zsmul CategoryTheory.unop_zsmulₓ'. -/
@[simp]
theorem unop_zsmul {X Y : Cᵒᵖ} (k : ℤ) (f : X ⟶ Y) : (k • f).unop = k • f.unop :=
  rfl
#align category_theory.unop_zsmul CategoryTheory.unop_zsmul

/- warning: category_theory.unop_neg -> CategoryTheory.unop_neg is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {X : Opposite.{succ u1} C} {Y : Opposite.{succ u1} C} (f : Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (Quiver.Hom.unop.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y (Neg.neg.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (SubNegMonoid.toHasNeg.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.Opposite.preadditive.{u1, u2} C _inst_1 _inst_2) X Y)))) f)) (Neg.neg.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (SubNegMonoid.toHasNeg.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X))))) (Quiver.Hom.unop.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y f))
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : Opposite.{succ u2} C} {Y : Opposite.{succ u2} C} (f : Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (Quiver.Hom.unop.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y (Neg.neg.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (NegZeroClass.toNeg.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (SubNegZeroMonoid.toNegZeroClass.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Quiver.Hom.{succ u1, u2} (Opposite.{succ u2} C) (Quiver.opposite.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1))) X Y) (CategoryTheory.Preadditive.homGroup.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) (CategoryTheory.instPreadditiveOppositeOpposite.{u2, u1} C _inst_1 _inst_2) X Y)))))) f)) (Neg.neg.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (NegZeroClass.toNeg.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (SubNegZeroMonoid.toNegZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (AddCommGroup.toDivisionAddCommMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X)) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (Opposite.unop.{succ u2} C Y) (Opposite.unop.{succ u2} C X))))))) (Quiver.Hom.unop.{u2, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y f))
Case conversion may be inaccurate. Consider using '#align category_theory.unop_neg CategoryTheory.unop_negₓ'. -/
@[simp]
theorem unop_neg {X Y : Cᵒᵖ} (f : X ⟶ Y) : (-f).unop = -f.unop :=
  rfl
#align category_theory.unop_neg CategoryTheory.unop_neg

#print CategoryTheory.op_zero /-
@[simp]
theorem op_zero (X Y : C) : (0 : X ⟶ Y).op = 0 :=
  rfl
#align category_theory.op_zero CategoryTheory.op_zero
-/

/- warning: category_theory.op_add -> CategoryTheory.op_add is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {X : C} {Y : C} (f : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (g : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y (HAdd.hAdd.{u2, u2, u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (instHAdd.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddZeroClass.toHasAdd.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddMonoid.toAddZeroClass.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (SubNegMonoid.toAddMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 X Y))))))) f g)) (HAdd.hAdd.{u2, u2, u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (instHAdd.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddZeroClass.toHasAdd.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddMonoid.toAddZeroClass.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (SubNegMonoid.toAddMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (CategoryTheory.Preadditive.homGroup.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.Opposite.preadditive.{u1, u2} C _inst_1 _inst_2) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)))))))) (Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y f) (Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y g))
but is expected to have type
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {X : C} {Y : C} (f : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (g : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y (HAdd.hAdd.{u2, u2, u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (instHAdd.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddZeroClass.toAdd.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddMonoid.toAddZeroClass.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (SubNegMonoid.toAddMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 X Y))))))) f g)) (HAdd.hAdd.{u2, u2, u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (instHAdd.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddZeroClass.toAdd.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddMonoid.toAddZeroClass.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (SubNegMonoid.toAddMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (CategoryTheory.Preadditive.homGroup.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.instPreadditiveOppositeOpposite.{u1, u2} C _inst_1 _inst_2) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)))))))) (Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y f) (Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y g))
Case conversion may be inaccurate. Consider using '#align category_theory.op_add CategoryTheory.op_addₓ'. -/
@[simp]
theorem op_add {X Y : C} (f g : X ⟶ Y) : (f + g).op = f.op + g.op :=
  rfl
#align category_theory.op_add CategoryTheory.op_add

/- warning: category_theory.op_zsmul -> CategoryTheory.op_zsmul is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {X : C} {Y : C} (k : Int) (f : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y (SMul.smul.{0, u2} Int (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (SubNegMonoid.SMulInt.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 X Y)))) k f)) (SMul.smul.{0, u2} Int (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (SubNegMonoid.SMulInt.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (CategoryTheory.Preadditive.homGroup.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.Opposite.preadditive.{u1, u2} C _inst_1 _inst_2) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X))))) k (Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y f))
but is expected to have type
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {X : C} {Y : C} (k : Int) (f : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y (HSMul.hSMul.{0, u2, u2} Int (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (instHSMul.{0, u2} Int (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (SubNegMonoid.SMulInt.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 X Y))))) k f)) (HSMul.hSMul.{0, u2, u2} Int (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (instHSMul.{0, u2} Int (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (SubNegMonoid.SMulInt.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (CategoryTheory.Preadditive.homGroup.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.instPreadditiveOppositeOpposite.{u1, u2} C _inst_1 _inst_2) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)))))) k (Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y f))
Case conversion may be inaccurate. Consider using '#align category_theory.op_zsmul CategoryTheory.op_zsmulₓ'. -/
@[simp]
theorem op_zsmul {X Y : C} (k : ℤ) (f : X ⟶ Y) : (k • f).op = k • f.op :=
  rfl
#align category_theory.op_zsmul CategoryTheory.op_zsmul

/- warning: category_theory.op_neg -> CategoryTheory.op_neg is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {X : C} {Y : C} (f : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y (Neg.neg.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (SubNegMonoid.toHasNeg.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 X Y)))) f)) (Neg.neg.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (SubNegMonoid.toHasNeg.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (CategoryTheory.Preadditive.homGroup.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.Opposite.preadditive.{u1, u2} C _inst_1 _inst_2) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X))))) (Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y f))
but is expected to have type
  forall (C : Type.{u1}) [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {X : C} {Y : C} (f : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y (Neg.neg.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (NegZeroClass.toNeg.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (SubNegZeroMonoid.toNegZeroClass.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (SubtractionCommMonoid.toSubtractionMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddCommGroup.toDivisionAddCommMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 X Y)))))) f)) (Neg.neg.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (NegZeroClass.toNeg.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (SubNegZeroMonoid.toNegZeroClass.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (SubtractionCommMonoid.toSubtractionMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddCommGroup.toDivisionAddCommMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (CategoryTheory.Preadditive.homGroup.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.instPreadditiveOppositeOpposite.{u1, u2} C _inst_1 _inst_2) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X))))))) (Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y f))
Case conversion may be inaccurate. Consider using '#align category_theory.op_neg CategoryTheory.op_negₓ'. -/
@[simp]
theorem op_neg {X Y : C} (f : X ⟶ Y) : (-f).op = -f.op :=
  rfl
#align category_theory.op_neg CategoryTheory.op_neg

variable {C}

/- warning: category_theory.unop_hom -> CategoryTheory.unopHom is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (X : Opposite.{succ u1} C) (Y : Opposite.{succ u1} C), AddMonoidHom.{u2, u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (AddMonoid.toAddZeroClass.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (SubNegMonoid.toAddMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.Opposite.preadditive.{u1, u2} C _inst_1 _inst_2) X Y))))) (AddMonoid.toAddZeroClass.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (SubNegMonoid.toAddMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X))))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (X : Opposite.{succ u1} C) (Y : Opposite.{succ u1} C), AddMonoidHom.{u2, u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (AddMonoid.toAddZeroClass.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (SubNegMonoid.toAddMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.instPreadditiveOppositeOpposite.{u1, u2} C _inst_1 _inst_2) X Y))))) (AddMonoid.toAddZeroClass.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (SubNegMonoid.toAddMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X))))))
Case conversion may be inaccurate. Consider using '#align category_theory.unop_hom CategoryTheory.unopHomₓ'. -/
/-- `unop` induces morphisms of monoids on hom groups of a preadditive category -/
@[simps]
def unopHom (X Y : Cᵒᵖ) : (X ⟶ Y) →+ (Opposite.unop Y ⟶ Opposite.unop X) :=
  AddMonoidHom.mk' (fun f => f.unop) fun f g => unop_add _ f g
#align category_theory.unop_hom CategoryTheory.unopHom

/- warning: category_theory.unop_sum -> CategoryTheory.unop_sum is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (X : Opposite.{succ u1} C) (Y : Opposite.{succ u1} C) {ι : Type.{u3}} (s : Finset.{u3} ι) (f : ι -> (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y)), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (Quiver.Hom.unop.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y (Finset.sum.{u2, u3} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) ι (AddCommGroup.toAddCommMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) X Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.Opposite.preadditive.{u1, u2} C _inst_1 _inst_2) X Y)) s f)) (Finset.sum.{u2, u3} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) ι (AddCommGroup.toAddCommMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X)) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 (Opposite.unop.{succ u1} C Y) (Opposite.unop.{succ u1} C X))) s (fun (i : ι) => Quiver.Hom.unop.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y (f i)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u3} C _inst_1] (X : Opposite.{succ u3} C) (Y : Opposite.{succ u3} C) {ι : Type.{u2}} (s : Finset.{u2} ι) (f : ι -> (Quiver.Hom.{succ u1, u3} (Opposite.{succ u3} C) (Quiver.opposite.{u3, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1))) X Y)), Eq.{succ u1} (Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (Opposite.unop.{succ u3} C Y) (Opposite.unop.{succ u3} C X)) (Quiver.Hom.unop.{u3, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) X Y (Finset.sum.{u1, u2} (Quiver.Hom.{succ u1, u3} (Opposite.{succ u3} C) (Quiver.opposite.{u3, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1))) X Y) ι (AddCommGroup.toAddCommMonoid.{u1} (Quiver.Hom.{succ u1, u3} (Opposite.{succ u3} C) (Quiver.opposite.{u3, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1))) X Y) (CategoryTheory.Preadditive.homGroup.{u1, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u1, u3} C _inst_1) (CategoryTheory.instPreadditiveOppositeOpposite.{u3, u1} C _inst_1 _inst_2) X Y)) s f)) (Finset.sum.{u1, u2} (Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (Opposite.unop.{succ u3} C Y) (Opposite.unop.{succ u3} C X)) ι (AddCommGroup.toAddCommMonoid.{u1} (Quiver.Hom.{succ u1, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) (Opposite.unop.{succ u3} C Y) (Opposite.unop.{succ u3} C X)) (CategoryTheory.Preadditive.homGroup.{u1, u3} C _inst_1 _inst_2 (Opposite.unop.{succ u3} C Y) (Opposite.unop.{succ u3} C X))) s (fun (i : ι) => Quiver.Hom.unop.{u3, succ u1} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) X Y (f i)))
Case conversion may be inaccurate. Consider using '#align category_theory.unop_sum CategoryTheory.unop_sumₓ'. -/
@[simp]
theorem unop_sum (X Y : Cᵒᵖ) {ι : Type _} (s : Finset ι) (f : ι → (X ⟶ Y)) :
    (s.Sum f).unop = s.Sum fun i => (f i).unop :=
  (unopHom X Y).map_sum _ _
#align category_theory.unop_sum CategoryTheory.unop_sum

/- warning: category_theory.op_hom -> CategoryTheory.opHom is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (X : C) (Y : C), AddMonoidHom.{u2, u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddMonoid.toAddZeroClass.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (SubNegMonoid.toAddMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 X Y))))) (AddMonoid.toAddZeroClass.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (SubNegMonoid.toAddMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (CategoryTheory.Preadditive.homGroup.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.Opposite.preadditive.{u1, u2} C _inst_1 _inst_2) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X))))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (X : C) (Y : C), AddMonoidHom.{u2, u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddMonoid.toAddZeroClass.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (SubNegMonoid.toAddMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 X Y))))) (AddMonoid.toAddZeroClass.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (SubNegMonoid.toAddMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddGroup.toSubNegMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (AddCommGroup.toAddGroup.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (CategoryTheory.Preadditive.homGroup.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.instPreadditiveOppositeOpposite.{u1, u2} C _inst_1 _inst_2) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X))))))
Case conversion may be inaccurate. Consider using '#align category_theory.op_hom CategoryTheory.opHomₓ'. -/
/-- `op` induces morphisms of monoids on hom groups of a preadditive category -/
@[simps]
def opHom (X Y : C) : (X ⟶ Y) →+ (Opposite.op Y ⟶ Opposite.op X) :=
  AddMonoidHom.mk' (fun f => f.op) fun f g => op_add _ f g
#align category_theory.op_hom CategoryTheory.opHom

/- warning: category_theory.op_sum -> CategoryTheory.op_sum is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (X : C) (Y : C) {ι : Type.{u3}} (s : Finset.{u3} ι) (f : ι -> (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y)), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y (Finset.sum.{u2, u3} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) ι (AddCommGroup.toAddCommMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 X Y)) s f)) (Finset.sum.{u2, u3} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) ι (AddCommGroup.toAddCommMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (CategoryTheory.Preadditive.homGroup.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.Opposite.preadditive.{u1, u2} C _inst_1 _inst_2) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X))) s (fun (i : ι) => Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y (f i)))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] (X : C) (Y : C) {ι : Type.{u3}} (s : Finset.{u3} ι) (f : ι -> (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y)), Eq.{succ u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y (Finset.sum.{u2, u3} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) ι (AddCommGroup.toAddCommMonoid.{u2} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u2, u1} C _inst_1 _inst_2 X Y)) s f)) (Finset.sum.{u2, u3} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) ι (AddCommGroup.toAddCommMonoid.{u2} (Quiver.Hom.{succ u2, u1} (Opposite.{succ u1} C) (Quiver.opposite.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1))) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X)) (CategoryTheory.Preadditive.homGroup.{u2, u1} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.instPreadditiveOppositeOpposite.{u1, u2} C _inst_1 _inst_2) (Opposite.op.{succ u1} C Y) (Opposite.op.{succ u1} C X))) s (fun (i : ι) => Quiver.Hom.op.{u1, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y (f i)))
Case conversion may be inaccurate. Consider using '#align category_theory.op_sum CategoryTheory.op_sumₓ'. -/
@[simp]
theorem op_sum (X Y : C) {ι : Type _} (s : Finset ι) (f : ι → (X ⟶ Y)) :
    (s.Sum f).op = s.Sum fun i => (f i).op :=
  (opHom X Y).map_sum _ _
#align category_theory.op_sum CategoryTheory.op_sum

variable {D : Type _} [Category D] [Preadditive D]

/- warning: category_theory.functor.op_additive -> CategoryTheory.Functor.op_additive is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {D : Type.{u3}} [_inst_3 : CategoryTheory.Category.{u4, u3} D] [_inst_4 : CategoryTheory.Preadditive.{u4, u3} D _inst_3] (F : CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_3) [_inst_5 : CategoryTheory.Functor.Additive.{u1, u3, u2, u4} C D _inst_1 _inst_3 _inst_2 _inst_4 F], CategoryTheory.Functor.Additive.{u1, u3, u2, u4} (Opposite.{succ u1} C) (Opposite.{succ u3} D) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.Category.opposite.{u4, u3} D _inst_3) (CategoryTheory.Opposite.preadditive.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Opposite.preadditive.{u3, u4} D _inst_3 _inst_4) (CategoryTheory.Functor.op.{u2, u4, u1, u3} C _inst_1 D _inst_3 F)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {D : Type.{u3}} [_inst_3 : CategoryTheory.Category.{u4, u3} D] [_inst_4 : CategoryTheory.Preadditive.{u4, u3} D _inst_3] (F : CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_3) [_inst_5 : CategoryTheory.Functor.Additive.{u1, u3, u2, u4} C D _inst_1 _inst_3 _inst_2 _inst_4 F], CategoryTheory.Functor.Additive.{u1, u3, u2, u4} (Opposite.{succ u1} C) (Opposite.{succ u3} D) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.Category.opposite.{u4, u3} D _inst_3) (CategoryTheory.instPreadditiveOppositeOpposite.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.instPreadditiveOppositeOpposite.{u3, u4} D _inst_3 _inst_4) (CategoryTheory.Functor.op.{u2, u4, u1, u3} C _inst_1 D _inst_3 F)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.op_additive CategoryTheory.Functor.op_additiveₓ'. -/
instance Functor.op_additive (F : C ⥤ D) [F.Additive] : F.op.Additive where
#align category_theory.functor.op_additive CategoryTheory.Functor.op_additive

/- warning: category_theory.functor.right_op_additive -> CategoryTheory.Functor.rightOp_additive is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {D : Type.{u3}} [_inst_3 : CategoryTheory.Category.{u4, u3} D] [_inst_4 : CategoryTheory.Preadditive.{u4, u3} D _inst_3] (F : CategoryTheory.Functor.{u2, u4, u1, u3} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) D _inst_3) [_inst_5 : CategoryTheory.Functor.Additive.{u1, u3, u2, u4} (Opposite.{succ u1} C) D (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) _inst_3 (CategoryTheory.Opposite.preadditive.{u1, u2} C _inst_1 _inst_2) _inst_4 F], CategoryTheory.Functor.Additive.{u1, u3, u2, u4} C (Opposite.{succ u3} D) _inst_1 (CategoryTheory.Category.opposite.{u4, u3} D _inst_3) _inst_2 (CategoryTheory.Opposite.preadditive.{u3, u4} D _inst_3 _inst_4) (CategoryTheory.Functor.rightOp.{u2, u4, u1, u3} C _inst_1 D _inst_3 F)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {D : Type.{u3}} [_inst_3 : CategoryTheory.Category.{u4, u3} D] [_inst_4 : CategoryTheory.Preadditive.{u4, u3} D _inst_3] (F : CategoryTheory.Functor.{u2, u4, u1, u3} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) D _inst_3) [_inst_5 : CategoryTheory.Functor.Additive.{u1, u3, u2, u4} (Opposite.{succ u1} C) D (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) _inst_3 (CategoryTheory.instPreadditiveOppositeOpposite.{u1, u2} C _inst_1 _inst_2) _inst_4 F], CategoryTheory.Functor.Additive.{u1, u3, u2, u4} C (Opposite.{succ u3} D) _inst_1 (CategoryTheory.Category.opposite.{u4, u3} D _inst_3) _inst_2 (CategoryTheory.instPreadditiveOppositeOpposite.{u3, u4} D _inst_3 _inst_4) (CategoryTheory.Functor.rightOp.{u2, u4, u1, u3} C _inst_1 D _inst_3 F)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.right_op_additive CategoryTheory.Functor.rightOp_additiveₓ'. -/
instance Functor.rightOp_additive (F : Cᵒᵖ ⥤ D) [F.Additive] : F.rightOp.Additive where
#align category_theory.functor.right_op_additive CategoryTheory.Functor.rightOp_additive

/- warning: category_theory.functor.left_op_additive -> CategoryTheory.Functor.leftOp_additive is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {D : Type.{u3}} [_inst_3 : CategoryTheory.Category.{u4, u3} D] [_inst_4 : CategoryTheory.Preadditive.{u4, u3} D _inst_3] (F : CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 (Opposite.{succ u3} D) (CategoryTheory.Category.opposite.{u4, u3} D _inst_3)) [_inst_5 : CategoryTheory.Functor.Additive.{u1, u3, u2, u4} C (Opposite.{succ u3} D) _inst_1 (CategoryTheory.Category.opposite.{u4, u3} D _inst_3) _inst_2 (CategoryTheory.Opposite.preadditive.{u3, u4} D _inst_3 _inst_4) F], CategoryTheory.Functor.Additive.{u1, u3, u2, u4} (Opposite.{succ u1} C) D (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) _inst_3 (CategoryTheory.Opposite.preadditive.{u1, u2} C _inst_1 _inst_2) _inst_4 (CategoryTheory.Functor.leftOp.{u2, u4, u1, u3} C _inst_1 D _inst_3 F)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {D : Type.{u3}} [_inst_3 : CategoryTheory.Category.{u4, u3} D] [_inst_4 : CategoryTheory.Preadditive.{u4, u3} D _inst_3] (F : CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 (Opposite.{succ u3} D) (CategoryTheory.Category.opposite.{u4, u3} D _inst_3)) [_inst_5 : CategoryTheory.Functor.Additive.{u1, u3, u2, u4} C (Opposite.{succ u3} D) _inst_1 (CategoryTheory.Category.opposite.{u4, u3} D _inst_3) _inst_2 (CategoryTheory.instPreadditiveOppositeOpposite.{u3, u4} D _inst_3 _inst_4) F], CategoryTheory.Functor.Additive.{u1, u3, u2, u4} (Opposite.{succ u1} C) D (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) _inst_3 (CategoryTheory.instPreadditiveOppositeOpposite.{u1, u2} C _inst_1 _inst_2) _inst_4 (CategoryTheory.Functor.leftOp.{u2, u4, u1, u3} C _inst_1 D _inst_3 F)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.left_op_additive CategoryTheory.Functor.leftOp_additiveₓ'. -/
instance Functor.leftOp_additive (F : C ⥤ Dᵒᵖ) [F.Additive] : F.leftOp.Additive where
#align category_theory.functor.left_op_additive CategoryTheory.Functor.leftOp_additive

/- warning: category_theory.functor.unop_additive -> CategoryTheory.Functor.unop_additive is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {D : Type.{u3}} [_inst_3 : CategoryTheory.Category.{u4, u3} D] [_inst_4 : CategoryTheory.Preadditive.{u4, u3} D _inst_3] (F : CategoryTheory.Functor.{u2, u4, u1, u3} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (Opposite.{succ u3} D) (CategoryTheory.Category.opposite.{u4, u3} D _inst_3)) [_inst_5 : CategoryTheory.Functor.Additive.{u1, u3, u2, u4} (Opposite.{succ u1} C) (Opposite.{succ u3} D) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.Category.opposite.{u4, u3} D _inst_3) (CategoryTheory.Opposite.preadditive.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.Opposite.preadditive.{u3, u4} D _inst_3 _inst_4) F], CategoryTheory.Functor.Additive.{u1, u3, u2, u4} C D _inst_1 _inst_3 _inst_2 _inst_4 (CategoryTheory.Functor.unop.{u2, u4, u1, u3} C _inst_1 D _inst_3 F)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Preadditive.{u2, u1} C _inst_1] {D : Type.{u3}} [_inst_3 : CategoryTheory.Category.{u4, u3} D] [_inst_4 : CategoryTheory.Preadditive.{u4, u3} D _inst_3] (F : CategoryTheory.Functor.{u2, u4, u1, u3} (Opposite.{succ u1} C) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (Opposite.{succ u3} D) (CategoryTheory.Category.opposite.{u4, u3} D _inst_3)) [_inst_5 : CategoryTheory.Functor.Additive.{u1, u3, u2, u4} (Opposite.{succ u1} C) (Opposite.{succ u3} D) (CategoryTheory.Category.opposite.{u2, u1} C _inst_1) (CategoryTheory.Category.opposite.{u4, u3} D _inst_3) (CategoryTheory.instPreadditiveOppositeOpposite.{u1, u2} C _inst_1 _inst_2) (CategoryTheory.instPreadditiveOppositeOpposite.{u3, u4} D _inst_3 _inst_4) F], CategoryTheory.Functor.Additive.{u1, u3, u2, u4} C D _inst_1 _inst_3 _inst_2 _inst_4 (CategoryTheory.Functor.unop.{u2, u4, u1, u3} C _inst_1 D _inst_3 F)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.unop_additive CategoryTheory.Functor.unop_additiveₓ'. -/
instance Functor.unop_additive (F : Cᵒᵖ ⥤ Dᵒᵖ) [F.Additive] : F.unop.Additive where
#align category_theory.functor.unop_additive CategoryTheory.Functor.unop_additive

end CategoryTheory

