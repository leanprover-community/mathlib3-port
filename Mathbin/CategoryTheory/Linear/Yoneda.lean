/-
Copyright (c) 2021 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module category_theory.linear.yoneda
! leanprover-community/mathlib commit 09f981f72d43749f1fa072deade828d9c1e185bb
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Category.Module.Basic
import Mathbin.CategoryTheory.Linear.Basic
import Mathbin.CategoryTheory.Preadditive.Yoneda.Basic

/-!
# The Yoneda embedding for `R`-linear categories

The Yoneda embedding for `R`-linear categories `C`,
sends an object `X : C` to the `Module R`-valued presheaf on `C`,
with value on `Y : Cᵒᵖ` given by `Module.of R (unop Y ⟶ X)`.

TODO: `linear_yoneda R C` is `R`-linear.
TODO: In fact, `linear_yoneda` itself is additive and `R`-linear.
-/


universe w v u

open Opposite

namespace CategoryTheory

variable (R : Type w) [Ring R] (C : Type u) [Category.{v} C] [Preadditive C] [Linear R C]

#print CategoryTheory.linearYoneda /-
/-- The Yoneda embedding for `R`-linear categories `C`,
sending an object `X : C` to the `Module R`-valued presheaf on `C`,
with value on `Y : Cᵒᵖ` given by `Module.of R (unop Y ⟶ X)`. -/
@[simps]
def linearYoneda : C ⥤ Cᵒᵖ ⥤ ModuleCat R
    where
  obj X :=
    { obj := fun Y => ModuleCat.of R (unop Y ⟶ X)
      map := fun Y Y' f => Linear.leftComp R _ f.unop
      map_comp' := fun _ _ _ f g => LinearMap.ext fun _ => Category.assoc _ _ _
      map_id' := fun Y => LinearMap.ext fun _ => Category.id_comp _ }
  map X X' f :=
    { app := fun Y => Linear.rightComp R _ f
      naturality' := fun X Y f =>
        LinearMap.ext fun x => by
          simp only [category.assoc, ModuleCat.coe_comp, Function.comp_apply,
            linear.left_comp_apply, linear.right_comp_apply] }
  map_id' X :=
    NatTrans.ext _ _ <|
      funext fun _ =>
        LinearMap.ext fun _ => by
          simp only [linear.right_comp_apply, category.comp_id, nat_trans.id_app,
            ModuleCat.id_apply]
  map_comp' _ _ _ f g :=
    NatTrans.ext _ _ <|
      funext fun _ =>
        LinearMap.ext fun _ => by
          simp only [category.assoc, linear.right_comp_apply, nat_trans.comp_app,
            ModuleCat.coe_comp, Function.comp_apply]
#align category_theory.linear_yoneda CategoryTheory.linearYoneda
-/

#print CategoryTheory.linearCoyoneda /-
/-- The Yoneda embedding for `R`-linear categories `C`,
sending an object `Y : Cᵒᵖ` to the `Module R`-valued copresheaf on `C`,
with value on `X : C` given by `Module.of R (unop Y ⟶ X)`. -/
@[simps]
def linearCoyoneda : Cᵒᵖ ⥤ C ⥤ ModuleCat R
    where
  obj Y :=
    { obj := fun X => ModuleCat.of R (unop Y ⟶ X)
      map := fun Y Y' => Linear.rightComp _ _
      map_id' := fun Y => LinearMap.ext fun _ => Category.comp_id _
      map_comp' := fun _ _ _ f g => LinearMap.ext fun _ => Eq.symm (Category.assoc _ _ _) }
  map Y Y' f :=
    { app := fun X => Linear.leftComp _ _ f.unop
      naturality' := fun X Y f =>
        LinearMap.ext fun x => by
          simp only [category.assoc, ModuleCat.coe_comp, Function.comp_apply,
            linear.right_comp_apply, linear.left_comp_apply] }
  map_id' X :=
    NatTrans.ext _ _ <|
      funext fun _ =>
        LinearMap.ext fun _ => by
          simp only [linear.left_comp_apply, unop_id, category.id_comp, nat_trans.id_app,
            ModuleCat.id_apply]
  map_comp' _ _ _ f g :=
    NatTrans.ext _ _ <|
      funext fun _ =>
        LinearMap.ext fun _ => by
          simp only [category.assoc, ModuleCat.coe_comp, Function.comp_apply,
            linear.left_comp_apply, unop_comp, nat_trans.comp_app]
#align category_theory.linear_coyoneda CategoryTheory.linearCoyoneda
-/

/- warning: category_theory.linear_yoneda_obj_additive -> CategoryTheory.linearYoneda_obj_additive is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Ring.{u1} R] (C : Type.{u3}) [_inst_2 : CategoryTheory.Category.{u2, u3} C] [_inst_3 : CategoryTheory.Preadditive.{u2, u3} C _inst_2] [_inst_4 : CategoryTheory.Linear.{u1, u2, u3} R (Ring.toSemiring.{u1} R _inst_1) C _inst_2 _inst_3] (X : C), CategoryTheory.Functor.Additive.{u3, max u1 (succ u2), u2, u2} (Opposite.{succ u3} C) (ModuleCat.{u2, u1} R _inst_1) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) (CategoryTheory.Opposite.preadditive.{u3, u2} C _inst_2 _inst_3) (ModuleCat.CategoryTheory.preadditive.{u2, u1} R _inst_1) (CategoryTheory.Functor.obj.{u2, max u3 u2, u3, max u2 u3 u1 (succ u2)} C _inst_2 (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.linearYoneda.{u1, u2, u3} R _inst_1 C _inst_2 _inst_3 _inst_4) X)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Ring.{u1} R] (C : Type.{u3}) [_inst_2 : CategoryTheory.Category.{u2, u3} C] [_inst_3 : CategoryTheory.Preadditive.{u2, u3} C _inst_2] [_inst_4 : CategoryTheory.Linear.{u1, u2, u3} R (Ring.toSemiring.{u1} R _inst_1) C _inst_2 _inst_3] (X : C), CategoryTheory.Functor.Additive.{u3, max (succ u2) u1, u2, u2} (Opposite.{succ u3} C) (ModuleCat.{u2, u1} R _inst_1) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) (CategoryTheory.instPreadditiveOppositeOpposite.{u3, u2} C _inst_2 _inst_3) (ModuleCat.instPreadditiveModuleCatModuleCategory.{u2, u1} R _inst_1) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, max (max u3 (succ u2)) u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_2)) (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 (succ u2)) u1} (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 (succ u2)) u1} (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)))) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, max (max u3 (succ u2)) u1} C _inst_2 (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.linearYoneda.{u1, u2, u3} R _inst_1 C _inst_2 _inst_3 _inst_4)) X)
Case conversion may be inaccurate. Consider using '#align category_theory.linear_yoneda_obj_additive CategoryTheory.linearYoneda_obj_additiveₓ'. -/
instance linearYoneda_obj_additive (X : C) : ((linearYoneda R C).obj X).Additive where
#align category_theory.linear_yoneda_obj_additive CategoryTheory.linearYoneda_obj_additive

/- warning: category_theory.linear_coyoneda_obj_additive -> CategoryTheory.linearCoyoneda_obj_additive is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Ring.{u1} R] (C : Type.{u3}) [_inst_2 : CategoryTheory.Category.{u2, u3} C] [_inst_3 : CategoryTheory.Preadditive.{u2, u3} C _inst_2] [_inst_4 : CategoryTheory.Linear.{u1, u2, u3} R (Ring.toSemiring.{u1} R _inst_1) C _inst_2 _inst_3] (Y : Opposite.{succ u3} C), CategoryTheory.Functor.Additive.{u3, max u1 (succ u2), u2, u2} C (ModuleCat.{u2, u1} R _inst_1) _inst_2 (ModuleCat.moduleCategory.{u2, u1} R _inst_1) _inst_3 (ModuleCat.CategoryTheory.preadditive.{u2, u1} R _inst_1) (CategoryTheory.Functor.obj.{u2, max u3 u2, u3, max u2 u3 u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.linearCoyoneda.{u1, u2, u3} R _inst_1 C _inst_2 _inst_3 _inst_4) Y)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Ring.{u1} R] (C : Type.{u3}) [_inst_2 : CategoryTheory.Category.{u2, u3} C] [_inst_3 : CategoryTheory.Preadditive.{u2, u3} C _inst_2] [_inst_4 : CategoryTheory.Linear.{u1, u2, u3} R (Ring.toSemiring.{u1} R _inst_1) C _inst_2 _inst_3] (Y : Opposite.{succ u3} C), CategoryTheory.Functor.Additive.{u3, max (succ u2) u1, u2, u2} C (ModuleCat.{u2, u1} R _inst_1) _inst_2 (ModuleCat.moduleCategory.{u2, u1} R _inst_1) _inst_3 (ModuleCat.instPreadditiveModuleCatModuleCategory.{u2, u1} R _inst_1) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, max (max u3 (succ u2)) u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2))) (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 (succ u2)) u1} (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 (succ u2)) u1} (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)))) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, max (max u3 (succ u2)) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.linearCoyoneda.{u1, u2, u3} R _inst_1 C _inst_2 _inst_3 _inst_4)) Y)
Case conversion may be inaccurate. Consider using '#align category_theory.linear_coyoneda_obj_additive CategoryTheory.linearCoyoneda_obj_additiveₓ'. -/
instance linearCoyoneda_obj_additive (Y : Cᵒᵖ) : ((linearCoyoneda R C).obj Y).Additive where
#align category_theory.linear_coyoneda_obj_additive CategoryTheory.linearCoyoneda_obj_additive

/- warning: category_theory.whiskering_linear_yoneda -> CategoryTheory.whiskering_linearYoneda is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Ring.{u1} R] (C : Type.{u3}) [_inst_2 : CategoryTheory.Category.{u2, u3} C] [_inst_3 : CategoryTheory.Preadditive.{u2, u3} C _inst_2] [_inst_4 : CategoryTheory.Linear.{u1, u2, u3} R (Ring.toSemiring.{u1} R _inst_1) C _inst_2 _inst_3], Eq.{succ (max u2 (max u3 u2) u3 u2 u3 (succ u2))} (CategoryTheory.Functor.{u2, max u3 u2, u3, max u2 u3 (succ u2)} C _inst_2 (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.comp.{u2, max u3 u2, max u3 u2, u3, max u2 u3 u1 (succ u2), max u2 u3 (succ u2)} C _inst_2 (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.linearYoneda.{u1, u2, u3} R _inst_1 C _inst_2 _inst_3 _inst_4) (CategoryTheory.Functor.obj.{max (max u1 (succ u2)) u2, max (max u2 u3 u1 (succ u2)) u3 u2, max u2 u1 (succ u2), max (max u3 u2) (max u2 u3 u1 (succ u2)) u2 u3 (succ u2)} (CategoryTheory.Functor.{u2, u2, max u1 (succ u2), succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, max u1 (succ u2), succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u2 u3 u1 (succ u2), max u2 u3 (succ u2)} (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u2 u3 u1 (succ u2), max u2 u3 (succ u2)} (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.whiskeringRight.{u3, u2, max u1 (succ u2), u2, succ u2, u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.forget.{max u1 (succ u2), u2, u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) (ModuleCat.moduleConcreteCategory.{u2, u1} R _inst_1)))) (CategoryTheory.yoneda.{u2, u3} C _inst_2)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Ring.{u1} R] (C : Type.{u3}) [_inst_2 : CategoryTheory.Category.{u2, u3} C] [_inst_3 : CategoryTheory.Preadditive.{u2, u3} C _inst_2] [_inst_4 : CategoryTheory.Linear.{u1, u2, u3} R (Ring.toSemiring.{u1} R _inst_1) C _inst_2 _inst_3], Eq.{max (succ u3) (succ (succ u2))} (CategoryTheory.Functor.{u2, max u3 u2, u3, max (max u3 u2) (succ u2)} C _inst_2 (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.comp.{u2, max u3 u2, max u3 u2, u3, max (max u3 (succ u2)) u1, max (max u3 u2) (succ u2)} C _inst_2 (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.linearYoneda.{u1, u2, u3} R _inst_1 C _inst_2 _inst_3 _inst_4) (Prefunctor.obj.{max (succ u2) (succ (max (succ u2) u1)), max (max (succ u2) (succ (max (succ u2) u1))) (succ u3), max (succ u2) u1, max (max (max (succ u2) u1) u2) u3} (CategoryTheory.Functor.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 (succ u2) u1, max (succ u2) u1} (CategoryTheory.Functor.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Category.toCategoryStruct.{max u2 (succ u2) u1, max (succ u2) u1} (CategoryTheory.Functor.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max (succ u2) u1) u3) u2, max (max (succ u2) u3) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.CategoryStruct.toQuiver.{max (max u2 (succ u2) u1) u3, max (max (max (succ u2) u1) u2) u3} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max (succ u2) u1) u3) u2, max (max (succ u2) u3) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Category.toCategoryStruct.{max (max u2 (succ u2) u1) u3, max (max (max (succ u2) u1) u2) u3} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max (succ u2) u1) u3) u2, max (max (succ u2) u3) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max u3 (succ u2) u1) u2, max (max u3 (succ u2)) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2})))) (CategoryTheory.Functor.toPrefunctor.{max u2 (succ u2) u1, max (max u2 (succ u2) u1) u3, max (succ u2) u1, max (max (max (succ u2) u1) u2) u3} (CategoryTheory.Functor.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max (succ u2) u1) u3) u2, max (max (succ u2) u3) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max u3 (succ u2) u1) u2, max (max u3 (succ u2)) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.whiskeringRight.{u3, u2, max (succ u2) u1, u2, succ u2, u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.forget.{max (succ u2) u1, u2, u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) (ModuleCat.moduleConcreteCategory.{u2, u1} R _inst_1)))) (CategoryTheory.yoneda.{u2, u3} C _inst_2)
Case conversion may be inaccurate. Consider using '#align category_theory.whiskering_linear_yoneda CategoryTheory.whiskering_linearYonedaₓ'. -/
@[simp]
theorem whiskering_linearYoneda :
    linearYoneda R C ⋙ (whiskeringRight _ _ _).obj (forget (ModuleCat.{v} R)) = yoneda :=
  rfl
#align category_theory.whiskering_linear_yoneda CategoryTheory.whiskering_linearYoneda

/- warning: category_theory.whiskering_linear_yoneda₂ -> CategoryTheory.whiskering_linearYoneda₂ is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Ring.{u1} R] (C : Type.{u3}) [_inst_2 : CategoryTheory.Category.{u2, u3} C] [_inst_3 : CategoryTheory.Preadditive.{u2, u3} C _inst_2] [_inst_4 : CategoryTheory.Linear.{u1, u2, u3} R (Ring.toSemiring.{u1} R _inst_1) C _inst_2 _inst_3], Eq.{succ (max u2 (max u3 u2) u3 u2 u3 (succ u2))} (CategoryTheory.Functor.{u2, max u3 u2, u3, max u2 u3 (succ u2)} C _inst_2 (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.Functor.comp.{u2, max u3 u2, max u3 u2, u3, max u2 u3 u1 (succ u2), max u2 u3 (succ u2)} C _inst_2 (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.linearYoneda.{u1, u2, u3} R _inst_1 C _inst_2 _inst_3 _inst_4) (CategoryTheory.Functor.obj.{max (max u1 (succ u2)) u2, max (max u2 u3 u1 (succ u2)) u3 u2, max u2 u1 (succ u2), max (max u3 u2) (max u2 u3 u1 (succ u2)) u2 u3 (succ u2)} (CategoryTheory.Functor.{u2, u2, max u1 (succ u2), succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, max u1 (succ u2), succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u2 u3 u1 (succ u2), max u2 u3 (succ u2)} (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u2 u3 u1 (succ u2), max u2 u3 (succ u2)} (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.whiskeringRight.{u3, u2, max u1 (succ u2), u2, succ u2, u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.forget₂.{max u1 (succ u2), succ u2, u2, u2, u2} (ModuleCat.{u2, u1} R _inst_1) AddCommGroupCat.{u2} (ModuleCat.moduleCategory.{u2, u1} R _inst_1) (ModuleCat.moduleConcreteCategory.{u2, u1} R _inst_1) AddCommGroupCat.largeCategory.{u2} AddCommGroupCat.concreteCategory.{u2} (ModuleCat.hasForgetToAddCommGroup.{u1, u2} R _inst_1)))) (CategoryTheory.preadditiveYoneda.{u2, u3} C _inst_2 _inst_3)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Ring.{u1} R] (C : Type.{u3}) [_inst_2 : CategoryTheory.Category.{u2, u3} C] [_inst_3 : CategoryTheory.Preadditive.{u2, u3} C _inst_2] [_inst_4 : CategoryTheory.Linear.{u1, u2, u3} R (Ring.toSemiring.{u1} R _inst_1) C _inst_2 _inst_3], Eq.{max (succ u3) (succ (succ u2))} (CategoryTheory.Functor.{u2, max u3 u2, u3, max (max u3 u2) (succ u2)} C _inst_2 (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.Functor.comp.{u2, max u3 u2, max u3 u2, u3, max (max u3 (succ u2)) u1, max (max u3 u2) (succ u2)} C _inst_2 (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.linearYoneda.{u1, u2, u3} R _inst_1 C _inst_2 _inst_3 _inst_4) (Prefunctor.obj.{max (succ u2) (succ (max (succ u2) u1)), max (max (succ u2) (succ (max (succ u2) u1))) (succ u3), max (succ u2) u1, max (max (max (succ u2) u1) u2) u3} (CategoryTheory.Functor.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 (succ u2) u1, max (succ u2) u1} (CategoryTheory.Functor.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Category.toCategoryStruct.{max u2 (succ u2) u1, max (succ u2) u1} (CategoryTheory.Functor.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max (succ u2) u1) u3) u2, max (max (succ u2) u3) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.CategoryStruct.toQuiver.{max (max u2 (succ u2) u1) u3, max (max (max (succ u2) u1) u2) u3} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max (succ u2) u1) u3) u2, max (max (succ u2) u3) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.Category.toCategoryStruct.{max (max u2 (succ u2) u1) u3, max (max (max (succ u2) u1) u2) u3} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max (succ u2) u1) u3) u2, max (max (succ u2) u3) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max u3 (succ u2) u1) u2, max (max u3 (succ u2)) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})))) (CategoryTheory.Functor.toPrefunctor.{max u2 (succ u2) u1, max (max u2 (succ u2) u1) u3, max (succ u2) u1, max (max (max (succ u2) u1) u2) u3} (CategoryTheory.Functor.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max (succ u2) u1) u3) u2, max (max (succ u2) u3) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max u3 (succ u2) u1) u2, max (max u3 (succ u2)) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.whiskeringRight.{u3, u2, max (succ u2) u1, u2, succ u2, u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.forget₂.{max (succ u2) u1, succ u2, u2, u2, u2} (ModuleCat.{u2, u1} R _inst_1) AddCommGroupCat.{u2} (ModuleCat.moduleCategory.{u2, u1} R _inst_1) (ModuleCat.moduleConcreteCategory.{u2, u1} R _inst_1) AddCommGroupCat.largeCategory.{u2} AddCommGroupCat.concreteCategory.{u2} (ModuleCat.hasForgetToAddCommGroup.{u1, u2} R _inst_1)))) (CategoryTheory.preadditiveYoneda.{u2, u3} C _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align category_theory.whiskering_linear_yoneda₂ CategoryTheory.whiskering_linearYoneda₂ₓ'. -/
@[simp]
theorem whiskering_linearYoneda₂ :
    linearYoneda R C ⋙ (whiskeringRight _ _ _).obj (forget₂ (ModuleCat.{v} R) AddCommGroupCat.{v}) =
      preadditiveYoneda :=
  rfl
#align category_theory.whiskering_linear_yoneda₂ CategoryTheory.whiskering_linearYoneda₂

/- warning: category_theory.whiskering_linear_coyoneda -> CategoryTheory.whiskering_linearCoyoneda is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Ring.{u1} R] (C : Type.{u3}) [_inst_2 : CategoryTheory.Category.{u2, u3} C] [_inst_3 : CategoryTheory.Preadditive.{u2, u3} C _inst_2] [_inst_4 : CategoryTheory.Linear.{u1, u2, u3} R (Ring.toSemiring.{u1} R _inst_1) C _inst_2 _inst_3], Eq.{succ (max u2 (max u3 u2) u3 u2 u3 (succ u2))} (CategoryTheory.Functor.{u2, max u3 u2, u3, max u2 u3 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.comp.{u2, max u3 u2, max u3 u2, u3, max u2 u3 u1 (succ u2), max u2 u3 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.linearCoyoneda.{u1, u2, u3} R _inst_1 C _inst_2 _inst_3 _inst_4) (CategoryTheory.Functor.obj.{max (max u1 (succ u2)) u2, max (max u2 u3 u1 (succ u2)) u3 u2, max u2 u1 (succ u2), max (max u3 u2) (max u2 u3 u1 (succ u2)) u2 u3 (succ u2)} (CategoryTheory.Functor.{u2, u2, max u1 (succ u2), succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, max u1 (succ u2), succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u2 u3 u1 (succ u2), max u2 u3 (succ u2)} (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u2 u3 u1 (succ u2), max u2 u3 (succ u2)} (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.whiskeringRight.{u3, u2, max u1 (succ u2), u2, succ u2, u2} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.forget.{max u1 (succ u2), u2, u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) (ModuleCat.moduleConcreteCategory.{u2, u1} R _inst_1)))) (CategoryTheory.coyoneda.{u2, u3} C _inst_2)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Ring.{u1} R] (C : Type.{u3}) [_inst_2 : CategoryTheory.Category.{u2, u3} C] [_inst_3 : CategoryTheory.Preadditive.{u2, u3} C _inst_2] [_inst_4 : CategoryTheory.Linear.{u1, u2, u3} R (Ring.toSemiring.{u1} R _inst_1) C _inst_2 _inst_3], Eq.{max (succ u3) (succ (succ u2))} (CategoryTheory.Functor.{u2, max u3 u2, u3, max (max u3 u2) (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.comp.{u2, max u3 u2, max u3 u2, u3, max (max u3 (succ u2)) u1, max (max u3 u2) (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.linearCoyoneda.{u1, u2, u3} R _inst_1 C _inst_2 _inst_3 _inst_4) (Prefunctor.obj.{max (succ u2) (succ (max (succ u2) u1)), max (max (succ u2) (succ (max (succ u2) u1))) (succ u3), max (succ u2) u1, max (max (max (succ u2) u1) u2) u3} (CategoryTheory.Functor.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 (succ u2) u1, max (succ u2) u1} (CategoryTheory.Functor.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Category.toCategoryStruct.{max u2 (succ u2) u1, max (succ u2) u1} (CategoryTheory.Functor.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max (succ u2) u1) u3) u2, max (max (succ u2) u3) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.CategoryStruct.toQuiver.{max (max u2 (succ u2) u1) u3, max (max (max (succ u2) u1) u2) u3} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max (succ u2) u1) u3) u2, max (max (succ u2) u3) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Category.toCategoryStruct.{max (max u2 (succ u2) u1) u3, max (max (max (succ u2) u1) u2) u3} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max (succ u2) u1) u3) u2, max (max (succ u2) u3) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max u3 (succ u2) u1) u2, max (max u3 (succ u2)) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2})))) (CategoryTheory.Functor.toPrefunctor.{max u2 (succ u2) u1, max (max u2 (succ u2) u1) u3, max (succ u2) u1, max (max (max (succ u2) u1) u2) u3} (CategoryTheory.Functor.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max (succ u2) u1) u3) u2, max (max (succ u2) u3) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max u3 (succ u2) u1) u2, max (max u3 (succ u2)) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.whiskeringRight.{u3, u2, max (succ u2) u1, u2, succ u2, u2} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.forget.{max (succ u2) u1, u2, u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) (ModuleCat.moduleConcreteCategory.{u2, u1} R _inst_1)))) (CategoryTheory.coyoneda.{u2, u3} C _inst_2)
Case conversion may be inaccurate. Consider using '#align category_theory.whiskering_linear_coyoneda CategoryTheory.whiskering_linearCoyonedaₓ'. -/
@[simp]
theorem whiskering_linearCoyoneda :
    linearCoyoneda R C ⋙ (whiskeringRight _ _ _).obj (forget (ModuleCat.{v} R)) = coyoneda :=
  rfl
#align category_theory.whiskering_linear_coyoneda CategoryTheory.whiskering_linearCoyoneda

/- warning: category_theory.whiskering_linear_coyoneda₂ -> CategoryTheory.whiskering_linearCoyoneda₂ is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Ring.{u1} R] (C : Type.{u3}) [_inst_2 : CategoryTheory.Category.{u2, u3} C] [_inst_3 : CategoryTheory.Preadditive.{u2, u3} C _inst_2] [_inst_4 : CategoryTheory.Linear.{u1, u2, u3} R (Ring.toSemiring.{u1} R _inst_1) C _inst_2 _inst_3], Eq.{succ (max u2 (max u3 u2) u3 u2 u3 (succ u2))} (CategoryTheory.Functor.{u2, max u3 u2, u3, max u2 u3 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.Functor.comp.{u2, max u3 u2, max u3 u2, u3, max u2 u3 u1 (succ u2), max u2 u3 (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.linearCoyoneda.{u1, u2, u3} R _inst_1 C _inst_2 _inst_3 _inst_4) (CategoryTheory.Functor.obj.{max (max u1 (succ u2)) u2, max (max u2 u3 u1 (succ u2)) u3 u2, max u2 u1 (succ u2), max (max u3 u2) (max u2 u3 u1 (succ u2)) u2 u3 (succ u2)} (CategoryTheory.Functor.{u2, u2, max u1 (succ u2), succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, max u1 (succ u2), succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u2 u3 u1 (succ u2), max u2 u3 (succ u2)} (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u2 u3 u1 (succ u2), max u2 u3 (succ u2)} (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.whiskeringRight.{u3, u2, max u1 (succ u2), u2, succ u2, u2} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.forget₂.{max u1 (succ u2), succ u2, u2, u2, u2} (ModuleCat.{u2, u1} R _inst_1) AddCommGroupCat.{u2} (ModuleCat.moduleCategory.{u2, u1} R _inst_1) (ModuleCat.moduleConcreteCategory.{u2, u1} R _inst_1) AddCommGroupCat.largeCategory.{u2} AddCommGroupCat.concreteCategory.{u2} (ModuleCat.hasForgetToAddCommGroup.{u1, u2} R _inst_1)))) (CategoryTheory.preadditiveCoyoneda.{u2, u3} C _inst_2 _inst_3)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Ring.{u1} R] (C : Type.{u3}) [_inst_2 : CategoryTheory.Category.{u2, u3} C] [_inst_3 : CategoryTheory.Preadditive.{u2, u3} C _inst_2] [_inst_4 : CategoryTheory.Linear.{u1, u2, u3} R (Ring.toSemiring.{u1} R _inst_1) C _inst_2 _inst_3], Eq.{max (succ u3) (succ (succ u2))} (CategoryTheory.Functor.{u2, max u3 u2, u3, max (max u3 u2) (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.Functor.comp.{u2, max u3 u2, max u3 u2, u3, max (max u3 (succ u2)) u1, max (max u3 u2) (succ u2)} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_2) (CategoryTheory.Functor.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max u1 (succ u2)} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.linearCoyoneda.{u1, u2, u3} R _inst_1 C _inst_2 _inst_3 _inst_4) (Prefunctor.obj.{max (succ u2) (succ (max (succ u2) u1)), max (max (succ u2) (succ (max (succ u2) u1))) (succ u3), max (succ u2) u1, max (max (max (succ u2) u1) u2) u3} (CategoryTheory.Functor.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 (succ u2) u1, max (succ u2) u1} (CategoryTheory.Functor.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Category.toCategoryStruct.{max u2 (succ u2) u1, max (succ u2) u1} (CategoryTheory.Functor.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max (succ u2) u1) u3) u2, max (max (succ u2) u3) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.CategoryStruct.toQuiver.{max (max u2 (succ u2) u1) u3, max (max (max (succ u2) u1) u2) u3} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max (succ u2) u1) u3) u2, max (max (succ u2) u3) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.Category.toCategoryStruct.{max (max u2 (succ u2) u1) u3, max (max (max (succ u2) u1) u2) u3} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max (succ u2) u1) u3) u2, max (max (succ u2) u3) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max u3 (succ u2) u1) u2, max (max u3 (succ u2)) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})))) (CategoryTheory.Functor.toPrefunctor.{max u2 (succ u2) u1, max (max u2 (succ u2) u1) u3, max (succ u2) u1, max (max (max (succ u2) u1) u2) u3} (CategoryTheory.Functor.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, max (succ u2) u1, succ u2} (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max (succ u2) u1) u3) u2, max (max (succ u2) u3) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max u3 (succ u2) u1) u2, max (max u3 (succ u2)) u2} (CategoryTheory.Functor.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.category.{u2, u2, u3, max (succ u2) u1} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1)) (CategoryTheory.Functor.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2}) (CategoryTheory.Functor.category.{u2, u2, u3, succ u2} C _inst_2 AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.whiskeringRight.{u3, u2, max (succ u2) u1, u2, succ u2, u2} C _inst_2 (ModuleCat.{u2, u1} R _inst_1) (ModuleCat.moduleCategory.{u2, u1} R _inst_1) AddCommGroupCat.{u2} AddCommGroupCat.largeCategory.{u2})) (CategoryTheory.forget₂.{max (succ u2) u1, succ u2, u2, u2, u2} (ModuleCat.{u2, u1} R _inst_1) AddCommGroupCat.{u2} (ModuleCat.moduleCategory.{u2, u1} R _inst_1) (ModuleCat.moduleConcreteCategory.{u2, u1} R _inst_1) AddCommGroupCat.largeCategory.{u2} AddCommGroupCat.concreteCategory.{u2} (ModuleCat.hasForgetToAddCommGroup.{u1, u2} R _inst_1)))) (CategoryTheory.preadditiveCoyoneda.{u2, u3} C _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align category_theory.whiskering_linear_coyoneda₂ CategoryTheory.whiskering_linearCoyoneda₂ₓ'. -/
@[simp]
theorem whiskering_linearCoyoneda₂ :
    linearCoyoneda R C ⋙
        (whiskeringRight _ _ _).obj (forget₂ (ModuleCat.{v} R) AddCommGroupCat.{v}) =
      preadditiveCoyoneda :=
  rfl
#align category_theory.whiskering_linear_coyoneda₂ CategoryTheory.whiskering_linearCoyoneda₂

#print CategoryTheory.full_linearYoneda /-
instance full_linearYoneda : Full (linearYoneda R C) :=
  let yoneda_full :
    Full (linearYoneda R C ⋙ (whiskeringRight _ _ _).obj (forget (ModuleCat.{v} R))) :=
    Yoneda.yonedaFull
  full.of_comp_faithful (linear_yoneda R C)
    ((whiskering_right _ _ _).obj (forget (ModuleCat.{v} R)))
#align category_theory.linear_yoneda_full CategoryTheory.full_linearYoneda
-/

#print CategoryTheory.full_linearCoyoneda /-
instance full_linearCoyoneda : Full (linearCoyoneda R C) :=
  let coyoneda_full :
    Full (linearCoyoneda R C ⋙ (whiskeringRight _ _ _).obj (forget (ModuleCat.{v} R))) :=
    Coyoneda.coyonedaFull
  full.of_comp_faithful (linear_coyoneda R C)
    ((whiskering_right _ _ _).obj (forget (ModuleCat.{v} R)))
#align category_theory.linear_coyoneda_full CategoryTheory.full_linearCoyoneda
-/

#print CategoryTheory.faithful_linearYoneda /-
instance faithful_linearYoneda : Faithful (linearYoneda R C) :=
  Faithful.of_comp_eq (whiskering_linearYoneda R C)
#align category_theory.linear_yoneda_faithful CategoryTheory.faithful_linearYoneda
-/

#print CategoryTheory.faithful_linearCoyoneda /-
instance faithful_linearCoyoneda : Faithful (linearCoyoneda R C) :=
  Faithful.of_comp_eq (whiskering_linearCoyoneda R C)
#align category_theory.linear_coyoneda_faithful CategoryTheory.faithful_linearCoyoneda
-/

end CategoryTheory

