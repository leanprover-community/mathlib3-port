/-
Copyright (c) 2021 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module category_theory.linear.linear_functor
! leanprover-community/mathlib commit 10bf4f825ad729c5653adc039dafa3622e7f93c9
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Preadditive.AdditiveFunctor
import Mathbin.CategoryTheory.Linear.Basic

/-!
# Linear Functors

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

An additive functor between two `R`-linear categories is called *linear*
if the induced map on hom types is a morphism of `R`-modules.

# Implementation details

`functor.linear` is a `Prop`-valued class, defined by saying that
for every two objects `X` and `Y`, the map
`F.map : (X ⟶ Y) → (F.obj X ⟶ F.obj Y)` is a morphism of `R`-modules.

-/


namespace CategoryTheory

variable (R : Type _) [Semiring R]

#print CategoryTheory.Functor.Linear /-
/-- An additive functor `F` is `R`-linear provided `F.map` is an `R`-module morphism. -/
class Functor.Linear {C D : Type _} [Category C] [Category D] [Preadditive C] [Preadditive D]
  [Linear R C] [Linear R D] (F : C ⥤ D) [F.Additive] : Prop where
  map_smul' : ∀ {X Y : C} {f : X ⟶ Y} {r : R}, F.map (r • f) = r • F.map f := by obviously
#align category_theory.functor.linear CategoryTheory.Functor.Linear
-/

section Linear

namespace Functor

section

variable {R} {C D : Type _} [Category C] [Category D] [Preadditive C] [Preadditive D]
  [CategoryTheory.Linear R C] [CategoryTheory.Linear R D] (F : C ⥤ D) [Additive F] [Linear R F]

/- warning: category_theory.functor.map_smul -> CategoryTheory.Functor.map_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {C : Type.{u2}} {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u2} C] [_inst_3 : CategoryTheory.Category.{u5, u3} D] [_inst_4 : CategoryTheory.Preadditive.{u4, u2} C _inst_2] [_inst_5 : CategoryTheory.Preadditive.{u5, u3} D _inst_3] [_inst_6 : CategoryTheory.Linear.{u1, u4, u2} R _inst_1 C _inst_2 _inst_4] [_inst_7 : CategoryTheory.Linear.{u1, u5, u3} R _inst_1 D _inst_3 _inst_5] (F : CategoryTheory.Functor.{u4, u5, u2, u3} C _inst_2 D _inst_3) [_inst_8 : CategoryTheory.Functor.Additive.{u2, u3, u4, u5} C D _inst_2 _inst_3 _inst_4 _inst_5 F] [_inst_9 : CategoryTheory.Functor.Linear.{u1, u2, u3, u4, u5} R _inst_1 C D _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 F _inst_8] {X : C} {Y : C} (r : R) (f : Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y), Eq.{succ u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (CategoryTheory.Functor.map.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X Y (SMul.smul.{u1, u4} R (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (SMulZeroClass.toHasSmul.{u1, u4} R (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (AddZeroClass.toHasZero.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (AddMonoid.toAddZeroClass.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (AddCommMonoid.toAddMonoid.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (AddCommGroup.toAddCommMonoid.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (CategoryTheory.Preadditive.homGroup.{u4, u2} C _inst_2 _inst_4 X Y))))) (SMulWithZero.toSmulZeroClass.{u1, u4} R (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (AddMonoid.toAddZeroClass.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (AddCommMonoid.toAddMonoid.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (AddCommGroup.toAddCommMonoid.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (CategoryTheory.Preadditive.homGroup.{u4, u2} C _inst_2 _inst_4 X Y))))) (MulActionWithZero.toSMulWithZero.{u1, u4} R (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (AddMonoid.toAddZeroClass.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (AddCommMonoid.toAddMonoid.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (AddCommGroup.toAddCommMonoid.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (CategoryTheory.Preadditive.homGroup.{u4, u2} C _inst_2 _inst_4 X Y))))) (Module.toMulActionWithZero.{u1, u4} R (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) _inst_1 (AddCommGroup.toAddCommMonoid.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (CategoryTheory.Preadditive.homGroup.{u4, u2} C _inst_2 _inst_4 X Y)) (CategoryTheory.Linear.homModule.{u1, u4, u2} R _inst_1 C _inst_2 _inst_4 _inst_6 X Y))))) r f)) (SMul.smul.{u1, u5} R (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (SMulZeroClass.toHasSmul.{u1, u5} R (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (AddZeroClass.toHasZero.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (AddMonoid.toAddZeroClass.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (AddCommMonoid.toAddMonoid.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (AddCommGroup.toAddCommMonoid.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (CategoryTheory.Preadditive.homGroup.{u5, u3} D _inst_3 _inst_5 (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)))))) (SMulWithZero.toSmulZeroClass.{u1, u5} R (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (AddMonoid.toAddZeroClass.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (AddCommMonoid.toAddMonoid.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (AddCommGroup.toAddCommMonoid.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (CategoryTheory.Preadditive.homGroup.{u5, u3} D _inst_3 _inst_5 (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)))))) (MulActionWithZero.toSMulWithZero.{u1, u5} R (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (AddMonoid.toAddZeroClass.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (AddCommMonoid.toAddMonoid.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (AddCommGroup.toAddCommMonoid.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (CategoryTheory.Preadditive.homGroup.{u5, u3} D _inst_3 _inst_5 (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)))))) (Module.toMulActionWithZero.{u1, u5} R (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) _inst_1 (AddCommGroup.toAddCommMonoid.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (CategoryTheory.Preadditive.homGroup.{u5, u3} D _inst_3 _inst_5 (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y))) (CategoryTheory.Linear.homModule.{u1, u5, u3} R _inst_1 D _inst_3 _inst_5 _inst_7 (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)))))) r (CategoryTheory.Functor.map.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X Y f))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {C : Type.{u4}} {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{u5, u4} C] [_inst_3 : CategoryTheory.Category.{u3, u2} D] [_inst_4 : CategoryTheory.Preadditive.{u5, u4} C _inst_2] [_inst_5 : CategoryTheory.Preadditive.{u3, u2} D _inst_3] [_inst_6 : CategoryTheory.Linear.{u1, u5, u4} R _inst_1 C _inst_2 _inst_4] [_inst_7 : CategoryTheory.Linear.{u1, u3, u2} R _inst_1 D _inst_3 _inst_5] (F : CategoryTheory.Functor.{u5, u3, u4, u2} C _inst_2 D _inst_3) [_inst_8 : CategoryTheory.Functor.Additive.{u4, u2, u5, u3} C D _inst_2 _inst_3 _inst_4 _inst_5 F] [_inst_9 : CategoryTheory.Functor.Linear.{u1, u4, u2, u5, u3} R _inst_1 C D _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 F _inst_8] {X : C} {Y : C} (r : R) (f : Quiver.Hom.{succ u5, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) X Y), Eq.{succ u3} (Quiver.Hom.{succ u3, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) Y)) (Prefunctor.map.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) X Y (HSMul.hSMul.{u1, u5, u5} R (Quiver.Hom.{succ u5, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) X Y) (Quiver.Hom.{succ u5, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) X Y) (instHSMul.{u1, u5} R (Quiver.Hom.{succ u5, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) X Y) (SMulZeroClass.toSMul.{u1, u5} R (Quiver.Hom.{succ u5, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) X Y) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u5, u4} C _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u5, u4} C _inst_2 _inst_4) X Y) (SMulWithZero.toSMulZeroClass.{u1, u5} R (Quiver.Hom.{succ u5, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) X Y) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u5, u4} C _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u5, u4} C _inst_2 _inst_4) X Y) (MulActionWithZero.toSMulWithZero.{u1, u5} R (Quiver.Hom.{succ u5, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) X Y) (Semiring.toMonoidWithZero.{u1} R _inst_1) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u5, u4} C _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u5, u4} C _inst_2 _inst_4) X Y) (Module.toMulActionWithZero.{u1, u5} R (Quiver.Hom.{succ u5, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) X Y) _inst_1 (AddCommGroup.toAddCommMonoid.{u5} (Quiver.Hom.{succ u5, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) X Y) (CategoryTheory.Preadditive.homGroup.{u5, u4} C _inst_2 _inst_4 X Y)) (CategoryTheory.Linear.homModule.{u1, u5, u4} R _inst_1 C _inst_2 _inst_4 _inst_6 X Y)))))) r f)) (HSMul.hSMul.{u1, u3, u3} R (Quiver.Hom.{succ u3, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) Y)) (Quiver.Hom.{succ u3, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) Y)) (instHSMul.{u1, u3} R (Quiver.Hom.{succ u3, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) Y)) (SMulZeroClass.toSMul.{u1, u3} R (Quiver.Hom.{succ u3, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) Y)) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u3, u2} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u3, u2} D _inst_3 _inst_5) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) Y)) (SMulWithZero.toSMulZeroClass.{u1, u3} R (Quiver.Hom.{succ u3, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) Y)) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u3, u2} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u3, u2} D _inst_3 _inst_5) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) Y)) (MulActionWithZero.toSMulWithZero.{u1, u3} R (Quiver.Hom.{succ u3, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) Y)) (Semiring.toMonoidWithZero.{u1} R _inst_1) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u3, u2} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u3, u2} D _inst_3 _inst_5) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) Y)) (Module.toMulActionWithZero.{u1, u3} R (Quiver.Hom.{succ u3, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) Y)) _inst_1 (AddCommGroup.toAddCommMonoid.{u3} (Quiver.Hom.{succ u3, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) Y)) (CategoryTheory.Preadditive.homGroup.{u3, u2} D _inst_3 _inst_5 (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) Y))) (CategoryTheory.Linear.homModule.{u1, u3, u2} R _inst_1 D _inst_3 _inst_5 _inst_7 (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) Y))))))) r (Prefunctor.map.{succ u5, succ u3, u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u4} C (CategoryTheory.Category.toCategoryStruct.{u5, u4} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} D (CategoryTheory.Category.toCategoryStruct.{u3, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u3, u4, u2} C _inst_2 D _inst_3 F) X Y f))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.map_smul CategoryTheory.Functor.map_smulₓ'. -/
@[simp]
theorem map_smul {X Y : C} (r : R) (f : X ⟶ Y) : F.map (r • f) = r • F.map f :=
  Functor.Linear.map_smul'
#align category_theory.functor.map_smul CategoryTheory.Functor.map_smul

instance : Linear R (𝟭 C) where

instance {E : Type _} [Category E] [Preadditive E] [CategoryTheory.Linear R E] (G : D ⥤ E)
    [Additive G] [Linear R G] : Linear R (F ⋙ G) where

variable (R)

/- warning: category_theory.functor.map_linear_map -> CategoryTheory.Functor.mapLinearMap is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {C : Type.{u2}} {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u2} C] [_inst_3 : CategoryTheory.Category.{u5, u3} D] [_inst_4 : CategoryTheory.Preadditive.{u4, u2} C _inst_2] [_inst_5 : CategoryTheory.Preadditive.{u5, u3} D _inst_3] [_inst_6 : CategoryTheory.Linear.{u1, u4, u2} R _inst_1 C _inst_2 _inst_4] [_inst_7 : CategoryTheory.Linear.{u1, u5, u3} R _inst_1 D _inst_3 _inst_5] (F : CategoryTheory.Functor.{u4, u5, u2, u3} C _inst_2 D _inst_3) [_inst_8 : CategoryTheory.Functor.Additive.{u2, u3, u4, u5} C D _inst_2 _inst_3 _inst_4 _inst_5 F] [_inst_9 : CategoryTheory.Functor.Linear.{u1, u2, u3, u4, u5} R _inst_1 C D _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 F _inst_8] {X : C} {Y : C}, LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (AddCommGroup.toAddCommMonoid.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (CategoryTheory.Preadditive.homGroup.{u4, u2} C _inst_2 _inst_4 X Y)) (AddCommGroup.toAddCommMonoid.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (CategoryTheory.Preadditive.homGroup.{u5, u3} D _inst_3 _inst_5 (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y))) (CategoryTheory.Linear.homModule.{u1, u4, u2} R _inst_1 C _inst_2 _inst_4 _inst_6 X Y) (CategoryTheory.Linear.homModule.{u1, u5, u3} R _inst_1 D _inst_3 _inst_5 _inst_7 (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {C : Type.{u2}} {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u2} C] [_inst_3 : CategoryTheory.Category.{u5, u3} D] [_inst_4 : CategoryTheory.Preadditive.{u4, u2} C _inst_2] [_inst_5 : CategoryTheory.Preadditive.{u5, u3} D _inst_3] [_inst_6 : CategoryTheory.Linear.{u1, u4, u2} R _inst_1 C _inst_2 _inst_4] [_inst_7 : CategoryTheory.Linear.{u1, u5, u3} R _inst_1 D _inst_3 _inst_5] (F : CategoryTheory.Functor.{u4, u5, u2, u3} C _inst_2 D _inst_3) [_inst_8 : CategoryTheory.Functor.Additive.{u2, u3, u4, u5} C D _inst_2 _inst_3 _inst_4 _inst_5 F] [_inst_9 : CategoryTheory.Functor.Linear.{u1, u2, u3, u4, u5} R _inst_1 C D _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 F _inst_8] {X : C} {Y : C}, LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (Prefunctor.obj.{succ u4, succ u5, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u4, u5, u2, u3} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u4, succ u5, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u4, u5, u2, u3} C _inst_2 D _inst_3 F) Y)) (AddCommGroup.toAddCommMonoid.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (CategoryTheory.Preadditive.homGroup.{u4, u2} C _inst_2 _inst_4 X Y)) (AddCommGroup.toAddCommMonoid.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (Prefunctor.obj.{succ u4, succ u5, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u4, u5, u2, u3} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u4, succ u5, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u4, u5, u2, u3} C _inst_2 D _inst_3 F) Y)) (CategoryTheory.Preadditive.homGroup.{u5, u3} D _inst_3 _inst_5 (Prefunctor.obj.{succ u4, succ u5, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u4, u5, u2, u3} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u4, succ u5, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u4, u5, u2, u3} C _inst_2 D _inst_3 F) Y))) (CategoryTheory.Linear.homModule.{u1, u4, u2} R _inst_1 C _inst_2 _inst_4 _inst_6 X Y) (CategoryTheory.Linear.homModule.{u1, u5, u3} R _inst_1 D _inst_3 _inst_5 _inst_7 (Prefunctor.obj.{succ u4, succ u5, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u4, u5, u2, u3} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u4, succ u5, u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u4, u5, u2, u3} C _inst_2 D _inst_3 F) Y))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.map_linear_map CategoryTheory.Functor.mapLinearMapₓ'. -/
/-- `F.map_linear_map` is an `R`-linear map whose underlying function is `F.map`. -/
@[simps]
def mapLinearMap {X Y : C} : (X ⟶ Y) →ₗ[R] F.obj X ⟶ F.obj Y :=
  { F.mapAddHom with map_smul' := fun r f => F.map_smul r f }
#align category_theory.functor.map_linear_map CategoryTheory.Functor.mapLinearMap

/- warning: category_theory.functor.coe_map_linear_map -> CategoryTheory.Functor.coe_mapLinearMap is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {C : Type.{u2}} {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u2} C] [_inst_3 : CategoryTheory.Category.{u5, u3} D] [_inst_4 : CategoryTheory.Preadditive.{u4, u2} C _inst_2] [_inst_5 : CategoryTheory.Preadditive.{u5, u3} D _inst_3] [_inst_6 : CategoryTheory.Linear.{u1, u4, u2} R _inst_1 C _inst_2 _inst_4] [_inst_7 : CategoryTheory.Linear.{u1, u5, u3} R _inst_1 D _inst_3 _inst_5] (F : CategoryTheory.Functor.{u4, u5, u2, u3} C _inst_2 D _inst_3) [_inst_8 : CategoryTheory.Functor.Additive.{u2, u3, u4, u5} C D _inst_2 _inst_3 _inst_4 _inst_5 F] [_inst_9 : CategoryTheory.Functor.Linear.{u1, u2, u3, u4, u5} R _inst_1 C D _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 F _inst_8] {X : C} {Y : C}, Eq.{max (succ u4) (succ u5)} ((Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) -> (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y))) (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (AddCommGroup.toAddCommMonoid.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (CategoryTheory.Preadditive.homGroup.{u4, u2} C _inst_2 _inst_4 X Y)) (AddCommGroup.toAddCommMonoid.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (CategoryTheory.Preadditive.homGroup.{u5, u3} D _inst_3 _inst_5 (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y))) (CategoryTheory.Linear.homModule.{u1, u4, u2} R _inst_1 C _inst_2 _inst_4 _inst_6 X Y) (CategoryTheory.Linear.homModule.{u1, u5, u3} R _inst_1 D _inst_3 _inst_5 _inst_7 (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y))) (fun (_x : LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (AddCommGroup.toAddCommMonoid.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (CategoryTheory.Preadditive.homGroup.{u4, u2} C _inst_2 _inst_4 X Y)) (AddCommGroup.toAddCommMonoid.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (CategoryTheory.Preadditive.homGroup.{u5, u3} D _inst_3 _inst_5 (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y))) (CategoryTheory.Linear.homModule.{u1, u4, u2} R _inst_1 C _inst_2 _inst_4 _inst_6 X Y) (CategoryTheory.Linear.homModule.{u1, u5, u3} R _inst_1 D _inst_3 _inst_5 _inst_7 (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y))) => (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) -> (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y))) (LinearMap.hasCoeToFun.{u1, u1, u4, u5} R R (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u4} (Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_2)) X Y) (CategoryTheory.Preadditive.homGroup.{u4, u2} C _inst_2 _inst_4 X Y)) (AddCommGroup.toAddCommMonoid.{u5} (Quiver.Hom.{succ u5, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} D (CategoryTheory.Category.toCategoryStruct.{u5, u3} D _inst_3)) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (CategoryTheory.Preadditive.homGroup.{u5, u3} D _inst_3 _inst_5 (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y))) (CategoryTheory.Linear.homModule.{u1, u4, u2} R _inst_1 C _inst_2 _inst_4 _inst_6 X Y) (CategoryTheory.Linear.homModule.{u1, u5, u3} R _inst_1 D _inst_3 _inst_5 _inst_7 (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X) (CategoryTheory.Functor.obj.{u4, u5, u2, u3} C _inst_2 D _inst_3 F Y)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (CategoryTheory.Functor.mapLinearMap.{u1, u2, u3, u4, u5} R _inst_1 C D _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 F _inst_8 _inst_9 X Y)) (CategoryTheory.Functor.map.{u4, u5, u2, u3} C _inst_2 D _inst_3 F X Y)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {C : Type.{u3}} {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{u5, u3} C] [_inst_3 : CategoryTheory.Category.{u4, u2} D] [_inst_4 : CategoryTheory.Preadditive.{u5, u3} C _inst_2] [_inst_5 : CategoryTheory.Preadditive.{u4, u2} D _inst_3] [_inst_6 : CategoryTheory.Linear.{u1, u5, u3} R _inst_1 C _inst_2 _inst_4] [_inst_7 : CategoryTheory.Linear.{u1, u4, u2} R _inst_1 D _inst_3 _inst_5] (F : CategoryTheory.Functor.{u5, u4, u3, u2} C _inst_2 D _inst_3) [_inst_8 : CategoryTheory.Functor.Additive.{u3, u2, u5, u4} C D _inst_2 _inst_3 _inst_4 _inst_5 F] [_inst_9 : CategoryTheory.Functor.Linear.{u1, u3, u2, u5, u4} R _inst_1 C D _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 F _inst_8] {X : C} {Y : C}, Eq.{max (succ u5) (succ u4)} (forall (ᾰ : Quiver.Hom.{succ u5, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) X Y), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : Quiver.Hom.{succ u5, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) X Y) => Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) Y)) ᾰ) (FunLike.coe.{max (succ u5) (succ u4), succ u5, succ u4} (LinearMap.{u1, u1, u5, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Quiver.Hom.{succ u5, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) X Y) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) Y)) (AddCommGroup.toAddCommMonoid.{u5} (Quiver.Hom.{succ u5, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) X Y) (CategoryTheory.Preadditive.homGroup.{u5, u3} C _inst_2 _inst_4 X Y)) (AddCommGroup.toAddCommMonoid.{u4} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) Y)) (CategoryTheory.Preadditive.homGroup.{u4, u2} D _inst_3 _inst_5 (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) Y))) (CategoryTheory.Linear.homModule.{u1, u5, u3} R _inst_1 C _inst_2 _inst_4 _inst_6 X Y) (CategoryTheory.Linear.homModule.{u1, u4, u2} R _inst_1 D _inst_3 _inst_5 _inst_7 (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) Y))) (Quiver.Hom.{succ u5, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) X Y) (fun (_x : Quiver.Hom.{succ u5, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) X Y) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : Quiver.Hom.{succ u5, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) X Y) => Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) Y)) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u5, u4} R R (Quiver.Hom.{succ u5, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) X Y) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) Y)) _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u5} (Quiver.Hom.{succ u5, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) X Y) (CategoryTheory.Preadditive.homGroup.{u5, u3} C _inst_2 _inst_4 X Y)) (AddCommGroup.toAddCommMonoid.{u4} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) Y)) (CategoryTheory.Preadditive.homGroup.{u4, u2} D _inst_3 _inst_5 (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) Y))) (CategoryTheory.Linear.homModule.{u1, u5, u3} R _inst_1 C _inst_2 _inst_4 _inst_6 X Y) (CategoryTheory.Linear.homModule.{u1, u4, u2} R _inst_1 D _inst_3 _inst_5 _inst_7 (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) X) (Prefunctor.obj.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) Y)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (CategoryTheory.Functor.mapLinearMap.{u1, u3, u2, u5, u4} R _inst_1 C D _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 F _inst_8 _inst_9 X Y)) (Prefunctor.map.{succ u5, succ u4, u3, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u3} C (CategoryTheory.Category.toCategoryStruct.{u5, u3} C _inst_2)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u5, u4, u3, u2} C _inst_2 D _inst_3 F) X Y)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.coe_map_linear_map CategoryTheory.Functor.coe_mapLinearMapₓ'. -/
theorem coe_mapLinearMap {X Y : C} : ⇑(F.mapLinearMap R : (X ⟶ Y) →ₗ[R] _) = @map C _ D _ F X Y :=
  rfl
#align category_theory.functor.coe_map_linear_map CategoryTheory.Functor.coe_mapLinearMap

end

section InducedCategory

variable {C : Type _} {D : Type _} [Category D] [Preadditive D] [CategoryTheory.Linear R D]
  (F : C → D)

#print CategoryTheory.Functor.inducedFunctorLinear /-
instance inducedFunctorLinear : Functor.Linear R (inducedFunctor F) where
#align category_theory.functor.induced_functor_linear CategoryTheory.Functor.inducedFunctorLinear
-/

end InducedCategory

/- warning: category_theory.functor.full_subcategory_inclusion_linear -> CategoryTheory.Functor.fullSubcategoryInclusionLinear is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {C : Type.{u2}} [_inst_2 : CategoryTheory.Category.{u3, u2} C] [_inst_3 : CategoryTheory.Preadditive.{u3, u2} C _inst_2] [_inst_4 : CategoryTheory.Linear.{u1, u3, u2} R _inst_1 C _inst_2 _inst_3] (Z : C -> Prop), CategoryTheory.Functor.Linear.{u1, u2, u2, u3, u3} R _inst_1 (CategoryTheory.FullSubcategoryₓ.{u3, u2} C _inst_2 Z) C (CategoryTheory.InducedCategory.category.{u3, u2, u2} (CategoryTheory.FullSubcategoryₓ.{u3, u2} C _inst_2 Z) C _inst_2 (CategoryTheory.FullSubcategoryₓ.obj.{u3, u2} C _inst_2 Z)) _inst_2 (CategoryTheory.Preadditive.fullSubcategory.{u3, u2} C _inst_2 _inst_3 Z) _inst_3 (CategoryTheory.Linear.fullSubcategory.{u1, u3, u2} C _inst_2 _inst_3 R _inst_1 _inst_4 Z) _inst_4 (CategoryTheory.fullSubcategoryInclusion.{u3, u2} C _inst_2 Z) (CategoryTheory.Functor.fullSubcategoryInclusion_additive.{u2, u3} C _inst_2 _inst_3 Z)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {C : Type.{u2}} [_inst_2 : CategoryTheory.Category.{u3, u2} C] [_inst_3 : CategoryTheory.Preadditive.{u3, u2} C _inst_2] [_inst_4 : CategoryTheory.Linear.{u1, u3, u2} R _inst_1 C _inst_2 _inst_3] (Z : C -> Prop), CategoryTheory.Functor.Linear.{u1, u2, u2, u3, u3} R _inst_1 (CategoryTheory.FullSubcategory.{u2} C Z) C (CategoryTheory.FullSubcategory.category.{u3, u2} C _inst_2 Z) _inst_2 (CategoryTheory.Preadditive.fullSubcategory.{u3, u2} C _inst_2 _inst_3 Z) _inst_3 (CategoryTheory.Linear.fullSubcategory.{u1, u3, u2} C _inst_2 _inst_3 R _inst_1 _inst_4 Z) _inst_4 (CategoryTheory.fullSubcategoryInclusion.{u3, u2} C _inst_2 Z) (CategoryTheory.Functor.fullSubcategoryInclusion_additive.{u2, u3} C _inst_2 _inst_3 Z)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.full_subcategory_inclusion_linear CategoryTheory.Functor.fullSubcategoryInclusionLinearₓ'. -/
instance fullSubcategoryInclusionLinear {C : Type _} [Category C] [Preadditive C]
    [CategoryTheory.Linear R C] (Z : C → Prop) : (fullSubcategoryInclusion Z).Linear R where
#align category_theory.functor.full_subcategory_inclusion_linear CategoryTheory.Functor.fullSubcategoryInclusionLinear

section

variable {R} {C D : Type _} [Category C] [Category D] [Preadditive C] [Preadditive D] (F : C ⥤ D)
  [Additive F]

#print CategoryTheory.Functor.natLinear /-
instance natLinear : F.Linear ℕ where map_smul' X Y f r := F.mapAddHom.map_nsmul f r
#align category_theory.functor.nat_linear CategoryTheory.Functor.natLinear
-/

/- warning: category_theory.functor.int_linear -> CategoryTheory.Functor.intLinear is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{u3, u1} C] [_inst_3 : CategoryTheory.Category.{u4, u2} D] [_inst_4 : CategoryTheory.Preadditive.{u3, u1} C _inst_2] [_inst_5 : CategoryTheory.Preadditive.{u4, u2} D _inst_3] (F : CategoryTheory.Functor.{u3, u4, u1, u2} C _inst_2 D _inst_3) [_inst_6 : CategoryTheory.Functor.Additive.{u1, u2, u3, u4} C D _inst_2 _inst_3 _inst_4 _inst_5 F], CategoryTheory.Functor.Linear.{0, u1, u2, u3, u4} Int Int.semiring C D _inst_2 _inst_3 _inst_4 _inst_5 (CategoryTheory.Linear.preadditiveIntLinear.{u3, u1} C _inst_2 _inst_4) (CategoryTheory.Linear.preadditiveIntLinear.{u4, u2} D _inst_3 _inst_5) F _inst_6
but is expected to have type
  forall {C : Type.{u1}} {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{u3, u1} C] [_inst_3 : CategoryTheory.Category.{u4, u2} D] [_inst_4 : CategoryTheory.Preadditive.{u3, u1} C _inst_2] [_inst_5 : CategoryTheory.Preadditive.{u4, u2} D _inst_3] (F : CategoryTheory.Functor.{u3, u4, u1, u2} C _inst_2 D _inst_3) [_inst_6 : CategoryTheory.Functor.Additive.{u1, u2, u3, u4} C D _inst_2 _inst_3 _inst_4 _inst_5 F], CategoryTheory.Functor.Linear.{0, u1, u2, u3, u4} Int Int.instSemiringInt C D _inst_2 _inst_3 _inst_4 _inst_5 (CategoryTheory.Linear.preadditiveIntLinear.{u3, u1} C _inst_2 _inst_4) (CategoryTheory.Linear.preadditiveIntLinear.{u4, u2} D _inst_3 _inst_5) F _inst_6
Case conversion may be inaccurate. Consider using '#align category_theory.functor.int_linear CategoryTheory.Functor.intLinearₓ'. -/
instance intLinear : F.Linear ℤ
    where map_smul' X Y f r := (F.mapAddHom : (X ⟶ Y) →+ (F.obj X ⟶ F.obj Y)).map_zsmul f r
#align category_theory.functor.int_linear CategoryTheory.Functor.intLinear

variable [CategoryTheory.Linear ℚ C] [CategoryTheory.Linear ℚ D]

#print CategoryTheory.Functor.ratLinear /-
instance ratLinear : F.Linear ℚ where map_smul' X Y f r := F.mapAddHom.toRatLinearMap.map_smul r f
#align category_theory.functor.rat_linear CategoryTheory.Functor.ratLinear
-/

end

end Functor

namespace Equivalence

variable {C D : Type _} [Category C] [Category D] [Preadditive C] [Linear R C] [Preadditive D]
  [Linear R D]

/- warning: category_theory.equivalence.inverse_linear -> CategoryTheory.Equivalence.inverseLinear is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {C : Type.{u2}} {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u2} C] [_inst_3 : CategoryTheory.Category.{u5, u3} D] [_inst_4 : CategoryTheory.Preadditive.{u4, u2} C _inst_2] [_inst_5 : CategoryTheory.Linear.{u1, u4, u2} R _inst_1 C _inst_2 _inst_4] [_inst_6 : CategoryTheory.Preadditive.{u5, u3} D _inst_3] [_inst_7 : CategoryTheory.Linear.{u1, u5, u3} R _inst_1 D _inst_3 _inst_6] (e : CategoryTheory.Equivalence.{u4, u5, u2, u3} C _inst_2 D _inst_3) [_inst_8 : CategoryTheory.Functor.Additive.{u2, u3, u4, u5} C D _inst_2 _inst_3 _inst_4 _inst_6 (CategoryTheory.Equivalence.functor.{u4, u5, u2, u3} C _inst_2 D _inst_3 e)] [_inst_9 : CategoryTheory.Functor.Linear.{u1, u2, u3, u4, u5} R _inst_1 C D _inst_2 _inst_3 _inst_4 _inst_6 _inst_5 _inst_7 (CategoryTheory.Equivalence.functor.{u4, u5, u2, u3} C _inst_2 D _inst_3 e) _inst_8], CategoryTheory.Functor.Linear.{u1, u3, u2, u5, u4} R _inst_1 D C _inst_3 _inst_2 _inst_6 _inst_4 _inst_7 _inst_5 (CategoryTheory.Equivalence.inverse.{u4, u5, u2, u3} C _inst_2 D _inst_3 e) (CategoryTheory.Equivalence.inverse_additive.{u2, u3, u4, u5} C D _inst_2 _inst_3 _inst_4 _inst_6 e _inst_8)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {C : Type.{u2}} {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u2} C] [_inst_3 : CategoryTheory.Category.{u5, u3} D] [_inst_4 : CategoryTheory.Preadditive.{u4, u2} C _inst_2] [_inst_5 : CategoryTheory.Linear.{u1, u4, u2} R _inst_1 C _inst_2 _inst_4] [_inst_6 : CategoryTheory.Preadditive.{u5, u3} D _inst_3] [_inst_7 : CategoryTheory.Linear.{u1, u5, u3} R _inst_1 D _inst_3 _inst_6] (e : CategoryTheory.Equivalence.{u4, u5, u2, u3} C D _inst_2 _inst_3) [_inst_8 : CategoryTheory.Functor.Additive.{u2, u3, u4, u5} C D _inst_2 _inst_3 _inst_4 _inst_6 (CategoryTheory.Equivalence.functor.{u4, u5, u2, u3} C D _inst_2 _inst_3 e)] [_inst_9 : CategoryTheory.Functor.Linear.{u1, u2, u3, u4, u5} R _inst_1 C D _inst_2 _inst_3 _inst_4 _inst_6 _inst_5 _inst_7 (CategoryTheory.Equivalence.functor.{u4, u5, u2, u3} C D _inst_2 _inst_3 e) _inst_8], CategoryTheory.Functor.Linear.{u1, u3, u2, u5, u4} R _inst_1 D C _inst_3 _inst_2 _inst_6 _inst_4 _inst_7 _inst_5 (CategoryTheory.Equivalence.inverse.{u4, u5, u2, u3} C D _inst_2 _inst_3 e) (CategoryTheory.Equivalence.inverse_additive.{u2, u3, u4, u5} C D _inst_2 _inst_3 _inst_4 _inst_6 e _inst_8)
Case conversion may be inaccurate. Consider using '#align category_theory.equivalence.inverse_linear CategoryTheory.Equivalence.inverseLinearₓ'. -/
instance inverseLinear (e : C ≌ D) [e.Functor.Additive] [e.Functor.Linear R] : e.inverse.Linear R
    where map_smul' X Y r f := by
    apply e.functor.map_injective
    simp
#align category_theory.equivalence.inverse_linear CategoryTheory.Equivalence.inverseLinear

end Equivalence

end Linear

end CategoryTheory

