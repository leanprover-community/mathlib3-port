/-
Copyright (c) 2020 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta, Scott Morrison

! This file was ported from Lean 3 source module category_theory.subobject.lattice
! leanprover-community/mathlib commit ce38d86c0b2d427ce208c3cee3159cb421d2b3c4
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Subobject.FactorThru
import Mathbin.CategoryTheory.Subobject.WellPowered

/-!
# The lattice of subobjects

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We provide the `semilattice_inf` with `order_top (subobject X)` instance when `[has_pullback C]`,
and the `semilattice_sup (subobject X)` instance when `[has_images C] [has_binary_coproducts C]`.
-/


universe v₁ v₂ u₁ u₂

noncomputable section

open CategoryTheory CategoryTheory.Category CategoryTheory.Limits

variable {C : Type u₁} [Category.{v₁} C] {X Y Z : C}

variable {D : Type u₂} [Category.{v₂} D]

namespace CategoryTheory

namespace MonoOver

section Top

instance {X : C} : Top (MonoOver X) where top := mk' (𝟙 _)

instance {X : C} : Inhabited (MonoOver X) :=
  ⟨⊤⟩

#print CategoryTheory.MonoOver.leTop /-
/-- The morphism to the top object in `mono_over X`. -/
def leTop (f : MonoOver X) : f ⟶ ⊤ :=
  homMk f.arrow (comp_id _)
#align category_theory.mono_over.le_top CategoryTheory.MonoOver.leTop
-/

/- warning: category_theory.mono_over.top_left -> CategoryTheory.MonoOver.top_left is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (X : C), Eq.{succ u2} C ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 X)))) (Top.top.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.hasTop.{u1, u2} C _inst_1 X))) X
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (X : C), Eq.{succ u2} C (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 X) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 X) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (Top.top.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.instTopMonoOver.{u1, u2} C _inst_1 X)))) X
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.top_left CategoryTheory.MonoOver.top_leftₓ'. -/
@[simp]
theorem top_left (X : C) : ((⊤ : MonoOver X) : C) = X :=
  rfl
#align category_theory.mono_over.top_left CategoryTheory.MonoOver.top_left

/- warning: category_theory.mono_over.top_arrow -> CategoryTheory.MonoOver.top_arrow is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 X)))) (Top.top.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.hasTop.{u1, u2} C _inst_1 X))) X) (CategoryTheory.MonoOver.arrow.{u1, u2} C _inst_1 X (Top.top.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.hasTop.{u1, u2} C _inst_1 X))) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 X) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 X) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (Top.top.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.instTopMonoOver.{u1, u2} C _inst_1 X)))) X) (CategoryTheory.MonoOver.arrow.{u1, u2} C _inst_1 X (Top.top.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.instTopMonoOver.{u1, u2} C _inst_1 X))) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X)
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.top_arrow CategoryTheory.MonoOver.top_arrowₓ'. -/
@[simp]
theorem top_arrow (X : C) : (⊤ : MonoOver X).arrow = 𝟙 X :=
  rfl
#align category_theory.mono_over.top_arrow CategoryTheory.MonoOver.top_arrow

/- warning: category_theory.mono_over.map_top -> CategoryTheory.MonoOver.mapTop is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], CategoryTheory.Iso.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y) (CategoryTheory.Functor.obj.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y) (CategoryTheory.MonoOver.map.{u1, u2} C _inst_1 X Y f _inst_3) (Top.top.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.hasTop.{u1, u2} C _inst_1 X))) (CategoryTheory.MonoOver.mk'.{u1, u2} C _inst_1 Y X f _inst_3)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], CategoryTheory.Iso.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 Y) (Prefunctor.obj.{succ u1, succ u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 Y))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.map.{u1, u2} C _inst_1 X Y f _inst_3)) (Top.top.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.instTopMonoOver.{u1, u2} C _inst_1 X))) (CategoryTheory.MonoOver.mk'.{u1, u2} C _inst_1 Y X f _inst_3)
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.map_top CategoryTheory.MonoOver.mapTopₓ'. -/
/-- `map f` sends `⊤ : mono_over X` to `⟨X, f⟩ : mono_over Y`. -/
def mapTop (f : X ⟶ Y) [Mono f] : (map f).obj ⊤ ≅ mk' f :=
  iso_of_both_ways (homMk (𝟙 _) rfl) (homMk (𝟙 _) (by simp [id_comp f]))
#align category_theory.mono_over.map_top CategoryTheory.MonoOver.mapTop

section

variable [HasPullbacks C]

/- warning: category_theory.mono_over.pullback_top -> CategoryTheory.MonoOver.pullbackTop is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), CategoryTheory.Iso.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X) (CategoryTheory.Functor.obj.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X) (CategoryTheory.MonoOver.pullback.{u1, u2} C _inst_1 X Y _inst_3 f) (Top.top.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.hasTop.{u1, u2} C _inst_1 Y))) (Top.top.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.hasTop.{u1, u2} C _inst_1 X))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), CategoryTheory.Iso.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X) (Prefunctor.obj.{succ u1, succ u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 Y))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.pullback.{u1, u2} C _inst_1 X Y _inst_3 f)) (Top.top.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.instTopMonoOver.{u1, u2} C _inst_1 Y))) (Top.top.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.instTopMonoOver.{u1, u2} C _inst_1 X))
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.pullback_top CategoryTheory.MonoOver.pullbackTopₓ'. -/
/-- The pullback of the top object in `mono_over Y`
is (isomorphic to) the top object in `mono_over X`. -/
def pullbackTop (f : X ⟶ Y) : (pullback f).obj ⊤ ≅ ⊤ :=
  iso_of_both_ways (leTop _) (homMk (pullback.lift f (𝟙 _) (by tidy)) (pullback.lift_snd _ _ _))
#align category_theory.mono_over.pullback_top CategoryTheory.MonoOver.pullbackTop

/- warning: category_theory.mono_over.top_le_pullback_self -> CategoryTheory.MonoOver.topLEPullbackSelf is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} {B : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f], Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (Top.top.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.hasTop.{u1, u2} C _inst_1 A)) (CategoryTheory.Functor.obj.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.MonoOver.pullback.{u1, u2} C _inst_1 A B _inst_3 f) (CategoryTheory.MonoOver.mk'.{u1, u2} C _inst_1 B A f _inst_4))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} {B : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f], Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (Top.top.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.instTopMonoOver.{u1, u2} C _inst_1 A)) (Prefunctor.obj.{succ u1, succ u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 B))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.pullback.{u1, u2} C _inst_1 A B _inst_3 f)) (CategoryTheory.MonoOver.mk'.{u1, u2} C _inst_1 B A f _inst_4))
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.top_le_pullback_self CategoryTheory.MonoOver.topLEPullbackSelfₓ'. -/
/-- There is a morphism from `⊤ : mono_over A` to the pullback of a monomorphism along itself;
as the category is thin this is an isomorphism. -/
def topLEPullbackSelf {A B : C} (f : A ⟶ B) [Mono f] :
    (⊤ : MonoOver A) ⟶ (pullback f).obj (mk' f) :=
  homMk _ (pullback.lift_snd _ _ rfl)
#align category_theory.mono_over.top_le_pullback_self CategoryTheory.MonoOver.topLEPullbackSelf

/- warning: category_theory.mono_over.pullback_self -> CategoryTheory.MonoOver.pullbackSelf is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} {B : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f], CategoryTheory.Iso.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.Functor.obj.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.MonoOver.pullback.{u1, u2} C _inst_1 A B _inst_3 f) (CategoryTheory.MonoOver.mk'.{u1, u2} C _inst_1 B A f _inst_4)) (Top.top.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.hasTop.{u1, u2} C _inst_1 A))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} {B : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f], CategoryTheory.Iso.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (Prefunctor.obj.{succ u1, succ u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 B))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.pullback.{u1, u2} C _inst_1 A B _inst_3 f)) (CategoryTheory.MonoOver.mk'.{u1, u2} C _inst_1 B A f _inst_4)) (Top.top.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.instTopMonoOver.{u1, u2} C _inst_1 A))
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.pullback_self CategoryTheory.MonoOver.pullbackSelfₓ'. -/
/-- The pullback of a monomorphism along itself is isomorphic to the top object. -/
def pullbackSelf {A B : C} (f : A ⟶ B) [Mono f] : (pullback f).obj (mk' f) ≅ ⊤ :=
  iso_of_both_ways (leTop _) (topLEPullbackSelf _)
#align category_theory.mono_over.pullback_self CategoryTheory.MonoOver.pullbackSelf

end

end Top

section Bot

variable [HasInitial C] [InitialMonoClass C]

instance {X : C} : Bot (MonoOver X) where bot := mk' (initial.to X)

/- warning: category_theory.mono_over.bot_left -> CategoryTheory.MonoOver.bot_left is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasInitial.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.InitialMonoClass.{u1, u2} C _inst_1] (X : C), Eq.{succ u2} C ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 X)))) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.hasBot.{u1, u2} C _inst_1 _inst_3 _inst_4 X))) (CategoryTheory.Limits.initial.{u1, u2} C _inst_1 _inst_3)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasInitial.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.InitialMonoClass.{u1, u2} C _inst_1] (X : C), Eq.{succ u2} C (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 X) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 X) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.instBotMonoOver.{u1, u2} C _inst_1 _inst_3 _inst_4 X)))) (CategoryTheory.Limits.initial.{u1, u2} C _inst_1 _inst_3)
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.bot_left CategoryTheory.MonoOver.bot_leftₓ'. -/
@[simp]
theorem bot_left (X : C) : ((⊥ : MonoOver X) : C) = ⊥_ C :=
  rfl
#align category_theory.mono_over.bot_left CategoryTheory.MonoOver.bot_left

/- warning: category_theory.mono_over.bot_arrow -> CategoryTheory.MonoOver.bot_arrow is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasInitial.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.InitialMonoClass.{u1, u2} C _inst_1] {X : C}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 X)))) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.hasBot.{u1, u2} C _inst_1 _inst_3 _inst_4 X))) X) (CategoryTheory.MonoOver.arrow.{u1, u2} C _inst_1 X (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.hasBot.{u1, u2} C _inst_1 _inst_3 _inst_4 X))) (CategoryTheory.Limits.initial.to.{u1, u2} C _inst_1 _inst_3 X)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasInitial.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.InitialMonoClass.{u1, u2} C _inst_1] {X : C}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 X) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 X) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.instBotMonoOver.{u1, u2} C _inst_1 _inst_3 _inst_4 X)))) X) (CategoryTheory.MonoOver.arrow.{u1, u2} C _inst_1 X (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.instBotMonoOver.{u1, u2} C _inst_1 _inst_3 _inst_4 X))) (CategoryTheory.Limits.initial.to.{u1, u2} C _inst_1 _inst_3 X)
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.bot_arrow CategoryTheory.MonoOver.bot_arrowₓ'. -/
@[simp]
theorem bot_arrow {X : C} : (⊥ : MonoOver X).arrow = initial.to X :=
  rfl
#align category_theory.mono_over.bot_arrow CategoryTheory.MonoOver.bot_arrow

#print CategoryTheory.MonoOver.botLE /-
/-- The (unique) morphism from `⊥ : mono_over X` to any other `f : mono_over X`. -/
def botLE {X : C} (f : MonoOver X) : ⊥ ⟶ f :=
  homMk (initial.to _) (by simp)
#align category_theory.mono_over.bot_le CategoryTheory.MonoOver.botLE
-/

/- warning: category_theory.mono_over.map_bot -> CategoryTheory.MonoOver.mapBot is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} [_inst_3 : CategoryTheory.Limits.HasInitial.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.InitialMonoClass.{u1, u2} C _inst_1] (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_5 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], CategoryTheory.Iso.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y) (CategoryTheory.Functor.obj.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y) (CategoryTheory.MonoOver.map.{u1, u2} C _inst_1 X Y f _inst_5) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.hasBot.{u1, u2} C _inst_1 _inst_3 _inst_4 X))) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.hasBot.{u1, u2} C _inst_1 _inst_3 _inst_4 Y))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} [_inst_3 : CategoryTheory.Limits.HasInitial.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.InitialMonoClass.{u1, u2} C _inst_1] (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_5 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], CategoryTheory.Iso.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 Y) (Prefunctor.obj.{succ u1, succ u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 Y))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.map.{u1, u2} C _inst_1 X Y f _inst_5)) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.instBotMonoOver.{u1, u2} C _inst_1 _inst_3 _inst_4 X))) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.instBotMonoOver.{u1, u2} C _inst_1 _inst_3 _inst_4 Y))
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.map_bot CategoryTheory.MonoOver.mapBotₓ'. -/
/-- `map f` sends `⊥ : mono_over X` to `⊥ : mono_over Y`. -/
def mapBot (f : X ⟶ Y) [Mono f] : (map f).obj ⊥ ≅ ⊥ :=
  iso_of_both_ways (homMk (initial.to _) (by simp)) (homMk (𝟙 _) (by simp))
#align category_theory.mono_over.map_bot CategoryTheory.MonoOver.mapBot

end Bot

section ZeroOrderBot

variable [HasZeroObject C]

open ZeroObject

/- warning: category_theory.mono_over.bot_coe_iso_zero -> CategoryTheory.MonoOver.botCoeIsoZero is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasZeroObject.{u1, u2} C _inst_1] {B : C}, CategoryTheory.Iso.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 B)))) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.hasBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B))) (OfNat.ofNat.{u2} C 0 (OfNat.mk.{u2} C 0 (Zero.zero.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasZeroObject.{u1, u2} C _inst_1] {B : C}, CategoryTheory.Iso.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 B) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 B) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) f)) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.instBotMonoOver.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) (OfNat.ofNat.{u2} C 0 (Zero.toOfNat0.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3)))
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.bot_coe_iso_zero CategoryTheory.MonoOver.botCoeIsoZeroₓ'. -/
/-- The object underlying `⊥ : subobject B` is (up to isomorphism) the zero object. -/
def botCoeIsoZero {B : C} : ((⊥ : MonoOver B) : C) ≅ 0 :=
  initialIsInitial.uniqueUpToIso HasZeroObject.zeroIsInitial
#align category_theory.mono_over.bot_coe_iso_zero CategoryTheory.MonoOver.botCoeIsoZero

/- warning: category_theory.mono_over.bot_arrow_eq_zero -> CategoryTheory.MonoOver.bot_arrow_eq_zero is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasZeroObject.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} C _inst_1] {B : C}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 B)))) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.hasBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B))) B) (CategoryTheory.MonoOver.arrow.{u1, u2} C _inst_1 B (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.hasBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B))) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 B)))) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.hasBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B))) B) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 B)))) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.hasBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B))) B) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 B)))) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.hasBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B))) B) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} C _inst_1 _inst_4 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 B)))) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.hasBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B))) B))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasZeroObject.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} C _inst_1] {B : C}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 B) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 B) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) f)) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.instBotMonoOver.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) B) (CategoryTheory.MonoOver.arrow.{u1, u2} C _inst_1 B (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.instBotMonoOver.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B))) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 B) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 B) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) f)) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.instBotMonoOver.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) B) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 B) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 B) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) f)) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.instBotMonoOver.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) B) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} C _inst_1 _inst_4 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 B) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 B) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 B) f)) (Bot.bot.{max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.instBotMonoOver.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) B)))
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.bot_arrow_eq_zero CategoryTheory.MonoOver.bot_arrow_eq_zeroₓ'. -/
@[simp]
theorem bot_arrow_eq_zero [HasZeroMorphisms C] {B : C} : (⊥ : MonoOver B).arrow = 0 :=
  zero_of_source_iso_zero _ botCoeIsoZero
#align category_theory.mono_over.bot_arrow_eq_zero CategoryTheory.MonoOver.bot_arrow_eq_zero

end ZeroOrderBot

section Inf

variable [HasPullbacks C]

#print CategoryTheory.MonoOver.inf /-
/-- When `[has_pullbacks C]`, `mono_over A` has "intersections", functorial in both arguments.

As `mono_over A` is only a preorder, this doesn't satisfy the axioms of `semilattice_inf`,
but we reuse all the names from `semilattice_inf` because they will be used to construct
`semilattice_inf (subobject A)` shortly.
-/
@[simps]
def inf {A : C} : MonoOver A ⥤ MonoOver A ⥤ MonoOver A
    where
  obj f := pullback f.arrow ⋙ map f.arrow
  map f₁ f₂ k :=
    {
      app := fun g => by
        apply hom_mk _ _
        apply pullback.lift pullback.fst (pullback.snd ≫ k.left) _
        rw [pullback.condition, assoc, w k]
        dsimp
        rw [pullback.lift_snd_assoc, assoc, w k] }
#align category_theory.mono_over.inf CategoryTheory.MonoOver.inf
-/

/- warning: category_theory.mono_over.inf_le_left -> CategoryTheory.MonoOver.infLELeft is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} (f : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (g : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A), Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Functor.obj.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.Functor.obj.{u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.MonoOver.inf.{u1, u2} C _inst_1 _inst_3 A) f) g) f
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} (f : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (g : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A), Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (Prefunctor.obj.{succ u1, succ u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.MonoOver.inf.{u1, u2} C _inst_1 _inst_3 A)) f)) g) f
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.inf_le_left CategoryTheory.MonoOver.infLELeftₓ'. -/
/-- A morphism from the "infimum" of two objects in `mono_over A` to the first object. -/
def infLELeft {A : C} (f g : MonoOver A) : (inf.obj f).obj g ⟶ f :=
  homMk _ rfl
#align category_theory.mono_over.inf_le_left CategoryTheory.MonoOver.infLELeft

/- warning: category_theory.mono_over.inf_le_right -> CategoryTheory.MonoOver.infLERight is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} (f : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (g : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A), Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Functor.obj.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.Functor.obj.{u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.MonoOver.inf.{u1, u2} C _inst_1 _inst_3 A) f) g) g
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} (f : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (g : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A), Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (Prefunctor.obj.{succ u1, succ u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.MonoOver.inf.{u1, u2} C _inst_1 _inst_3 A)) f)) g) g
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.inf_le_right CategoryTheory.MonoOver.infLERightₓ'. -/
/-- A morphism from the "infimum" of two objects in `mono_over A` to the second object. -/
def infLERight {A : C} (f g : MonoOver A) : (inf.obj f).obj g ⟶ g :=
  homMk _ pullback.condition
#align category_theory.mono_over.inf_le_right CategoryTheory.MonoOver.infLERight

/- warning: category_theory.mono_over.le_inf -> CategoryTheory.MonoOver.leInf is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} (f : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (g : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (h : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A), (Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) h f) -> (Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) h g) -> (Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) h (CategoryTheory.Functor.obj.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.Functor.obj.{u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.MonoOver.inf.{u1, u2} C _inst_1 _inst_3 A) f) g))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} (f : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (g : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (h : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A), (Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) h f) -> (Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) h g) -> (Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) h (Prefunctor.obj.{succ u1, succ u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.MonoOver.inf.{u1, u2} C _inst_1 _inst_3 A)) f)) g))
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.le_inf CategoryTheory.MonoOver.leInfₓ'. -/
/-- A morphism version of the `le_inf` axiom. -/
def leInf {A : C} (f g h : MonoOver A) : (h ⟶ f) → (h ⟶ g) → (h ⟶ (inf.obj f).obj g) :=
  by
  intro k₁ k₂
  refine' hom_mk (pullback.lift k₂.left k₁.left _) _
  rw [w k₁, w k₂]
  erw [pullback.lift_snd_assoc, w k₁]
#align category_theory.mono_over.le_inf CategoryTheory.MonoOver.leInf

end Inf

section Sup

variable [HasImages C] [HasBinaryCoproducts C]

/- warning: category_theory.mono_over.sup -> CategoryTheory.MonoOver.sup is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasBinaryCoproducts.{u1, u2} C _inst_1] {A : C}, CategoryTheory.Functor.{u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.InducedCategory.category.{u1, max u2 u1, max u2 u1} (CategoryTheory.FullSubcategoryₓ.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f))) (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (CategoryTheory.FullSubcategoryₓ.obj.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)))) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.InducedCategory.category.{u1, max u2 u1, max u2 u1} (CategoryTheory.FullSubcategoryₓ.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f))) (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (CategoryTheory.FullSubcategoryₓ.obj.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.InducedCategory.category.{u1, max u2 u1, max u2 u1} (CategoryTheory.FullSubcategoryₓ.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f))) (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (CategoryTheory.FullSubcategoryₓ.obj.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasBinaryCoproducts.{u1, u2} C _inst_1] {A : C}, CategoryTheory.Functor.{u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.sup CategoryTheory.MonoOver.supₓ'. -/
/-- When `[has_images C] [has_binary_coproducts C]`, `mono_over A` has a `sup` construction,
which is functorial in both arguments,
and which on `subobject A` will induce a `semilattice_sup`. -/
def sup {A : C} : MonoOver A ⥤ MonoOver A ⥤ MonoOver A :=
  curryObj ((forget A).Prod (forget A) ⋙ uncurry.obj Over.coprod ⋙ image)
#align category_theory.mono_over.sup CategoryTheory.MonoOver.sup

/- warning: category_theory.mono_over.le_sup_left -> CategoryTheory.MonoOver.leSupLeft is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasBinaryCoproducts.{u1, u2} C _inst_1] {A : C} (f : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (g : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A), Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) f (CategoryTheory.Functor.obj.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.InducedCategory.category.{u1, max u2 u1, max u2 u1} (CategoryTheory.FullSubcategoryₓ.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f))) (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (CategoryTheory.FullSubcategoryₓ.obj.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.Functor.obj.{u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.InducedCategory.category.{u1, max u2 u1, max u2 u1} (CategoryTheory.FullSubcategoryₓ.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f))) (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (CategoryTheory.FullSubcategoryₓ.obj.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)))) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.InducedCategory.category.{u1, max u2 u1, max u2 u1} (CategoryTheory.FullSubcategoryₓ.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f))) (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (CategoryTheory.FullSubcategoryₓ.obj.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.InducedCategory.category.{u1, max u2 u1, max u2 u1} (CategoryTheory.FullSubcategoryₓ.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f))) (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (CategoryTheory.FullSubcategoryₓ.obj.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.MonoOver.sup.{u1, u2} C _inst_1 _inst_3 _inst_4 A) f) g)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasBinaryCoproducts.{u1, u2} C _inst_1] {A : C} (f : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (g : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A), Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) f (Prefunctor.obj.{succ u1, succ u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.MonoOver.sup.{u1, u2} C _inst_1 _inst_3 _inst_4 A)) f)) g)
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.le_sup_left CategoryTheory.MonoOver.leSupLeftₓ'. -/
/-- A morphism version of `le_sup_left`. -/
def leSupLeft {A : C} (f g : MonoOver A) : f ⟶ (sup.obj f).obj g :=
  by
  refine' hom_mk (coprod.inl ≫ factor_thru_image _) _
  erw [category.assoc, image.fac, coprod.inl_desc]
  rfl
#align category_theory.mono_over.le_sup_left CategoryTheory.MonoOver.leSupLeft

/- warning: category_theory.mono_over.le_sup_right -> CategoryTheory.MonoOver.leSupRight is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasBinaryCoproducts.{u1, u2} C _inst_1] {A : C} (f : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (g : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A), Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) g (CategoryTheory.Functor.obj.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.InducedCategory.category.{u1, max u2 u1, max u2 u1} (CategoryTheory.FullSubcategoryₓ.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f))) (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (CategoryTheory.FullSubcategoryₓ.obj.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.Functor.obj.{u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.InducedCategory.category.{u1, max u2 u1, max u2 u1} (CategoryTheory.FullSubcategoryₓ.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f))) (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (CategoryTheory.FullSubcategoryₓ.obj.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)))) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.InducedCategory.category.{u1, max u2 u1, max u2 u1} (CategoryTheory.FullSubcategoryₓ.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f))) (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (CategoryTheory.FullSubcategoryₓ.obj.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.InducedCategory.category.{u1, max u2 u1, max u2 u1} (CategoryTheory.FullSubcategoryₓ.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f))) (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (CategoryTheory.FullSubcategoryₓ.obj.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.MonoOver.sup.{u1, u2} C _inst_1 _inst_3 _inst_4 A) f) g)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasBinaryCoproducts.{u1, u2} C _inst_1] {A : C} (f : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (g : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A), Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) g (Prefunctor.obj.{succ u1, succ u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.MonoOver.sup.{u1, u2} C _inst_1 _inst_3 _inst_4 A)) f)) g)
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.le_sup_right CategoryTheory.MonoOver.leSupRightₓ'. -/
/-- A morphism version of `le_sup_right`. -/
def leSupRight {A : C} (f g : MonoOver A) : g ⟶ (sup.obj f).obj g :=
  by
  refine' hom_mk (coprod.inr ≫ factor_thru_image _) _
  erw [category.assoc, image.fac, coprod.inr_desc]
  rfl
#align category_theory.mono_over.le_sup_right CategoryTheory.MonoOver.leSupRight

/- warning: category_theory.mono_over.sup_le -> CategoryTheory.MonoOver.supLe is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasBinaryCoproducts.{u1, u2} C _inst_1] {A : C} (f : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (g : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (h : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A), (Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) f h) -> (Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) g h) -> (Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Functor.obj.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.InducedCategory.category.{u1, max u2 u1, max u2 u1} (CategoryTheory.FullSubcategoryₓ.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f))) (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (CategoryTheory.FullSubcategoryₓ.obj.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A) (CategoryTheory.Functor.obj.{u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.InducedCategory.category.{u1, max u2 u1, max u2 u1} (CategoryTheory.FullSubcategoryₓ.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f))) (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (CategoryTheory.FullSubcategoryₓ.obj.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)))) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.InducedCategory.category.{u1, max u2 u1, max u2 u1} (CategoryTheory.FullSubcategoryₓ.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f))) (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (CategoryTheory.FullSubcategoryₓ.obj.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.InducedCategory.category.{u1, max u2 u1, max u2 u1} (CategoryTheory.FullSubcategoryₓ.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f))) (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (CategoryTheory.FullSubcategoryₓ.obj.{u1, max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (CategoryTheory.Over.category.{u2, u1} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.MonoOver.sup.{u1, u2} C _inst_1 _inst_3 _inst_4 A) f) g) h)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasBinaryCoproducts.{u1, u2} C _inst_1] {A : C} (f : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (g : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (h : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A), (Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) f h) -> (Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) g h) -> (Quiver.Hom.{succ u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (Prefunctor.obj.{succ u1, succ u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.Functor.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.Functor.category.{u1, u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) (CategoryTheory.MonoOver.sup.{u1, u2} C _inst_1 _inst_3 _inst_4 A)) f)) g) h)
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.sup_le CategoryTheory.MonoOver.supLeₓ'. -/
/-- A morphism version of `sup_le`. -/
def supLe {A : C} (f g h : MonoOver A) : (f ⟶ h) → (g ⟶ h) → ((sup.obj f).obj g ⟶ h) :=
  by
  intro k₁ k₂
  refine' hom_mk _ _
  apply image.lift ⟨_, h.arrow, coprod.desc k₁.left k₂.left, _⟩
  · dsimp
    ext1
    · simp [w k₁]
    · simp [w k₂]
  · apply image.lift_fac
#align category_theory.mono_over.sup_le CategoryTheory.MonoOver.supLe

end Sup

end MonoOver

namespace Subobject

section OrderTop

#print CategoryTheory.Subobject.orderTop /-
instance orderTop {X : C} : OrderTop (Subobject X)
    where
  top := Quotient.mk'' ⊤
  le_top := by
    refine' Quotient.ind' fun f => _
    exact ⟨mono_over.le_top f⟩
#align category_theory.subobject.order_top CategoryTheory.Subobject.orderTop
-/

instance {X : C} : Inhabited (Subobject X) :=
  ⟨⊤⟩

/- warning: category_theory.subobject.top_eq_id -> CategoryTheory.Subobject.top_eq_id is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (B : C), Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B B (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B) (CategoryTheory.CategoryStruct.id.mono.{u1, u2} C _inst_1 B))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (B : C), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderTop.toTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B B (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B) (CategoryTheory.instMonoIdToCategoryStruct.{u1, u2} C _inst_1 B))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.top_eq_id CategoryTheory.Subobject.top_eq_idₓ'. -/
theorem top_eq_id (B : C) : (⊤ : Subobject B) = Subobject.mk (𝟙 B) :=
  rfl
#align category_theory.subobject.top_eq_id CategoryTheory.Subobject.top_eq_id

/- warning: category_theory.subobject.underlying_iso_top_hom -> CategoryTheory.Subobject.underlyingIso_top_hom is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B B (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B) (CategoryTheory.CategoryStruct.id.mono.{u1, u2} C _inst_1 B))) B) (CategoryTheory.Iso.hom.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B B (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B) (CategoryTheory.CategoryStruct.id.mono.{u1, u2} C _inst_1 B))) B (CategoryTheory.Subobject.underlyingIso.{u1, u2} C _inst_1 B B (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B) (CategoryTheory.CategoryStruct.id.mono.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 B))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B B (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B) (CategoryTheory.instMonoIdToCategoryStruct.{u1, u2} C _inst_1 B))) B) (CategoryTheory.Iso.hom.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B B (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B) (CategoryTheory.instMonoIdToCategoryStruct.{u1, u2} C _inst_1 B))) B (CategoryTheory.Subobject.underlyingIso.{u1, u2} C _inst_1 B B (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B) (CategoryTheory.instMonoIdToCategoryStruct.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderTop.toTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 B))))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.underlying_iso_top_hom CategoryTheory.Subobject.underlyingIso_top_homₓ'. -/
theorem underlyingIso_top_hom {B : C} : (underlyingIso (𝟙 B)).Hom = (⊤ : Subobject B).arrow :=
  by
  convert underlying_iso_hom_comp_eq_mk (𝟙 B)
  simp only [comp_id]
#align category_theory.subobject.underlying_iso_top_hom CategoryTheory.Subobject.underlyingIso_top_hom

/- warning: category_theory.subobject.top_arrow_is_iso -> CategoryTheory.Subobject.top_arrow_isIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C}, CategoryTheory.IsIso.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 B)))) B (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 B))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C}, CategoryTheory.IsIso.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderTop.toTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 B)))) B (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderTop.toTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 B))))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.top_arrow_is_iso CategoryTheory.Subobject.top_arrow_isIsoₓ'. -/
instance top_arrow_isIso {B : C} : IsIso (⊤ : Subobject B).arrow :=
  by
  rw [← underlying_iso_top_hom]
  infer_instance
#align category_theory.subobject.top_arrow_is_iso CategoryTheory.Subobject.top_arrow_isIso

/- warning: category_theory.subobject.underlying_iso_inv_top_arrow -> CategoryTheory.Subobject.underlyingIso_inv_top_arrow is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) B B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B B (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B) (CategoryTheory.CategoryStruct.id.mono.{u1, u2} C _inst_1 B))) B (CategoryTheory.Iso.inv.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B B (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B) (CategoryTheory.CategoryStruct.id.mono.{u1, u2} C _inst_1 B))) B (CategoryTheory.Subobject.underlyingIso.{u1, u2} C _inst_1 B B (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B) (CategoryTheory.CategoryStruct.id.mono.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 B))))) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) B B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B B (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B) (CategoryTheory.instMonoIdToCategoryStruct.{u1, u2} C _inst_1 B))) B (CategoryTheory.Iso.inv.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B B (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B) (CategoryTheory.instMonoIdToCategoryStruct.{u1, u2} C _inst_1 B))) B (CategoryTheory.Subobject.underlyingIso.{u1, u2} C _inst_1 B B (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B) (CategoryTheory.instMonoIdToCategoryStruct.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderTop.toTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 B))))) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) B)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.underlying_iso_inv_top_arrow CategoryTheory.Subobject.underlyingIso_inv_top_arrowₓ'. -/
@[simp, reassoc.1]
theorem underlyingIso_inv_top_arrow {B : C} :
    (underlyingIso _).inv ≫ (⊤ : Subobject B).arrow = 𝟙 B :=
  underlyingIso_arrow _
#align category_theory.subobject.underlying_iso_inv_top_arrow CategoryTheory.Subobject.underlyingIso_inv_top_arrow

/- warning: category_theory.subobject.map_top -> CategoryTheory.Subobject.map_top is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 X Y f _inst_3) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 X)))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 X Y f _inst_3)) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (OrderTop.toTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 X)))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.map_top CategoryTheory.Subobject.map_topₓ'. -/
@[simp]
theorem map_top (f : X ⟶ Y) [Mono f] : (map f).obj ⊤ = Subobject.mk f :=
  Quotient.sound' ⟨MonoOver.mapTop f⟩
#align category_theory.subobject.map_top CategoryTheory.Subobject.map_top

/- warning: category_theory.subobject.top_factors -> CategoryTheory.Subobject.top_factors is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {A : C} {B : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B), CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 B))) f
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {A : C} {B : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B), CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderTop.toTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 B))) f
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.top_factors CategoryTheory.Subobject.top_factorsₓ'. -/
theorem top_factors {A B : C} (f : A ⟶ B) : (⊤ : Subobject B).Factors f :=
  ⟨f, comp_id _⟩
#align category_theory.subobject.top_factors CategoryTheory.Subobject.top_factors

/- warning: category_theory.subobject.is_iso_iff_mk_eq_top -> CategoryTheory.Subobject.isIso_iff_mk_eq_top is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], Iff (CategoryTheory.IsIso.{u1, u2} C _inst_1 X Y f) (Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 Y))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], Iff (CategoryTheory.IsIso.{u1, u2} C _inst_1 X Y f) (Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderTop.toTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 Y))))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.is_iso_iff_mk_eq_top CategoryTheory.Subobject.isIso_iff_mk_eq_topₓ'. -/
theorem isIso_iff_mk_eq_top {X Y : C} (f : X ⟶ Y) [Mono f] : IsIso f ↔ mk f = ⊤ :=
  ⟨fun _ => mk_eq_mk_of_comm _ _ (as_iso f) (category.comp_id _), fun h =>
    by
    rw [← of_mk_le_mk_comp h.le, category.comp_id]
    exact is_iso.of_iso (iso_of_mk_eq_mk _ _ h)⟩
#align category_theory.subobject.is_iso_iff_mk_eq_top CategoryTheory.Subobject.isIso_iff_mk_eq_top

/- warning: category_theory.subobject.is_iso_arrow_iff_eq_top -> CategoryTheory.Subobject.isIso_arrow_iff_eq_top is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {Y : C} (P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y), Iff (CategoryTheory.IsIso.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) P) Y (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y P)) (Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) P (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 Y))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {Y : C} (P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y), Iff (CategoryTheory.IsIso.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) P) Y (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y P)) (Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) P (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderTop.toTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 Y))))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.is_iso_arrow_iff_eq_top CategoryTheory.Subobject.isIso_arrow_iff_eq_topₓ'. -/
theorem isIso_arrow_iff_eq_top {Y : C} (P : Subobject Y) : IsIso P.arrow ↔ P = ⊤ := by
  rw [is_iso_iff_mk_eq_top, mk_arrow]
#align category_theory.subobject.is_iso_arrow_iff_eq_top CategoryTheory.Subobject.isIso_arrow_iff_eq_top

/- warning: category_theory.subobject.is_iso_top_arrow -> CategoryTheory.Subobject.isIso_top_arrow is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {Y : C}, CategoryTheory.IsIso.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 Y)))) Y (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 Y))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {Y : C}, CategoryTheory.IsIso.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderTop.toTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 Y)))) Y (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderTop.toTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 Y))))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.is_iso_top_arrow CategoryTheory.Subobject.isIso_top_arrowₓ'. -/
instance isIso_top_arrow {Y : C} : IsIso (⊤ : Subobject Y).arrow := by rw [is_iso_arrow_iff_eq_top]
#align category_theory.subobject.is_iso_top_arrow CategoryTheory.Subobject.isIso_top_arrow

/- warning: category_theory.subobject.mk_eq_top_of_is_iso -> CategoryTheory.Subobject.mk_eq_top_of_isIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_3 : CategoryTheory.IsIso.{u1, u2} C _inst_1 X Y f], Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f (CategoryTheory.mono_of_strongMono.{u1, u2} C _inst_1 X Y f (CategoryTheory.strongMono_of_isIso.{u1, u2} C _inst_1 X Y f _inst_3))) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 Y)))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_3 : CategoryTheory.IsIso.{u1, u2} C _inst_1 X Y f], Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f (CategoryTheory.mono_of_strongMono.{u1, u2} C _inst_1 X Y f (CategoryTheory.strongMono_of_isIso.{u1, u2} C _inst_1 X Y f _inst_3))) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderTop.toTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 Y)))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.mk_eq_top_of_is_iso CategoryTheory.Subobject.mk_eq_top_of_isIsoₓ'. -/
theorem mk_eq_top_of_isIso {X Y : C} (f : X ⟶ Y) [IsIso f] : mk f = ⊤ :=
  (isIso_iff_mk_eq_top f).mp inferInstance
#align category_theory.subobject.mk_eq_top_of_is_iso CategoryTheory.Subobject.mk_eq_top_of_isIso

/- warning: category_theory.subobject.eq_top_of_is_iso_arrow -> CategoryTheory.Subobject.eq_top_of_isIso_arrow is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {Y : C} (P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) [_inst_3 : CategoryTheory.IsIso.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) P) Y (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y P)], Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) P (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 Y)))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {Y : C} (P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) [_inst_3 : CategoryTheory.IsIso.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) P) Y (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y P)], Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) P (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderTop.toTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 Y)))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.eq_top_of_is_iso_arrow CategoryTheory.Subobject.eq_top_of_isIso_arrowₓ'. -/
theorem eq_top_of_isIso_arrow {Y : C} (P : Subobject Y) [IsIso P.arrow] : P = ⊤ :=
  (isIso_arrow_iff_eq_top P).mp inferInstance
#align category_theory.subobject.eq_top_of_is_iso_arrow CategoryTheory.Subobject.eq_top_of_isIso_arrow

section

variable [HasPullbacks C]

/- warning: category_theory.subobject.pullback_top -> CategoryTheory.Subobject.pullback_top is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 X Y _inst_3 f) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 Y)))) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 X)))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 X Y _inst_3 f)) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderTop.toTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 Y)))) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (OrderTop.toTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 X)))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.pullback_top CategoryTheory.Subobject.pullback_topₓ'. -/
theorem pullback_top (f : X ⟶ Y) : (pullback f).obj ⊤ = ⊤ :=
  Quotient.sound' ⟨MonoOver.pullbackTop f⟩
#align category_theory.subobject.pullback_top CategoryTheory.Subobject.pullback_top

/- warning: category_theory.subobject.pullback_self -> CategoryTheory.Subobject.pullback_self is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} {B : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f], Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 A B _inst_3 f) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_4)) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 A))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 A)))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} {B : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f], Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 A B _inst_3 f)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_4)) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (OrderTop.toTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 A)))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.pullback_self CategoryTheory.Subobject.pullback_selfₓ'. -/
theorem pullback_self {A B : C} (f : A ⟶ B) [Mono f] : (pullback f).obj (mk f) = ⊤ :=
  Quotient.sound' ⟨MonoOver.pullbackSelf f⟩
#align category_theory.subobject.pullback_self CategoryTheory.Subobject.pullback_self

end

end OrderTop

section OrderBot

variable [HasInitial C] [InitialMonoClass C]

#print CategoryTheory.Subobject.orderBot /-
instance orderBot {X : C} : OrderBot (Subobject X)
    where
  bot := Quotient.mk'' ⊥
  bot_le := by
    refine' Quotient.ind' fun f => _
    exact ⟨mono_over.bot_le f⟩
#align category_theory.subobject.order_bot CategoryTheory.Subobject.orderBot
-/

/- warning: category_theory.subobject.bot_eq_initial_to -> CategoryTheory.Subobject.bot_eq_initial_to is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasInitial.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.InitialMonoClass.{u1, u2} C _inst_1] {B : C}, Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toHasBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 _inst_3 _inst_4 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B (CategoryTheory.Limits.initial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.initial.to.{u1, u2} C _inst_1 _inst_3 B) (CategoryTheory.Limits.initial.mono_from.{u1, u2} C _inst_1 _inst_3 _inst_4 B (CategoryTheory.Limits.initial.to.{u1, u2} C _inst_1 _inst_3 B)))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasInitial.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.InitialMonoClass.{u1, u2} C _inst_1] {B : C}, Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 _inst_3 _inst_4 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B (CategoryTheory.Limits.initial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.initial.to.{u1, u2} C _inst_1 _inst_3 B) (CategoryTheory.Limits.initial.mono_from.{u1, u2} C _inst_1 _inst_3 _inst_4 B (CategoryTheory.Limits.initial.to.{u1, u2} C _inst_1 _inst_3 B)))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.bot_eq_initial_to CategoryTheory.Subobject.bot_eq_initial_toₓ'. -/
theorem bot_eq_initial_to {B : C} : (⊥ : Subobject B) = Subobject.mk (initial.to B) :=
  rfl
#align category_theory.subobject.bot_eq_initial_to CategoryTheory.Subobject.bot_eq_initial_to

/- warning: category_theory.subobject.bot_coe_iso_initial -> CategoryTheory.Subobject.botCoeIsoInitial is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasInitial.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.InitialMonoClass.{u1, u2} C _inst_1] {B : C}, CategoryTheory.Iso.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toHasBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 _inst_3 _inst_4 B)))) (CategoryTheory.Limits.initial.{u1, u2} C _inst_1 _inst_3)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasInitial.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.InitialMonoClass.{u1, u2} C _inst_1] {B : C}, CategoryTheory.Iso.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 _inst_3 _inst_4 B)))) (CategoryTheory.Limits.initial.{u1, u2} C _inst_1 _inst_3)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.bot_coe_iso_initial CategoryTheory.Subobject.botCoeIsoInitialₓ'. -/
/-- The object underlying `⊥ : subobject B` is (up to isomorphism) the initial object. -/
def botCoeIsoInitial {B : C} : ((⊥ : Subobject B) : C) ≅ ⊥_ C :=
  underlyingIso _
#align category_theory.subobject.bot_coe_iso_initial CategoryTheory.Subobject.botCoeIsoInitial

/- warning: category_theory.subobject.map_bot -> CategoryTheory.Subobject.map_bot is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} [_inst_3 : CategoryTheory.Limits.HasInitial.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.InitialMonoClass.{u1, u2} C _inst_1] (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_5 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 X Y f _inst_5) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (OrderBot.toHasBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 _inst_3 _inst_4 X)))) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderBot.toHasBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 _inst_3 _inst_4 Y)))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} [_inst_3 : CategoryTheory.Limits.HasInitial.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.InitialMonoClass.{u1, u2} C _inst_1] (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_5 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 X Y f _inst_5)) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (OrderBot.toBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 _inst_3 _inst_4 X)))) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderBot.toBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 _inst_3 _inst_4 Y)))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.map_bot CategoryTheory.Subobject.map_botₓ'. -/
theorem map_bot (f : X ⟶ Y) [Mono f] : (map f).obj ⊥ = ⊥ :=
  Quotient.sound' ⟨MonoOver.mapBot f⟩
#align category_theory.subobject.map_bot CategoryTheory.Subobject.map_bot

end OrderBot

section ZeroOrderBot

variable [HasZeroObject C]

open ZeroObject

/- warning: category_theory.subobject.bot_coe_iso_zero -> CategoryTheory.Subobject.botCoeIsoZero is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasZeroObject.{u1, u2} C _inst_1] {B : C}, CategoryTheory.Iso.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toHasBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) (OfNat.ofNat.{u2} C 0 (OfNat.mk.{u2} C 0 (Zero.zero.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasZeroObject.{u1, u2} C _inst_1] {B : C}, CategoryTheory.Iso.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) (OfNat.ofNat.{u2} C 0 (Zero.toOfNat0.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3)))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.bot_coe_iso_zero CategoryTheory.Subobject.botCoeIsoZeroₓ'. -/
/-- The object underlying `⊥ : subobject B` is (up to isomorphism) the zero object. -/
def botCoeIsoZero {B : C} : ((⊥ : Subobject B) : C) ≅ 0 :=
  botCoeIsoInitial ≪≫ initialIsInitial.uniqueUpToIso HasZeroObject.zeroIsInitial
#align category_theory.subobject.bot_coe_iso_zero CategoryTheory.Subobject.botCoeIsoZero

variable [HasZeroMorphisms C]

/- warning: category_theory.subobject.bot_eq_zero -> CategoryTheory.Subobject.bot_eq_zero is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasZeroObject.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} C _inst_1] {B : C}, Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toHasBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B (OfNat.ofNat.{u2} C 0 (OfNat.mk.{u2} C 0 (Zero.zero.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3)))) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Zero.zero.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3)) B) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Zero.zero.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3)) B) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Zero.zero.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3)) B) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} C _inst_1 _inst_4 (Zero.zero.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3)) B)))) (CategoryTheory.Limits.HasZeroObject.CategoryTheory.mono.{u1, u2} C _inst_1 _inst_3 B (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Zero.zero.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3)) B) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Zero.zero.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3)) B) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Zero.zero.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3)) B) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} C _inst_1 _inst_4 (Zero.zero.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3)) B))))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasZeroObject.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} C _inst_1] {B : C}, Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B (OfNat.ofNat.{u2} C 0 (Zero.toOfNat0.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3))) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (OfNat.ofNat.{u2} C 0 (Zero.toOfNat0.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3))) B) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (OfNat.ofNat.{u2} C 0 (Zero.toOfNat0.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3))) B) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} C _inst_1 _inst_4 (OfNat.ofNat.{u2} C 0 (Zero.toOfNat0.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3))) B))) (CategoryTheory.Limits.HasZeroObject.instMonoOfNat.{u1, u2} C _inst_1 _inst_3 B (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (OfNat.ofNat.{u2} C 0 (Zero.toOfNat0.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3))) B) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (OfNat.ofNat.{u2} C 0 (Zero.toOfNat0.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3))) B) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} C _inst_1 _inst_4 (OfNat.ofNat.{u2} C 0 (Zero.toOfNat0.{u2} C (CategoryTheory.Limits.HasZeroObject.zero'.{u1, u2} C _inst_1 _inst_3))) B)))))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.bot_eq_zero CategoryTheory.Subobject.bot_eq_zeroₓ'. -/
theorem bot_eq_zero {B : C} : (⊥ : Subobject B) = Subobject.mk (0 : 0 ⟶ B) :=
  mk_eq_mk_of_comm _ _ (initialIsInitial.uniqueUpToIso HasZeroObject.zeroIsInitial) (by simp)
#align category_theory.subobject.bot_eq_zero CategoryTheory.Subobject.bot_eq_zero

/- warning: category_theory.subobject.bot_arrow -> CategoryTheory.Subobject.bot_arrow is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasZeroObject.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} C _inst_1] {B : C}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toHasBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) B) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toHasBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toHasBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) B) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toHasBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) B) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toHasBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) B) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} C _inst_1 _inst_4 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toHasBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) B))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasZeroObject.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} C _inst_1] {B : C}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) B) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) B) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) B) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} C _inst_1 _inst_4 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B)))) B)))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.bot_arrow CategoryTheory.Subobject.bot_arrowₓ'. -/
@[simp]
theorem bot_arrow {B : C} : (⊥ : Subobject B).arrow = 0 :=
  zero_of_source_iso_zero _ botCoeIsoZero
#align category_theory.subobject.bot_arrow CategoryTheory.Subobject.bot_arrow

/- warning: category_theory.subobject.bot_factors_iff_zero -> CategoryTheory.Subobject.bot_factors_iff_zero is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasZeroObject.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} C _inst_1] {A : C} {B : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B), Iff (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toHasBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B))) f) (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) f (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} C _inst_1 _inst_4 A B)))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasZeroObject.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} C _inst_1] {A : C} {B : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B), Iff (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (OrderBot.toBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) B))) f) (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) f (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} C _inst_1 _inst_4 A B))))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.bot_factors_iff_zero CategoryTheory.Subobject.bot_factors_iff_zeroₓ'. -/
theorem bot_factors_iff_zero {A B : C} (f : A ⟶ B) : (⊥ : Subobject B).Factors f ↔ f = 0 :=
  ⟨by
    rintro ⟨h, rfl⟩
    simp, by
    rintro rfl
    exact ⟨0, by simp⟩⟩
#align category_theory.subobject.bot_factors_iff_zero CategoryTheory.Subobject.bot_factors_iff_zero

/- warning: category_theory.subobject.mk_eq_bot_iff_zero -> CategoryTheory.Subobject.mk_eq_bot_iff_zero is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} [_inst_3 : CategoryTheory.Limits.HasZeroObject.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} C _inst_1] {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y} [_inst_5 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], Iff (Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_5) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderBot.toHasBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) Y)))) (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) f (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} C _inst_1 _inst_4 X Y)))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} [_inst_3 : CategoryTheory.Limits.HasZeroObject.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} C _inst_1] {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y} [_inst_5 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], Iff (Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_5) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (OrderBot.toBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} C _inst_1 _inst_3) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} C _inst_1 _inst_3) Y)))) (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) f (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} C _inst_1 _inst_4 X Y))))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.mk_eq_bot_iff_zero CategoryTheory.Subobject.mk_eq_bot_iff_zeroₓ'. -/
theorem mk_eq_bot_iff_zero {f : X ⟶ Y} [Mono f] : Subobject.mk f = ⊥ ↔ f = 0 :=
  ⟨fun h => by simpa [h, bot_factors_iff_zero] using mk_factors_self f, fun h =>
    mk_eq_mk_of_comm _ _ ((isoZeroOfMonoEqZero h).trans HasZeroObject.zeroIsoInitial) (by simp [h])⟩
#align category_theory.subobject.mk_eq_bot_iff_zero CategoryTheory.Subobject.mk_eq_bot_iff_zero

end ZeroOrderBot

section Functor

variable (C)

#print CategoryTheory.Subobject.functor /-
/-- Sending `X : C` to `subobject X` is a contravariant functor `Cᵒᵖ ⥤ Type`. -/
@[simps]
def functor [HasPullbacks C] : Cᵒᵖ ⥤ Type max u₁ v₁
    where
  obj X := Subobject X.unop
  map X Y f := (pullback f.unop).obj
  map_id' X := funext pullback_id
  map_comp' X Y Z f g := funext (pullback_comp _ _)
#align category_theory.subobject.functor CategoryTheory.Subobject.functor
-/

end Functor

section SemilatticeInfTop

variable [HasPullbacks C]

#print CategoryTheory.Subobject.inf /-
/-- The functorial infimum on `mono_over A` descends to an infimum on `subobject A`. -/
def inf {A : C} : Subobject A ⥤ Subobject A ⥤ Subobject A :=
  ThinSkeleton.map₂ MonoOver.inf
#align category_theory.subobject.inf CategoryTheory.Subobject.inf
-/

/- warning: category_theory.subobject.inf_le_left -> CategoryTheory.Subobject.inf_le_left is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} (f : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (g : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 A))) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)))) (CategoryTheory.Subobject.inf.{u1, u2} C _inst_1 _inst_3 A) f) g) f
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} (f : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (g : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.Subobject.inf.{u1, u2} C _inst_1 _inst_3 A)) f)) g) f
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.inf_le_left CategoryTheory.Subobject.inf_le_leftₓ'. -/
theorem inf_le_left {A : C} (f g : Subobject A) : (inf.obj f).obj g ≤ f :=
  Quotient.inductionOn₂' f g fun a b => ⟨MonoOver.infLELeft _ _⟩
#align category_theory.subobject.inf_le_left CategoryTheory.Subobject.inf_le_left

/- warning: category_theory.subobject.inf_le_right -> CategoryTheory.Subobject.inf_le_right is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} (f : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (g : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 A))) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)))) (CategoryTheory.Subobject.inf.{u1, u2} C _inst_1 _inst_3 A) f) g) g
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} (f : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (g : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.Subobject.inf.{u1, u2} C _inst_1 _inst_3 A)) f)) g) g
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.inf_le_right CategoryTheory.Subobject.inf_le_rightₓ'. -/
theorem inf_le_right {A : C} (f g : Subobject A) : (inf.obj f).obj g ≤ g :=
  Quotient.inductionOn₂' f g fun a b => ⟨MonoOver.infLERight _ _⟩
#align category_theory.subobject.inf_le_right CategoryTheory.Subobject.inf_le_right

/- warning: category_theory.subobject.le_inf -> CategoryTheory.Subobject.le_inf is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} (h : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (f : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (g : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 A))) h f) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 A))) h g) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 A))) h (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)))) (CategoryTheory.Subobject.inf.{u1, u2} C _inst_1 _inst_3 A) f) g))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} (h : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (f : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (g : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) h f) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) h g) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) h (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.Subobject.inf.{u1, u2} C _inst_1 _inst_3 A)) f)) g))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.le_inf CategoryTheory.Subobject.le_infₓ'. -/
theorem le_inf {A : C} (h f g : Subobject A) : h ≤ f → h ≤ g → h ≤ (inf.obj f).obj g :=
  Quotient.inductionOn₃' h f g
    (by
      rintro f g h ⟨k⟩ ⟨l⟩
      exact ⟨mono_over.le_inf _ _ _ k l⟩)
#align category_theory.subobject.le_inf CategoryTheory.Subobject.le_inf

instance {B : C} : SemilatticeInf (Subobject B) :=
  { Subobject.partialOrder _ with
    inf := fun m n => (inf.obj m).obj n
    inf_le_left := inf_le_left
    inf_le_right := inf_le_right
    le_inf := le_inf }

/- warning: category_theory.subobject.factors_left_of_inf_factors -> CategoryTheory.Subobject.factors_left_of_inf_factors is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} {B : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B}, (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeInf.toHasInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B)) X Y) f) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B X f)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} {B : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B}, (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeInf.toInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B)) X Y) f) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B X f)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factors_left_of_inf_factors CategoryTheory.Subobject.factors_left_of_inf_factorsₓ'. -/
theorem factors_left_of_inf_factors {A B : C} {X Y : Subobject B} {f : A ⟶ B}
    (h : (X ⊓ Y).Factors f) : X.Factors f :=
  factors_of_le _ (inf_le_left _ _) h
#align category_theory.subobject.factors_left_of_inf_factors CategoryTheory.Subobject.factors_left_of_inf_factors

/- warning: category_theory.subobject.factors_right_of_inf_factors -> CategoryTheory.Subobject.factors_right_of_inf_factors is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} {B : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B}, (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeInf.toHasInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B)) X Y) f) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B Y f)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} {B : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B}, (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeInf.toInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B)) X Y) f) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B Y f)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factors_right_of_inf_factors CategoryTheory.Subobject.factors_right_of_inf_factorsₓ'. -/
theorem factors_right_of_inf_factors {A B : C} {X Y : Subobject B} {f : A ⟶ B}
    (h : (X ⊓ Y).Factors f) : Y.Factors f :=
  factors_of_le _ (inf_le_right _ _) h
#align category_theory.subobject.factors_right_of_inf_factors CategoryTheory.Subobject.factors_right_of_inf_factors

/- warning: category_theory.subobject.inf_factors -> CategoryTheory.Subobject.inf_factors is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} {B : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B), Iff (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeInf.toHasInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B)) X Y) f) (And (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B X f) (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B Y f))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} {B : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B), Iff (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeInf.toInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B)) X Y) f) (And (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B X f) (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B Y f))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.inf_factors CategoryTheory.Subobject.inf_factorsₓ'. -/
@[simp]
theorem inf_factors {A B : C} {X Y : Subobject B} (f : A ⟶ B) :
    (X ⊓ Y).Factors f ↔ X.Factors f ∧ Y.Factors f :=
  ⟨fun h => ⟨factors_left_of_inf_factors h, factors_right_of_inf_factors h⟩,
    by
    revert X Y
    refine' Quotient.ind₂' _
    rintro X Y ⟨⟨g₁, rfl⟩, ⟨g₂, hg₂⟩⟩
    exact ⟨_, pullback.lift_snd_assoc _ _ hg₂ _⟩⟩
#align category_theory.subobject.inf_factors CategoryTheory.Subobject.inf_factors

/- warning: category_theory.subobject.inf_arrow_factors_left -> CategoryTheory.Subobject.inf_arrow_factors_left is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {B : C} (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B), CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeInf.toHasInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B)) X Y)) B X (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeInf.toHasInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B)) X Y))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {B : C} (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B), CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeInf.toInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B)) X Y)) B X (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeInf.toInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B)) X Y))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.inf_arrow_factors_left CategoryTheory.Subobject.inf_arrow_factors_leftₓ'. -/
theorem inf_arrow_factors_left {B : C} (X Y : Subobject B) : X.Factors (X ⊓ Y).arrow :=
  (factors_iff _ _).mpr ⟨ofLE (X ⊓ Y) X (inf_le_left X Y), by simp⟩
#align category_theory.subobject.inf_arrow_factors_left CategoryTheory.Subobject.inf_arrow_factors_left

/- warning: category_theory.subobject.inf_arrow_factors_right -> CategoryTheory.Subobject.inf_arrow_factors_right is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {B : C} (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B), CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeInf.toHasInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B)) X Y)) B Y (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeInf.toHasInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B)) X Y))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {B : C} (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B), CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeInf.toInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B)) X Y)) B Y (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeInf.toInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B)) X Y))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.inf_arrow_factors_right CategoryTheory.Subobject.inf_arrow_factors_rightₓ'. -/
theorem inf_arrow_factors_right {B : C} (X Y : Subobject B) : Y.Factors (X ⊓ Y).arrow :=
  (factors_iff _ _).mpr ⟨ofLE (X ⊓ Y) Y (inf_le_right X Y), by simp⟩
#align category_theory.subobject.inf_arrow_factors_right CategoryTheory.Subobject.inf_arrow_factors_right

/- warning: category_theory.subobject.finset_inf_factors -> CategoryTheory.Subobject.finset_inf_factors is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {I : Type.{u3}} {A : C} {B : C} {s : Finset.{u3} I} {P : I -> (CategoryTheory.Subobject.{u1, u2} C _inst_1 B)} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B), Iff (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (Finset.inf.{max u2 u1, u3} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) I (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 B) s P) f) (forall (i : I), (Membership.Mem.{u3, u3} I (Finset.{u3} I) (Finset.hasMem.{u3} I) i s) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (P i) f))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u2, u3} C _inst_1] {I : Type.{u1}} {A : C} {B : C} {s : Finset.{u1} I} {P : I -> (CategoryTheory.Subobject.{u2, u3} C _inst_1 B)} (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) A B), Iff (CategoryTheory.Subobject.Factors.{u2, u3} C _inst_1 A B (Finset.inf.{max u3 u2, u1} (CategoryTheory.Subobject.{u2, u3} C _inst_1 B) I (CategoryTheory.Subobject.semilatticeInf.{u2, u3} C _inst_1 _inst_3 B) (CategoryTheory.Subobject.orderTop.{u2, u3} C _inst_1 B) s P) f) (forall (i : I), (Membership.mem.{u1, u1} I (Finset.{u1} I) (Finset.instMembershipFinset.{u1} I) i s) -> (CategoryTheory.Subobject.Factors.{u2, u3} C _inst_1 A B (P i) f))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.finset_inf_factors CategoryTheory.Subobject.finset_inf_factorsₓ'. -/
@[simp]
theorem finset_inf_factors {I : Type _} {A B : C} {s : Finset I} {P : I → Subobject B} (f : A ⟶ B) :
    (s.inf P).Factors f ↔ ∀ i ∈ s, (P i).Factors f := by
  classical
    apply Finset.induction_on s
    · simp [top_factors]
    · intro i s nm ih
      simp [ih]
#align category_theory.subobject.finset_inf_factors CategoryTheory.Subobject.finset_inf_factors

/- warning: category_theory.subobject.finset_inf_arrow_factors -> CategoryTheory.Subobject.finset_inf_arrow_factors is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {I : Type.{u3}} {B : C} (s : Finset.{u3} I) (P : I -> (CategoryTheory.Subobject.{u1, u2} C _inst_1 B)) (i : I), (Membership.Mem.{u3, u3} I (Finset.{u3} I) (Finset.hasMem.{u3} I) i s) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) (Finset.inf.{max u2 u1, u3} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) I (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 B) s P)) B (P i) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B (Finset.inf.{max u2 u1, u3} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) I (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B) (CategoryTheory.Subobject.orderTop.{u1, u2} C _inst_1 B) s P)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u2, u3} C _inst_1] {I : Type.{u1}} {B : C} (s : Finset.{u1} I) (P : I -> (CategoryTheory.Subobject.{u2, u3} C _inst_1 B)) (i : I), (Membership.mem.{u1, u1} I (Finset.{u1} I) (Finset.instMembershipFinset.{u1} I) i s) -> (CategoryTheory.Subobject.Factors.{u2, u3} C _inst_1 (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} C _inst_1 B) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} C _inst_1 B) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u2, u3} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} C _inst_1 B) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} C _inst_1 B) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u2, u3} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} C _inst_1 B)) (Finset.inf.{max u3 u2, u1} (CategoryTheory.Subobject.{u2, u3} C _inst_1 B) I (CategoryTheory.Subobject.semilatticeInf.{u2, u3} C _inst_1 _inst_3 B) (CategoryTheory.Subobject.orderTop.{u2, u3} C _inst_1 B) s P)) B (P i) (CategoryTheory.Subobject.arrow.{u2, u3} C _inst_1 B (Finset.inf.{max u3 u2, u1} (CategoryTheory.Subobject.{u2, u3} C _inst_1 B) I (CategoryTheory.Subobject.semilatticeInf.{u2, u3} C _inst_1 _inst_3 B) (CategoryTheory.Subobject.orderTop.{u2, u3} C _inst_1 B) s P)))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.finset_inf_arrow_factors CategoryTheory.Subobject.finset_inf_arrow_factorsₓ'. -/
-- `i` is explicit here because often we'd like to defer a proof of `m`
theorem finset_inf_arrow_factors {I : Type _} {B : C} (s : Finset I) (P : I → Subobject B) (i : I)
    (m : i ∈ s) : (P i).Factors (s.inf P).arrow :=
  by
  revert i m
  classical
    apply Finset.induction_on s
    · rintro _ ⟨⟩
    · intro i s nm ih j m
      rw [Finset.inf_insert]
      simp only [Finset.mem_insert] at m
      rcases m with (rfl | m)
      · rw [← factor_thru_arrow _ _ (inf_arrow_factors_left _ _)]
        exact factors_comp_arrow _
      · rw [← factor_thru_arrow _ _ (inf_arrow_factors_right _ _)]
        apply factors_of_factors_right
        exact ih _ m
#align category_theory.subobject.finset_inf_arrow_factors CategoryTheory.Subobject.finset_inf_arrow_factors

/- warning: category_theory.subobject.inf_eq_map_pullback' -> CategoryTheory.Subobject.inf_eq_map_pullback' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} (f₁ : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (f₂ : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)))) (CategoryTheory.Subobject.inf.{u1, u2} C _inst_1 _inst_3 A) (Quotient.mk''.{succ (max u2 u1)} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.isIsomorphicSetoid.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) f₁)) f₂) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁)) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁))) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁)) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁)))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁) A (CategoryTheory.MonoOver.arrow.{u1, u2} C _inst_1 A f₁) (CategoryTheory.MonoOver.mono.{u1, u2} C _inst_1 A f₁)) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁)) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁))) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁)) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁)))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁) A _inst_3 (CategoryTheory.MonoOver.arrow.{u1, u2} C _inst_1 A f₁)) f₂))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} (f₁ : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (f₂ : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A)))) (CategoryTheory.Subobject.inf.{u1, u2} C _inst_1 _inst_3 A)) (Quotient.mk''.{max (succ u2) (succ u1)} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.isIsomorphicSetoid.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) f₁))) f₂) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁)) A (CategoryTheory.MonoOver.arrow.{u1, u2} C _inst_1 A f₁) (CategoryTheory.MonoOver.mono.{u1, u2} C _inst_1 A f₁))) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁)) A _inst_3 (CategoryTheory.MonoOver.arrow.{u1, u2} C _inst_1 A f₁))) f₂))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.inf_eq_map_pullback' CategoryTheory.Subobject.inf_eq_map_pullback'ₓ'. -/
theorem inf_eq_map_pullback' {A : C} (f₁ : MonoOver A) (f₂ : Subobject A) :
    (Subobject.inf.obj (Quotient.mk'' f₁)).obj f₂ =
      (Subobject.map f₁.arrow).obj ((Subobject.pullback f₁.arrow).obj f₂) :=
  by
  apply Quotient.inductionOn' f₂
  intro f₂
  rfl
#align category_theory.subobject.inf_eq_map_pullback' CategoryTheory.Subobject.inf_eq_map_pullback'

/- warning: category_theory.subobject.inf_eq_map_pullback -> CategoryTheory.Subobject.inf_eq_map_pullback is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} (f₁ : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (f₂ : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (SemilatticeInf.toHasInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 A)) (Quotient.mk''.{succ (max u2 u1)} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.isIsomorphicSetoid.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) f₁) f₂) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁)) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁))) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁)) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁)))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁) A (CategoryTheory.MonoOver.arrow.{u1, u2} C _inst_1 A f₁) (CategoryTheory.MonoOver.mono.{u1, u2} C _inst_1 A f₁)) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁)) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁))) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁)) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁)))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 A)))) f₁) A _inst_3 (CategoryTheory.MonoOver.arrow.{u1, u2} C _inst_1 A f₁)) f₂))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} (f₁ : CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (f₂ : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (SemilatticeInf.toInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 A)) (Quotient.mk''.{max (succ u2) (succ u1)} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.isIsomorphicSetoid.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 A)) f₁) f₂) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁)) A (CategoryTheory.MonoOver.arrow.{u1, u2} C _inst_1 A f₁) (CategoryTheory.MonoOver.mono.{u1, u2} C _inst_1 A f₁))) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁))))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 A) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 A) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 A) f)) f₁)) A _inst_3 (CategoryTheory.MonoOver.arrow.{u1, u2} C _inst_1 A f₁))) f₂))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.inf_eq_map_pullback CategoryTheory.Subobject.inf_eq_map_pullbackₓ'. -/
theorem inf_eq_map_pullback {A : C} (f₁ : MonoOver A) (f₂ : Subobject A) :
    (Quotient.mk'' f₁ ⊓ f₂ : Subobject A) = (map f₁.arrow).obj ((pullback f₁.arrow).obj f₂) :=
  inf_eq_map_pullback' f₁ f₂
#align category_theory.subobject.inf_eq_map_pullback CategoryTheory.Subobject.inf_eq_map_pullback

/- warning: category_theory.subobject.prod_eq_inf -> CategoryTheory.Subobject.prod_eq_inf is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} {f₁ : CategoryTheory.Subobject.{u1, u2} C _inst_1 A} {f₂ : CategoryTheory.Subobject.{u1, u2} C _inst_1 A} [_inst_4 : CategoryTheory.Limits.HasBinaryProduct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.category.{u2, u1} C _inst_1 A) f₁ f₂], Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Limits.prod.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.category.{u2, u1} C _inst_1 A) f₁ f₂ _inst_4) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (SemilatticeInf.toHasInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 A)) f₁ f₂)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {A : C} {f₁ : CategoryTheory.Subobject.{u1, u2} C _inst_1 A} {f₂ : CategoryTheory.Subobject.{u1, u2} C _inst_1 A} [_inst_4 : CategoryTheory.Limits.HasBinaryProduct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) f₁ f₂], Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Limits.prod.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) f₁ f₂ _inst_4) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (SemilatticeInf.toInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 A)) f₁ f₂)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.prod_eq_inf CategoryTheory.Subobject.prod_eq_infₓ'. -/
theorem prod_eq_inf {A : C} {f₁ f₂ : Subobject A} [HasBinaryProduct f₁ f₂] : (f₁ ⨯ f₂) = f₁ ⊓ f₂ :=
  le_antisymm (le_inf Limits.prod.fst.le Limits.prod.snd.le)
    (prod.lift inf_le_left.Hom inf_le_right.Hom).le
#align category_theory.subobject.prod_eq_inf CategoryTheory.Subobject.prod_eq_inf

/- warning: category_theory.subobject.inf_def -> CategoryTheory.Subobject.inf_def is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {B : C} (m : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (m' : CategoryTheory.Subobject.{u1, u2} C _inst_1 B), Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeInf.toHasInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B)) m m') (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B))) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B))) (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 B) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 B)))) (CategoryTheory.Subobject.inf.{u1, u2} C _inst_1 _inst_3 B) m) m')
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {B : C} (m : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (m' : CategoryTheory.Subobject.{u1, u2} C _inst_1 B), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeInf.toInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 B)) m m') (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B)))) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B)))) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B)))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B)))) (CategoryTheory.Subobject.inf.{u1, u2} C _inst_1 _inst_3 B)) m)) m')
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.inf_def CategoryTheory.Subobject.inf_defₓ'. -/
theorem inf_def {B : C} (m m' : Subobject B) : m ⊓ m' = (inf.obj m).obj m' :=
  rfl
#align category_theory.subobject.inf_def CategoryTheory.Subobject.inf_def

/- warning: category_theory.subobject.inf_pullback -> CategoryTheory.Subobject.inf_pullback is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {X : C} {Y : C} (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (f₁ : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (f₂ : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y), Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 X Y _inst_3 g) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (SemilatticeInf.toHasInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 Y)) f₁ f₂)) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (SemilatticeInf.toHasInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 X)) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 X Y _inst_3 g) f₁) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 X Y _inst_3 g) f₂))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {X : C} {Y : C} (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (f₁ : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (f₂ : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 X Y _inst_3 g)) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (SemilatticeInf.toInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 Y)) f₁ f₂)) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (SemilatticeInf.toInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 X)) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 X Y _inst_3 g)) f₁) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 X Y _inst_3 g)) f₂))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.inf_pullback CategoryTheory.Subobject.inf_pullbackₓ'. -/
/-- `⊓` commutes with pullback. -/
theorem inf_pullback {X Y : C} (g : X ⟶ Y) (f₁ f₂) :
    (pullback g).obj (f₁ ⊓ f₂) = (pullback g).obj f₁ ⊓ (pullback g).obj f₂ :=
  by
  revert f₁
  apply Quotient.ind'
  intro f₁
  erw [inf_def, inf_def, inf_eq_map_pullback', inf_eq_map_pullback', ← pullback_comp, ←
    map_pullback pullback.condition (pullback_is_pullback f₁.arrow g), ← pullback_comp,
    pullback.condition]
  rfl
#align category_theory.subobject.inf_pullback CategoryTheory.Subobject.inf_pullback

/- warning: category_theory.subobject.inf_map -> CategoryTheory.Subobject.inf_map is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {X : C} {Y : C} (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y X) [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 Y X g] (f₁ : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (f₂ : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y), Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 Y X g _inst_4) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (SemilatticeInf.toHasInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 Y)) f₁ f₂)) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (SemilatticeInf.toHasInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 X)) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 Y X g _inst_4) f₁) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 Y X g _inst_4) f₂))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {X : C} {Y : C} (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y X) [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 Y X g] (f₁ : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (f₂ : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 Y X g _inst_4)) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (SemilatticeInf.toInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 Y)) f₁ f₂)) (Inf.inf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (SemilatticeInf.toInf.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.semilatticeInf.{u1, u2} C _inst_1 _inst_3 X)) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 Y X g _inst_4)) f₁) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 Y X g _inst_4)) f₂))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.inf_map CategoryTheory.Subobject.inf_mapₓ'. -/
/-- `⊓` commutes with map. -/
theorem inf_map {X Y : C} (g : Y ⟶ X) [Mono g] (f₁ f₂) :
    (map g).obj (f₁ ⊓ f₂) = (map g).obj f₁ ⊓ (map g).obj f₂ :=
  by
  revert f₁
  apply Quotient.ind'
  intro f₁
  erw [inf_def, inf_def, inf_eq_map_pullback', inf_eq_map_pullback', ← map_comp]
  dsimp
  rw [pullback_comp, pullback_map_self]
#align category_theory.subobject.inf_map CategoryTheory.Subobject.inf_map

end SemilatticeInfTop

section SemilatticeSup

variable [HasImages C] [HasBinaryCoproducts C]

#print CategoryTheory.Subobject.sup /-
/-- The functorial supremum on `mono_over A` descends to an supremum on `subobject A`. -/
def sup {A : C} : Subobject A ⥤ Subobject A ⥤ Subobject A :=
  ThinSkeleton.map₂ MonoOver.sup
#align category_theory.subobject.sup CategoryTheory.Subobject.sup
-/

instance {B : C} : SemilatticeSup (Subobject B) :=
  { Subobject.partialOrder B with
    sup := fun m n => (sup.obj m).obj n
    le_sup_left := fun m n => Quotient.inductionOn₂' m n fun a b => ⟨MonoOver.leSupLeft _ _⟩
    le_sup_right := fun m n => Quotient.inductionOn₂' m n fun a b => ⟨MonoOver.leSupRight _ _⟩
    sup_le := fun m n k =>
      Quotient.inductionOn₃' m n k fun a b c ⟨i⟩ ⟨j⟩ => ⟨MonoOver.supLe _ _ _ i j⟩ }

/- warning: category_theory.subobject.sup_factors_of_factors_left -> CategoryTheory.Subobject.sup_factors_of_factors_left is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasBinaryCoproducts.{u1, u2} C _inst_1] {A : C} {B : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B}, (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B X f) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (Sup.sup.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeSup.toHasSup.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeSup.{u1, u2} C _inst_1 _inst_3 _inst_4 B)) X Y) f)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasBinaryCoproducts.{u1, u2} C _inst_1] {A : C} {B : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B}, (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B X f) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (Sup.sup.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeSup.toSup.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeSup.{u1, u2} C _inst_1 _inst_3 _inst_4 B)) X Y) f)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.sup_factors_of_factors_left CategoryTheory.Subobject.sup_factors_of_factors_leftₓ'. -/
theorem sup_factors_of_factors_left {A B : C} {X Y : Subobject B} {f : A ⟶ B} (P : X.Factors f) :
    (X ⊔ Y).Factors f :=
  factors_of_le f le_sup_left P
#align category_theory.subobject.sup_factors_of_factors_left CategoryTheory.Subobject.sup_factors_of_factors_left

/- warning: category_theory.subobject.sup_factors_of_factors_right -> CategoryTheory.Subobject.sup_factors_of_factors_right is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasBinaryCoproducts.{u1, u2} C _inst_1] {A : C} {B : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B}, (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B Y f) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (Sup.sup.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeSup.toHasSup.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeSup.{u1, u2} C _inst_1 _inst_3 _inst_4 B)) X Y) f)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasBinaryCoproducts.{u1, u2} C _inst_1] {A : C} {B : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B}, (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B Y f) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (Sup.sup.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (SemilatticeSup.toSup.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.semilatticeSup.{u1, u2} C _inst_1 _inst_3 _inst_4 B)) X Y) f)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.sup_factors_of_factors_right CategoryTheory.Subobject.sup_factors_of_factors_rightₓ'. -/
theorem sup_factors_of_factors_right {A B : C} {X Y : Subobject B} {f : A ⟶ B} (P : Y.Factors f) :
    (X ⊔ Y).Factors f :=
  factors_of_le f le_sup_right P
#align category_theory.subobject.sup_factors_of_factors_right CategoryTheory.Subobject.sup_factors_of_factors_right

variable [HasInitial C] [InitialMonoClass C]

/- warning: category_theory.subobject.finset_sup_factors -> CategoryTheory.Subobject.finset_sup_factors is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasBinaryCoproducts.{u1, u2} C _inst_1] [_inst_5 : CategoryTheory.Limits.HasInitial.{u1, u2} C _inst_1] [_inst_6 : CategoryTheory.Limits.InitialMonoClass.{u1, u2} C _inst_1] {I : Type.{u3}} {A : C} {B : C} {s : Finset.{u3} I} {P : I -> (CategoryTheory.Subobject.{u1, u2} C _inst_1 B)} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B}, (Exists.{succ u3} I (fun (i : I) => Exists.{0} (Membership.Mem.{u3, u3} I (Finset.{u3} I) (Finset.hasMem.{u3} I) i s) (fun (H : Membership.Mem.{u3, u3} I (Finset.{u3} I) (Finset.hasMem.{u3} I) i s) => CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (P i) f))) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 A B (Finset.sup.{max u2 u1, u3} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) I (CategoryTheory.Subobject.semilatticeSup.{u1, u2} C _inst_1 _inst_3 _inst_4 B) (CategoryTheory.Subobject.orderBot.{u1, u2} C _inst_1 _inst_5 _inst_6 B) s P) f)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] [_inst_3 : CategoryTheory.Limits.HasImages.{u2, u3} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasBinaryCoproducts.{u2, u3} C _inst_1] [_inst_5 : CategoryTheory.Limits.HasInitial.{u2, u3} C _inst_1] [_inst_6 : CategoryTheory.Limits.InitialMonoClass.{u2, u3} C _inst_1] {I : Type.{u1}} {A : C} {B : C} {s : Finset.{u1} I} {P : I -> (CategoryTheory.Subobject.{u2, u3} C _inst_1 B)} {f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) A B}, (Exists.{succ u1} I (fun (i : I) => And (Membership.mem.{u1, u1} I (Finset.{u1} I) (Finset.instMembershipFinset.{u1} I) i s) (CategoryTheory.Subobject.Factors.{u2, u3} C _inst_1 A B (P i) f))) -> (CategoryTheory.Subobject.Factors.{u2, u3} C _inst_1 A B (Finset.sup.{max u3 u2, u1} (CategoryTheory.Subobject.{u2, u3} C _inst_1 B) I (CategoryTheory.Subobject.semilatticeSup.{u2, u3} C _inst_1 _inst_3 _inst_4 B) (CategoryTheory.Subobject.orderBot.{u2, u3} C _inst_1 _inst_5 _inst_6 B) s P) f)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.finset_sup_factors CategoryTheory.Subobject.finset_sup_factorsₓ'. -/
theorem finset_sup_factors {I : Type _} {A B : C} {s : Finset I} {P : I → Subobject B} {f : A ⟶ B}
    (h : ∃ i ∈ s, (P i).Factors f) : (s.sup P).Factors f := by
  classical
    revert h
    apply Finset.induction_on s
    · rintro ⟨_, ⟨⟨⟩, _⟩⟩
    · rintro i s nm ih ⟨j, ⟨m, h⟩⟩
      simp only [Finset.sup_insert]
      simp at m
      rcases m with (rfl | m)
      · exact sup_factors_of_factors_left h
      · exact sup_factors_of_factors_right (ih ⟨j, ⟨m, h⟩⟩)
#align category_theory.subobject.finset_sup_factors CategoryTheory.Subobject.finset_sup_factors

end SemilatticeSup

section Lattice

instance [HasInitial C] [InitialMonoClass C] {B : C} : BoundedOrder (Subobject B) :=
  { Subobject.orderTop, Subobject.orderBot with }

variable [HasPullbacks C] [HasImages C] [HasBinaryCoproducts C]

instance {B : C} : Lattice (Subobject B) :=
  { Subobject.semilatticeInf, Subobject.semilatticeSup with }

end Lattice

section Inf

variable [WellPowered C]

#print CategoryTheory.Subobject.wideCospan /-
/-- The "wide cospan" diagram, with a small indexing type, constructed from a set of subobjects.
(This is just the diagram of all the subobjects pasted together, but using `well_powered C`
to make the diagram small.)
-/
def wideCospan {A : C} (s : Set (Subobject A)) : WidePullbackShape (equivShrink _ '' s) ⥤ C :=
  WidePullbackShape.wideCospan A
    (fun j : equivShrink _ '' s => ((equivShrink (Subobject A)).symm j : C)) fun j =>
    ((equivShrink (Subobject A)).symm j).arrow
#align category_theory.subobject.wide_cospan CategoryTheory.Subobject.wideCospan
-/

#print CategoryTheory.Subobject.wideCospan_map_term /-
@[simp]
theorem wideCospan_map_term {A : C} (s : Set (Subobject A)) (j) :
    (wideCospan s).map (WidePullbackShape.Hom.term j) =
      ((equivShrink (Subobject A)).symm j).arrow :=
  rfl
#align category_theory.subobject.wide_cospan_map_term CategoryTheory.Subobject.wideCospan_map_term
-/

#print CategoryTheory.Subobject.leInfCone /-
/-- Auxiliary construction of a cone for `le_Inf`. -/
def leInfCone {A : C} (s : Set (Subobject A)) (f : Subobject A) (k : ∀ g ∈ s, f ≤ g) :
    Cone (wideCospan s) :=
  WidePullbackShape.mkCone f.arrow
    (fun j =>
      underlying.map
        (homOfLE
          (k _
            (by
              rcases j with ⟨-, ⟨g, ⟨m, rfl⟩⟩⟩
              simpa using m))))
    (by tidy)
#align category_theory.subobject.le_Inf_cone CategoryTheory.Subobject.leInfCone
-/

/- warning: category_theory.subobject.le_Inf_cone_π_app_none -> CategoryTheory.Subobject.leInfCone_π_app_none is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.WellPowered.{u1, u2} C _inst_1] {A : C} (s : Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) (f : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (k : forall (g : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), (Membership.Mem.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) (Set.hasMem.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) g s) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 A))) f g)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1 (CategoryTheory.Subobject.wideCospan.{u1, u2} C _inst_1 _inst_3 A s) (CategoryTheory.Subobject.leInfCone.{u1, u2} C _inst_1 _inst_3 A s f k))) (Option.none.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s)))) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1 (CategoryTheory.Subobject.wideCospan.{u1, u2} C _inst_1 _inst_3 A s) (Option.none.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))))) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1) (CategoryTheory.Limits.Cone.pt.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1 (CategoryTheory.Subobject.wideCospan.{u1, u2} C _inst_1 _inst_3 A s) (CategoryTheory.Subobject.leInfCone.{u1, u2} C _inst_1 _inst_3 A s f k))) (CategoryTheory.Subobject.wideCospan.{u1, u2} C _inst_1 _inst_3 A s) (CategoryTheory.Limits.Cone.π.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1 (CategoryTheory.Subobject.wideCospan.{u1, u2} C _inst_1 _inst_3 A s) (CategoryTheory.Subobject.leInfCone.{u1, u2} C _inst_1 _inst_3 A s f k)) (Option.none.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) Type.{u1} (Set.hasCoeToSort.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) => (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) -> (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s)))) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 A f)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.WellPowered.{u1, u2} C _inst_1] {A : C} (s : Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) (f : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (k : forall (g : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), (Membership.mem.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) (Set.instMembershipSet.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) g s) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) f g)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (_x : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) _x) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1)) (CategoryTheory.Limits.Cone.pt.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1 (CategoryTheory.Subobject.wideCospan.{u1, u2} C _inst_1 _inst_3 A s) (CategoryTheory.Subobject.leInfCone.{u1, u2} C _inst_1 _inst_3 A s f k)))) (Option.none.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (_x : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) _x) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s)))) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (_x : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) _x) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1 (CategoryTheory.Subobject.wideCospan.{u1, u2} C _inst_1 _inst_3 A s)) (Option.none.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (_x : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) _x) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))))) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (_x : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) _x) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (_x : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) _x) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (_x : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) _x) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (_x : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) _x) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u1 u2} C _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1) (CategoryTheory.Functor.const.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (a : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) a) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1)) (CategoryTheory.Limits.Cone.pt.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (_x : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) _x) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (_x : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) _x) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1 (CategoryTheory.Subobject.wideCospan.{u1, u2} C _inst_1 _inst_3 A s) (CategoryTheory.Subobject.leInfCone.{u1, u2} C _inst_1 _inst_3 A s f k))) (CategoryTheory.Subobject.wideCospan.{u1, u2} C _inst_1 _inst_3 A s) (CategoryTheory.Limits.Cone.π.{u1, u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (_x : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) _x) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) (CategoryTheory.Limits.WidePullbackShape.category.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (_x : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) _x) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s))) C _inst_1 (CategoryTheory.Subobject.wideCospan.{u1, u2} C _inst_1 _inst_3 A s) (CategoryTheory.Subobject.leInfCone.{u1, u2} C _inst_1 _inst_3 A s f k)) (Option.none.{u1} (Set.Elem.{u1} (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (Set.image.{max u2 u1, u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) (FunLike.coe.{max (succ (max u2 u1)) (succ u1), succ (max u2 u1), succ u1} (Equiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (fun (_x : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : CategoryTheory.Subobject.{u1, u2} C _inst_1 A) => Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A)) _x) (Equiv.instFunLikeEquiv.{succ (max u2 u1), succ u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Shrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) (equivShrink.{u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.small_subobject.{u1, u2} C _inst_1 _inst_3 A))) s)))) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 A f)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.le_Inf_cone_π_app_none CategoryTheory.Subobject.leInfCone_π_app_noneₓ'. -/
@[simp]
theorem leInfCone_π_app_none {A : C} (s : Set (Subobject A)) (f : Subobject A)
    (k : ∀ g ∈ s, f ≤ g) : (leInfCone s f k).π.app none = f.arrow :=
  rfl
#align category_theory.subobject.le_Inf_cone_π_app_none CategoryTheory.Subobject.leInfCone_π_app_none

variable [HasWidePullbacks.{v₁} C]

#print CategoryTheory.Subobject.widePullback /-
/-- The limit of `wide_cospan s`. (This will be the supremum of the set of subobjects.)
-/
def widePullback {A : C} (s : Set (Subobject A)) : C :=
  Limits.limit (wideCospan s)
#align category_theory.subobject.wide_pullback CategoryTheory.Subobject.widePullback
-/

#print CategoryTheory.Subobject.widePullbackι /-
/-- The inclusion map from `wide_pullback s` to `A`
-/
def widePullbackι {A : C} (s : Set (Subobject A)) : widePullback s ⟶ A :=
  Limits.limit.π (wideCospan s) none
#align category_theory.subobject.wide_pullback_ι CategoryTheory.Subobject.widePullbackι
-/

#print CategoryTheory.Subobject.widePullbackι_mono /-
instance widePullbackι_mono {A : C} (s : Set (Subobject A)) : Mono (widePullbackι s) :=
  ⟨fun W u v h =>
    limit.hom_ext fun j => by
      cases j
      · exact h
      · apply (cancel_mono ((equivShrink (subobject A)).symm j).arrow).1
        rw [assoc, assoc]
        erw [limit.w (wide_cospan s) (wide_pullback_shape.hom.term j)]
        exact h⟩
#align category_theory.subobject.wide_pullback_ι_mono CategoryTheory.Subobject.widePullbackι_mono
-/

#print CategoryTheory.Subobject.infₛ /-
/-- When `[well_powered C]` and `[has_wide_pullbacks C]`, `subobject A` has arbitrary infimums.
-/
def infₛ {A : C} (s : Set (Subobject A)) : Subobject A :=
  Subobject.mk (widePullbackι s)
#align category_theory.subobject.Inf CategoryTheory.Subobject.infₛ
-/

/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (f «expr ∈ » s) -/
#print CategoryTheory.Subobject.infₛ_le /-
theorem infₛ_le {A : C} (s : Set (Subobject A)) (f) (_ : f ∈ s) : infₛ s ≤ f :=
  by
  fapply le_of_comm
  · refine'
      (underlying_iso _).Hom ≫
        limits.limit.π (wide_cospan s)
            (some ⟨equivShrink _ f, Set.mem_image_of_mem (equivShrink (subobject A)) H⟩) ≫
          _
    apply eq_to_hom
    apply congr_arg fun X : subobject A => (X : C)
    exact Equiv.symm_apply_apply _ _
  · dsimp [Inf]
    simp only [category.comp_id, category.assoc, ← underlying_iso_hom_comp_eq_mk,
      subobject.arrow_congr, congr_arg_mpr_hom_left, iso.cancel_iso_hom_left]
    convert limit.w (wide_cospan s) (wide_pullback_shape.hom.term _)
#align category_theory.subobject.Inf_le CategoryTheory.Subobject.infₛ_le
-/

/- warning: category_theory.subobject.le_Inf clashes with category_theory.subobject.le_inf -> CategoryTheory.Subobject.le_inf
warning: category_theory.subobject.le_Inf -> CategoryTheory.Subobject.le_inf is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.WellPowered.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasWidePullbacks.{u1, u1, u2} C _inst_1] {A : C} (s : Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) (f : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), (forall (g : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), (Membership.Mem.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) (Set.hasMem.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) g s) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 A))) f g)) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 A))) f (CategoryTheory.Subobject.infₛ.{u1, u2} C _inst_1 _inst_3 (fun (J : Type.{u1}) => _inst_4 J) A s))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] {_inst_4 : C} (A : CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (s : CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (f : CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4), (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4))) A s) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4))) A f) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4))) A (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4))) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4))))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4)))) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4)))) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4)))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_4) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_4)))) (CategoryTheory.Subobject.inf.{u1, u2} C _inst_1 _inst_3 _inst_4)) s)) f))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.le_Inf CategoryTheory.Subobject.le_infₓ'. -/
theorem le_inf {A : C} (s : Set (Subobject A)) (f : Subobject A) (k : ∀ g ∈ s, f ≤ g) :
    f ≤ infₛ s := by
  fapply le_of_comm
  · exact limits.limit.lift _ (le_Inf_cone s f k) ≫ (underlying_iso _).inv
  · dsimp [Inf, wide_pullback_ι]
    simp
#align category_theory.subobject.le_Inf CategoryTheory.Subobject.le_inf

instance {B : C} : CompleteSemilatticeInf (Subobject B) :=
  { Subobject.partialOrder B with
    infₛ := infₛ
    inf_le := infₛ_le
    le_inf := le_inf }

end Inf

section Sup

variable [WellPowered C] [HasCoproducts.{v₁} C]

#print CategoryTheory.Subobject.smallCoproductDesc /-
/-- The univesal morphism out of the coproduct of a set of subobjects,
after using `[well_powered C]` to reindex by a small type.
-/
def smallCoproductDesc {A : C} (s : Set (Subobject A)) : _ ⟶ A :=
  Limits.Sigma.desc fun j : equivShrink _ '' s => ((equivShrink (Subobject A)).symm j).arrow
#align category_theory.subobject.small_coproduct_desc CategoryTheory.Subobject.smallCoproductDesc
-/

variable [HasImages C]

/- warning: category_theory.subobject.Sup clashes with category_theory.subobject.sup -> CategoryTheory.Subobject.sup
warning: category_theory.subobject.Sup -> CategoryTheory.Subobject.sup is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.WellPowered.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasCoproducts.{u1, u1, u2} C _inst_1] [_inst_5 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] {A : C}, (Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) -> (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasBinaryCoproducts.{u1, u2} C _inst_1] {_inst_5 : C}, CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_5) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_5) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_5) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_5))) (CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_5) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_5) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_5) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_5))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_5) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_5) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_5) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_5)))) (CategoryTheory.Functor.category.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_5) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_5) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_5) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_5))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_5) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_5) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 _inst_5) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 _inst_5))))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.Sup CategoryTheory.Subobject.supₓ'. -/
/-- When `[well_powered C] [has_images C] [has_coproducts C]`,
`subobject A` has arbitrary supremums. -/
def sup {A : C} (s : Set (Subobject A)) : Subobject A :=
  Subobject.mk (image.ι (smallCoproductDesc s))
#align category_theory.subobject.Sup CategoryTheory.Subobject.sup

/- warning: category_theory.subobject.le_Sup -> CategoryTheory.Subobject.le_supₛ is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.WellPowered.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasCoproducts.{u1, u1, u2} C _inst_1] [_inst_5 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] {A : C} (s : Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) (f : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), (Membership.Mem.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) (Set.hasMem.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) f s) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 A))) f (CategoryTheory.Subobject.sup.{u1, u2} C _inst_1 _inst_3 (fun (J : Type.{u1}) => _inst_4 J) _inst_5 A s))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.WellPowered.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasCoproducts.{u1, u1, u2} C _inst_1] [_inst_5 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] {A : C} (s : Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) (f : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), (Membership.mem.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) (Set.instMembershipSet.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) f s) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) f (CategoryTheory.Subobject.supₛ.{u1, u2} C _inst_1 _inst_3 (fun (J : Type.{u1}) => _inst_4 J) _inst_5 A s))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.le_Sup CategoryTheory.Subobject.le_supₛₓ'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (f «expr ∈ » s) -/
theorem le_supₛ {A : C} (s : Set (Subobject A)) (f) (_ : f ∈ s) : f ≤ sup s :=
  by
  fapply le_of_comm
  · dsimp [Sup]
    refine' _ ≫ factor_thru_image _ ≫ (underlying_iso _).inv
    refine' _ ≫ sigma.ι _ ⟨equivShrink _ f, by simpa [Set.mem_image] using H⟩
    exact eq_to_hom (congr_arg (fun X : subobject A => (X : C)) (Equiv.symm_apply_apply _ _).symm)
  · dsimp [Sup, small_coproduct_desc]
    simp
    dsimp
    simp
#align category_theory.subobject.le_Sup CategoryTheory.Subobject.le_supₛ

/- warning: category_theory.subobject.symm_apply_mem_iff_mem_image -> CategoryTheory.Subobject.symm_apply_mem_iff_mem_image is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} (e : Equiv.{succ u1, succ u2} α β) (s : Set.{u1} α) (x : β), Iff (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} β α) (fun (_x : Equiv.{succ u2, succ u1} β α) => β -> α) (Equiv.hasCoeToFun.{succ u2, succ u1} β α) (Equiv.symm.{succ u1, succ u2} α β e) x) s) (Membership.Mem.{u2, u2} β (Set.{u2} β) (Set.hasMem.{u2} β) x (Set.image.{u1, u2} α β (coeFn.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1), max (succ u1) (succ u2)} (Equiv.{succ u1, succ u2} α β) (fun (_x : Equiv.{succ u1, succ u2} α β) => α -> β) (Equiv.hasCoeToFun.{succ u1, succ u2} α β) e) s))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} (e : Equiv.{succ u2, succ u1} α β) (s : Set.{u2} α) (x : β), Iff (Membership.mem.{u2, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : β) => α) x) (Set.{u2} α) (Set.instMembershipSet.{u2} α) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (Equiv.{succ u1, succ u2} β α) β (fun (_x : β) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : β) => α) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u2} β α) (Equiv.symm.{succ u2, succ u1} α β e) x) s) (Membership.mem.{u1, u1} β (Set.{u1} β) (Set.instMembershipSet.{u1} β) x (Set.image.{u2, u1} α β (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Equiv.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α) => β) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} α β) e) s))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.symm_apply_mem_iff_mem_image CategoryTheory.Subobject.symm_apply_mem_iff_mem_imageₓ'. -/
theorem symm_apply_mem_iff_mem_image {α β : Type _} (e : α ≃ β) (s : Set α) (x : β) :
    e.symm x ∈ s ↔ x ∈ e '' s :=
  ⟨fun h => ⟨e.symm x, h, by simp⟩, by
    rintro ⟨a, m, rfl⟩
    simpa using m⟩
#align category_theory.subobject.symm_apply_mem_iff_mem_image CategoryTheory.Subobject.symm_apply_mem_iff_mem_image

/- warning: category_theory.subobject.Sup_le -> CategoryTheory.Subobject.supₛ_le is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.WellPowered.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasCoproducts.{u1, u1, u2} C _inst_1] [_inst_5 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] {A : C} (s : Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) (f : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), (forall (g : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), (Membership.Mem.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) (Set.hasMem.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) g s) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 A))) g f)) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 A))) (CategoryTheory.Subobject.sup.{u1, u2} C _inst_1 _inst_3 (fun (J : Type.{u1}) => _inst_4 J) _inst_5 A s) f)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.WellPowered.{u1, u2} C _inst_1] [_inst_4 : CategoryTheory.Limits.HasCoproducts.{u1, u1, u2} C _inst_1] [_inst_5 : CategoryTheory.Limits.HasImages.{u1, u2} C _inst_1] {A : C} (s : Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) (f : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), (forall (g : CategoryTheory.Subobject.{u1, u2} C _inst_1 A), (Membership.mem.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) (Set.instMembershipSet.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A)) g s) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) g f)) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (CategoryTheory.Subobject.supₛ.{u1, u2} C _inst_1 _inst_3 (fun (J : Type.{u1}) => _inst_4 J) _inst_5 A s) f)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.Sup_le CategoryTheory.Subobject.supₛ_leₓ'. -/
theorem supₛ_le {A : C} (s : Set (Subobject A)) (f : Subobject A) (k : ∀ g ∈ s, g ≤ f) :
    sup s ≤ f := by
  fapply le_of_comm
  · dsimp [Sup]
    refine' (underlying_iso _).Hom ≫ image.lift ⟨_, f.arrow, _, _⟩
    · refine' sigma.desc _
      rintro ⟨g, m⟩
      refine' underlying.map (hom_of_le (k _ _))
      simpa [symm_apply_mem_iff_mem_image] using m
    · ext j
      rcases j with ⟨j, m⟩
      dsimp [small_coproduct_desc]
      simp
      dsimp
      simp
  · dsimp [Sup]
    simp
#align category_theory.subobject.Sup_le CategoryTheory.Subobject.supₛ_le

instance {B : C} : CompleteSemilatticeSup (Subobject B) :=
  { Subobject.partialOrder B with
    supₛ := sup
    le_sup := le_supₛ
    sup_le := supₛ_le }

end Sup

section CompleteLattice

variable [WellPowered C] [HasWidePullbacks.{v₁} C] [HasImages C] [HasCoproducts.{v₁} C]
  [InitialMonoClass C]

attribute [local instance] has_smallest_coproducts_of_has_coproducts

instance {B : C} : CompleteLattice (Subobject B) :=
  { Subobject.semilatticeInf, Subobject.semilatticeSup, Subobject.boundedOrder,
    Subobject.completeSemilatticeInf, Subobject.completeSemilatticeSup with }

end CompleteLattice

section ZeroObject

variable [HasZeroMorphisms C] [HasZeroObject C]

open ZeroObject

#print CategoryTheory.Subobject.nontrivial_of_not_isZero /-
/-- A nonzero object has nontrivial subobject lattice. -/
theorem nontrivial_of_not_isZero {X : C} (h : ¬IsZero X) : Nontrivial (Subobject X) :=
  ⟨⟨mk (0 : 0 ⟶ X), mk (𝟙 X), fun w => h (IsZero.of_iso (isZero_zero C) (isoOfMkEqMk _ _ w).symm)⟩⟩
#align category_theory.subobject.nontrivial_of_not_is_zero CategoryTheory.Subobject.nontrivial_of_not_isZero
-/

end ZeroObject

section SubobjectSubobject

/- warning: category_theory.subobject.subobject_order_iso -> CategoryTheory.Subobject.subobjectOrderIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), OrderIso.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 X)))) Y)) (coeSort.{succ (max u2 u1), succ (succ (max u2 u1))} (Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X)) Type.{max u2 u1} (Set.hasCoeToSort.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X)) (Set.Iic.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 X)) Y)) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 X)))) Y)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 X)))) Y)) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 X)))) Y)))) (Subtype.hasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 X))) (fun (x : CategoryTheory.Subobject.{u1, u2} C _inst_1 X) => Membership.Mem.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X)) (Set.hasMem.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X)) x (Set.Iic.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 X)) Y)))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), OrderIso.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) Y)) (Set.Elem.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Set.Iic.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X)) Y)) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) Y)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) Y)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) Y)))) (Subtype.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (fun (x : CategoryTheory.Subobject.{u1, u2} C _inst_1 X) => Membership.mem.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Set.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X)) (Set.instMembershipSet.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X)) x (Set.Iic.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X)) Y)))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.subobject_order_iso CategoryTheory.Subobject.subobjectOrderIsoₓ'. -/
/-- The subobject lattice of a subobject `Y` is order isomorphic to the interval `set.Iic Y`. -/
def subobjectOrderIso {X : C} (Y : Subobject X) : Subobject (Y : C) ≃o Set.Iic Y
    where
  toFun Z :=
    ⟨Subobject.mk (Z.arrow ≫ Y.arrow),
      Set.mem_Iic.mpr (le_of_comm ((underlyingIso _).Hom ≫ Z.arrow) (by simp))⟩
  invFun Z := Subobject.mk (ofLE _ _ Z.2)
  left_inv Z :=
    mk_eq_of_comm _ (underlyingIso _)
      (by
        ext
        simp)
  right_inv Z :=
    Subtype.ext
      (mk_eq_of_comm _ (underlyingIso _)
        (by
          dsimp
          simp [← iso.eq_inv_comp]))
  map_rel_iff' W Z :=
    ⟨fun h =>
      le_of_comm ((underlyingIso _).inv ≫ ofLE _ _ (Subtype.mk_le_mk.mp h) ≫ (underlyingIso _).Hom)
        (by
          ext
          simp),
      fun h =>
      Subtype.mk_le_mk.mpr
        (le_of_comm ((underlyingIso _).Hom ≫ ofLE _ _ h ≫ (underlyingIso _).inv) (by simp))⟩
#align category_theory.subobject.subobject_order_iso CategoryTheory.Subobject.subobjectOrderIso

end SubobjectSubobject

end Subobject

end CategoryTheory

