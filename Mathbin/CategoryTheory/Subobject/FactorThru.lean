/-
Copyright (c) 2020 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta, Scott Morrison

! This file was ported from Lean 3 source module category_theory.subobject.factor_thru
! leanprover-community/mathlib commit ce38d86c0b2d427ce208c3cee3159cb421d2b3c4
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Subobject.Basic
import Mathbin.CategoryTheory.Preadditive.Basic

/-!
# Factoring through subobjects

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

The predicate `h : P.factors f`, for `P : subobject Y` and `f : X ⟶ Y`
asserts the existence of some `P.factor_thru f : X ⟶ (P : C)` making the obvious diagram commute.

-/


universe v₁ v₂ u₁ u₂

noncomputable section

open CategoryTheory CategoryTheory.Category CategoryTheory.Limits

variable {C : Type u₁} [Category.{v₁} C] {X Y Z : C}

variable {D : Type u₂} [Category.{v₂} D]

namespace CategoryTheory

namespace MonoOver

#print CategoryTheory.MonoOver.Factors /-
/-- When `f : X ⟶ Y` and `P : mono_over Y`,
`P.factors f` expresses that there exists a factorisation of `f` through `P`.
Given `h : P.factors f`, you can recover the morphism as `P.factor_thru f h`.
-/
def Factors {X Y : C} (P : MonoOver Y) (f : X ⟶ Y) : Prop :=
  ∃ g : X ⟶ (P : C), g ≫ P.arrow = f
#align category_theory.mono_over.factors CategoryTheory.MonoOver.Factors
-/

#print CategoryTheory.MonoOver.factors_congr /-
theorem factors_congr {X : C} {f g : MonoOver X} {Y : C} (h : Y ⟶ X) (e : f ≅ g) :
    f.Factors h ↔ g.Factors h :=
  ⟨fun ⟨u, hu⟩ => ⟨u ≫ ((MonoOver.forget _).map e.Hom).left, by simp [hu]⟩, fun ⟨u, hu⟩ =>
    ⟨u ≫ ((MonoOver.forget _).map e.inv).left, by simp [hu]⟩⟩
#align category_theory.mono_over.factors_congr CategoryTheory.MonoOver.factors_congr
-/

/- warning: category_theory.mono_over.factor_thru -> CategoryTheory.MonoOver.factorThru is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (P : CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), (CategoryTheory.MonoOver.Factors.{u1, u2} C _inst_1 X Y P f) -> (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 Y)))) P))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (P : CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), (CategoryTheory.MonoOver.Factors.{u1, u2} C _inst_1 X Y P f) -> (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 Y) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 Y) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 Y) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 Y) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 Y)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 Y) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 Y) f)) P)))
Case conversion may be inaccurate. Consider using '#align category_theory.mono_over.factor_thru CategoryTheory.MonoOver.factorThruₓ'. -/
/-- `P.factor_thru f h` provides a factorisation of `f : X ⟶ Y` through some `P : mono_over Y`,
given the evidence `h : P.factors f` that such a factorisation exists. -/
def factorThru {X Y : C} (P : MonoOver Y) (f : X ⟶ Y) (h : Factors P f) : X ⟶ (P : C) :=
  Classical.choose h
#align category_theory.mono_over.factor_thru CategoryTheory.MonoOver.factorThru

end MonoOver

namespace Subobject

#print CategoryTheory.Subobject.Factors /-
/-- When `f : X ⟶ Y` and `P : subobject Y`,
`P.factors f` expresses that there exists a factorisation of `f` through `P`.
Given `h : P.factors f`, you can recover the morphism as `P.factor_thru f h`.
-/
def Factors {X Y : C} (P : Subobject Y) (f : X ⟶ Y) : Prop :=
  Quotient.liftOn' P (fun P => P.Factors f)
    (by
      rintro P Q ⟨h⟩
      apply propext
      constructor
      · rintro ⟨i, w⟩
        exact ⟨i ≫ h.hom.left, by erw [category.assoc, over.w h.hom, w]⟩
      · rintro ⟨i, w⟩
        exact ⟨i ≫ h.inv.left, by erw [category.assoc, over.w h.inv, w]⟩)
#align category_theory.subobject.factors CategoryTheory.Subobject.Factors
-/

#print CategoryTheory.Subobject.mk_factors_iff /-
@[simp]
theorem mk_factors_iff {X Y Z : C} (f : Y ⟶ X) [Mono f] (g : Z ⟶ X) :
    (Subobject.mk f).Factors g ↔ (MonoOver.mk' f).Factors g :=
  Iff.rfl
#align category_theory.subobject.mk_factors_iff CategoryTheory.Subobject.mk_factors_iff
-/

#print CategoryTheory.Subobject.mk_factors_self /-
theorem mk_factors_self (f : X ⟶ Y) [Mono f] : (mk f).Factors f :=
  ⟨𝟙 _, by simp⟩
#align category_theory.subobject.mk_factors_self CategoryTheory.Subobject.mk_factors_self
-/

/- warning: category_theory.subobject.factors_iff -> CategoryTheory.Subobject.factors_iff is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), Iff (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P f) (CategoryTheory.MonoOver.Factors.{u1, u2} C _inst_1 X Y (CategoryTheory.Functor.obj.{max u2 u1, u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y) (CategoryTheory.Subobject.representative.{u1, u2} C _inst_1 Y) P) f)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), Iff (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P f) (CategoryTheory.MonoOver.Factors.{u1, u2} C _inst_1 X Y (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 Y))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.representative.{u1, u2} C _inst_1 Y)) P) f)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factors_iff CategoryTheory.Subobject.factors_iffₓ'. -/
theorem factors_iff {X Y : C} (P : Subobject Y) (f : X ⟶ Y) :
    P.Factors f ↔ (representative.obj P).Factors f :=
  Quot.inductionOn P fun a => MonoOver.factors_congr _ (representativeIso _).symm
#align category_theory.subobject.factors_iff CategoryTheory.Subobject.factors_iff

/- warning: category_theory.subobject.factors_self -> CategoryTheory.Subobject.factors_self is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (P : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 X)))) P) X P (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 X P)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (P : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) P) X P (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 X P)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factors_self CategoryTheory.Subobject.factors_selfₓ'. -/
theorem factors_self {X : C} (P : Subobject X) : P.Factors P.arrow :=
  (factors_iff _ _).mpr ⟨𝟙 P, by simp⟩
#align category_theory.subobject.factors_self CategoryTheory.Subobject.factors_self

/- warning: category_theory.subobject.factors_comp_arrow -> CategoryTheory.Subobject.factors_comp_arrow is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} {P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) P)), CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) P) Y f (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y P))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} {P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) P)), CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) P) Y f (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y P))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factors_comp_arrow CategoryTheory.Subobject.factors_comp_arrowₓ'. -/
theorem factors_comp_arrow {X Y : C} {P : Subobject Y} (f : X ⟶ P) : P.Factors (f ≫ P.arrow) :=
  (factors_iff _ _).mpr ⟨f, rfl⟩
#align category_theory.subobject.factors_comp_arrow CategoryTheory.Subobject.factors_comp_arrow

#print CategoryTheory.Subobject.factors_of_factors_right /-
theorem factors_of_factors_right {X Y Z : C} {P : Subobject Z} (f : X ⟶ Y) {g : Y ⟶ Z}
    (h : P.Factors g) : P.Factors (f ≫ g) := by
  revert P
  refine' Quotient.ind' _
  intro P
  rintro ⟨g, rfl⟩
  exact ⟨f ≫ g, by simp⟩
#align category_theory.subobject.factors_of_factors_right CategoryTheory.Subobject.factors_of_factors_right
-/

#print CategoryTheory.Subobject.factors_zero /-
theorem factors_zero [HasZeroMorphisms C] {X Y : C} {P : Subobject Y} : P.Factors (0 : X ⟶ Y) :=
  (factors_iff _ _).mpr ⟨0, by simp⟩
#align category_theory.subobject.factors_zero CategoryTheory.Subobject.factors_zero
-/

/- warning: category_theory.subobject.factors_of_le -> CategoryTheory.Subobject.factors_of_le is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {Y : C} {Z : C} {P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} {Q : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Z Y), (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 Y))) P Q) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 Z Y P f) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 Z Y Q f)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {Y : C} {Z : C} {P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} {Q : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Z Y), (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) P Q) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 Z Y P f) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 Z Y Q f)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factors_of_le CategoryTheory.Subobject.factors_of_leₓ'. -/
theorem factors_of_le {Y Z : C} {P Q : Subobject Y} (f : Z ⟶ Y) (h : P ≤ Q) :
    P.Factors f → Q.Factors f := by
  simp only [factors_iff]
  exact fun ⟨u, hu⟩ => ⟨u ≫ of_le _ _ h, by simp [← hu]⟩
#align category_theory.subobject.factors_of_le CategoryTheory.Subobject.factors_of_le

/- warning: category_theory.subobject.factor_thru -> CategoryTheory.Subobject.factorThru is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P f) -> (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) P))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P f) -> (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) P))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factor_thru CategoryTheory.Subobject.factorThruₓ'. -/
/-- `P.factor_thru f h` provides a factorisation of `f : X ⟶ Y` through some `P : subobject Y`,
given the evidence `h : P.factors f` that such a factorisation exists. -/
def factorThru {X Y : C} (P : Subobject Y) (f : X ⟶ Y) (h : Factors P f) : X ⟶ P :=
  Classical.choose ((factors_iff _ _).mp h)
#align category_theory.subobject.factor_thru CategoryTheory.Subobject.factorThru

/- warning: category_theory.subobject.factor_thru_arrow -> CategoryTheory.Subobject.factorThru_arrow is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (h : CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P f), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) P) Y (CategoryTheory.Subobject.factorThru.{u1, u2} C _inst_1 X Y P f h) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y P)) f
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (h : CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P f), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) P) Y (CategoryTheory.Subobject.factorThru.{u1, u2} C _inst_1 X Y P f h) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y P)) f
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factor_thru_arrow CategoryTheory.Subobject.factorThru_arrowₓ'. -/
@[simp, reassoc]
theorem factorThru_arrow {X Y : C} (P : Subobject Y) (f : X ⟶ Y) (h : Factors P f) :
    P.factorThru f h ≫ P.arrow = f :=
  Classical.choose_spec ((factors_iff _ _).mp h)
#align category_theory.subobject.factor_thru_arrow CategoryTheory.Subobject.factorThru_arrow

/- warning: category_theory.subobject.factor_thru_self -> CategoryTheory.Subobject.factorThru_self is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (P : CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (h : CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 X)))) P) X P (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 X P)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 X)))) P) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 X)))) P)) (CategoryTheory.Subobject.factorThru.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 X)))) P) X P (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 X P) h) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 X)))) P))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (P : CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (h : CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) P) X P (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 X P)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) P) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) P)) (CategoryTheory.Subobject.factorThru.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) P) X P (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 X P) h) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) P))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factor_thru_self CategoryTheory.Subobject.factorThru_selfₓ'. -/
@[simp]
theorem factorThru_self {X : C} (P : Subobject X) (h) : P.factorThru P.arrow h = 𝟙 P :=
  by
  ext
  simp
#align category_theory.subobject.factor_thru_self CategoryTheory.Subobject.factorThru_self

/- warning: category_theory.subobject.factor_thru_mk_self -> CategoryTheory.Subobject.factorThru_mk_self is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3))) (CategoryTheory.Subobject.factorThru.{u1, u2} C _inst_1 X Y (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3) f (CategoryTheory.Subobject.mk_factors_self.{u1, u2} C _inst_1 X Y f _inst_3)) (CategoryTheory.Iso.inv.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3)) X (CategoryTheory.Subobject.underlyingIso.{u1, u2} C _inst_1 X Y f _inst_3))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3))) (CategoryTheory.Subobject.factorThru.{u1, u2} C _inst_1 X Y (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3) f (CategoryTheory.Subobject.mk_factors_self.{u1, u2} C _inst_1 X Y f _inst_3)) (CategoryTheory.Iso.inv.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3)) X (CategoryTheory.Subobject.underlyingIso.{u1, u2} C _inst_1 X Y f _inst_3))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factor_thru_mk_self CategoryTheory.Subobject.factorThru_mk_selfₓ'. -/
@[simp]
theorem factorThru_mk_self (f : X ⟶ Y) [Mono f] :
    (mk f).factorThru f (mk_factors_self f) = (underlyingIso f).inv :=
  by
  ext
  simp
#align category_theory.subobject.factor_thru_mk_self CategoryTheory.Subobject.factorThru_mk_self

/- warning: category_theory.subobject.factor_thru_comp_arrow -> CategoryTheory.Subobject.factorThru_comp_arrow is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} {P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) P)) (h : CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) P) Y f (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y P))), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) P)) (CategoryTheory.Subobject.factorThru.{u1, u2} C _inst_1 X Y P (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) P) Y f (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y P)) h) f
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} {P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) P)) (h : CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) P) Y f (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y P))), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) P)) (CategoryTheory.Subobject.factorThru.{u1, u2} C _inst_1 X Y P (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) P) Y f (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y P)) h) f
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factor_thru_comp_arrow CategoryTheory.Subobject.factorThru_comp_arrowₓ'. -/
@[simp]
theorem factorThru_comp_arrow {X Y : C} {P : Subobject Y} (f : X ⟶ P) (h) :
    P.factorThru (f ≫ P.arrow) h = f := by
  ext
  simp
#align category_theory.subobject.factor_thru_comp_arrow CategoryTheory.Subobject.factorThru_comp_arrow

/- warning: category_theory.subobject.factor_thru_eq_zero -> CategoryTheory.Subobject.factorThru_eq_zero is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factor_thru_eq_zero CategoryTheory.Subobject.factorThru_eq_zeroₓ'. -/
@[simp]
theorem factorThru_eq_zero [HasZeroMorphisms C] {X Y : C} {P : Subobject Y} {f : X ⟶ Y}
    {h : Factors P f} : P.factorThru f h = 0 ↔ f = 0 :=
  by
  fconstructor
  · intro w
    replace w := w =≫ P.arrow
    simpa using w
  · rintro rfl
    ext
    simp
#align category_theory.subobject.factor_thru_eq_zero CategoryTheory.Subobject.factorThru_eq_zero

/- warning: category_theory.subobject.factor_thru_right -> CategoryTheory.Subobject.factorThru_right is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} {Z : C} {P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Z} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y Z) (h : CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 Y Z P g), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Z)))) P)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X Y ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Z)))) P) f (CategoryTheory.Subobject.factorThru.{u1, u2} C _inst_1 Y Z P g h)) (CategoryTheory.Subobject.factorThru.{u1, u2} C _inst_1 X Z P (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X Y Z f g) (CategoryTheory.Subobject.factors_of_factors_right.{u1, u2} C _inst_1 X Y Z P f g h))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} {Z : C} {P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Z} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y Z) (h : CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 Y Z P g), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Z))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Z))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Z)) P)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X Y (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Z))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Z))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Z)) P) f (CategoryTheory.Subobject.factorThru.{u1, u2} C _inst_1 Y Z P g h)) (CategoryTheory.Subobject.factorThru.{u1, u2} C _inst_1 X Z P (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X Y Z f g) (CategoryTheory.Subobject.factors_of_factors_right.{u1, u2} C _inst_1 X Y Z P f g h))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factor_thru_right CategoryTheory.Subobject.factorThru_rightₓ'. -/
theorem factorThru_right {X Y Z : C} {P : Subobject Z} (f : X ⟶ Y) (g : Y ⟶ Z) (h : P.Factors g) :
    f ≫ P.factorThru g h = P.factorThru (f ≫ g) (factors_of_factors_right f h) :=
  by
  apply (cancel_mono P.arrow).mp
  simp
#align category_theory.subobject.factor_thru_right CategoryTheory.Subobject.factorThru_right

/- warning: category_theory.subobject.factor_thru_zero -> CategoryTheory.Subobject.factorThru_zero is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factor_thru_zero CategoryTheory.Subobject.factorThru_zeroₓ'. -/
@[simp]
theorem factorThru_zero [HasZeroMorphisms C] {X Y : C} {P : Subobject Y}
    (h : P.Factors (0 : X ⟶ Y)) : P.factorThru 0 h = 0 := by simp
#align category_theory.subobject.factor_thru_zero CategoryTheory.Subobject.factorThru_zero

/- warning: category_theory.subobject.factor_thru_of_le -> CategoryTheory.Subobject.factorThru_ofLE is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {Y : C} {Z : C} {P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} {Q : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Z Y} (h : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 Y))) P Q) (w : CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 Z Y P f), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Z ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) Q)) (CategoryTheory.Subobject.factorThru.{u1, u2} C _inst_1 Z Y Q f (CategoryTheory.Subobject.factors_of_le.{u1, u2} C _inst_1 Y Z P Q f h w)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) Z ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) P) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) Q) (CategoryTheory.Subobject.factorThru.{u1, u2} C _inst_1 Z Y P f w) (CategoryTheory.Subobject.ofLE.{u1, u2} C _inst_1 Y P Q h))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {Y : C} {Z : C} {P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} {Q : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Z Y} (h : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) P Q) (w : CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 Z Y P f), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Z (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) Q)) (CategoryTheory.Subobject.factorThru.{u1, u2} C _inst_1 Z Y Q f (CategoryTheory.Subobject.factors_of_le.{u1, u2} C _inst_1 Y Z P Q f h w)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) Z (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) P) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) Q) (CategoryTheory.Subobject.factorThru.{u1, u2} C _inst_1 Z Y P f w) (CategoryTheory.Subobject.ofLE.{u1, u2} C _inst_1 Y P Q h))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factor_thru_of_le CategoryTheory.Subobject.factorThru_ofLEₓ'. -/
-- `h` is an explicit argument here so we can use
-- `rw factor_thru_le h`, obtaining a subgoal `P.factors f`.
-- (While the reverse direction looks plausible as a simp lemma, it seems to be unproductive.)
theorem factorThru_ofLE {Y Z : C} {P Q : Subobject Y} {f : Z ⟶ Y} (h : P ≤ Q) (w : P.Factors f) :
    Q.factorThru f (factors_of_le f h w) = P.factorThru f w ≫ ofLE P Q h :=
  by
  ext
  simp
#align category_theory.subobject.factor_thru_of_le CategoryTheory.Subobject.factorThru_ofLE

section Preadditive

variable [Preadditive C]

/- warning: category_theory.subobject.factors_add -> CategoryTheory.Subobject.factors_add is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} {P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P f) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P g) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_3 X Y))))))) f g))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} {P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P f) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P g) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_3 X Y))))))) f g))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factors_add CategoryTheory.Subobject.factors_addₓ'. -/
theorem factors_add {X Y : C} {P : Subobject Y} (f g : X ⟶ Y) (wf : P.Factors f)
    (wg : P.Factors g) : P.Factors (f + g) :=
  (factors_iff _ _).mpr ⟨P.factorThru f wf + P.factorThru g wg, by simp⟩
#align category_theory.subobject.factors_add CategoryTheory.Subobject.factors_add

/- warning: category_theory.subobject.factor_thru_add -> CategoryTheory.Subobject.factorThru_add is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factor_thru_add CategoryTheory.Subobject.factorThru_addₓ'. -/
-- This can't be a `simp` lemma as `wf` and `wg` may not exist.
-- However you can `rw` by it to assert that `f` and `g` factor through `P` separately.
theorem factorThru_add {X Y : C} {P : Subobject Y} (f g : X ⟶ Y) (w : P.Factors (f + g))
    (wf : P.Factors f) (wg : P.Factors g) :
    P.factorThru (f + g) w = P.factorThru f wf + P.factorThru g wg :=
  by
  ext
  simp
#align category_theory.subobject.factor_thru_add CategoryTheory.Subobject.factorThru_add

/- warning: category_theory.subobject.factors_left_of_factors_add -> CategoryTheory.Subobject.factors_left_of_factors_add is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} {P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_3 X Y))))))) f g)) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P g) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P f)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} {P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_3 X Y))))))) f g)) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P g) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P f)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factors_left_of_factors_add CategoryTheory.Subobject.factors_left_of_factors_addₓ'. -/
theorem factors_left_of_factors_add {X Y : C} {P : Subobject Y} (f g : X ⟶ Y)
    (w : P.Factors (f + g)) (wg : P.Factors g) : P.Factors f :=
  (factors_iff _ _).mpr ⟨P.factorThru (f + g) w - P.factorThru g wg, by simp⟩
#align category_theory.subobject.factors_left_of_factors_add CategoryTheory.Subobject.factors_left_of_factors_add

/- warning: category_theory.subobject.factor_thru_add_sub_factor_thru_right -> CategoryTheory.Subobject.factorThru_add_sub_factorThru_right is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factor_thru_add_sub_factor_thru_right CategoryTheory.Subobject.factorThru_add_sub_factorThru_rightₓ'. -/
@[simp]
theorem factorThru_add_sub_factorThru_right {X Y : C} {P : Subobject Y} (f g : X ⟶ Y)
    (w : P.Factors (f + g)) (wg : P.Factors g) :
    P.factorThru (f + g) w - P.factorThru g wg =
      P.factorThru f (factors_left_of_factors_add f g w wg) :=
  by
  ext
  simp
#align category_theory.subobject.factor_thru_add_sub_factor_thru_right CategoryTheory.Subobject.factorThru_add_sub_factorThru_right

/- warning: category_theory.subobject.factors_right_of_factors_add -> CategoryTheory.Subobject.factors_right_of_factors_add is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} {P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_3 X Y))))))) f g)) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P f) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P g)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_3 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} {P : CategoryTheory.Subobject.{u1, u2} C _inst_1 Y} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_3 X Y))))))) f g)) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P f) -> (CategoryTheory.Subobject.Factors.{u1, u2} C _inst_1 X Y P g)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factors_right_of_factors_add CategoryTheory.Subobject.factors_right_of_factors_addₓ'. -/
theorem factors_right_of_factors_add {X Y : C} {P : Subobject Y} (f g : X ⟶ Y)
    (w : P.Factors (f + g)) (wf : P.Factors f) : P.Factors g :=
  (factors_iff _ _).mpr ⟨P.factorThru (f + g) w - P.factorThru f wf, by simp⟩
#align category_theory.subobject.factors_right_of_factors_add CategoryTheory.Subobject.factors_right_of_factors_add

/- warning: category_theory.subobject.factor_thru_add_sub_factor_thru_left -> CategoryTheory.Subobject.factorThru_add_sub_factorThru_left is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.factor_thru_add_sub_factor_thru_left CategoryTheory.Subobject.factorThru_add_sub_factorThru_leftₓ'. -/
@[simp]
theorem factorThru_add_sub_factorThru_left {X Y : C} {P : Subobject Y} (f g : X ⟶ Y)
    (w : P.Factors (f + g)) (wf : P.Factors f) :
    P.factorThru (f + g) w - P.factorThru f wf =
      P.factorThru g (factors_right_of_factors_add f g w wf) :=
  by
  ext
  simp
#align category_theory.subobject.factor_thru_add_sub_factor_thru_left CategoryTheory.Subobject.factorThru_add_sub_factorThru_left

end Preadditive

end Subobject

end CategoryTheory

