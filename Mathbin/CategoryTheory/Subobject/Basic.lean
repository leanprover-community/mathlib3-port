/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta, Scott Morrison

! This file was ported from Lean 3 source module category_theory.subobject.basic
! leanprover-community/mathlib commit ce38d86c0b2d427ce208c3cee3159cb421d2b3c4
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Subobject.MonoOver
import Mathbin.CategoryTheory.Skeletal
import Mathbin.CategoryTheory.ConcreteCategory.Basic
import Mathbin.Tactic.ApplyFun
import Mathbin.Tactic.Elementwise

/-!
# Subobjects

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We define `subobject X` as the quotient (by isomorphisms) of
`mono_over X := {f : over X // mono f.hom}`.

Here `mono_over X` is a thin category (a pair of objects has at most one morphism between them),
so we can think of it as a preorder. However as it is not skeletal, it is not a partial order.

There is a coercion from `subobject X` back to the ambient category `C`
(using choice to pick a representative), and for `P : subobject X`,
`P.arrow : (P : C) ⟶ X` is the inclusion morphism.

We provide
* `def pullback [has_pullbacks C] (f : X ⟶ Y) : subobject Y ⥤ subobject X`
* `def map (f : X ⟶ Y) [mono f] : subobject X ⥤ subobject Y`
* `def «exists» [has_images C] (f : X ⟶ Y) : subobject X ⥤ subobject Y`
and prove their basic properties and relationships.
These are all easy consequences of the earlier development
of the corresponding functors for `mono_over`.

The subobjects of `X` form a preorder making them into a category. We have `X ≤ Y` if and only if
`X.arrow` factors through `Y.arrow`: see `of_le`/`of_le_mk`/`of_mk_le`/`of_mk_le_mk` and
`le_of_comm`. Similarly, to show that two subobjects are equal, we can supply an isomorphism between
the underlying objects that commutes with the arrows (`eq_of_comm`).

See also

* `category_theory.subobject.factor_thru` :
  an API describing factorization of morphisms through subobjects.
* `category_theory.subobject.lattice` :
  the lattice structures on subobjects.

## Notes

This development originally appeared in Bhavik Mehta's "Topos theory for Lean" repository,
and was ported to mathlib by Scott Morrison.

### Implementation note

Currently we describe `pullback`, `map`, etc., as functors.
It may be better to just say that they are monotone functions,
and even avoid using categorical language entirely when describing `subobject X`.
(It's worth keeping this in mind in future use; it should be a relatively easy change here
if it looks preferable.)

### Relation to pseudoelements

There is a separate development of pseudoelements in `category_theory.abelian.pseudoelements`,
as a quotient (but not by isomorphism) of `over X`.

When a morphism `f` has an image, the image represents the same pseudoelement.
In a category with images `pseudoelements X` could be constructed as a quotient of `mono_over X`.
In fact, in an abelian category (I'm not sure in what generality beyond that),
`pseudoelements X` agrees with `subobject X`, but we haven't developed this in mathlib yet.

-/


universe v₁ v₂ u₁ u₂

noncomputable section

namespace CategoryTheory

open CategoryTheory CategoryTheory.Category CategoryTheory.Limits

variable {C : Type u₁} [Category.{v₁} C] {X Y Z : C}

variable {D : Type u₂} [Category.{v₂} D]

/-!
We now construct the subobject lattice for `X : C`,
as the quotient by isomorphisms of `mono_over X`.

Since `mono_over X` is a thin category, we use `thin_skeleton` to take the quotient.

Essentially all the structure defined above on `mono_over X` descends to `subobject X`,
with morphisms becoming inequalities, and isomorphisms becoming equations.
-/


#print CategoryTheory.Subobject /-
/-- The category of subobjects of `X : C`, defined as isomorphism classes of monomorphisms into `X`.
-/
def Subobject (X : C) :=
  ThinSkeleton (MonoOver X)deriving PartialOrder, Category
#align category_theory.subobject CategoryTheory.Subobject
-/

namespace Subobject

#print CategoryTheory.Subobject.mk /-
/-- Convenience constructor for a subobject. -/
abbrev mk {X A : C} (f : A ⟶ X) [Mono f] : Subobject X :=
  (toThinSkeleton _).obj (MonoOver.mk' f)
#align category_theory.subobject.mk CategoryTheory.Subobject.mk
-/

section

attribute [local ext] CategoryTheory.Comma

#print CategoryTheory.Subobject.ind /-
protected theorem ind {X : C} (p : Subobject X → Prop)
    (h : ∀ ⦃A : C⦄ (f : A ⟶ X) [Mono f], p (subobject.mk f)) (P : Subobject X) : p P :=
  by
  apply Quotient.inductionOn'
  intro a
  convert h a.arrow
  ext <;> rfl
#align category_theory.subobject.ind CategoryTheory.Subobject.ind
-/

#print CategoryTheory.Subobject.ind₂ /-
protected theorem ind₂ {X : C} (p : Subobject X → Subobject X → Prop)
    (h : ∀ ⦃A B : C⦄ (f : A ⟶ X) (g : B ⟶ X) [Mono f] [Mono g], p (subobject.mk f) (subobject.mk g))
    (P Q : Subobject X) : p P Q := by
  apply Quotient.inductionOn₂'
  intro a b
  convert h a.arrow b.arrow <;> ext <;> rfl
#align category_theory.subobject.ind₂ CategoryTheory.Subobject.ind₂
-/

end

#print CategoryTheory.Subobject.lift /-
/-- Declare a function on subobjects of `X` by specifying a function on monomorphisms with
    codomain `X`. -/
protected def lift {α : Sort _} {X : C} (F : ∀ ⦃A : C⦄ (f : A ⟶ X) [Mono f], α)
    (h :
      ∀ ⦃A B : C⦄ (f : A ⟶ X) (g : B ⟶ X) [Mono f] [Mono g] (i : A ≅ B),
        i.Hom ≫ g = f → F f = F g) :
    Subobject X → α := fun P =>
  Quotient.liftOn' P (fun m => F m.arrow) fun m n ⟨i⟩ =>
    h m.arrow n.arrow ((MonoOver.forget X ⋙ Over.forget X).mapIso i) (Over.w i.Hom)
#align category_theory.subobject.lift CategoryTheory.Subobject.lift
-/

/- warning: category_theory.subobject.lift_mk -> CategoryTheory.Subobject.lift_mk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {α : Sort.{u3}} {X : C} (F : forall {{A : C}} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A X) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A X f], α) {h : forall {{A : C}} {{B : C}} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A X) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) B X) [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A X f] [_inst_5 : CategoryTheory.Mono.{u1, u2} C _inst_1 B X g] (i : CategoryTheory.Iso.{u1, u2} C _inst_1 A B), (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A X) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A B X (CategoryTheory.Iso.hom.{u1, u2} C _inst_1 A B i) g) f) -> (Eq.{u3} α (F A f _inst_4) (F B g _inst_5))} {A : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A X) [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A X f], Eq.{u3} α (CategoryTheory.Subobject.lift.{u1, u2, u3} C _inst_1 α X F h (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 X A f _inst_4)) (F A f _inst_4)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {α : Sort.{u1}} {X : C} (F : forall {{A : C}} (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) A X) [_inst_3 : CategoryTheory.Mono.{u2, u3} C _inst_1 A X f], α) {h : forall {{A : C}} {{B : C}} (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) A X) (g : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) [_inst_4 : CategoryTheory.Mono.{u2, u3} C _inst_1 A X f] [_inst_5 : CategoryTheory.Mono.{u2, u3} C _inst_1 B X g] (i : CategoryTheory.Iso.{u2, u3} C _inst_1 A B), (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) A X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) A B X (CategoryTheory.Iso.hom.{u2, u3} C _inst_1 A B i) g) f) -> (Eq.{u1} α (F A f _inst_4) (F B g _inst_5))} {A : C} (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) A X) [_inst_4 : CategoryTheory.Mono.{u2, u3} C _inst_1 A X f], Eq.{u1} α (CategoryTheory.Subobject.lift.{u2, u3, u1} C _inst_1 α X F h (CategoryTheory.Subobject.mk.{u2, u3} C _inst_1 X A f _inst_4)) (F A f _inst_4)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.lift_mk CategoryTheory.Subobject.lift_mkₓ'. -/
@[simp]
protected theorem lift_mk {α : Sort _} {X : C} (F : ∀ ⦃A : C⦄ (f : A ⟶ X) [Mono f], α) {h A}
    (f : A ⟶ X) [Mono f] : Subobject.lift F h (Subobject.mk f) = F f :=
  rfl
#align category_theory.subobject.lift_mk CategoryTheory.Subobject.lift_mk

/- warning: category_theory.subobject.equiv_mono_over -> CategoryTheory.Subobject.equivMonoOver is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (X : C), CategoryTheory.Equivalence.{max u2 u1, u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (X : C), CategoryTheory.Equivalence.{max u2 u1, u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.equiv_mono_over CategoryTheory.Subobject.equivMonoOverₓ'. -/
/-- The category of subobjects is equivalent to the `mono_over` category. It is more convenient to
use the former due to the partial order instance, but oftentimes it is easier to define structures
on the latter. -/
noncomputable def equivMonoOver (X : C) : Subobject X ≌ MonoOver X :=
  ThinSkeleton.equivalence _
#align category_theory.subobject.equiv_mono_over CategoryTheory.Subobject.equivMonoOver

#print CategoryTheory.Subobject.representative /-
/-- Use choice to pick a representative `mono_over X` for each `subobject X`.
-/
noncomputable def representative {X : C} : Subobject X ⥤ MonoOver X :=
  (equivMonoOver X).Functor
#align category_theory.subobject.representative CategoryTheory.Subobject.representative
-/

/- warning: category_theory.subobject.representative_iso -> CategoryTheory.Subobject.representativeIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (A : CategoryTheory.MonoOver.{u1, u2} C _inst_1 X), CategoryTheory.Iso.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X) (CategoryTheory.Functor.obj.{max u2 u1, u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X) (CategoryTheory.Subobject.representative.{u1, u2} C _inst_1 X) (CategoryTheory.Functor.obj.{u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X) (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.toThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) A)) A
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (A : CategoryTheory.MonoOver.{u1, u2} C _inst_1 X), CategoryTheory.Iso.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.representative.{u1, u2} C _inst_1 X)) (Prefunctor.obj.{succ u1, succ (max u2 u1), max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X))) (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X)) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X)) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X))))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X))) (CategoryTheory.toThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X))) A)) A
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.representative_iso CategoryTheory.Subobject.representativeIsoₓ'. -/
/-- Starting with `A : mono_over X`, we can take its equivalence class in `subobject X`
then pick an arbitrary representative using `representative.obj`.
This is isomorphic (in `mono_over X`) to the original `A`.
-/
noncomputable def representativeIso {X : C} (A : MonoOver X) :
    representative.obj ((toThinSkeleton _).obj A) ≅ A :=
  (equivMonoOver X).counitIso.app A
#align category_theory.subobject.representative_iso CategoryTheory.Subobject.representativeIso

#print CategoryTheory.Subobject.underlying /-
/-- Use choice to pick a representative underlying object in `C` for any `subobject X`.

Prefer to use the coercion `P : C` rather than explicitly writing `underlying.obj P`.
-/
noncomputable def underlying {X : C} : Subobject X ⥤ C :=
  representative ⋙ MonoOver.forget _ ⋙ Over.forget _
#align category_theory.subobject.underlying CategoryTheory.Subobject.underlying
-/

instance : Coe (Subobject X) C where coe Y := underlying.obj Y

@[simp]
theorem underlying_as_coe {X : C} (P : Subobject X) : underlying.obj P = P :=
  rfl
#align category_theory.subobject.underlying_as_coe CategoryTheory.Subobject.underlying_as_coe

/- warning: category_theory.subobject.underlying_iso -> CategoryTheory.Subobject.underlyingIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], CategoryTheory.Iso.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3)) X
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], CategoryTheory.Iso.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3)) X
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.underlying_iso CategoryTheory.Subobject.underlyingIsoₓ'. -/
/-- If we construct a `subobject Y` from an explicit `f : X ⟶ Y` with `[mono f]`,
then pick an arbitrary choice of underlying object `(subobject.mk f : C)` back in `C`,
it is isomorphic (in `C`) to the original `X`.
-/
noncomputable def underlyingIso {X Y : C} (f : X ⟶ Y) [Mono f] : (Subobject.mk f : C) ≅ X :=
  (MonoOver.forget _ ⋙ Over.forget _).mapIso (representativeIso (MonoOver.mk' f))
#align category_theory.subobject.underlying_iso CategoryTheory.Subobject.underlyingIso

/- warning: category_theory.subobject.arrow -> CategoryTheory.Subobject.arrow is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 X)))) Y) X
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) Y) X
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.arrow CategoryTheory.Subobject.arrowₓ'. -/
/-- The morphism in `C` from the arbitrarily chosen underlying object to the ambient object.
-/
noncomputable def arrow {X : C} (Y : Subobject X) : (Y : C) ⟶ X :=
  (representative.obj Y).obj.Hom
#align category_theory.subobject.arrow CategoryTheory.Subobject.arrow

/- warning: category_theory.subobject.arrow_mono -> CategoryTheory.Subobject.arrow_mono is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), CategoryTheory.Mono.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 X)))) Y) X (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 X Y)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) Y) X (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 X Y)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.arrow_mono CategoryTheory.Subobject.arrow_monoₓ'. -/
instance arrow_mono {X : C} (Y : Subobject X) : Mono Y.arrow :=
  (representative.obj Y).property
#align category_theory.subobject.arrow_mono CategoryTheory.Subobject.arrow_mono

/- warning: category_theory.subobject.arrow_congr -> CategoryTheory.Subobject.arrow_congr is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.arrow_congr CategoryTheory.Subobject.arrow_congrₓ'. -/
@[simp]
theorem arrow_congr {A : C} (X Y : Subobject A) (h : X = Y) :
    eqToHom (congr_arg (fun X : Subobject A => (X : C)) h) ≫ Y.arrow = X.arrow :=
  by
  induction h
  simp
#align category_theory.subobject.arrow_congr CategoryTheory.Subobject.arrow_congr

/- warning: category_theory.subobject.representative_coe -> CategoryTheory.Subobject.representative_coe is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), Eq.{succ u2} C ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 X)))) (CategoryTheory.Functor.obj.{max u2 u1, u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X) (CategoryTheory.Subobject.representative.{u1, u2} C _inst_1 X) Y)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 X)))) Y)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), Eq.{succ u2} C (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 X) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 X) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.representative.{u1, u2} C _inst_1 X)) Y))) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) Y)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.representative_coe CategoryTheory.Subobject.representative_coeₓ'. -/
@[simp]
theorem representative_coe (Y : Subobject X) : (representative.obj Y : C) = (Y : C) :=
  rfl
#align category_theory.subobject.representative_coe CategoryTheory.Subobject.representative_coe

/- warning: category_theory.subobject.representative_arrow -> CategoryTheory.Subobject.representative_arrow is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) C (CategoryTheory.MonoOver.hasCoe.{u1, u2} C _inst_1 X)))) (CategoryTheory.Functor.obj.{max u2 u1, u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X) (CategoryTheory.Subobject.representative.{u1, u2} C _inst_1 X) Y)) X) (CategoryTheory.MonoOver.arrow.{u1, u2} C _inst_1 X (CategoryTheory.Functor.obj.{max u2 u1, u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X) (CategoryTheory.Subobject.representative.{u1, u2} C _inst_1 X) Y)) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 X Y)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) (CategoryTheory.FullSubcategory.obj.{max u2 u1} (CategoryTheory.Over.{u1, u2} C _inst_1 X) (fun (f : CategoryTheory.Over.{u1, u2} C _inst_1 X) => CategoryTheory.Mono.{u1, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (CategoryTheory.Comma.left.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X)) (CategoryTheory.Comma.right.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (CategoryTheory.Comma.hom.{u1, u1, u1, u2, u1, u2} C _inst_1 (CategoryTheory.Discrete.{u1} PUnit.{succ u1}) (CategoryTheory.discreteCategory.{u1} PUnit.{succ u1}) C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.fromPUnit.{u1, u2} C _inst_1 X) f)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.representative.{u1, u2} C _inst_1 X)) Y))) X) (CategoryTheory.MonoOver.arrow.{u1, u2} C _inst_1 X (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.instCategoryMonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.representative.{u1, u2} C _inst_1 X)) Y)) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 X Y)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.representative_arrow CategoryTheory.Subobject.representative_arrowₓ'. -/
@[simp]
theorem representative_arrow (Y : Subobject X) : (representative.obj Y).arrow = Y.arrow :=
  rfl
#align category_theory.subobject.representative_arrow CategoryTheory.Subobject.representative_arrow

/- warning: category_theory.subobject.underlying_arrow -> CategoryTheory.Subobject.underlying_arrow is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 X} {Z : CategoryTheory.Subobject.{u1, u2} C _inst_1 X} (f : Quiver.Hom.{succ (max u2 u1), max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.category.{u2, u1} C _inst_1 X))) Y Z), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X) Y) X) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X) Y) (CategoryTheory.Functor.obj.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X) Z) X (CategoryTheory.Functor.map.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X) Y Z f) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 X Z)) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 X Y)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 X} {Z : CategoryTheory.Subobject.{u1, u2} C _inst_1 X} (f : Quiver.Hom.{max (succ u2) (succ u1), max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) Y Z), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) Y) X) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) Y) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) Z) X (Prefunctor.map.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) Y Z f) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 X Z)) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 X Y)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.underlying_arrow CategoryTheory.Subobject.underlying_arrowₓ'. -/
@[simp, reassoc]
theorem underlying_arrow {X : C} {Y Z : Subobject X} (f : Y ⟶ Z) :
    underlying.map f ≫ arrow Z = arrow Y :=
  Over.w (representative.map f)
#align category_theory.subobject.underlying_arrow CategoryTheory.Subobject.underlying_arrow

/- warning: category_theory.subobject.underlying_iso_arrow -> CategoryTheory.Subobject.underlyingIso_arrow is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3)) Y (CategoryTheory.Iso.inv.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3)) X (CategoryTheory.Subobject.underlyingIso.{u1, u2} C _inst_1 X Y f _inst_3)) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3))) f
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3)) Y (CategoryTheory.Iso.inv.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3)) X (CategoryTheory.Subobject.underlyingIso.{u1, u2} C _inst_1 X Y f _inst_3)) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3))) f
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.underlying_iso_arrow CategoryTheory.Subobject.underlyingIso_arrowₓ'. -/
@[simp, reassoc, elementwise]
theorem underlyingIso_arrow {X Y : C} (f : X ⟶ Y) [Mono f] :
    (underlyingIso f).inv ≫ (Subobject.mk f).arrow = f :=
  Over.w _
#align category_theory.subobject.underlying_iso_arrow CategoryTheory.Subobject.underlyingIso_arrow

/- warning: category_theory.subobject.underlying_iso_hom_comp_eq_mk -> CategoryTheory.Subobject.underlyingIso_hom_comp_eq_mk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3)) Y) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3)) X Y (CategoryTheory.Iso.hom.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 Y)))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3)) X (CategoryTheory.Subobject.underlyingIso.{u1, u2} C _inst_1 X Y f _inst_3)) f) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f], Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3)) Y) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3)) X Y (CategoryTheory.Iso.hom.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 Y)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3)) X (CategoryTheory.Subobject.underlyingIso.{u1, u2} C _inst_1 X Y f _inst_3)) f) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 Y (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 Y X f _inst_3))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.underlying_iso_hom_comp_eq_mk CategoryTheory.Subobject.underlyingIso_hom_comp_eq_mkₓ'. -/
@[simp, reassoc]
theorem underlyingIso_hom_comp_eq_mk {X Y : C} (f : X ⟶ Y) [Mono f] :
    (underlyingIso f).Hom ≫ f = (mk f).arrow :=
  (Iso.eq_inv_comp _).1 (underlyingIso_arrow f).symm
#align category_theory.subobject.underlying_iso_hom_comp_eq_mk CategoryTheory.Subobject.underlyingIso_hom_comp_eq_mk

/- warning: category_theory.subobject.eq_of_comp_arrow_eq -> CategoryTheory.Subobject.eq_of_comp_arrow_eq is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.eq_of_comp_arrow_eq CategoryTheory.Subobject.eq_of_comp_arrow_eqₓ'. -/
/-- Two morphisms into a subobject are equal exactly if
the morphisms into the ambient object are equal -/
@[ext]
theorem eq_of_comp_arrow_eq {X Y : C} {P : Subobject Y} {f g : X ⟶ P}
    (h : f ≫ P.arrow = g ≫ P.arrow) : f = g :=
  (cancel_mono P.arrow).mp h
#align category_theory.subobject.eq_of_comp_arrow_eq CategoryTheory.Subobject.eq_of_comp_arrow_eq

/- warning: category_theory.subobject.mk_le_mk_of_comm -> CategoryTheory.Subobject.mk_le_mk_of_comm is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A₁ : C} {A₂ : C} {f₁ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ B} {f₂ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₂ B} [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₁ B f₁] [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₂ B f₂] (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ A₂), (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A₁ A₂ B g f₂) f₁) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f₁ _inst_3) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ f₂ _inst_4))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A₁ : C} {A₂ : C} {f₁ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ B} {f₂ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₂ B} [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₁ B f₁] [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₂ B f₂] (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ A₂), (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A₁ A₂ B g f₂) f₁) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f₁ _inst_3) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ f₂ _inst_4))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.mk_le_mk_of_comm CategoryTheory.Subobject.mk_le_mk_of_commₓ'. -/
theorem mk_le_mk_of_comm {B A₁ A₂ : C} {f₁ : A₁ ⟶ B} {f₂ : A₂ ⟶ B} [Mono f₁] [Mono f₂] (g : A₁ ⟶ A₂)
    (w : g ≫ f₂ = f₁) : mk f₁ ≤ mk f₂ :=
  ⟨MonoOver.homMk _ w⟩
#align category_theory.subobject.mk_le_mk_of_comm CategoryTheory.Subobject.mk_le_mk_of_comm

/- warning: category_theory.subobject.mk_arrow -> CategoryTheory.Subobject.mk_arrow is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (P : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 X ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 X)))) P) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 X P) (CategoryTheory.Subobject.arrow_mono.{u1, u2} C _inst_1 X P)) P
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (P : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 X (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 X)) P) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 X P) (CategoryTheory.Subobject.arrow_mono.{u1, u2} C _inst_1 X P)) P
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.mk_arrow CategoryTheory.Subobject.mk_arrowₓ'. -/
@[simp]
theorem mk_arrow (P : Subobject X) : mk P.arrow = P :=
  Quotient.inductionOn' P fun Q =>
    by
    obtain ⟨e⟩ := @Quotient.mk_out' _ (is_isomorphic_setoid _) Q
    refine' Quotient.sound' ⟨mono_over.iso_mk _ _ ≪≫ e⟩ <;> tidy
#align category_theory.subobject.mk_arrow CategoryTheory.Subobject.mk_arrow

/- warning: category_theory.subobject.le_of_comm -> CategoryTheory.Subobject.le_of_comm is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.le_of_comm CategoryTheory.Subobject.le_of_commₓ'. -/
theorem le_of_comm {B : C} {X Y : Subobject B} (f : (X : C) ⟶ (Y : C)) (w : f ≫ Y.arrow = X.arrow) :
    X ≤ Y := by convert mk_le_mk_of_comm _ w <;> simp
#align category_theory.subobject.le_of_comm CategoryTheory.Subobject.le_of_comm

/- warning: category_theory.subobject.le_mk_of_comm -> CategoryTheory.Subobject.le_mk_of_comm is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B} [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) A), (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) A B g f) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B X)) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) X (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B} [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) A), (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) A B g f) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B X)) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) X (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.le_mk_of_comm CategoryTheory.Subobject.le_mk_of_commₓ'. -/
theorem le_mk_of_comm {B A : C} {X : Subobject B} {f : A ⟶ B} [Mono f] (g : (X : C) ⟶ A)
    (w : g ≫ f = X.arrow) : X ≤ mk f :=
  le_of_comm (g ≫ (underlyingIso f).inv) <| by simp [w]
#align category_theory.subobject.le_mk_of_comm CategoryTheory.Subobject.le_mk_of_comm

/- warning: category_theory.subobject.mk_le_of_comm -> CategoryTheory.Subobject.mk_le_of_comm is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B} [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X)), (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) B g (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B X)) f) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3) X)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B} [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X)), (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) B g (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B X)) f) -> (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3) X)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.mk_le_of_comm CategoryTheory.Subobject.mk_le_of_commₓ'. -/
theorem mk_le_of_comm {B A : C} {X : Subobject B} {f : A ⟶ B} [Mono f] (g : A ⟶ (X : C))
    (w : g ≫ X.arrow = f) : mk f ≤ X :=
  le_of_comm ((underlyingIso f).Hom ≫ g) <| by simp [w]
#align category_theory.subobject.mk_le_of_comm CategoryTheory.Subobject.mk_le_of_comm

/- warning: category_theory.subobject.eq_of_comm -> CategoryTheory.Subobject.eq_of_comm is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.eq_of_comm CategoryTheory.Subobject.eq_of_commₓ'. -/
/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with
    the arrows. -/
@[ext]
theorem eq_of_comm {B : C} {X Y : Subobject B} (f : (X : C) ≅ (Y : C))
    (w : f.Hom ≫ Y.arrow = X.arrow) : X = Y :=
  le_antisymm (le_of_comm f.Hom w) <| le_of_comm f.inv <| f.inv_comp_eq.2 w.symm
#align category_theory.subobject.eq_of_comm CategoryTheory.Subobject.eq_of_comm

/- warning: category_theory.subobject.eq_mk_of_comm -> CategoryTheory.Subobject.eq_mk_of_comm is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] (i : CategoryTheory.Iso.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) A), (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) A B (CategoryTheory.Iso.hom.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) A i) f) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B X)) -> (Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) X (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] (i : CategoryTheory.Iso.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) A), (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) A B (CategoryTheory.Iso.hom.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) A i) f) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B X)) -> (Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) X (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.eq_mk_of_comm CategoryTheory.Subobject.eq_mk_of_commₓ'. -/
/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with
    the arrows. -/
@[ext]
theorem eq_mk_of_comm {B A : C} {X : Subobject B} (f : A ⟶ B) [Mono f] (i : (X : C) ≅ A)
    (w : i.Hom ≫ f = X.arrow) : X = mk f :=
  eq_of_comm (i.trans (underlyingIso f).symm) <| by simp [w]
#align category_theory.subobject.eq_mk_of_comm CategoryTheory.Subobject.eq_mk_of_comm

/- warning: category_theory.subobject.mk_eq_of_comm -> CategoryTheory.Subobject.mk_eq_of_comm is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] (i : CategoryTheory.Iso.{u1, u2} C _inst_1 A ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X)), (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) B (CategoryTheory.Iso.hom.{u1, u2} C _inst_1 A ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) i) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B X)) f) -> (Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3) X)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] (i : CategoryTheory.Iso.{u1, u2} C _inst_1 A (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X)), (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) B (CategoryTheory.Iso.hom.{u1, u2} C _inst_1 A (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) i) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B X)) f) -> (Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3) X)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.mk_eq_of_comm CategoryTheory.Subobject.mk_eq_of_commₓ'. -/
/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with
    the arrows. -/
@[ext]
theorem mk_eq_of_comm {B A : C} {X : Subobject B} (f : A ⟶ B) [Mono f] (i : A ≅ (X : C))
    (w : i.Hom ≫ X.arrow = f) : mk f = X :=
  Eq.symm <| eq_mk_of_comm _ i.symm <| by rw [iso.symm_hom, iso.inv_comp_eq, w]
#align category_theory.subobject.mk_eq_of_comm CategoryTheory.Subobject.mk_eq_of_comm

#print CategoryTheory.Subobject.mk_eq_mk_of_comm /-
/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with
    the arrows. -/
@[ext]
theorem mk_eq_mk_of_comm {B A₁ A₂ : C} (f : A₁ ⟶ B) (g : A₂ ⟶ B) [Mono f] [Mono g] (i : A₁ ≅ A₂)
    (w : i.Hom ≫ g = f) : mk f = mk g :=
  eq_mk_of_comm _ ((underlyingIso f).trans i) <| by simp [w]
#align category_theory.subobject.mk_eq_mk_of_comm CategoryTheory.Subobject.mk_eq_mk_of_comm
-/

/- warning: category_theory.subobject.of_le -> CategoryTheory.Subobject.ofLE is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B), (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) X Y) -> (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) Y))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B), (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) X Y) -> (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) Y))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_le CategoryTheory.Subobject.ofLEₓ'. -/
-- We make `X` and `Y` explicit arguments here so that when `of_le` appears in goal statements
-- it is possible to see its source and target
-- (`h` will just display as `_`, because it is in `Prop`).
/-- An inequality of subobjects is witnessed by some morphism between the corresponding objects. -/
def ofLE {B : C} (X Y : Subobject B) (h : X ≤ Y) : (X : C) ⟶ (Y : C) :=
  underlying.map <| h.Hom
#align category_theory.subobject.of_le CategoryTheory.Subobject.ofLE

/- warning: category_theory.subobject.of_le_arrow -> CategoryTheory.Subobject.ofLE_arrow is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} (h : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) X Y), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) Y) B (CategoryTheory.Subobject.ofLE.{u1, u2} C _inst_1 B X Y h) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B Y)) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B X)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} (h : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) X Y), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) Y) B (CategoryTheory.Subobject.ofLE.{u1, u2} C _inst_1 B X Y h) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B Y)) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B X)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_le_arrow CategoryTheory.Subobject.ofLE_arrowₓ'. -/
@[simp, reassoc]
theorem ofLE_arrow {B : C} {X Y : Subobject B} (h : X ≤ Y) : ofLE X Y h ≫ Y.arrow = X.arrow :=
  underlying_arrow _
#align category_theory.subobject.of_le_arrow CategoryTheory.Subobject.ofLE_arrow

instance {B : C} (X Y : Subobject B) (h : X ≤ Y) : Mono (ofLE X Y h) :=
  by
  fconstructor
  intro Z f g w
  replace w := w =≫ Y.arrow
  ext
  simpa using w

/- warning: category_theory.subobject.of_le_mk_le_mk_of_comm -> CategoryTheory.Subobject.ofLE_mk_le_mk_of_comm is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_le_mk_le_mk_of_comm CategoryTheory.Subobject.ofLE_mk_le_mk_of_commₓ'. -/
theorem ofLE_mk_le_mk_of_comm {B A₁ A₂ : C} {f₁ : A₁ ⟶ B} {f₂ : A₂ ⟶ B} [Mono f₁] [Mono f₂]
    (g : A₁ ⟶ A₂) (w : g ≫ f₂ = f₁) :
    ofLE _ _ (mk_le_mk_of_comm g w) = (underlyingIso _).Hom ≫ g ≫ (underlyingIso _).inv :=
  by
  ext
  simp [w]
#align category_theory.subobject.of_le_mk_le_mk_of_comm CategoryTheory.Subobject.ofLE_mk_le_mk_of_comm

/- warning: category_theory.subobject.of_le_mk -> CategoryTheory.Subobject.ofLEMk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f], (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) X (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3)) -> (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) A)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f], (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) X (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3)) -> (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) A)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_le_mk CategoryTheory.Subobject.ofLEMkₓ'. -/
/-- An inequality of subobjects is witnessed by some morphism between the corresponding objects. -/
def ofLEMk {B A : C} (X : Subobject B) (f : A ⟶ B) [Mono f] (h : X ≤ mk f) : (X : C) ⟶ A :=
  ofLE X (mk f) h ≫ (underlyingIso f).Hom deriving Mono
#align category_theory.subobject.of_le_mk CategoryTheory.Subobject.ofLEMk

/- warning: category_theory.subobject.of_le_mk_comp -> CategoryTheory.Subobject.ofLEMk_comp is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B} [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] (h : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) X (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) A B (CategoryTheory.Subobject.ofLEMk.{u1, u2} C _inst_1 B A X f _inst_3 h) f) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B X)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B} [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] (h : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) X (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) A B (CategoryTheory.Subobject.ofLEMk.{u1, u2} C _inst_1 B A X f _inst_3 h) f) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B X)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_le_mk_comp CategoryTheory.Subobject.ofLEMk_compₓ'. -/
@[simp]
theorem ofLEMk_comp {B A : C} {X : Subobject B} {f : A ⟶ B} [Mono f] (h : X ≤ mk f) :
    ofLEMk X f h ≫ f = X.arrow := by simp [of_le_mk]
#align category_theory.subobject.of_le_mk_comp CategoryTheory.Subobject.ofLEMk_comp

/- warning: category_theory.subobject.of_mk_le -> CategoryTheory.Subobject.ofMkLE is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B), (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3) X) -> (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B), (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3) X) -> (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_mk_le CategoryTheory.Subobject.ofMkLEₓ'. -/
/-- An inequality of subobjects is witnessed by some morphism between the corresponding objects. -/
def ofMkLE {B A : C} (f : A ⟶ B) [Mono f] (X : Subobject B) (h : mk f ≤ X) : A ⟶ (X : C) :=
  (underlyingIso f).inv ≫ ofLE (mk f) X h deriving Mono
#align category_theory.subobject.of_mk_le CategoryTheory.Subobject.ofMkLE

/- warning: category_theory.subobject.of_mk_le_arrow -> CategoryTheory.Subobject.ofMkLE_arrow is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B} [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} (h : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3) X), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) B (CategoryTheory.Subobject.ofMkLE.{u1, u2} C _inst_1 B A f _inst_3 X h) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B X)) f
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B} [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] {X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B} (h : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3) X), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) B (CategoryTheory.Subobject.ofMkLE.{u1, u2} C _inst_1 B A f _inst_3 X h) (CategoryTheory.Subobject.arrow.{u1, u2} C _inst_1 B X)) f
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_mk_le_arrow CategoryTheory.Subobject.ofMkLE_arrowₓ'. -/
@[simp]
theorem ofMkLE_arrow {B A : C} {f : A ⟶ B} [Mono f] {X : Subobject B} (h : mk f ≤ X) :
    ofMkLE f X h ≫ X.arrow = f := by simp [of_mk_le]
#align category_theory.subobject.of_mk_le_arrow CategoryTheory.Subobject.ofMkLE_arrow

/- warning: category_theory.subobject.of_mk_le_mk -> CategoryTheory.Subobject.ofMkLEMk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A₁ : C} {A₂ : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ B) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₂ B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₁ B f] [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₂ B g], (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f _inst_3) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ g _inst_4)) -> (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ A₂)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A₁ : C} {A₂ : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ B) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₂ B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₁ B f] [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₂ B g], (LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f _inst_3) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ g _inst_4)) -> (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ A₂)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_mk_le_mk CategoryTheory.Subobject.ofMkLEMkₓ'. -/
/-- An inequality of subobjects is witnessed by some morphism between the corresponding objects. -/
def ofMkLEMk {B A₁ A₂ : C} (f : A₁ ⟶ B) (g : A₂ ⟶ B) [Mono f] [Mono g] (h : mk f ≤ mk g) :
    A₁ ⟶ A₂ :=
  (underlyingIso f).inv ≫ ofLE (mk f) (mk g) h ≫ (underlyingIso g).Hom deriving Mono
#align category_theory.subobject.of_mk_le_mk CategoryTheory.Subobject.ofMkLEMk

/- warning: category_theory.subobject.of_mk_le_mk_comp -> CategoryTheory.Subobject.ofMkLEMk_comp is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A₁ : C} {A₂ : C} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ B} {g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₂ B} [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₁ B f] [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₂ B g] (h : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f _inst_3) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ g _inst_4)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A₁ A₂ B (CategoryTheory.Subobject.ofMkLEMk.{u1, u2} C _inst_1 B A₁ A₂ f g _inst_3 _inst_4 h) g) f
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A₁ : C} {A₂ : C} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ B} {g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₂ B} [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₁ B f] [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₂ B g] (h : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f _inst_3) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ g _inst_4)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ B) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A₁ A₂ B (CategoryTheory.Subobject.ofMkLEMk.{u1, u2} C _inst_1 B A₁ A₂ f g _inst_3 _inst_4 h) g) f
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_mk_le_mk_comp CategoryTheory.Subobject.ofMkLEMk_compₓ'. -/
@[simp]
theorem ofMkLEMk_comp {B A₁ A₂ : C} {f : A₁ ⟶ B} {g : A₂ ⟶ B} [Mono f] [Mono g] (h : mk f ≤ mk g) :
    ofMkLEMk f g h ≫ g = f := by simp [of_mk_le_mk]
#align category_theory.subobject.of_mk_le_mk_comp CategoryTheory.Subobject.ofMkLEMk_comp

/- warning: category_theory.subobject.of_le_comp_of_le -> CategoryTheory.Subobject.ofLE_comp_ofLE is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_le_comp_of_le CategoryTheory.Subobject.ofLE_comp_ofLEₓ'. -/
@[simp, reassoc]
theorem ofLE_comp_ofLE {B : C} (X Y Z : Subobject B) (h₁ : X ≤ Y) (h₂ : Y ≤ Z) :
    ofLE X Y h₁ ≫ ofLE Y Z h₂ = ofLE X Z (h₁.trans h₂) := by
  simp [of_le, ← functor.map_comp underlying]
#align category_theory.subobject.of_le_comp_of_le CategoryTheory.Subobject.ofLE_comp_ofLE

/- warning: category_theory.subobject.of_le_comp_of_le_mk -> CategoryTheory.Subobject.ofLE_comp_ofLEMk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] (h₁ : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) X Y) (h₂ : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) Y (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) A) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) Y) A (CategoryTheory.Subobject.ofLE.{u1, u2} C _inst_1 B X Y h₁) (CategoryTheory.Subobject.ofLEMk.{u1, u2} C _inst_1 B A Y f _inst_3 h₂)) (CategoryTheory.Subobject.ofLEMk.{u1, u2} C _inst_1 B A X f _inst_3 (LE.le.trans.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B)) X Y (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3) h₁ h₂))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] (h₁ : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) X Y) (h₂ : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) Y (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) A) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) Y) A (CategoryTheory.Subobject.ofLE.{u1, u2} C _inst_1 B X Y h₁) (CategoryTheory.Subobject.ofLEMk.{u1, u2} C _inst_1 B A Y f _inst_3 h₂)) (CategoryTheory.Subobject.ofLEMk.{u1, u2} C _inst_1 B A X f _inst_3 (LE.le.trans.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B)) X Y (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3) h₁ h₂))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_le_comp_of_le_mk CategoryTheory.Subobject.ofLE_comp_ofLEMkₓ'. -/
@[simp, reassoc]
theorem ofLE_comp_ofLEMk {B A : C} (X Y : Subobject B) (f : A ⟶ B) [Mono f] (h₁ : X ≤ Y)
    (h₂ : Y ≤ mk f) : ofLE X Y h₁ ≫ ofLEMk Y f h₂ = ofLEMk X f (h₁.trans h₂) := by
  simp [of_mk_le, of_le_mk, of_le, ← functor.map_comp_assoc underlying]
#align category_theory.subobject.of_le_comp_of_le_mk CategoryTheory.Subobject.ofLE_comp_ofLEMk

/- warning: category_theory.subobject.of_le_mk_comp_of_mk_le -> CategoryTheory.Subobject.ofLEMk_comp_ofMkLE is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_le_mk_comp_of_mk_le CategoryTheory.Subobject.ofLEMk_comp_ofMkLEₓ'. -/
@[simp, reassoc]
theorem ofLEMk_comp_ofMkLE {B A : C} (X : Subobject B) (f : A ⟶ B) [Mono f] (Y : Subobject B)
    (h₁ : X ≤ mk f) (h₂ : mk f ≤ Y) : ofLEMk X f h₁ ≫ ofMkLE f Y h₂ = ofLE X Y (h₁.trans h₂) := by
  simp [of_mk_le, of_le_mk, of_le, ← functor.map_comp underlying]
#align category_theory.subobject.of_le_mk_comp_of_mk_le CategoryTheory.Subobject.ofLEMk_comp_ofMkLE

/- warning: category_theory.subobject.of_le_mk_comp_of_mk_le_mk -> CategoryTheory.Subobject.ofLEMk_comp_ofMkLEMk is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_le_mk_comp_of_mk_le_mk CategoryTheory.Subobject.ofLEMk_comp_ofMkLEMkₓ'. -/
@[simp, reassoc]
theorem ofLEMk_comp_ofMkLEMk {B A₁ A₂ : C} (X : Subobject B) (f : A₁ ⟶ B) [Mono f] (g : A₂ ⟶ B)
    [Mono g] (h₁ : X ≤ mk f) (h₂ : mk f ≤ mk g) :
    ofLEMk X f h₁ ≫ ofMkLEMk f g h₂ = ofLEMk X g (h₁.trans h₂) := by
  simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ← functor.map_comp_assoc underlying]
#align category_theory.subobject.of_le_mk_comp_of_mk_le_mk CategoryTheory.Subobject.ofLEMk_comp_ofMkLEMk

/- warning: category_theory.subobject.of_mk_le_comp_of_le -> CategoryTheory.Subobject.ofMkLE_comp_ofLE is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A₁ : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₁ B f] (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (h₁ : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f _inst_3) X) (h₂ : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) X Y), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) Y)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A₁ ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) Y) (CategoryTheory.Subobject.ofMkLE.{u1, u2} C _inst_1 B A₁ f _inst_3 X h₁) (CategoryTheory.Subobject.ofLE.{u1, u2} C _inst_1 B X Y h₂)) (CategoryTheory.Subobject.ofMkLE.{u1, u2} C _inst_1 B A₁ f _inst_3 Y (LE.le.trans.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f _inst_3) X Y h₁ h₂))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A₁ : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₁ B f] (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (h₁ : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f _inst_3) X) (h₂ : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) X Y), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) Y)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A₁ (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) Y) (CategoryTheory.Subobject.ofMkLE.{u1, u2} C _inst_1 B A₁ f _inst_3 X h₁) (CategoryTheory.Subobject.ofLE.{u1, u2} C _inst_1 B X Y h₂)) (CategoryTheory.Subobject.ofMkLE.{u1, u2} C _inst_1 B A₁ f _inst_3 Y (LE.le.trans.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f _inst_3) X Y h₁ h₂))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_mk_le_comp_of_le CategoryTheory.Subobject.ofMkLE_comp_ofLEₓ'. -/
@[simp, reassoc]
theorem ofMkLE_comp_ofLE {B A₁ : C} (f : A₁ ⟶ B) [Mono f] (X Y : Subobject B) (h₁ : mk f ≤ X)
    (h₂ : X ≤ Y) : ofMkLE f X h₁ ≫ ofLE X Y h₂ = ofMkLE f Y (h₁.trans h₂) := by
  simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ← functor.map_comp underlying]
#align category_theory.subobject.of_mk_le_comp_of_le CategoryTheory.Subobject.ofMkLE_comp_ofLE

/- warning: category_theory.subobject.of_mk_le_comp_of_le_mk -> CategoryTheory.Subobject.ofMkLE_comp_ofLEMk is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_mk_le_comp_of_le_mk CategoryTheory.Subobject.ofMkLE_comp_ofLEMkₓ'. -/
@[simp, reassoc]
theorem ofMkLE_comp_ofLEMk {B A₁ A₂ : C} (f : A₁ ⟶ B) [Mono f] (X : Subobject B) (g : A₂ ⟶ B)
    [Mono g] (h₁ : mk f ≤ X) (h₂ : X ≤ mk g) :
    ofMkLE f X h₁ ≫ ofLEMk X g h₂ = ofMkLEMk f g (h₁.trans h₂) := by
  simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ← functor.map_comp_assoc underlying]
#align category_theory.subobject.of_mk_le_comp_of_le_mk CategoryTheory.Subobject.ofMkLE_comp_ofLEMk

/- warning: category_theory.subobject.of_mk_le_mk_comp_of_mk_le -> CategoryTheory.Subobject.ofMkLEMk_comp_ofMkLE is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A₁ : C} {A₂ : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₁ B f] (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₂ B) [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₂ B g] (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (h₁ : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f _inst_3) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ g _inst_4)) (h₂ : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ g _inst_4) X), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A₁ A₂ ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) (CategoryTheory.Subobject.ofMkLEMk.{u1, u2} C _inst_1 B A₁ A₂ f g _inst_3 _inst_4 h₁) (CategoryTheory.Subobject.ofMkLE.{u1, u2} C _inst_1 B A₂ g _inst_4 X h₂)) (CategoryTheory.Subobject.ofMkLE.{u1, u2} C _inst_1 B A₁ f _inst_3 X (LE.le.trans.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f _inst_3) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ g _inst_4) X h₁ h₂))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A₁ : C} {A₂ : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₁ B f] (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₂ B) [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₂ B g] (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (h₁ : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f _inst_3) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ g _inst_4)) (h₂ : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ g _inst_4) X), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A₁ A₂ (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) (CategoryTheory.Subobject.ofMkLEMk.{u1, u2} C _inst_1 B A₁ A₂ f g _inst_3 _inst_4 h₁) (CategoryTheory.Subobject.ofMkLE.{u1, u2} C _inst_1 B A₂ g _inst_4 X h₂)) (CategoryTheory.Subobject.ofMkLE.{u1, u2} C _inst_1 B A₁ f _inst_3 X (LE.le.trans.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f _inst_3) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ g _inst_4) X h₁ h₂))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_mk_le_mk_comp_of_mk_le CategoryTheory.Subobject.ofMkLEMk_comp_ofMkLEₓ'. -/
@[simp, reassoc]
theorem ofMkLEMk_comp_ofMkLE {B A₁ A₂ : C} (f : A₁ ⟶ B) [Mono f] (g : A₂ ⟶ B) [Mono g]
    (X : Subobject B) (h₁ : mk f ≤ mk g) (h₂ : mk g ≤ X) :
    ofMkLEMk f g h₁ ≫ ofMkLE g X h₂ = ofMkLE f X (h₁.trans h₂) := by
  simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ← functor.map_comp underlying]
#align category_theory.subobject.of_mk_le_mk_comp_of_mk_le CategoryTheory.Subobject.ofMkLEMk_comp_ofMkLE

/- warning: category_theory.subobject.of_mk_le_mk_comp_of_mk_le_mk -> CategoryTheory.Subobject.ofMkLEMk_comp_ofMkLEMk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A₁ : C} {A₂ : C} {A₃ : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₁ B f] (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₂ B) [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₂ B g] (h : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₃ B) [_inst_5 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₃ B h] (h₁ : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f _inst_3) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ g _inst_4)) (h₂ : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ g _inst_4) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₃ h _inst_5)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ A₃) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A₁ A₂ A₃ (CategoryTheory.Subobject.ofMkLEMk.{u1, u2} C _inst_1 B A₁ A₂ f g _inst_3 _inst_4 h₁) (CategoryTheory.Subobject.ofMkLEMk.{u1, u2} C _inst_1 B A₂ A₃ g h _inst_4 _inst_5 h₂)) (CategoryTheory.Subobject.ofMkLEMk.{u1, u2} C _inst_1 B A₁ A₃ f h _inst_3 _inst_5 (LE.le.trans.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f _inst_3) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ g _inst_4) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₃ h _inst_5) h₁ h₂))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A₁ : C} {A₂ : C} {A₃ : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₁ B f] (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₂ B) [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₂ B g] (h : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₃ B) [_inst_5 : CategoryTheory.Mono.{u1, u2} C _inst_1 A₃ B h] (h₁ : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f _inst_3) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ g _inst_4)) (h₂ : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ g _inst_4) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₃ h _inst_5)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A₁ A₃) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) A₁ A₂ A₃ (CategoryTheory.Subobject.ofMkLEMk.{u1, u2} C _inst_1 B A₁ A₂ f g _inst_3 _inst_4 h₁) (CategoryTheory.Subobject.ofMkLEMk.{u1, u2} C _inst_1 B A₂ A₃ g h _inst_4 _inst_5 h₂)) (CategoryTheory.Subobject.ofMkLEMk.{u1, u2} C _inst_1 B A₁ A₃ f h _inst_3 _inst_5 (LE.le.trans.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B)) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₁ f _inst_3) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₂ g _inst_4) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A₃ h _inst_5) h₁ h₂))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_mk_le_mk_comp_of_mk_le_mk CategoryTheory.Subobject.ofMkLEMk_comp_ofMkLEMkₓ'. -/
@[simp, reassoc]
theorem ofMkLEMk_comp_ofMkLEMk {B A₁ A₂ A₃ : C} (f : A₁ ⟶ B) [Mono f] (g : A₂ ⟶ B) [Mono g]
    (h : A₃ ⟶ B) [Mono h] (h₁ : mk f ≤ mk g) (h₂ : mk g ≤ mk h) :
    ofMkLEMk f g h₁ ≫ ofMkLEMk g h h₂ = ofMkLEMk f h (h₁.trans h₂) := by
  simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ← functor.map_comp_assoc underlying]
#align category_theory.subobject.of_mk_le_mk_comp_of_mk_le_mk CategoryTheory.Subobject.ofMkLEMk_comp_ofMkLEMk

/- warning: category_theory.subobject.of_le_refl -> CategoryTheory.Subobject.ofLE_refl is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X)) (CategoryTheory.Subobject.ofLE.{u1, u2} C _inst_1 B X X (le_rfl.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 B)) X)) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X)) (CategoryTheory.Subobject.ofLE.{u1, u2} C _inst_1 B X X (le_rfl.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B)) X)) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.of_le_refl CategoryTheory.Subobject.ofLE_reflₓ'. -/
@[simp]
theorem ofLE_refl {B : C} (X : Subobject B) : ofLE X X le_rfl = 𝟙 _ :=
  by
  apply (cancel_mono X.arrow).mp
  simp
#align category_theory.subobject.of_le_refl CategoryTheory.Subobject.ofLE_refl

#print CategoryTheory.Subobject.ofMkLEMk_refl /-
@[simp]
theorem ofMkLEMk_refl {B A₁ : C} (f : A₁ ⟶ B) [Mono f] : ofMkLEMk f f le_rfl = 𝟙 _ :=
  by
  apply (cancel_mono f).mp
  simp
#align category_theory.subobject.of_mk_le_mk_refl CategoryTheory.Subobject.ofMkLEMk_refl
-/

/- warning: category_theory.subobject.iso_of_eq -> CategoryTheory.Subobject.isoOfEq is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B), (Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) X Y) -> (CategoryTheory.Iso.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) Y))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Y : CategoryTheory.Subobject.{u1, u2} C _inst_1 B), (Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) X Y) -> (CategoryTheory.Iso.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) Y))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.iso_of_eq CategoryTheory.Subobject.isoOfEqₓ'. -/
-- As with `of_le`, we have `X` and `Y` as explicit arguments for readability.
/-- An equality of subobjects gives an isomorphism of the corresponding objects.
(One could use `underlying.map_iso (eq_to_iso h))` here, but this is more readable.) -/
@[simps]
def isoOfEq {B : C} (X Y : Subobject B) (h : X = Y) : (X : C) ≅ (Y : C)
    where
  Hom := ofLE _ _ h.le
  inv := ofLE _ _ h.ge
#align category_theory.subobject.iso_of_eq CategoryTheory.Subobject.isoOfEq

/- warning: category_theory.subobject.iso_of_eq_mk -> CategoryTheory.Subobject.isoOfEqMk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f], (Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) X (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3)) -> (CategoryTheory.Iso.{u1, u2} C _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X) A)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f], (Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) X (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3)) -> (CategoryTheory.Iso.{u1, u2} C _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X) A)
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.iso_of_eq_mk CategoryTheory.Subobject.isoOfEqMkₓ'. -/
/-- An equality of subobjects gives an isomorphism of the corresponding objects. -/
@[simps]
def isoOfEqMk {B A : C} (X : Subobject B) (f : A ⟶ B) [Mono f] (h : X = mk f) : (X : C) ≅ A
    where
  Hom := ofLEMk X f h.le
  inv := ofMkLE f X h.ge
#align category_theory.subobject.iso_of_eq_mk CategoryTheory.Subobject.isoOfEqMk

/- warning: category_theory.subobject.iso_of_mk_eq -> CategoryTheory.Subobject.isoOfMkEq is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B), (Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3) X) -> (CategoryTheory.Iso.{u1, u2} C _inst_1 A ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) C (CategoryTheory.Subobject.hasCoe.{u1, u2} C _inst_1 B)))) X))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {B : C} {A : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) A B) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 A B f] (X : CategoryTheory.Subobject.{u1, u2} C _inst_1 B), (Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.mk.{u1, u2} C _inst_1 B A f _inst_3) X) -> (CategoryTheory.Iso.{u1, u2} C _inst_1 A (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))) C _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} C _inst_1 B)) X))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.iso_of_mk_eq CategoryTheory.Subobject.isoOfMkEqₓ'. -/
/-- An equality of subobjects gives an isomorphism of the corresponding objects. -/
@[simps]
def isoOfMkEq {B A : C} (f : A ⟶ B) [Mono f] (X : Subobject B) (h : mk f = X) : A ≅ (X : C)
    where
  Hom := ofMkLE f X h.le
  inv := ofLEMk X f h.ge
#align category_theory.subobject.iso_of_mk_eq CategoryTheory.Subobject.isoOfMkEq

#print CategoryTheory.Subobject.isoOfMkEqMk /-
/-- An equality of subobjects gives an isomorphism of the corresponding objects. -/
@[simps]
def isoOfMkEqMk {B A₁ A₂ : C} (f : A₁ ⟶ B) (g : A₂ ⟶ B) [Mono f] [Mono g] (h : mk f = mk g) :
    A₁ ≅ A₂ where
  Hom := ofMkLEMk f g h.le
  inv := ofMkLEMk g f h.ge
#align category_theory.subobject.iso_of_mk_eq_mk CategoryTheory.Subobject.isoOfMkEqMk
-/

end Subobject

open CategoryTheory.Limits

namespace Subobject

#print CategoryTheory.Subobject.lower /-
/-- Any functor `mono_over X ⥤ mono_over Y` descends to a functor
`subobject X ⥤ subobject Y`, because `mono_over Y` is thin. -/
def lower {Y : D} (F : MonoOver X ⥤ MonoOver Y) : Subobject X ⥤ Subobject Y :=
  ThinSkeleton.map F
#align category_theory.subobject.lower CategoryTheory.Subobject.lower
-/

#print CategoryTheory.Subobject.lower_iso /-
/-- Isomorphic functors become equal when lowered to `subobject`.
(It's not as evil as usual to talk about equality between functors
because the categories are thin and skeletal.) -/
theorem lower_iso (F₁ F₂ : MonoOver X ⥤ MonoOver Y) (h : F₁ ≅ F₂) : lower F₁ = lower F₂ :=
  ThinSkeleton.map_iso_eq h
#align category_theory.subobject.lower_iso CategoryTheory.Subobject.lower_iso
-/

#print CategoryTheory.Subobject.lower₂ /-
/-- A ternary version of `subobject.lower`. -/
def lower₂ (F : MonoOver X ⥤ MonoOver Y ⥤ MonoOver Z) : Subobject X ⥤ Subobject Y ⥤ Subobject Z :=
  ThinSkeleton.map₂ F
#align category_theory.subobject.lower₂ CategoryTheory.Subobject.lower₂
-/

#print CategoryTheory.Subobject.lower_comm /-
@[simp]
theorem lower_comm (F : MonoOver Y ⥤ MonoOver X) :
    toThinSkeleton _ ⋙ lower F = F ⋙ toThinSkeleton _ :=
  rfl
#align category_theory.subobject.lower_comm CategoryTheory.Subobject.lower_comm
-/

#print CategoryTheory.Subobject.lowerAdjunction /-
/-- An adjunction between `mono_over A` and `mono_over B` gives an adjunction
between `subobject A` and `subobject B`. -/
def lowerAdjunction {A : C} {B : D} {L : MonoOver A ⥤ MonoOver B} {R : MonoOver B ⥤ MonoOver A}
    (h : L ⊣ R) : lower L ⊣ lower R :=
  ThinSkeleton.lowerAdjunction _ _ h
#align category_theory.subobject.lower_adjunction CategoryTheory.Subobject.lowerAdjunction
-/

/- warning: category_theory.subobject.lower_equivalence -> CategoryTheory.Subobject.lowerEquivalence is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {A : C} {B : D}, (CategoryTheory.Equivalence.{u1, u2, max u3 u1, max u4 u2} (CategoryTheory.MonoOver.{u1, u3} C _inst_1 A) (CategoryTheory.MonoOver.category.{u3, u1} C _inst_1 A) (CategoryTheory.MonoOver.{u2, u4} D _inst_2 B) (CategoryTheory.MonoOver.category.{u4, u2} D _inst_2 B)) -> (CategoryTheory.Equivalence.{max u3 u1, max u4 u2, max u3 u1, max u4 u2} (CategoryTheory.Subobject.{u1, u3} C _inst_1 A) (CategoryTheory.Subobject.category.{u3, u1} C _inst_1 A) (CategoryTheory.Subobject.{u2, u4} D _inst_2 B) (CategoryTheory.Subobject.category.{u4, u2} D _inst_2 B))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] {D : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u2, u4} D] {A : C} {B : D}, (CategoryTheory.Equivalence.{u1, u2, max u3 u1, max u4 u2} (CategoryTheory.MonoOver.{u1, u3} C _inst_1 A) (CategoryTheory.MonoOver.{u2, u4} D _inst_2 B) (CategoryTheory.instCategoryMonoOver.{u1, u3} C _inst_1 A) (CategoryTheory.instCategoryMonoOver.{u2, u4} D _inst_2 B)) -> (CategoryTheory.Equivalence.{max u3 u1, max u4 u2, max u3 u1, max u4 u2} (CategoryTheory.Subobject.{u1, u3} C _inst_1 A) (CategoryTheory.Subobject.{u2, u4} D _inst_2 B) (Preorder.smallCategory.{max u3 u1} (CategoryTheory.Subobject.{u1, u3} C _inst_1 A) (PartialOrder.toPreorder.{max u3 u1} (CategoryTheory.Subobject.{u1, u3} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u3} C _inst_1 A))) (Preorder.smallCategory.{max u4 u2} (CategoryTheory.Subobject.{u2, u4} D _inst_2 B) (PartialOrder.toPreorder.{max u4 u2} (CategoryTheory.Subobject.{u2, u4} D _inst_2 B) (CategoryTheory.instPartialOrderSubobject.{u2, u4} D _inst_2 B))))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.lower_equivalence CategoryTheory.Subobject.lowerEquivalenceₓ'. -/
/-- An equivalence between `mono_over A` and `mono_over B` gives an equivalence
between `subobject A` and `subobject B`. -/
@[simps]
def lowerEquivalence {A : C} {B : D} (e : MonoOver A ≌ MonoOver B) : Subobject A ≌ Subobject B
    where
  Functor := lower e.Functor
  inverse := lower e.inverse
  unitIso := by
    apply eq_to_iso
    convert thin_skeleton.map_iso_eq e.unit_iso
    · exact thin_skeleton.map_id_eq.symm
    · exact (thin_skeleton.map_comp_eq _ _).symm
  counitIso := by
    apply eq_to_iso
    convert thin_skeleton.map_iso_eq e.counit_iso
    · exact (thin_skeleton.map_comp_eq _ _).symm
    · exact thin_skeleton.map_id_eq.symm
#align category_theory.subobject.lower_equivalence CategoryTheory.Subobject.lowerEquivalence

section Pullback

variable [HasPullbacks C]

#print CategoryTheory.Subobject.pullback /-
/-- When `C` has pullbacks, a morphism `f : X ⟶ Y` induces a functor `subobject Y ⥤ subobject X`,
by pulling back a monomorphism along `f`. -/
def pullback (f : X ⟶ Y) : Subobject Y ⥤ Subobject X :=
  lower (MonoOver.pullback f)
#align category_theory.subobject.pullback CategoryTheory.Subobject.pullback
-/

/- warning: category_theory.subobject.pullback_id -> CategoryTheory.Subobject.pullback_id is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] (x : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 X X _inst_3 (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X)) x) x
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] (x : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 X X _inst_3 (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X))) x) x
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.pullback_id CategoryTheory.Subobject.pullback_idₓ'. -/
theorem pullback_id (x : Subobject X) : (pullback (𝟙 X)).obj x = x :=
  by
  apply Quotient.inductionOn' x
  intro f
  apply Quotient.sound
  exact ⟨mono_over.pullback_id.app f⟩
#align category_theory.subobject.pullback_id CategoryTheory.Subobject.pullback_id

/- warning: category_theory.subobject.pullback_comp -> CategoryTheory.Subobject.pullback_comp is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} {Z : C} [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y Z) (x : CategoryTheory.Subobject.{u1, u2} C _inst_1 Z), Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Z) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Z)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Z) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Z))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 X Z _inst_3 (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X Y Z f g)) x) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 X Y _inst_3 f) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Z) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Z)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Z) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Z))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 Y Z _inst_3 g) x))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} {Z : C} [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y Z) (x : CategoryTheory.Subobject.{u1, u2} C _inst_1 Z), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Z))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Z))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 X Z _inst_3 (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X Y Z f g))) x) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 X Y _inst_3 f)) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Z))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Z))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 Y Z _inst_3 g)) x))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.pullback_comp CategoryTheory.Subobject.pullback_compₓ'. -/
theorem pullback_comp (f : X ⟶ Y) (g : Y ⟶ Z) (x : Subobject Z) :
    (pullback (f ≫ g)).obj x = (pullback f).obj ((pullback g).obj x) :=
  by
  apply Quotient.inductionOn' x
  intro t
  apply Quotient.sound
  refine' ⟨(mono_over.pullback_comp _ _).app t⟩
#align category_theory.subobject.pullback_comp CategoryTheory.Subobject.pullback_comp

instance (f : X ⟶ Y) : Faithful (pullback f) where

end Pullback

section Map

#print CategoryTheory.Subobject.map /-
/-- We can map subobjects of `X` to subobjects of `Y`
by post-composition with a monomorphism `f : X ⟶ Y`.
-/
def map (f : X ⟶ Y) [Mono f] : Subobject X ⥤ Subobject Y :=
  lower (MonoOver.map f)
#align category_theory.subobject.map CategoryTheory.Subobject.map
-/

/- warning: category_theory.subobject.map_id -> CategoryTheory.Subobject.map_id is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (x : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 X X (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X) (CategoryTheory.CategoryStruct.id.mono.{u1, u2} C _inst_1 X)) x) x
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} (x : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 X X (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X) (CategoryTheory.instMonoIdToCategoryStruct.{u1, u2} C _inst_1 X))) x) x
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.map_id CategoryTheory.Subobject.map_idₓ'. -/
theorem map_id (x : Subobject X) : (map (𝟙 X)).obj x = x :=
  by
  apply Quotient.inductionOn' x
  intro f
  apply Quotient.sound
  exact ⟨mono_over.map_id.app f⟩
#align category_theory.subobject.map_id CategoryTheory.Subobject.map_id

/- warning: category_theory.subobject.map_comp -> CategoryTheory.Subobject.map_comp is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} {Z : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y Z) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f] [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 Y Z g] (x : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Z) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Z)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Z) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Z))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 X Z (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X Y Z f g) (CategoryTheory.mono_comp.{u1, u2} C _inst_1 X Y Z f _inst_3 g _inst_4)) x) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Z) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Z)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Z) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Z))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 Y Z g _inst_4) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 X Y f _inst_3) x))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} {Z : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y Z) [_inst_3 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f] [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 Y Z g] (x : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Z))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Z))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 X Z (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X Y Z f g) (CategoryTheory.mono_comp.{u1, u2} C _inst_1 X Y Z f _inst_3 g _inst_4))) x) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Z))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Z) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Z))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 Y Z g _inst_4)) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 X Y f _inst_3)) x))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.map_comp CategoryTheory.Subobject.map_compₓ'. -/
theorem map_comp (f : X ⟶ Y) (g : Y ⟶ Z) [Mono f] [Mono g] (x : Subobject X) :
    (map (f ≫ g)).obj x = (map g).obj ((map f).obj x) :=
  by
  apply Quotient.inductionOn' x
  intro t
  apply Quotient.sound
  refine' ⟨(mono_over.map_comp _ _).app t⟩
#align category_theory.subobject.map_comp CategoryTheory.Subobject.map_comp

/- warning: category_theory.subobject.map_iso -> CategoryTheory.Subobject.mapIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {A : C} {B : C}, (CategoryTheory.Iso.{u1, u2} C _inst_1 A B) -> (CategoryTheory.Equivalence.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.category.{u2, u1} C _inst_1 A) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.Subobject.category.{u2, u1} C _inst_1 B))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {A : C} {B : C}, (CategoryTheory.Iso.{u1, u2} C _inst_1 A B) -> (CategoryTheory.Equivalence.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 A))) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 B))))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.map_iso CategoryTheory.Subobject.mapIsoₓ'. -/
/-- Isomorphic objects have equivalent subobject lattices. -/
def mapIso {A B : C} (e : A ≅ B) : Subobject A ≌ Subobject B :=
  lowerEquivalence (MonoOver.mapIso e)
#align category_theory.subobject.map_iso CategoryTheory.Subobject.mapIso

/- warning: category_theory.subobject.map_iso_to_order_iso -> CategoryTheory.Subobject.mapIsoToOrderIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C}, (CategoryTheory.Iso.{u1, u2} C _inst_1 X Y) -> (OrderIso.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 X))) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Subobject.partialOrder.{u2, u1} C _inst_1 Y))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C}, (CategoryTheory.Iso.{u1, u2} C _inst_1 X Y) -> (OrderIso.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (Preorder.toLE.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.map_iso_to_order_iso CategoryTheory.Subobject.mapIsoToOrderIsoₓ'. -/
-- @[simps] here generates a lemma `map_iso_to_order_iso_to_equiv_symm_apply`
-- whose left hand side is not in simp normal form.
/-- In fact, there's a type level bijection between the subobjects of isomorphic objects,
which preserves the order. -/
def mapIsoToOrderIso (e : X ≅ Y) : Subobject X ≃o Subobject Y
    where
  toFun := (map e.Hom).obj
  invFun := (map e.inv).obj
  left_inv g := by simp_rw [← map_comp, e.hom_inv_id, map_id]
  right_inv g := by simp_rw [← map_comp, e.inv_hom_id, map_id]
  map_rel_iff' A B := by
    dsimp; fconstructor
    · intro h
      apply_fun (map e.inv).obj  at h
      simp_rw [← map_comp, e.hom_inv_id, map_id] at h
      exact h
    · intro h
      apply_fun (map e.hom).obj  at h
      exact h
#align category_theory.subobject.map_iso_to_order_iso CategoryTheory.Subobject.mapIsoToOrderIso

/- warning: category_theory.subobject.map_iso_to_order_iso_apply -> CategoryTheory.Subobject.mapIsoToOrderIso_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.map_iso_to_order_iso_apply CategoryTheory.Subobject.mapIsoToOrderIso_applyₓ'. -/
@[simp]
theorem mapIsoToOrderIso_apply (e : X ≅ Y) (P : Subobject X) :
    mapIsoToOrderIso e P = (map e.Hom).obj P :=
  rfl
#align category_theory.subobject.map_iso_to_order_iso_apply CategoryTheory.Subobject.mapIsoToOrderIso_apply

/- warning: category_theory.subobject.map_iso_to_order_iso_symm_apply -> CategoryTheory.Subobject.mapIsoToOrderIso_symm_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.map_iso_to_order_iso_symm_apply CategoryTheory.Subobject.mapIsoToOrderIso_symm_applyₓ'. -/
@[simp]
theorem mapIsoToOrderIso_symm_apply (e : X ≅ Y) (Q : Subobject Y) :
    (mapIsoToOrderIso e).symm Q = (map e.inv).obj Q :=
  rfl
#align category_theory.subobject.map_iso_to_order_iso_symm_apply CategoryTheory.Subobject.mapIsoToOrderIso_symm_apply

#print CategoryTheory.Subobject.mapPullbackAdj /-
/-- `map f : subobject X ⥤ subobject Y` is
the left adjoint of `pullback f : subobject Y ⥤ subobject X`. -/
def mapPullbackAdj [HasPullbacks C] (f : X ⟶ Y) [Mono f] : map f ⊣ pullback f :=
  lowerAdjunction (MonoOver.mapPullbackAdj f)
#align category_theory.subobject.map_pullback_adj CategoryTheory.Subobject.mapPullbackAdj
-/

/- warning: category_theory.subobject.pullback_map_self -> CategoryTheory.Subobject.pullback_map_self is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f] (g : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 X Y _inst_3 f) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 X) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 X))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.ThinSkeleton.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y)) (CategoryTheory.ThinSkeleton.preorder.{u1, max u2 u1} (CategoryTheory.MonoOver.{u1, u2} C _inst_1 Y) (CategoryTheory.MonoOver.category.{u2, u1} C _inst_1 Y))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 X Y f _inst_4) g)) g
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {Y : C} [_inst_3 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1] (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_4 : CategoryTheory.Mono.{u1, u2} C _inst_1 X Y f] (g : CategoryTheory.Subobject.{u1, u2} C _inst_1 X), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.pullback.{u1, u2} C _inst_1 X Y _inst_3 f)) (Prefunctor.obj.{max (succ u2) (succ u1), max (succ u2) (succ u1), max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 X) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 X))) (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} C _inst_1 Y) (CategoryTheory.instPartialOrderSubobject.{u1, u2} C _inst_1 Y))) (CategoryTheory.Subobject.map.{u1, u2} C _inst_1 X Y f _inst_4)) g)) g
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.pullback_map_self CategoryTheory.Subobject.pullback_map_selfₓ'. -/
@[simp]
theorem pullback_map_self [HasPullbacks C] (f : X ⟶ Y) [Mono f] (g : Subobject X) :
    (pullback f).obj ((map f).obj g) = g := by
  revert g
  apply Quotient.ind
  intro g'
  apply Quotient.sound
  exact ⟨(mono_over.pullback_map_self f).app _⟩
#align category_theory.subobject.pullback_map_self CategoryTheory.Subobject.pullback_map_self

/- warning: category_theory.subobject.map_pullback -> CategoryTheory.Subobject.map_pullback is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align category_theory.subobject.map_pullback CategoryTheory.Subobject.map_pullbackₓ'. -/
theorem map_pullback [HasPullbacks C] {X Y Z W : C} {f : X ⟶ Y} {g : X ⟶ Z} {h : Y ⟶ W} {k : Z ⟶ W}
    [Mono h] [Mono g] (comm : f ≫ h = g ≫ k) (t : IsLimit (PullbackCone.mk f g comm))
    (p : Subobject Y) : (map g).obj ((pullback f).obj p) = (pullback k).obj ((map h).obj p) :=
  by
  revert p
  apply Quotient.ind'
  intro a
  apply Quotient.sound
  apply thin_skeleton.equiv_of_both_ways
  · refine' mono_over.hom_mk (pullback.lift pullback.fst _ _) (pullback.lift_snd _ _ _)
    change _ ≫ a.arrow ≫ h = (pullback.snd ≫ g) ≫ _
    rw [assoc, ← comm, pullback.condition_assoc]
  · refine'
      mono_over.hom_mk
        (pullback.lift pullback.fst
          (pullback_cone.is_limit.lift' t (pullback.fst ≫ a.arrow) pullback.snd _).1
          (pullback_cone.is_limit.lift' _ _ _ _).2.1.symm)
        _
    · rw [← pullback.condition, assoc]
      rfl
    · dsimp
      rw [pullback.lift_snd_assoc]
      apply (pullback_cone.is_limit.lift' _ _ _ _).2.2
#align category_theory.subobject.map_pullback CategoryTheory.Subobject.map_pullback

end Map

section Exists

variable [HasImages C]

#print CategoryTheory.Subobject.exists /-
/-- The functor from subobjects of `X` to subobjects of `Y` given by
sending the subobject `S` to its "image" under `f`, usually denoted $\exists_f$.
For instance, when `C` is the category of types,
viewing `subobject X` as `set X` this is just `set.image f`.

This functor is left adjoint to the `pullback f` functor (shown in `exists_pullback_adj`)
provided both are defined, and generalises the `map f` functor, again provided it is defined.
-/
def exists (f : X ⟶ Y) : Subobject X ⥤ Subobject Y :=
  lower (MonoOver.exists f)
#align category_theory.subobject.exists CategoryTheory.Subobject.exists
-/

#print CategoryTheory.Subobject.exists_iso_map /-
/-- When `f : X ⟶ Y` is a monomorphism, `exists f` agrees with `map f`.
-/
theorem exists_iso_map (f : X ⟶ Y) [Mono f] : exists f = map f :=
  lower_iso _ _ (MonoOver.existsIsoMap f)
#align category_theory.subobject.exists_iso_map CategoryTheory.Subobject.exists_iso_map
-/

#print CategoryTheory.Subobject.existsPullbackAdj /-
/-- `exists f : subobject X ⥤ subobject Y` is
left adjoint to `pullback f : subobject Y ⥤ subobject X`.
-/
def existsPullbackAdj (f : X ⟶ Y) [HasPullbacks C] : exists f ⊣ pullback f :=
  lowerAdjunction (MonoOver.existsPullbackAdj f)
#align category_theory.subobject.exists_pullback_adj CategoryTheory.Subobject.existsPullbackAdj
-/

end Exists

end Subobject

end CategoryTheory

