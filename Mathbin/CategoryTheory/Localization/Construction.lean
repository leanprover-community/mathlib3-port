/-
Copyright (c) 2022 Joël Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joël Riou

! This file was ported from Lean 3 source module category_theory.localization.construction
! leanprover-community/mathlib commit 1a5e56f2166e4e9d0964c71f4273b1d39227678d
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.MorphismProperty
import Mathbin.CategoryTheory.Category.Quiv

/-!

# Construction of the localized category

This file constructs the localized category, obtained by formally inverting
a class of maps `W : morphism_property C` in a category `C`.

We first construct a quiver `loc_quiver W` whose objects are the same as those
of `C` and whose maps are the maps in `C` and placeholders for the formal
inverses of the maps in `W`.

The localized category `W.localization` is obtained by taking the quotient
of the path category of `loc_quiver W` by the congruence generated by four
types of relations.

The obvious functor `Q W : C ⥤ W.localization` satisfies the universal property
of the localization. Indeed, if `G : C ⥤ D` sends morphisms in `W` to isomorphisms
in `D` (i.e. we have `hG : W.is_inverted_by G`), then there exists a unique functor
`G' : W.localization ⥤ D` such that `Q W ≫ G' = G`. This `G'` is `lift G hG`.
The expected property of `lift G hG` if expressed by the lemma `fac` and the
uniqueness is expressed by `uniq`.

## References

* [P. Gabriel, M. Zisman, *Calculus of fractions and homotopy theory*][gabriel-zisman-1967]

-/


noncomputable section

open CategoryTheory.Category

namespace CategoryTheory

variable {C : Type _} [Category C] (W : MorphismProperty C) {D : Type _} [Category D]

namespace Localization

namespace Construction

#print CategoryTheory.Localization.Construction.LocQuiver /-
/-- If `W : morphism_property C`, `loc_quiver W` is a quiver with the same objects
as `C`, and whose morphisms are those in `C` and placeholders for formal
inverses of the morphisms in `W`. -/
@[nolint has_nonempty_instance]
structure LocQuiver (W : MorphismProperty C) where
  obj : C
#align category_theory.localization.construction.loc_quiver CategoryTheory.Localization.Construction.LocQuiver
-/

instance : Quiver (LocQuiver W) where Hom A B := Sum (A.obj ⟶ B.obj) { f : B.obj ⟶ A.obj // W f }

#print CategoryTheory.Localization.Construction.ιPaths /-
/-- The object in the path category of `loc_quiver W` attached to an object in
the category `C` -/
def ιPaths (X : C) : Paths (LocQuiver W) :=
  ⟨X⟩
#align category_theory.localization.construction.ι_paths CategoryTheory.Localization.Construction.ιPaths
-/

#print CategoryTheory.Localization.Construction.ψ₁ /-
/-- The morphism in the path category associated to a morphism in the original category. -/
@[simp]
def ψ₁ {X Y : C} (f : X ⟶ Y) : ιPaths W X ⟶ ιPaths W Y :=
  Paths.of.map (Sum.inl f)
#align category_theory.localization.construction.ψ₁ CategoryTheory.Localization.Construction.ψ₁
-/

#print CategoryTheory.Localization.Construction.ψ₂ /-
/-- The morphism in the path category corresponding to a formal inverse. -/
@[simp]
def ψ₂ {X Y : C} (w : X ⟶ Y) (hw : W w) : ιPaths W Y ⟶ ιPaths W X :=
  Paths.of.map (Sum.inr ⟨w, hw⟩)
#align category_theory.localization.construction.ψ₂ CategoryTheory.Localization.Construction.ψ₂
-/

#print CategoryTheory.Localization.Construction.relations /-
/-- The relations by which we take the quotient in order to get the localized category. -/
inductive relations : HomRel (Paths (LocQuiver W))
  | id (X : C) : relations (ψ₁ W (𝟙 X)) (𝟙 _)
  | comp {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) : relations (ψ₁ W (f ≫ g)) (ψ₁ W f ≫ ψ₁ W g)
  | Winv₁ {X Y : C} (w : X ⟶ Y) (hw : W w) : relations (ψ₁ W w ≫ ψ₂ W w hw) (𝟙 _)
  | Winv₂ {X Y : C} (w : X ⟶ Y) (hw : W w) : relations (ψ₂ W w hw ≫ ψ₁ W w) (𝟙 _)
#align category_theory.localization.construction.relations CategoryTheory.Localization.Construction.relations
-/

end Construction

end Localization

namespace MorphismProperty

open Localization.Construction

#print CategoryTheory.MorphismProperty.Localization /-
/-- The localized category obtained by formally inverting the morphisms
in `W : morphism_property C` -/
@[nolint has_nonempty_instance]
def Localization :=
  CategoryTheory.Quotient (Localization.Construction.relations W)deriving Category
#align category_theory.morphism_property.localization CategoryTheory.MorphismProperty.Localization
-/

#print CategoryTheory.MorphismProperty.Q /-
/-- The obvious functor `C ⥤ W.localization` -/
def Q : C ⥤ W.Localization
    where
  obj X := (Quotient.functor _).obj (Paths.of.obj ⟨X⟩)
  map X Y f := (Quotient.functor _).map (ψ₁ W f)
  map_id' X := Quotient.sound _ (relations.id X)
  map_comp' X Z Y f g := Quotient.sound _ (relations.comp f g)
#align category_theory.morphism_property.Q CategoryTheory.MorphismProperty.Q
-/

end MorphismProperty

namespace Localization

namespace Construction

variable {W}

/- warning: category_theory.localization.construction.Wiso -> CategoryTheory.Localization.Construction.wIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {W : CategoryTheory.MorphismProperty.{u2, u1} C _inst_1} {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y), (W X Y w) -> (CategoryTheory.Iso.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) (CategoryTheory.Functor.obj.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) X) (CategoryTheory.Functor.obj.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) Y))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {W : CategoryTheory.MorphismProperty.{u2, u1} C _inst_1} {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y), (W X Y w) -> (CategoryTheory.Iso.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W) (Prefunctor.obj.{succ u2, max (succ u1) (succ u2), u1, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W))) (CategoryTheory.Functor.toPrefunctor.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W)) X) (Prefunctor.obj.{succ u2, max (succ u1) (succ u2), u1, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W))) (CategoryTheory.Functor.toPrefunctor.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W)) Y))
Case conversion may be inaccurate. Consider using '#align category_theory.localization.construction.Wiso CategoryTheory.Localization.Construction.wIsoₓ'. -/
/-- The isomorphism in `W.localization` associated to a morphism `w` in W -/
def wIso {X Y : C} (w : X ⟶ Y) (hw : W w) : Iso (W.Q.obj X) (W.Q.obj Y)
    where
  Hom := W.Q.map w
  inv := (Quotient.functor _).map (Paths.of.map (Sum.inr ⟨w, hw⟩))
  hom_inv_id' := Quotient.sound _ (relations.Winv₁ w hw)
  inv_hom_id' := Quotient.sound _ (relations.Winv₂ w hw)
#align category_theory.localization.construction.Wiso CategoryTheory.Localization.Construction.wIso

/- warning: category_theory.localization.construction.Winv -> CategoryTheory.Localization.Construction.winv is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {W : CategoryTheory.MorphismProperty.{u2, u1} C _inst_1} {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y), (W X Y w) -> (Quiver.Hom.{succ (max u1 u2), u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 (fun {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w)) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 (fun {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w)) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 (fun {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w)) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 (fun {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w)))) (CategoryTheory.Functor.obj.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 (fun {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w)) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 (fun {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w)) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 (fun {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w)) Y) (CategoryTheory.Functor.obj.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 (fun {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w)) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 (fun {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w)) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 (fun {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w)) X))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {W : CategoryTheory.MorphismProperty.{u2, u1} C _inst_1} {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y), (W X Y w) -> (Quiver.Hom.{succ (max u1 u2), u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W))) (Prefunctor.obj.{succ u2, max (succ u1) (succ u2), u1, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W))) (CategoryTheory.Functor.toPrefunctor.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W)) Y) (Prefunctor.obj.{succ u2, max (succ u1) (succ u2), u1, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W))) (CategoryTheory.Functor.toPrefunctor.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W)) X))
Case conversion may be inaccurate. Consider using '#align category_theory.localization.construction.Winv CategoryTheory.Localization.Construction.winvₓ'. -/
/-- The formal inverse in `W.localization` of a morphism `w` in `W`. -/
abbrev winv {X Y : C} (w : X ⟶ Y) (hw : W w) :=
  (wIso w hw).inv
#align category_theory.localization.construction.Winv CategoryTheory.Localization.Construction.winv

variable (W)

#print CategoryTheory.MorphismProperty.Q_inverts /-
theorem CategoryTheory.MorphismProperty.Q_inverts : W.IsInvertedBy W.Q := fun X Y w hw =>
  IsIso.of_iso (Localization.Construction.wIso w hw)
#align category_theory.morphism_property.Q_inverts CategoryTheory.MorphismProperty.Q_inverts
-/

variable {W} (G : C ⥤ D) (hG : W.IsInvertedBy G)

include G hG

#print CategoryTheory.Localization.Construction.liftToPathCategory /-
/-- The lifting of a functor to the path category of `loc_quiver W` -/
@[simps]
def liftToPathCategory : Paths (LocQuiver W) ⥤ D :=
  QuivCat.lift
    { obj := fun X => G.obj X.obj
      map := fun X Y => by
        rintro (f | ⟨g, hg⟩)
        · exact G.map f
        · haveI := hG g hg
          exact inv (G.map g) }
#align category_theory.localization.construction.lift_to_path_category CategoryTheory.Localization.Construction.liftToPathCategory
-/

#print CategoryTheory.Localization.Construction.lift /-
/-- The lifting of a functor `C ⥤ D` inverting `W` as a functor `W.localization ⥤ D` -/
@[simps]
def lift : W.Localization ⥤ D :=
  Quotient.lift (relations W) (liftToPathCategory G hG)
    (by
      rintro ⟨X⟩ ⟨Y⟩ f₁ f₂ r
      rcases r with ⟨⟩
      tidy)
#align category_theory.localization.construction.lift CategoryTheory.Localization.Construction.lift
-/

/- warning: category_theory.localization.construction.fac -> CategoryTheory.Localization.Construction.fac is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {W : CategoryTheory.MorphismProperty.{u2, u1} C _inst_1} {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] (G : CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (hG : CategoryTheory.MorphismProperty.IsInvertedBy.{u2, u1, u3, u4} C _inst_1 D _inst_2 W G), Eq.{succ (max u2 u4 u1 u3)} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) (CategoryTheory.Localization.Construction.lift.{u1, u2, u3, u4} C _inst_1 W D _inst_2 G hG)) G
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u3, u4} C] {W : CategoryTheory.MorphismProperty.{u3, u4} C _inst_1} {D : Type.{u2}} [_inst_2 : CategoryTheory.Category.{u1, u2} D] (G : CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (hG : CategoryTheory.MorphismProperty.IsInvertedBy.{u3, u4, u2, u1} C _inst_1 D _inst_2 W G), Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (CategoryTheory.Functor.{u3, u1, u4, u2} C _inst_1 D _inst_2) (CategoryTheory.Functor.comp.{u3, max u4 u3, u1, u4, u4, u2} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W) (CategoryTheory.Localization.Construction.lift.{u4, u3, u2, u1} C _inst_1 W D _inst_2 G hG)) G
Case conversion may be inaccurate. Consider using '#align category_theory.localization.construction.fac CategoryTheory.Localization.Construction.facₓ'. -/
@[simp]
theorem fac : W.Q ⋙ lift G hG = G :=
  Functor.ext (fun X => rfl)
    (by
      intro X Y f
      simp only [functor.comp_map, eq_to_hom_refl, comp_id, id_comp]
      dsimp [lift, lift_to_path_category, morphism_property.Q]
      rw [compose_path_to_path])
#align category_theory.localization.construction.fac CategoryTheory.Localization.Construction.fac

omit G hG

/- warning: category_theory.localization.construction.uniq -> CategoryTheory.Localization.Construction.uniq is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {W : CategoryTheory.MorphismProperty.{u2, u1} C _inst_1} {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] (G₁ : CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2) (G₂ : CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2), (Eq.{succ (max u2 u4 u1 u3)} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) G₁) (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) G₂)) -> (Eq.{succ (max (max u1 u2) u4 u1 u3)} (CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2) G₁ G₂)
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u3, u4} C] {W : CategoryTheory.MorphismProperty.{u3, u4} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{u2, u1} D] (G₁ : CategoryTheory.Functor.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2) (G₂ : CategoryTheory.Functor.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2), (Eq.{max (max (max (succ u4) (succ u3)) (succ u1)) (succ u2)} (CategoryTheory.Functor.{u3, u2, u4, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.comp.{u3, max u4 u3, u2, u4, u4, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W) G₁) (CategoryTheory.Functor.comp.{u3, max u4 u3, u2, u4, u4, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W) G₂)) -> (Eq.{max (max (max (succ u4) (succ u3)) (succ u1)) (succ u2)} (CategoryTheory.Functor.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2) G₁ G₂)
Case conversion may be inaccurate. Consider using '#align category_theory.localization.construction.uniq CategoryTheory.Localization.Construction.uniqₓ'. -/
theorem uniq (G₁ G₂ : W.Localization ⥤ D) (h : W.Q ⋙ G₁ = W.Q ⋙ G₂) : G₁ = G₂ :=
  by
  suffices h' : quotient.functor _ ⋙ G₁ = quotient.functor _ ⋙ G₂
  · refine' Functor.ext _ _
    · rintro ⟨⟨X⟩⟩
      apply functor.congr_obj h
    · rintro ⟨⟨X⟩⟩ ⟨⟨Y⟩⟩ ⟨f⟩
      apply functor.congr_hom h'
  · refine' paths.ext_functor _ _
    · ext X
      cases X
      apply functor.congr_obj h
    · rintro ⟨X⟩ ⟨Y⟩ (f | ⟨w, hw⟩)
      · simpa only using functor.congr_hom h f
      · have hw : W.Q.map w = (Wiso w hw).Hom := rfl
        have hw' := functor.congr_hom h w
        simp only [functor.comp_map, hw] at hw'
        refine' functor.congr_inv_of_congr_hom _ _ _ _ _ hw'
        all_goals apply functor.congr_obj h
#align category_theory.localization.construction.uniq CategoryTheory.Localization.Construction.uniq

variable (W)

#print CategoryTheory.Localization.Construction.objEquiv /-
/-- The canonical bijection between objects in a category and its
localization with respect to a morphism_property `W` -/
@[simps]
def objEquiv : C ≃ W.Localization where
  toFun := W.Q.obj
  invFun X := X.as.obj
  left_inv X := rfl
  right_inv := by
    rintro ⟨⟨X⟩⟩
    rfl
#align category_theory.localization.construction.obj_equiv CategoryTheory.Localization.Construction.objEquiv
-/

variable {W}

/- warning: category_theory.localization.construction.morphism_property_is_top -> CategoryTheory.Localization.Construction.morphismProperty_is_top is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {W : CategoryTheory.MorphismProperty.{u2, u1} C _inst_1} (P : CategoryTheory.MorphismProperty.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W)), (forall {{X : C}} {{Y : C}} (f : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y), P (CategoryTheory.Functor.obj.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) X) (CategoryTheory.Functor.obj.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) Y) (CategoryTheory.Functor.map.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) X Y f)) -> (forall {{X : C}} {{Y : C}} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) (hw : W X Y w), P (CategoryTheory.Functor.obj.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 (fun {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w)) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 (fun {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w)) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 (fun {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w)) Y) (CategoryTheory.Functor.obj.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 (fun {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w)) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 (fun {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w)) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 (fun {X : C} {Y : C} (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w)) X) (CategoryTheory.Localization.Construction.winv.{u1, u2} C _inst_1 (fun (X : C) (Y : C) (w : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y) => W X Y w) X Y w hw)) -> (CategoryTheory.MorphismProperty.StableUnderComposition.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) P) -> (Eq.{max (succ u1) (succ (max u1 u2))} (CategoryTheory.MorphismProperty.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W)) P (Top.top.{max u1 u2} (CategoryTheory.MorphismProperty.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W)) (CompleteLattice.toHasTop.{max u1 u2} (CategoryTheory.MorphismProperty.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W)) (CategoryTheory.MorphismProperty.completeLattice.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W)))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {W : CategoryTheory.MorphismProperty.{u1, u2} C _inst_1} (P : CategoryTheory.MorphismProperty.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W)), (forall {{X : C}} {{Y : C}} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), P (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, u2} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u2, u1} C _inst_1 W)) X) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, u2} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u2, u1} C _inst_1 W)) Y) (Prefunctor.map.{succ u1, max (succ u2) (succ u1), u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, u2} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u2, u1} C _inst_1 W)) X Y f)) -> (forall {{X : C}} {{Y : C}} (w : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (hw : W X Y w), P (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, u2} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u2, u1} C _inst_1 W)) Y) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, u2} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u2, u1} C _inst_1 W)) X) (CategoryTheory.Localization.Construction.winv.{u2, u1} C _inst_1 W X Y w hw)) -> (CategoryTheory.MorphismProperty.StableUnderComposition.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) P) -> (Eq.{max (succ u2) (succ u1)} (CategoryTheory.MorphismProperty.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W)) P (Top.top.{max u2 u1} (CategoryTheory.MorphismProperty.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W)) (CompleteLattice.toTop.{max u2 u1} (CategoryTheory.MorphismProperty.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W)) (CategoryTheory.instCompleteLatticeMorphismProperty.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W)))))
Case conversion may be inaccurate. Consider using '#align category_theory.localization.construction.morphism_property_is_top CategoryTheory.Localization.Construction.morphismProperty_is_topₓ'. -/
/-- A `morphism_property` in `W.localization` is satisfied by all
morphisms in the localized category if it contains the image of the
morphisms in the original category, the inverses of the morphisms
in `W` and if it is stable under composition -/
theorem morphismProperty_is_top (P : MorphismProperty W.Localization)
    (hP₁ : ∀ ⦃X Y : C⦄ (f : X ⟶ Y), P (W.Q.map f))
    (hP₂ : ∀ ⦃X Y : C⦄ (w : X ⟶ Y) (hw : W w), P (winv w hw)) (hP₃ : P.StableUnderComposition) :
    P = ⊤ := by
  ext (X Y f)
  constructor
  · intro hf
    simp only [Pi.top_apply]
  · intro hf
    clear hf
    let G : _ ⥤ W.localization := quotient.functor _
    suffices
      ∀ (X₁ X₂ : C)
        (p : localization.construction.ι_paths W X₁ ⟶ localization.construction.ι_paths W X₂),
        P (G.map p)
      by
      rcases X with ⟨⟨X⟩⟩
      rcases Y with ⟨⟨Y⟩⟩
      simpa only [functor.image_preimage] using this _ _ (G.preimage f)
    intro X₁ X₂ p
    induction' p with X₂ X₃ p g hp
    · simpa only [Functor.map_id] using hP₁ (𝟙 X₁)
    · cases X₂
      cases X₃
      let p' : ι_paths W X₁ ⟶ ι_paths W X₂ := p
      rw [show p.cons g = p' ≫ Quiver.Hom.toPath g by rfl, G.map_comp]
      refine' hP₃ _ _ hp _
      rcases g with (g | ⟨g, hg⟩)
      · apply hP₁
      · apply hP₂
#align category_theory.localization.construction.morphism_property_is_top CategoryTheory.Localization.Construction.morphismProperty_is_top

/- warning: category_theory.localization.construction.morphism_property_is_top' -> CategoryTheory.Localization.Construction.morphismProperty_is_top' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {W : CategoryTheory.MorphismProperty.{u2, u1} C _inst_1} (P : CategoryTheory.MorphismProperty.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W)), (forall {{X : C}} {{Y : C}} (f : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) X Y), P (CategoryTheory.Functor.obj.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) X) (CategoryTheory.Functor.obj.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) Y) (CategoryTheory.Functor.map.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) X Y f)) -> (forall {{X : CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W}} {{Y : CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W}} (e : CategoryTheory.Iso.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) X Y), (P X Y (CategoryTheory.Iso.hom.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) X Y e)) -> (P Y X (CategoryTheory.Iso.inv.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) X Y e))) -> (CategoryTheory.MorphismProperty.StableUnderComposition.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) P) -> (Eq.{max (succ u1) (succ (max u1 u2))} (CategoryTheory.MorphismProperty.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W)) P (Top.top.{max u1 u2} (CategoryTheory.MorphismProperty.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W)) (CompleteLattice.toHasTop.{max u1 u2} (CategoryTheory.MorphismProperty.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W)) (CategoryTheory.MorphismProperty.completeLattice.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W)))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {W : CategoryTheory.MorphismProperty.{u1, u2} C _inst_1} (P : CategoryTheory.MorphismProperty.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W)), (forall {{X : C}} {{Y : C}} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y), P (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, u2} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u2, u1} C _inst_1 W)) X) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, u2} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u2, u1} C _inst_1 W)) Y) (Prefunctor.map.{succ u1, max (succ u2) (succ u1), u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, u2} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u2, u1} C _inst_1 W)) X Y f)) -> (forall {{X : CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W}} {{Y : CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W}} (e : CategoryTheory.Iso.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) X Y), (P X Y (CategoryTheory.Iso.hom.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) X Y e)) -> (P Y X (CategoryTheory.Iso.inv.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) X Y e))) -> (CategoryTheory.MorphismProperty.StableUnderComposition.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) P) -> (Eq.{max (succ u2) (succ u1)} (CategoryTheory.MorphismProperty.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W)) P (Top.top.{max u2 u1} (CategoryTheory.MorphismProperty.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W)) (CompleteLattice.toTop.{max u2 u1} (CategoryTheory.MorphismProperty.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W)) (CategoryTheory.instCompleteLatticeMorphismProperty.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W)))))
Case conversion may be inaccurate. Consider using '#align category_theory.localization.construction.morphism_property_is_top' CategoryTheory.Localization.Construction.morphismProperty_is_top'ₓ'. -/
/-- A `morphism_property` in `W.localization` is satisfied by all
morphisms in the localized category if it contains the image of the
morphisms in the original category, if is stable under composition
and if the property is stable by passing to inverses. -/
theorem morphismProperty_is_top' (P : MorphismProperty W.Localization)
    (hP₁ : ∀ ⦃X Y : C⦄ (f : X ⟶ Y), P (W.Q.map f))
    (hP₂ : ∀ ⦃X Y : W.Localization⦄ (e : X ≅ Y) (he : P e.Hom), P e.inv)
    (hP₃ : P.StableUnderComposition) : P = ⊤ :=
  morphismProperty_is_top P hP₁ (fun X Y w hw => hP₂ _ (hP₁ w)) hP₃
#align category_theory.localization.construction.morphism_property_is_top' CategoryTheory.Localization.Construction.morphismProperty_is_top'

namespace NatTransExtension

variable {F₁ F₂ : W.Localization ⥤ D} (τ : W.Q ⋙ F₁ ⟶ W.Q ⋙ F₂)

include τ

/- warning: category_theory.localization.construction.nat_trans_extension.app -> CategoryTheory.Localization.Construction.NatTransExtension.app is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {W : CategoryTheory.MorphismProperty.{u2, u1} C _inst_1} {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] {F₁ : CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2} {F₂ : CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2}, (Quiver.Hom.{succ (max u1 u4), max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u4, max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u1 u4, max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u2, u4, u1, u3} C _inst_1 D _inst_2))) (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) F₁) (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) F₂)) -> (forall (X : CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W), Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.obj.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 F₁ X) (CategoryTheory.Functor.obj.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 F₂ X))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {W : CategoryTheory.MorphismProperty.{u2, u1} C _inst_1} {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] {F₁ : CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W) D _inst_2} {F₂ : CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W) D _inst_2}, (Quiver.Hom.{max (succ u1) (succ u4), max (max (max u3 u1) u4) u2} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u4, max (max (max u1 u2) u3) u4} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u1 u4, max (max (max u1 u2) u3) u4} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u2, u4, u1, u3} C _inst_1 D _inst_2))) (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) F₁) (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) F₂)) -> (forall (X : CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W), Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (Prefunctor.obj.{max (succ u1) (succ u2), succ u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W))) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W) D _inst_2 F₁) X) (Prefunctor.obj.{max (succ u1) (succ u2), succ u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, u1} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W))) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W) D _inst_2 F₂) X))
Case conversion may be inaccurate. Consider using '#align category_theory.localization.construction.nat_trans_extension.app CategoryTheory.Localization.Construction.NatTransExtension.appₓ'. -/
/-- If `F₁` and `F₂` are functors `W.localization ⥤ D` and if we have
`τ : W.Q ⋙ F₁ ⟶ W.Q ⋙ F₂`, we shall define a natural transformation `F₁ ⟶ F₂`.
This is the `app` field of this natural transformation. -/
def app (X : W.Localization) : F₁.obj X ⟶ F₂.obj X :=
  eqToHom (congr_arg F₁.obj ((objEquiv W).right_inv X).symm) ≫
    τ.app ((objEquiv W).invFun X) ≫ eqToHom (congr_arg F₂.obj ((objEquiv W).right_inv X))
#align category_theory.localization.construction.nat_trans_extension.app CategoryTheory.Localization.Construction.NatTransExtension.app

/- warning: category_theory.localization.construction.nat_trans_extension.app_eq -> CategoryTheory.Localization.Construction.NatTransExtension.app_eq is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {W : CategoryTheory.MorphismProperty.{u2, u1} C _inst_1} {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] {F₁ : CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2} {F₂ : CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2} (τ : Quiver.Hom.{succ (max u1 u4), max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u4, max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u1 u4, max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u2, u4, u1, u3} C _inst_1 D _inst_2))) (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) F₁) (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) F₂)) (X : C), Eq.{succ u4} (Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.obj.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 F₁ (CategoryTheory.Functor.obj.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) X)) (CategoryTheory.Functor.obj.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 F₂ (CategoryTheory.Functor.obj.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) X))) (CategoryTheory.Localization.Construction.NatTransExtension.app.{u1, u2, u3, u4} C _inst_1 W D _inst_2 F₁ F₂ τ (CategoryTheory.Functor.obj.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) X)) (CategoryTheory.NatTrans.app.{u2, u4, u1, u3} C _inst_1 D _inst_2 (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) F₁) (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) F₂) τ X)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {W : CategoryTheory.MorphismProperty.{u1, u2} C _inst_1} {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] {F₁ : CategoryTheory.Functor.{max u2 u1, u4, u2, u3} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) D _inst_2} {F₂ : CategoryTheory.Functor.{max u2 u1, u4, u2, u3} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) D _inst_2} (τ : Quiver.Hom.{max (succ u2) (succ u4), max (max (max u3 u2) u4) u1} (CategoryTheory.Functor.{u1, u4, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u4, max (max (max u2 u1) u3) u4} (CategoryTheory.Functor.{u1, u4, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u4, max (max (max u2 u1) u3) u4} (CategoryTheory.Functor.{u1, u4, u2, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u1, u4, u2, u3} C _inst_1 D _inst_2))) (CategoryTheory.Functor.comp.{u1, max u2 u1, u4, u2, u2, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u2, u1} C _inst_1 W) F₁) (CategoryTheory.Functor.comp.{u1, max u2 u1, u4, u2, u2, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u2, u1} C _inst_1 W) F₂)) (X : C), Eq.{succ u4} (Quiver.Hom.{succ u4, u3} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u4, u2, u3} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W))) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u4, u2, u3} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) D _inst_2 F₁) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, u2} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u2, u1} C _inst_1 W)) X)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u4, u2, u3} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W))) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u3} D (CategoryTheory.Category.toCategoryStruct.{u4, u3} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u4, u2, u3} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) D _inst_2 F₂) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, u2} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u2, u1} C _inst_1 W)) X))) (CategoryTheory.Localization.Construction.NatTransExtension.app.{u2, u1, u3, u4} C _inst_1 W D _inst_2 F₁ F₂ τ (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, u2} (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, u2} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u2, u1} C _inst_1 W)) X)) (CategoryTheory.NatTrans.app.{u1, u4, u2, u3} C _inst_1 D _inst_2 (CategoryTheory.Functor.comp.{u1, max u2 u1, u4, u2, u2, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u2, u1} C _inst_1 W) F₁) (CategoryTheory.Functor.comp.{u1, max u2 u1, u4, u2, u2, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u2, u1} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u2, u1} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u2, u1} C _inst_1 W) F₂) τ X)
Case conversion may be inaccurate. Consider using '#align category_theory.localization.construction.nat_trans_extension.app_eq CategoryTheory.Localization.Construction.NatTransExtension.app_eqₓ'. -/
@[simp]
theorem app_eq (X : C) : (app τ) (W.Q.obj X) = τ.app X := by
  simpa only [app, eq_to_hom_refl, comp_id, id_comp]
#align category_theory.localization.construction.nat_trans_extension.app_eq CategoryTheory.Localization.Construction.NatTransExtension.app_eq

end NatTransExtension

#print CategoryTheory.Localization.Construction.natTransExtension /-
/-- If `F₁` and `F₂` are functors `W.localization ⥤ D`, a natural transformation `F₁ ⟶ F₂`
can be obtained from a natural transformation `W.Q ⋙ F₁ ⟶ W.Q ⋙ F₂`. -/
@[simps]
def natTransExtension {F₁ F₂ : W.Localization ⥤ D} (τ : W.Q ⋙ F₁ ⟶ W.Q ⋙ F₂) : F₁ ⟶ F₂
    where
  app := NatTransExtension.app τ
  naturality' X Y f :=
    by
    have h :=
      morphism_property_is_top' (morphism_property.naturality_property (nat_trans_extension.app τ))
        _ (morphism_property.naturality_property.is_stable_under_inverse _)
        (morphism_property.naturality_property.is_stable_under_composition _)
    swap
    · intro X Y f
      simpa only [morphism_property.naturality_property, nat_trans_extension.app_eq] using
        τ.naturality f
    have hf : (⊤ : morphism_property _) f := by simp only [Pi.top_apply]
    simpa only [← h] using hf
#align category_theory.localization.construction.nat_trans_extension CategoryTheory.Localization.Construction.natTransExtension
-/

/- warning: category_theory.localization.construction.nat_trans_extension_hcomp -> CategoryTheory.Localization.Construction.natTransExtension_hcomp is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {W : CategoryTheory.MorphismProperty.{u2, u1} C _inst_1} {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] {F : CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2} {G : CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2} (τ : Quiver.Hom.{succ (max u1 u4), max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u4, max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u1 u4, max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u2, u4, u1, u3} C _inst_1 D _inst_2))) (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) F) (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) G)), Eq.{succ (max u1 u4)} (Quiver.Hom.{succ (max u1 u4), max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u4, max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u1 u4, max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u2, u4, u1, u3} C _inst_1 D _inst_2))) (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) F) (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) G)) (CategoryTheory.NatTrans.hcomp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) F G (CategoryTheory.CategoryStruct.id.{max u1 u2, max u1 u2} (CategoryTheory.Functor.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W)) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u1 u2} (CategoryTheory.Functor.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W)) (CategoryTheory.Functor.category.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W))) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W)) (CategoryTheory.Localization.Construction.natTransExtension.{u1, u2, u3, u4} C _inst_1 W D _inst_2 F G τ)) τ
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u3, u4} C] {W : CategoryTheory.MorphismProperty.{u3, u4} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{u2, u1} D] {F : CategoryTheory.Functor.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2} {G : CategoryTheory.Functor.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2} (τ : Quiver.Hom.{max (succ u4) (succ u2), max (max (max u1 u4) u2) u3} (CategoryTheory.Functor.{u3, u2, u4, u1} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u2, max (max (max u4 u3) u1) u2} (CategoryTheory.Functor.{u3, u2, u4, u1} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u4 u2, max (max (max u4 u3) u1) u2} (CategoryTheory.Functor.{u3, u2, u4, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u2, u4, u1} C _inst_1 D _inst_2))) (CategoryTheory.Functor.comp.{u3, max u4 u3, u2, u4, u4, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W) F) (CategoryTheory.Functor.comp.{u3, max u4 u3, u2, u4, u4, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W) G)), Eq.{max (succ u4) (succ u2)} (Quiver.Hom.{max (succ u4) (succ u2), max (max (max u1 u4) u2) u3} (CategoryTheory.Functor.{u3, u2, u4, u1} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u2, max (max (max u4 u1) u3) u2} (CategoryTheory.Functor.{u3, u2, u4, u1} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u4 u2, max (max (max u4 u1) u3) u2} (CategoryTheory.Functor.{u3, u2, u4, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u2, u4, u1} C _inst_1 D _inst_2))) (CategoryTheory.Functor.comp.{u3, max u4 u3, u2, u4, u4, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W) F) (CategoryTheory.Functor.comp.{u3, max u4 u3, u2, u4, u4, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W) G)) (CategoryTheory.NatTrans.hcomp.{u3, max u4 u3, u2, u4, u4, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W) F G (CategoryTheory.CategoryStruct.id.{max u4 u3, max u4 u3} (CategoryTheory.Functor.{u3, max u4 u3, u4, u4} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W)) (CategoryTheory.Category.toCategoryStruct.{max u4 u3, max u4 u3} (CategoryTheory.Functor.{u3, max u4 u3, u4, u4} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W)) (CategoryTheory.Functor.category.{u3, max u4 u3, u4, u4} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W))) (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W)) (CategoryTheory.Localization.Construction.natTransExtension.{u4, u3, u1, u2} C _inst_1 W D _inst_2 F G τ)) τ
Case conversion may be inaccurate. Consider using '#align category_theory.localization.construction.nat_trans_extension_hcomp CategoryTheory.Localization.Construction.natTransExtension_hcompₓ'. -/
@[simp]
theorem natTransExtension_hcomp {F G : W.Localization ⥤ D} (τ : W.Q ⋙ F ⟶ W.Q ⋙ G) :
    𝟙 W.Q ◫ natTransExtension τ = τ := by
  ext X
  simp only [nat_trans.hcomp_app, nat_trans.id_app, G.map_id, comp_id, nat_trans_extension_app,
    nat_trans_extension.app_eq]
#align category_theory.localization.construction.nat_trans_extension_hcomp CategoryTheory.Localization.Construction.natTransExtension_hcomp

/- warning: category_theory.localization.construction.nat_trans_hcomp_injective -> CategoryTheory.Localization.Construction.natTrans_hcomp_injective is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {W : CategoryTheory.MorphismProperty.{u2, u1} C _inst_1} {D : Type.{u3}} [_inst_2 : CategoryTheory.Category.{u4, u3} D] {F : CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2} {G : CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2} {τ₁ : Quiver.Hom.{succ (max u1 u4), max (max u1 u2) u4 u1 u3} (CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u4, max (max u1 u2) u4 u1 u3} (CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u1 u4, max (max u1 u2) u4 u1 u3} (CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2) (CategoryTheory.Functor.category.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2))) F G} {τ₂ : Quiver.Hom.{succ (max u1 u4), max (max u1 u2) u4 u1 u3} (CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u4, max (max u1 u2) u4 u1 u3} (CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u1 u4, max (max u1 u2) u4 u1 u3} (CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2) (CategoryTheory.Functor.category.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2))) F G}, (Eq.{succ (max u1 u4)} (Quiver.Hom.{succ (max u1 u4), max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u4, max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u1 u4, max u2 u4 u1 u3} (CategoryTheory.Functor.{u2, u4, u1, u3} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u2, u4, u1, u3} C _inst_1 D _inst_2))) (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) F) (CategoryTheory.Functor.comp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) G)) (CategoryTheory.NatTrans.hcomp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) F G (CategoryTheory.CategoryStruct.id.{max u1 u2, max u1 u2} (CategoryTheory.Functor.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W)) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u1 u2} (CategoryTheory.Functor.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W)) (CategoryTheory.Functor.category.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W))) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W)) τ₁) (CategoryTheory.NatTrans.hcomp.{u2, max u1 u2, u4, u1, u1, u3} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W) F G (CategoryTheory.CategoryStruct.id.{max u1 u2, max u1 u2} (CategoryTheory.Functor.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W)) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max u1 u2} (CategoryTheory.Functor.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W)) (CategoryTheory.Functor.category.{u2, max u1 u2, u1, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W))) (CategoryTheory.MorphismProperty.Q.{u1, u2} C _inst_1 W)) τ₂)) -> (Eq.{succ (max u1 u4)} (Quiver.Hom.{succ (max u1 u4), max (max u1 u2) u4 u1 u3} (CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u4, max (max u1 u2) u4 u1 u3} (CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u1 u4, max (max u1 u2) u4 u1 u3} (CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2) (CategoryTheory.Functor.category.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2))) F G) τ₁ τ₂)
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u3, u4} C] {W : CategoryTheory.MorphismProperty.{u3, u4} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{u2, u1} D] {F : CategoryTheory.Functor.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2} {G : CategoryTheory.Functor.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2} {τ₁ : Quiver.Hom.{max (succ u4) (succ u2), max (max (max u4 u3) u1) u2} (CategoryTheory.Functor.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u2, max (max (max u4 u3) u1) u2} (CategoryTheory.Functor.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u4 u2, max (max (max u4 u3) u1) u2} (CategoryTheory.Functor.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2) (CategoryTheory.Functor.category.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2))) F G} {τ₂ : Quiver.Hom.{max (succ u4) (succ u2), max (max (max u4 u3) u1) u2} (CategoryTheory.Functor.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u2, max (max (max u4 u3) u1) u2} (CategoryTheory.Functor.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u4 u2, max (max (max u4 u3) u1) u2} (CategoryTheory.Functor.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2) (CategoryTheory.Functor.category.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2))) F G}, (Eq.{max (succ u4) (succ u2)} (Quiver.Hom.{max (succ u4) (succ u2), max (max (max u1 u4) u2) u3} (CategoryTheory.Functor.{u3, u2, u4, u1} C _inst_1 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u2, max (max (max u4 u1) u3) u2} (CategoryTheory.Functor.{u3, u2, u4, u1} C _inst_1 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u4 u2, max (max (max u4 u1) u3) u2} (CategoryTheory.Functor.{u3, u2, u4, u1} C _inst_1 D _inst_2) (CategoryTheory.Functor.category.{u3, u2, u4, u1} C _inst_1 D _inst_2))) (CategoryTheory.Functor.comp.{u3, max u4 u3, u2, u4, u4, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W) F) (CategoryTheory.Functor.comp.{u3, max u4 u3, u2, u4, u4, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W) G)) (CategoryTheory.NatTrans.hcomp.{u3, max u4 u3, u2, u4, u4, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W) F G (CategoryTheory.CategoryStruct.id.{max u4 u3, max u4 u3} (CategoryTheory.Functor.{u3, max u4 u3, u4, u4} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W)) (CategoryTheory.Category.toCategoryStruct.{max u4 u3, max u4 u3} (CategoryTheory.Functor.{u3, max u4 u3, u4, u4} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W)) (CategoryTheory.Functor.category.{u3, max u4 u3, u4, u4} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W))) (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W)) τ₁) (CategoryTheory.NatTrans.hcomp.{u3, max u4 u3, u2, u4, u4, u1} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2 (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W) F G (CategoryTheory.CategoryStruct.id.{max u4 u3, max u4 u3} (CategoryTheory.Functor.{u3, max u4 u3, u4, u4} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W)) (CategoryTheory.Category.toCategoryStruct.{max u4 u3, max u4 u3} (CategoryTheory.Functor.{u3, max u4 u3, u4, u4} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W)) (CategoryTheory.Functor.category.{u3, max u4 u3, u4, u4} C _inst_1 (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W))) (CategoryTheory.MorphismProperty.Q.{u4, u3} C _inst_1 W)) τ₂)) -> (Eq.{max (succ u4) (succ u2)} (Quiver.Hom.{max (succ u4) (succ u2), max (max (max u4 u3) u1) u2} (CategoryTheory.Functor.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u2, max (max (max u4 u3) u1) u2} (CategoryTheory.Functor.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u4 u2, max (max (max u4 u3) u1) u2} (CategoryTheory.Functor.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2) (CategoryTheory.Functor.category.{max u4 u3, u2, u4, u1} (CategoryTheory.MorphismProperty.Localization.{u4, u3} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u4, u3} C _inst_1 W) D _inst_2))) F G) τ₁ τ₂)
Case conversion may be inaccurate. Consider using '#align category_theory.localization.construction.nat_trans_hcomp_injective CategoryTheory.Localization.Construction.natTrans_hcomp_injectiveₓ'. -/
theorem natTrans_hcomp_injective {F G : W.Localization ⥤ D} {τ₁ τ₂ : F ⟶ G}
    (h : 𝟙 W.Q ◫ τ₁ = 𝟙 W.Q ◫ τ₂) : τ₁ = τ₂ := by
  ext X
  have eq := (obj_equiv W).right_inv X
  simp only [obj_equiv] at eq
  rw [← Eq, ← nat_trans.id_hcomp_app, ← nat_trans.id_hcomp_app, h]
#align category_theory.localization.construction.nat_trans_hcomp_injective CategoryTheory.Localization.Construction.natTrans_hcomp_injective

variable (W D)

namespace WhiskeringLeftEquivalence

#print CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.functor /-
/-- The functor `(W.localization ⥤ D) ⥤ (W.functors_inverting D)` induced by the
composition with `W.Q : C ⥤ W.localization`. -/
@[simps]
def functor : (W.Localization ⥤ D) ⥤ W.FunctorsInverting D :=
  FullSubcategory.lift _ ((whiskeringLeft _ _ D).obj W.Q) fun F =>
    MorphismProperty.IsInvertedBy.of_comp W W.Q W.Q_inverts _
#align category_theory.localization.construction.whiskering_left_equivalence.functor CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.functor
-/

#print CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.inverse /-
/-- The function `(W.functors_inverting D) ⥤ (W.localization ⥤ D)` induced by
`construction.lift`. -/
@[simps]
def inverse : W.FunctorsInverting D ⥤ W.Localization ⥤ D
    where
  obj G := lift G.obj G.property
  map G₁ G₂ τ := natTransExtension (eqToHom (by rw [fac]) ≫ τ ≫ eqToHom (by rw [fac]))
  map_id' G :=
    natTrans_hcomp_injective
      (by
        rw [nat_trans_extension_hcomp]
        ext X
        simpa only [nat_trans.comp_app, eq_to_hom_app, eq_to_hom_refl, comp_id, id_comp,
          nat_trans.hcomp_id_app, nat_trans.id_app, Functor.map_id] )
  map_comp' G₁ G₂ G₃ τ₁ τ₂ :=
    natTrans_hcomp_injective
      (by
        ext X
        simpa only [nat_trans_extension_hcomp, nat_trans.comp_app, eq_to_hom_app, eq_to_hom_refl,
          id_comp, comp_id, nat_trans.hcomp_app, nat_trans.id_app, Functor.map_id,
          nat_trans_extension_app, nat_trans_extension.app_eq] )
#align category_theory.localization.construction.whiskering_left_equivalence.inverse CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.inverse
-/

#print CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.unitIso /-
/-- The unit isomorphism of the equivalence of categories `whiskering_left_equivalence W D`. -/
@[simps]
def unitIso : 𝟭 (W.Localization ⥤ D) ≅ functor W D ⋙ inverse W D :=
  eqToIso
    (by
      refine' Functor.ext (fun G => _) fun G₁ G₂ τ => _
      · apply uniq
        dsimp [Functor]
        rw [fac]
      · apply nat_trans_hcomp_injective
        ext X
        simp only [functor.id_map, nat_trans.hcomp_app, comp_id, functor.comp_map, inverse_map,
          nat_trans.comp_app, eq_to_hom_app, eq_to_hom_refl, nat_trans_extension_app,
          nat_trans_extension.app_eq, functor_map_app, id_comp])
#align category_theory.localization.construction.whiskering_left_equivalence.unit_iso CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.unitIso
-/

#print CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.counitIso /-
/-- The counit isomorphism of the equivalence of categories `whiskering_left_equivalence W D`. -/
@[simps]
def counitIso : inverse W D ⋙ functor W D ≅ 𝟭 (W.FunctorsInverting D) :=
  eqToIso
    (by
      refine' Functor.ext _ _
      · rintro ⟨G, hG⟩
        ext1
        apply fac
      · rintro ⟨G₁, hG₁⟩ ⟨G₂, hG₂⟩ f
        ext X
        apply nat_trans_extension.app_eq)
#align category_theory.localization.construction.whiskering_left_equivalence.counit_iso CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.counitIso
-/

end WhiskeringLeftEquivalence

/- warning: category_theory.localization.construction.whiskering_left_equivalence -> CategoryTheory.Localization.Construction.whiskeringLeftEquivalence is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (W : CategoryTheory.MorphismProperty.{u2, u1} C _inst_1) (D : Type.{u3}) [_inst_2 : CategoryTheory.Category.{u4, u3} D], CategoryTheory.Equivalence.{max u1 u4, max u1 u4, max (max u1 u2) u4 u1 u3, max u2 u4 u1 u3} (CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2) (CategoryTheory.Functor.category.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.Localization.category.{u1, u2} C _inst_1 W) D _inst_2) (CategoryTheory.MorphismProperty.FunctorsInverting.{u2, u1, u3, u4} C _inst_1 W D _inst_2) (CategoryTheory.MorphismProperty.FunctorsInverting.category.{u2, u3, u1, u4} C _inst_1 W D _inst_2)
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (W : CategoryTheory.MorphismProperty.{u2, u1} C _inst_1) (D : Type.{u3}) [_inst_2 : CategoryTheory.Category.{u4, u3} D], CategoryTheory.Equivalence.{max u1 u4, max u1 u4, max (max (max u3 u1) u4) u1 u2, max (max (max u1 u2) u4) u3} (CategoryTheory.Functor.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W) D _inst_2) (CategoryTheory.MorphismProperty.FunctorsInverting.{u2, u1, u3, u4} C _inst_1 W D _inst_2) (CategoryTheory.Functor.category.{max u1 u2, u4, u1, u3} (CategoryTheory.MorphismProperty.Localization.{u1, u2} C _inst_1 W) (CategoryTheory.MorphismProperty.instCategoryLocalization.{u1, u2} C _inst_1 W) D _inst_2) (CategoryTheory.MorphismProperty.instCategoryFunctorsInverting.{u2, u1, u3, u4} C _inst_1 W D _inst_2)
Case conversion may be inaccurate. Consider using '#align category_theory.localization.construction.whiskering_left_equivalence CategoryTheory.Localization.Construction.whiskeringLeftEquivalenceₓ'. -/
/-- The equivalence of categories `(W.localization ⥤ D) ≌ (W.functors_inverting D)`
induced by the composition with `W.Q : C ⥤ W.localization`. -/
def whiskeringLeftEquivalence : W.Localization ⥤ D ≌ W.FunctorsInverting D
    where
  Functor := WhiskeringLeftEquivalence.functor W D
  inverse := WhiskeringLeftEquivalence.inverse W D
  unitIso := WhiskeringLeftEquivalence.unitIso W D
  counitIso := WhiskeringLeftEquivalence.counitIso W D
  functor_unitIso_comp' F := by
    ext X
    simpa only [eq_to_hom_app, whiskering_left_equivalence.unit_iso_hom,
      whiskering_left_equivalence.counit_iso_hom, eq_to_hom_map, eq_to_hom_trans, eq_to_hom_refl]
#align category_theory.localization.construction.whiskering_left_equivalence CategoryTheory.Localization.Construction.whiskeringLeftEquivalence

end Construction

end Localization

end CategoryTheory

