/-
Copyright (c) 2021 Adam Topaz. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Adam Topaz

! This file was ported from Lean 3 source module category_theory.sites.left_exact
! leanprover-community/mathlib commit 59382264386afdbaf1727e617f5fdda511992eb9
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Sites.Sheafification
import Mathbin.CategoryTheory.Sites.Limits
import Mathbin.CategoryTheory.Limits.FunctorCategory
import Mathbin.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit

/-!
# Left exactness of sheafification
In this file we show that sheafification commutes with finite limits.
-/


open CategoryTheory

open CategoryTheory.Limits

open Opposite

universe w v u

variable {C : Type max v u} [Category.{v} C] {J : GrothendieckTopology C}

variable {D : Type w} [Category.{max v u} D]

variable [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), HasMultiequalizer (S.index P)]

noncomputable section

namespace CategoryTheory.GrothendieckTopology

/- warning: category_theory.grothendieck_topology.cone_comp_evaluation_of_cone_comp_diagram_functor_comp_evaluation -> CategoryTheory.GrothendieckTopology.coneCompEvaluationOfConeCompDiagramFunctorCompEvaluation is a dubious translation:
lean 3 declaration is
  forall {C : Type.{max u2 u3}} [_inst_1 : CategoryTheory.Category.{u2, max u2 u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, max u2 u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u2 u3} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, max u2 u3} C _inst_1 X J D _inst_2 S P)] {X : C} {K : Type.{max u2 u3}} [_inst_4 : CategoryTheory.SmallCategory.{max u2 u3} K] {F : CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} K _inst_4 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2)} {W : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X} (i : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, max u2 u3} C _inst_1 X J W), (CategoryTheory.Limits.Cone.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_4 D _inst_2 (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} K _inst_4 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, max (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.diagramFunctor.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.coneCompEvaluationOfConeCompDiagramFunctorCompEvaluation._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_3) X) (CategoryTheory.Functor.obj.{max u2 u3, max (max u2 u3) u1, max u2 u3, max (max u2 u3) u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) (CategoryTheory.Functor.{max u2 u3, max u2 u3, max (max u2 u3) u1, u1} (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max (max u2 u3) u1, u1} (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) (Opposite.op.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) W))))) -> (CategoryTheory.Limits.Cone.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_4 D _inst_2 (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} K _inst_4 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.obj.{u2, max (max u2 (max u2 u3) u1) u2 u3, max u2 u3, max (max u2 u3) (max u2 (max u2 u3) u1) u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (Opposite.op.{succ (max u2 u3)} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, max u2 u3} C _inst_1 X J W i)))))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] {X : C} {K : Type.{max u2 u3}} [_inst_4 : CategoryTheory.SmallCategory.{max u3 u2} K] {F : CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2} K _inst_4 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)} {W : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} (i : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J W), (CategoryTheory.Limits.Cone.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_4 D _inst_2 (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, u1} K _inst_4 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.diagramFunctor.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) X) (Prefunctor.obj.{max (succ u3) (succ u2), max (max (succ u3) (succ u2)) (succ u1), max u3 u2, max (max u3 u2) u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u1 u3 u2, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u1 u3 u2, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u1 u3 u2, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max (max u3 u2) u1, max u3 u2, max (max u3 u2) u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u1 u3 u2, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2)) (Opposite.op.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) W))))) -> (CategoryTheory.Limits.Cone.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_4 D _inst_2 (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, u1} K _inst_4 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 F (Prefunctor.obj.{succ u2, max (max (max (succ u1) (succ (max u3 u2))) (succ u2)) (succ u3), u3, max (max (max u1 u3 u2) u2) u3} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max (max (max u1 u3 u2) u3) u2, max (max (max u1 u3 u2) u3) u2} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max (max (max u1 u3 u2) u3) u2, max (max (max u1 u3 u2) u3) u2} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{u2, max (max (max u1 u3 u2) u3) u2, u3, max (max (max u1 u3 u2) u3) u2} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J W i)))))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.cone_comp_evaluation_of_cone_comp_diagram_functor_comp_evaluation CategoryTheory.GrothendieckTopology.coneCompEvaluationOfConeCompDiagramFunctorCompEvaluationₓ'. -/
/-- An auxiliary definition to be used in the proof of the fact that
`J.diagram_functor D X` preserves limits. -/
@[simps]
def coneCompEvaluationOfConeCompDiagramFunctorCompEvaluation {X : C} {K : Type max v u}
    [SmallCategory K] {F : K ⥤ Cᵒᵖ ⥤ D} {W : J.cover X} (i : W.arrow)
    (E : Cone (F ⋙ J.diagramFunctor D X ⋙ (evaluation (J.cover X)ᵒᵖ D).obj (op W))) :
    Cone (F ⋙ (evaluation _ _).obj (op i.y))
    where
  pt := E.pt
  π :=
    { app := fun k => E.π.app k ≫ Multiequalizer.ι (W.index (F.obj k)) i
      naturality' := by
        intro a b f
        dsimp
        rw [category.id_comp, category.assoc, ← E.w f]
        dsimp [diagram_nat_trans]
        simp only [multiequalizer.lift_ι, category.assoc] }
#align category_theory.grothendieck_topology.cone_comp_evaluation_of_cone_comp_diagram_functor_comp_evaluation CategoryTheory.GrothendieckTopology.coneCompEvaluationOfConeCompDiagramFunctorCompEvaluation

/- warning: category_theory.grothendieck_topology.lift_to_diagram_limit_obj -> CategoryTheory.GrothendieckTopology.liftToDiagramLimitObj is a dubious translation:
lean 3 declaration is
  forall {C : Type.{max u2 u3}} [_inst_1 : CategoryTheory.Category.{u2, max u2 u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, max u2 u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u2 u3} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, max u2 u3} C _inst_1 X J D _inst_2 S P)] {X : C} {K : Type.{max u2 u3}} [_inst_4 : CategoryTheory.SmallCategory.{max u2 u3} K] [_inst_5 : CategoryTheory.Limits.HasLimitsOfShape.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_4 D _inst_2] {W : Opposite.{max 1 (succ (max u2 u3)) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)} (F : CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} K _inst_4 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2)) (E : CategoryTheory.Limits.Cone.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_4 D _inst_2 (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} K _inst_4 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, max (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.diagramFunctor.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.liftToDiagramLimitObj._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_3) X) (CategoryTheory.Functor.obj.{max u2 u3, max (max u2 u3) u1, max u2 u3, max (max u2 u3) u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) (CategoryTheory.Functor.{max u2 u3, max u2 u3, max (max u2 u3) u1, u1} (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max (max u2 u3) u1, u1} (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) W)))), Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Limits.Cone.pt.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_4 D _inst_2 (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} K _inst_4 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, max (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.diagramFunctor.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.liftToDiagramLimitObj._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_3) X) (CategoryTheory.Functor.obj.{max u2 u3, max (max u2 u3) u1, max u2 u3, max (max u2 u3) u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) (CategoryTheory.Functor.{max u2 u3, max u2 u3, max (max u2 u3) u1, u1} (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max (max u2 u3) u1, u1} (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2) W))) E) (CategoryTheory.Functor.obj.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2 (CategoryTheory.GrothendieckTopology.diagram.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.liftToDiagramLimitObj._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_3) (CategoryTheory.Limits.limit.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} K _inst_4 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) F (CategoryTheory.GrothendieckTopology.liftToDiagramLimitObj._proof_3.{u3, u2, u1} C _inst_1 D _inst_2 K _inst_4 _inst_5 F)) X) W)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] {X : C} {K : Type.{max u2 u3}} [_inst_4 : CategoryTheory.SmallCategory.{max u3 u2} K] [_inst_5 : CategoryTheory.Limits.HasLimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_4 D _inst_2] {W : Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)} (F : CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2} K _inst_4 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (E : CategoryTheory.Limits.Cone.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_4 D _inst_2 (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, u1} K _inst_4 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.diagramFunctor.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) X) (Prefunctor.obj.{max (succ u3) (succ u2), max (max (succ u3) (succ u2)) (succ u1), max u3 u2, max (max u3 u2) u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u1 u3 u2, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u1 u3 u2, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u1 u3 u2, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max (max u3 u2) u1, max u3 u2, max (max u3 u2) u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u1 u3 u2, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2)) W)))), Quiver.Hom.{max (succ u3) (succ u2), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Limits.Cone.pt.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_4 D _inst_2 (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, u1} K _inst_4 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.diagramFunctor.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) X) (Prefunctor.obj.{max (succ u3) (succ u2), max (max (succ u3) (succ u2)) (succ u1), max u3 u2, max (max u3 u2) u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u1 u3 u2, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u1 u3 u2, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u1 u3 u2, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max (max u3 u2) u1, max u3 u2, max (max u3 u2) u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u1 u3 u2, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2)) W))) E) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2 (CategoryTheory.GrothendieckTopology.diagram.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (CategoryTheory.Limits.limit.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1} K _inst_4 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) K _inst_4 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{max u3 u2, u2, max u3 u2, u3, max u3 u2, u1} D _inst_2 K _inst_4 (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) _inst_5) F)) X)) W)
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.lift_to_diagram_limit_obj CategoryTheory.GrothendieckTopology.liftToDiagramLimitObjₓ'. -/
/-- An auxiliary definition to be used in the proof of the fact that
`J.diagram_functor D X` preserves limits. -/
abbrev liftToDiagramLimitObj {X : C} {K : Type max v u} [SmallCategory K] [HasLimitsOfShape K D]
    {W : (J.cover X)ᵒᵖ} (F : K ⥤ Cᵒᵖ ⥤ D)
    (E : Cone (F ⋙ J.diagramFunctor D X ⋙ (evaluation (J.cover X)ᵒᵖ D).obj W)) :
    E.pt ⟶ (J.diagram (limit F) X).obj W :=
  Multiequalizer.lift _ _
    (fun i =>
      (isLimitOfPreserves ((evaluation _ _).obj (op i.y)) (limit.isLimit _)).lift
        (coneCompEvaluationOfConeCompDiagramFunctorCompEvaluation i E))
    (by
      intro i
      change (_ ≫ _) ≫ _ = (_ ≫ _) ≫ _
      dsimp [evaluate_combined_cones]
      erw [category.comp_id, category.comp_id, category.assoc, category.assoc, ←
        (limit.lift F _).naturality, ← (limit.lift F _).naturality, ← category.assoc, ←
        category.assoc]
      congr 1; ext1
      erw [category.assoc, category.assoc, limit.lift_π, limit.lift_π, limit.lift_π_assoc,
        limit.lift_π_assoc, category.assoc, category.assoc, multiequalizer.condition]
      rfl)
#align category_theory.grothendieck_topology.lift_to_diagram_limit_obj CategoryTheory.GrothendieckTopology.liftToDiagramLimitObj

instance (X : C) (K : Type max v u) [SmallCategory K] [HasLimitsOfShape K D] (F : K ⥤ Cᵒᵖ ⥤ D) :
    PreservesLimit F (J.diagramFunctor D X) :=
  preservesLimitOfEvaluation _ _ fun W =>
    preservesLimitOfPreservesLimitCone (limit.isLimit _)
      { lift := fun E => liftToDiagramLimitObj F E
        fac := by
          intro E k
          dsimp [diagram_nat_trans]
          ext1
          simp only [multiequalizer.lift_ι, multiequalizer.lift_ι_assoc, category.assoc]
          change (_ ≫ _) ≫ _ = _
          dsimp [evaluate_combined_cones]
          erw [category.comp_id, category.assoc, ← nat_trans.comp_app, limit.lift_π, limit.lift_π]
          rfl
        uniq := by
          intro E m hm
          ext
          delta lift_to_diagram_limit_obj
          erw [multiequalizer.lift_ι, category.assoc]
          change _ = (_ ≫ _) ≫ _
          dsimp [evaluate_combined_cones]
          erw [category.comp_id, category.assoc, ← nat_trans.comp_app, limit.lift_π, limit.lift_π]
          dsimp
          rw [← hm]
          dsimp [diagram_nat_trans]
          simp }

instance (X : C) (K : Type max v u) [SmallCategory K] [HasLimitsOfShape K D] :
    PreservesLimitsOfShape K (J.diagramFunctor D X) :=
  ⟨⟩

instance (X : C) [HasLimits D] : PreservesLimits (J.diagramFunctor D X) :=
  ⟨⟩

variable [∀ X : C, HasColimitsOfShape (J.cover X)ᵒᵖ D]

variable [ConcreteCategory.{max v u} D]

variable [∀ X : C, PreservesColimitsOfShape (J.cover X)ᵒᵖ (forget D)]

/- warning: category_theory.grothendieck_topology.lift_to_plus_obj_limit_obj -> CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj is a dubious translation:
lean 3 declaration is
  forall {C : Type.{max u2 u3}} [_inst_1 : CategoryTheory.Category.{u2, max u2 u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, max u2 u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u2 u3} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, max u2 u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2] [_inst_5 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_6 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_5)] {K : Type.{max u2 u3}} [_inst_7 : CategoryTheory.SmallCategory.{max u2 u3} K] [_inst_8 : CategoryTheory.FinCategory.{max u2 u3} K _inst_7] [_inst_9 : CategoryTheory.Limits.HasLimitsOfShape.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_7 D _inst_2] [_inst_10 : CategoryTheory.Limits.PreservesLimitsOfShape.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} K _inst_7 (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_5)] [_inst_11 : CategoryTheory.Limits.ReflectsLimitsOfShape.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} K _inst_7 (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_5)] (F : CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2)) (X : C) (S : CategoryTheory.Limits.Cone.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_7 D _inst_2 (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.plusFunctor.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_3) (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_4)) (CategoryTheory.Functor.obj.{u2, max (max u2 (max u2 u3) u1) u2 u3, max u2 u3, max (max u2 u3) (max u2 (max u2 u3) u1) u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (Opposite.op.{succ (max u2 u3)} C X))))), Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Limits.Cone.pt.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_7 D _inst_2 (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.plusFunctor.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_3) (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_4)) (CategoryTheory.Functor.obj.{u2, max (max u2 (max u2 u3) u1) u2 u3, max u2 u3, max (max u2 u3) (max u2 (max u2 u3) u1) u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (Opposite.op.{succ (max u2 u3)} C X)))) S) (CategoryTheory.Functor.obj.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj._proof_3.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_3) (CategoryTheory.Limits.limit.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) F (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj._proof_4.{u3, u2, u1} C _inst_1 D _inst_2 K _inst_7 _inst_9 F)) (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj._proof_5.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_4)) (Opposite.op.{succ (max u2 u3)} C X))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_5 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_6 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_5)] {K : Type.{max u2 u3}} [_inst_7 : CategoryTheory.SmallCategory.{max u3 u2} K] [_inst_8 : CategoryTheory.FinCategory.{max u3 u2} K _inst_7] [_inst_9 : CategoryTheory.Limits.HasLimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2] [_inst_10 : CategoryTheory.Limits.PreservesLimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} K _inst_7 (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_5)] [_inst_11 : CategoryTheory.Limits.ReflectsLimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} K _inst_7 (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_5)] (F : CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (X : C) (S : CategoryTheory.Limits.Cone.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2 (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.plusFunctor.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) (Prefunctor.obj.{succ u2, max (max (succ u3) (succ u2)) (succ u1), u3, max (max u3 u2) u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{u2, max (max u3 u2) u1, u3, max (max u3 u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (Opposite.op.{succ u3} C X))))), Quiver.Hom.{max (succ u3) (succ u2), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Limits.Cone.pt.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2 (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.plusFunctor.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) (Prefunctor.obj.{succ u2, max (max (succ u3) (succ u2)) (succ u1), u3, max (max u3 u2) u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{u2, max (max u3 u2) u1, u3, max (max u3 u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (Opposite.op.{succ u3} C X)))) S) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (CategoryTheory.Limits.limit.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) K _inst_7 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{max u3 u2, u2, max u3 u2, u3, max u3 u2, u1} D _inst_2 K _inst_7 (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) _inst_9) F)) (fun (X : C) => _inst_4 X))) (Opposite.op.{succ u3} C X))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.lift_to_plus_obj_limit_obj CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObjₓ'. -/
/-- An auxiliary definition to be used in the proof that `J.plus_functor D` commutes
with finite limits. -/
def liftToPlusObjLimitObj {K : Type max v u} [SmallCategory K] [FinCategory K]
    [HasLimitsOfShape K D] [PreservesLimitsOfShape K (forget D)]
    [ReflectsLimitsOfShape K (forget D)] (F : K ⥤ Cᵒᵖ ⥤ D) (X : C)
    (S : Cone (F ⋙ J.plusFunctor D ⋙ (evaluation Cᵒᵖ D).obj (op X))) :
    S.pt ⟶ (J.plusObj (limit F)).obj (op X) :=
  let e := colimitLimitIso (F ⋙ J.diagramFunctor D X)
  let t : J.diagram (limit F) X ≅ limit (F ⋙ J.diagramFunctor D X) :=
    (isLimitOfPreserves (J.diagramFunctor D X) (limit.isLimit _)).conePointUniqueUpToIso
      (limit.isLimit _)
  let p : (J.plusObj (limit F)).obj (op X) ≅ colimit (limit (F ⋙ J.diagramFunctor D X)) :=
    HasColimit.isoOfNatIso t
  let s :
    colimit (F ⋙ J.diagramFunctor D X).flip ≅ F ⋙ J.plusFunctor D ⋙ (evaluation Cᵒᵖ D).obj (op X) :=
    NatIso.ofComponents (fun k => colimitObjIsoColimitCompEvaluation _ k)
      (by
        intro i j f
        rw [← iso.eq_comp_inv, category.assoc, ← iso.inv_comp_eq]
        ext w
        dsimp [plus_map]
        erw [colimit.ι_map_assoc,
          colimit_obj_iso_colimit_comp_evaluation_ι_inv (F ⋙ J.diagram_functor D X).flip w j,
          colimit_obj_iso_colimit_comp_evaluation_ι_inv_assoc (F ⋙ J.diagram_functor D X).flip w i]
        rw [← (colimit.ι (F ⋙ J.diagram_functor D X).flip w).naturality]
        rfl)
  limit.lift _ S ≫ (HasLimit.isoOfNatIso s.symm).Hom ≫ e.inv ≫ p.inv
#align category_theory.grothendieck_topology.lift_to_plus_obj_limit_obj CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj

/- warning: category_theory.grothendieck_topology.lift_to_plus_obj_limit_obj_fac -> CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj_fac is a dubious translation:
lean 3 declaration is
  forall {C : Type.{max u2 u3}} [_inst_1 : CategoryTheory.Category.{u2, max u2 u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, max u2 u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u2 u3} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, max u2 u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u2 u3, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) D _inst_2] [_inst_5 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_6 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u2 u3)} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u2 u3, max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (Preorder.smallCategory.{max u2 u3} (CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, max u2 u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_5)] {K : Type.{max u2 u3}} [_inst_7 : CategoryTheory.SmallCategory.{max u2 u3} K] [_inst_8 : CategoryTheory.FinCategory.{max u2 u3} K _inst_7] [_inst_9 : CategoryTheory.Limits.HasLimitsOfShape.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_7 D _inst_2] [_inst_10 : CategoryTheory.Limits.PreservesLimitsOfShape.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} K _inst_7 (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_5)] [_inst_11 : CategoryTheory.Limits.ReflectsLimitsOfShape.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} K _inst_7 (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_5)] (F : CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2)) (X : C) (S : CategoryTheory.Limits.Cone.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_7 D _inst_2 (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.plusFunctor.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) (CategoryTheory.Functor.obj.{u2, max (max u2 (max u2 u3) u1) u2 u3, max u2 u3, max (max u2 u3) (max u2 (max u2 u3) u1) u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (Opposite.op.{succ (max u2 u3)} C X))))) (k : K), Eq.{succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Limits.Cone.pt.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_7 D _inst_2 (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.plusFunctor.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X))) (CategoryTheory.Functor.obj.{u2, max (max u2 (max u2 u3) u1) u2 u3, max u2 u3, max (max u2 u3) (max u2 (max u2 u3) u1) u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (Opposite.op.{succ (max u2 u3)} C X)))) S) (CategoryTheory.Functor.obj.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.plusMap._proof_3.{max u2 u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.Functor.obj.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) F k) (CategoryTheory.GrothendieckTopology.plusMap._proof_4.{max u2 u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X))) (Opposite.op.{succ (max u2 u3)} C X))) (CategoryTheory.CategoryStruct.comp.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2) (CategoryTheory.Limits.Cone.pt.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_7 D _inst_2 (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.plusFunctor.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X))) (CategoryTheory.Functor.obj.{u2, max (max u2 (max u2 u3) u1) u2 u3, max u2 u3, max (max u2 u3) (max u2 (max u2 u3) u1) u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (Opposite.op.{succ (max u2 u3)} C X)))) S) (CategoryTheory.Functor.obj.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj._proof_3.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.Limits.limit.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) F (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj._proof_4.{u3, u2, u1} C _inst_1 D _inst_2 K _inst_7 _inst_9 F)) (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj._proof_5.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X))) (Opposite.op.{succ (max u2 u3)} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.plusMap._proof_3.{max u2 u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.Functor.obj.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) F k) (CategoryTheory.GrothendieckTopology.plusMap._proof_4.{max u2 u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X))) (Opposite.op.{succ (max u2 u3)} C X)) (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) _inst_5 (fun (X : C) => _inst_6 X) K _inst_7 _inst_8 _inst_9 _inst_10 _inst_11 F X S) (CategoryTheory.NatTrans.app.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.plusMap._proof_1.{max u2 u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.Limits.limit.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) K _inst_7 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{max u2 u3, u2, max u2 u3, max u2 u3, max u2 u3, u1} D _inst_2 K _inst_7 (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) _inst_9) F)) (CategoryTheory.GrothendieckTopology.plusMap._proof_2.{max u2 u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X))) (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.plusMap._proof_3.{max u2 u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.Functor.obj.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) F k) (CategoryTheory.GrothendieckTopology.plusMap._proof_4.{max u2 u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X))) (CategoryTheory.GrothendieckTopology.plusMap.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) (CategoryTheory.Limits.limit.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) K _inst_7 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{max u2 u3, u2, max u2 u3, max u2 u3, max u2 u3, u1} D _inst_2 K _inst_7 (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) _inst_9) F)) (CategoryTheory.Functor.obj.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) F k) (CategoryTheory.Limits.limit.π.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) K _inst_7 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{max u2 u3, u2, max u2 u3, max u2 u3, max u2 u3, u1} D _inst_2 K _inst_7 (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) _inst_9) F) k)) (Opposite.op.{succ (max u2 u3)} C X))) (CategoryTheory.NatTrans.app.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_7 D _inst_2 (CategoryTheory.Functor.obj.{max u2 u3, max u2 u3, u1, max (max u2 u3) u1} D _inst_2 (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_7 D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_7 D _inst_2) (CategoryTheory.Functor.const.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_7 D _inst_2) (CategoryTheory.Limits.Cone.pt.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_7 D _inst_2 (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.plusFunctor.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) (CategoryTheory.Functor.obj.{u2, max (max u2 (max u2 u3) u1) u2 u3, max u2 u3, max (max u2 u3) (max u2 (max u2 u3) u1) u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (Opposite.op.{succ (max u2 u3)} C X)))) S)) (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.plusFunctor.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) (CategoryTheory.Functor.obj.{u2, max (max u2 (max u2 u3) u1) u2 u3, max u2 u3, max (max u2 u3) (max u2 (max u2 u3) u1) u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (Opposite.op.{succ (max u2 u3)} C X)))) (CategoryTheory.Limits.Cone.π.{max u2 u3, max u2 u3, max u2 u3, u1} K _inst_7 D _inst_2 (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} K _inst_7 (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u2 (max u2 u3) u1, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.plusFunctor.{u1, u2, max u2 u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, max u2 u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) (CategoryTheory.Functor.obj.{u2, max (max u2 (max u2 u3) u1) u2 u3, max u2 u3, max (max u2 u3) (max u2 (max u2 u3) u1) u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 (max u2 u3) u1, u1} (CategoryTheory.Functor.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u2 u3, max u2 u3, u1} (Opposite.{succ (max u2 u3)} C) (CategoryTheory.Category.opposite.{u2, max u2 u3} C _inst_1) D _inst_2) (Opposite.op.{succ (max u2 u3)} C X)))) S) k)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_5 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_6 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_5)] {K : Type.{max u2 u3}} [_inst_7 : CategoryTheory.SmallCategory.{max u3 u2} K] [_inst_8 : CategoryTheory.FinCategory.{max u3 u2} K _inst_7] [_inst_9 : CategoryTheory.Limits.HasLimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2] [_inst_10 : CategoryTheory.Limits.PreservesLimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} K _inst_7 (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_5)] [_inst_11 : CategoryTheory.Limits.ReflectsLimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} K _inst_7 (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_5)] (F : CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (X : C) (S : CategoryTheory.Limits.Cone.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2 (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.plusFunctor.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) (Prefunctor.obj.{succ u2, max (max (succ u3) (succ u2)) (succ u1), u3, max (max u3 u2) u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{u2, max (max u3 u2) u1, u3, max (max u3 u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (Opposite.op.{succ u3} C X))))) (k : K), Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{succ (max u3 u2), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Limits.Cone.pt.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2 (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.plusFunctor.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) (Prefunctor.obj.{succ u2, max (max (succ u3) (succ u2)) (succ u1), u3, max (max u3 u2) u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{u2, max (max u3 u2) u1, u3, max (max u3 u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (Opposite.op.{succ u3} C X)))) S) (Prefunctor.obj.{succ u2, succ (max u3 u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), max u3 u2, max (max u3 u2) u1} K (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} K (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} K _inst_7)) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) F) k) (fun (X : C) => _inst_4 X))) (Opposite.op.{succ u3} C X))) (CategoryTheory.CategoryStruct.comp.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2) (CategoryTheory.Limits.Cone.pt.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2 (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.plusFunctor.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) (Prefunctor.obj.{succ u2, max (max (succ u3) (succ u2)) (succ u1), u3, max (max u3 u2) u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{u2, max (max u3 u2) u1, u3, max (max u3 u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (Opposite.op.{succ u3} C X)))) S) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (CategoryTheory.Limits.limit.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) K _inst_7 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{max u3 u2, u2, max u3 u2, u3, max u3 u2, u1} D _inst_2 K _inst_7 (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) _inst_9) F)) (fun (X : C) => _inst_4 X))) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, succ (max u3 u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), max u3 u2, max (max u3 u2) u1} K (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} K (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} K _inst_7)) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) F) k) (fun (X : C) => _inst_4 X))) (Opposite.op.{succ u3} C X)) (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) _inst_5 (fun (X : C) => _inst_6 X) K _inst_7 _inst_8 _inst_9 _inst_10 _inst_11 F X S) (CategoryTheory.NatTrans.app.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (CategoryTheory.Limits.limit.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) K _inst_7 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{max u3 u2, u2, max u3 u2, u3, max u3 u2, u1} D _inst_2 K _inst_7 (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) _inst_9) F)) (fun (X : C) => _inst_4 X)) (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), max u3 u2, max (max u3 u2) u1} K (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} K (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} K _inst_7)) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) F) k) (fun (X : C) => _inst_4 X)) (CategoryTheory.GrothendieckTopology.plusMap.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) (CategoryTheory.Limits.limit.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) K _inst_7 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{max u3 u2, u2, max u3 u2, u3, max u3 u2, u1} D _inst_2 K _inst_7 (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) _inst_9) F)) (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), max u3 u2, max (max u3 u2) u1} K (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} K (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} K _inst_7)) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) F) k) (CategoryTheory.Limits.limit.π.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) K _inst_7 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{max u3 u2, u2, max u3 u2, u3, max u3 u2, u1} D _inst_2 K _inst_7 (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) _inst_9) F) k)) (Opposite.op.{succ u3} C X))) (CategoryTheory.NatTrans.app.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2 (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, max (max u3 u2) u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, max (max u3 u2) u1} D _inst_2 (CategoryTheory.Functor.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2) (CategoryTheory.Functor.const.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2)) (CategoryTheory.Limits.Cone.pt.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2 (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.plusFunctor.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) (Prefunctor.obj.{succ u2, max (max (succ u3) (succ u2)) (succ u1), u3, max (max u3 u2) u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{u2, max (max u3 u2) u1, u3, max (max u3 u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (Opposite.op.{succ u3} C X)))) S)) (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.plusFunctor.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) (Prefunctor.obj.{succ u2, max (max (succ u3) (succ u2)) (succ u1), u3, max (max u3 u2) u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{u2, max (max u3 u2) u1, u3, max (max u3 u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (Opposite.op.{succ u3} C X)))) (CategoryTheory.Limits.Cone.π.{max u3 u2, max u3 u2, max u3 u2, u1} K _inst_7 D _inst_2 (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, u1} K _inst_7 (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 F (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2 (CategoryTheory.GrothendieckTopology.plusFunctor.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) (Prefunctor.obj.{succ u2, max (max (succ u3) (succ u2)) (succ u1), u3, max (max u3 u2) u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{u2, max (max u3 u2) u1, u3, max (max u3 u2) u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max (max u3 u1) u2) u3 u2, u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) D _inst_2) (CategoryTheory.evaluation.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (Opposite.op.{succ u3} C X)))) S) k)
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.lift_to_plus_obj_limit_obj_fac CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj_facₓ'. -/
-- This lemma should not be used directly. Instead, one should use the fact that
-- `J.plus_functor D` preserves finite limits, along with the fact that
-- evaluation preserves limits.
theorem liftToPlusObjLimitObj_fac {K : Type max v u} [SmallCategory K] [FinCategory K]
    [HasLimitsOfShape K D] [PreservesLimitsOfShape K (forget D)]
    [ReflectsLimitsOfShape K (forget D)] (F : K ⥤ Cᵒᵖ ⥤ D) (X : C)
    (S : Cone (F ⋙ J.plusFunctor D ⋙ (evaluation Cᵒᵖ D).obj (op X))) (k) :
    liftToPlusObjLimitObj F X S ≫ (J.plusMap (limit.π F k)).app (op X) = S.π.app k :=
  by
  dsimp only [lift_to_plus_obj_limit_obj]
  rw [← (limit.is_limit (F ⋙ J.plus_functor D ⋙ (evaluation Cᵒᵖ D).obj (op X))).fac S k,
    category.assoc]
  congr 1
  dsimp
  simp only [category.assoc]
  rw [← iso.eq_inv_comp, iso.inv_comp_eq, iso.inv_comp_eq]
  ext
  dsimp [plus_map]
  simp only [has_colimit.iso_of_nat_iso_ι_hom_assoc, ι_colim_map]
  dsimp [is_limit.cone_point_unique_up_to_iso, has_limit.iso_of_nat_iso, is_limit.map]
  rw [limit.lift_π]
  dsimp
  rw [ι_colimit_limit_iso_limit_π_assoc]
  simp_rw [← nat_trans.comp_app, ← category.assoc, ← nat_trans.comp_app]
  rw [limit.lift_π, category.assoc]
  congr 1
  rw [← iso.comp_inv_eq]
  erw [colimit.ι_desc]
  rfl
#align category_theory.grothendieck_topology.lift_to_plus_obj_limit_obj_fac CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj_fac

instance (K : Type max v u) [SmallCategory K] [FinCategory K] [HasLimitsOfShape K D]
    [PreservesLimitsOfShape K (forget D)] [ReflectsLimitsOfShape K (forget D)] :
    PreservesLimitsOfShape K (J.plusFunctor D) :=
  by
  constructor; intro F; apply preserves_limit_of_evaluation; intro X
  apply preserves_limit_of_preserves_limit_cone (limit.is_limit F)
  refine' ⟨fun S => lift_to_plus_obj_limit_obj F X.unop S, _, _⟩
  · intro S k
    apply lift_to_plus_obj_limit_obj_fac
  · intro S m hm
    dsimp [lift_to_plus_obj_limit_obj]
    simp_rw [← category.assoc, iso.eq_comp_inv, ← iso.comp_inv_eq]
    ext
    simp only [limit.lift_π, category.assoc, ← hm]
    congr 1
    ext
    dsimp [plus_map, plus_obj]
    erw [colimit.ι_map, colimit.ι_desc_assoc, limit.lift_π]
    dsimp
    simp only [category.assoc]
    rw [ι_colimit_limit_iso_limit_π_assoc]
    simp only [nat_iso.of_components_inv_app, colimit_obj_iso_colimit_comp_evaluation_ι_app_hom,
      iso.symm_inv]
    dsimp [is_limit.cone_point_unique_up_to_iso]
    rw [← category.assoc, ← nat_trans.comp_app, limit.lift_π]
    rfl

instance [HasFiniteLimits D] [PreservesFiniteLimits (forget D)] [ReflectsIsomorphisms (forget D)] :
    PreservesFiniteLimits (J.plusFunctor D) :=
  by
  apply preservesFiniteLimitsOfPreservesFiniteLimitsOfSize.{max v u}
  intro K _ _
  haveI : reflects_limits_of_shape K (forget D) := reflects_limits_of_shape_of_reflects_isomorphisms
  infer_instance

instance (K : Type max v u) [SmallCategory K] [FinCategory K] [HasLimitsOfShape K D]
    [PreservesLimitsOfShape K (forget D)] [ReflectsLimitsOfShape K (forget D)] :
    PreservesLimitsOfShape K (J.sheafification D) :=
  Limits.compPreservesLimitsOfShape _ _

instance [HasFiniteLimits D] [PreservesFiniteLimits (forget D)] [ReflectsIsomorphisms (forget D)] :
    PreservesFiniteLimits (J.sheafification D) :=
  Limits.compPreservesFiniteLimits _ _

end CategoryTheory.GrothendieckTopology

namespace CategoryTheory

variable [∀ X : C, HasColimitsOfShape (J.cover X)ᵒᵖ D]

variable [ConcreteCategory.{max v u} D]

variable [∀ X : C, PreservesColimitsOfShape (J.cover X)ᵒᵖ (forget D)]

variable [PreservesLimits (forget D)]

variable [ReflectsIsomorphisms (forget D)]

variable (K : Type max v u)

variable [SmallCategory K] [FinCategory K] [HasLimitsOfShape K D]

instance : PreservesLimitsOfShape K (presheafToSheaf J D) :=
  by
  constructor; intro F; constructor; intro S hS
  apply is_limit_of_reflects (Sheaf_to_presheaf J D)
  haveI : reflects_limits_of_shape K (forget D) := reflects_limits_of_shape_of_reflects_isomorphisms
  apply is_limit_of_preserves (J.sheafification D) hS

instance [HasFiniteLimits D] : PreservesFiniteLimits (presheafToSheaf J D) :=
  by
  apply preservesFiniteLimitsOfPreservesFiniteLimitsOfSize.{max v u}
  intros ; skip; infer_instance

end CategoryTheory

